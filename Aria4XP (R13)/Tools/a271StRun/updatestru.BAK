****************************************************************************************************
*T20110704.0013 TMI 07/04/2011 
* Running fix programs would be within aria27 itself
****************************************************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*  
*  The Idea behind creating this program
*  
*  *  When the aria27 media was created it worked ok on the 64-bit windows platform systems, but for the media to accomplish
*  *   its role, the Aria27 application takes the files installed by the media and does update file structure.
*  *  But there was a problem that aas_win.exe , the main executable file of aria27 is a 16-bit based, and it won't run at 
*  *  the 64-bit based, so we created this program
*  *  This program was trivially a copy of the ARIA27.PRG main program in aria27
*  *  I changed it a bit to run the update of the media files easily
*  *  I changed also the places where the statements do not cope with VFP9
*  *  Otherwise , I left each other thing as it is
*  *  For this program to work correctly , I was forced to included all needed programs used as global functions in 
*  *  Aria27.prg , I also included all ARIA27 fix program that is called while doing the media update
*  *  so the working program is only this one, the other attached files to the project are just to enable it to work
*  
*  How this program works
*  
*  *  When the aria27 media runs, it updates the aria27\sysfiles in the SaaS shared folder with the media files
*  *  Next a call of the program UpdateSaaS27.exe is called which copies the media files to the folders of the clients sysfiles folders, the exe of this program, a271strun.exe, is copied to each client folder
*  *  The exe is then is called in sequence from the client folder , it recognizes the SYSFILES folder and does the media updates at this folder
*  
*  ****************************************************************************************************
*  APPLICATION : ARIA27 MEDIA
*   DEVELOPER   : TAREK MOHAMED IBRAHIM
*  ****************************************************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End ] 
****************************************************************************************************
*MODIFICATION 
*B609764,1 TMI 12/07/2011 Resolve the problem of duplicating menu items [Media project] 
*B609765,1 TMI 12/08/2011 Update the field SYCINST.cCompPath in the media 1st run [Media project]
*B609764,2 TMI 12/08/2011 remove the fix B609590 [Media project]
*E303059,1 TMI 02/09/2012 if there is more than one client then do not run , provided that this program runs from the 
*                                 same folder where aas_win was installed [MEDIA 2012] 
*E303062,1 TMI 02/13/2012 change the behaviour of the 1st run program [MEDIA 2012] 
*E303062,3 TMI 02/14/2012 replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012] 
*E303074,1 TMI 02/20/2012 force the function that creates the fox tables to be created in fox2x format
*E303074,1 TMI 02/20/2012 if the client path is the same as the installation path then do not rename the folders and jump immediatly to the update structure 
*E303076,1 TMI 02/22/2012 When the a271strun.exe is called in upgrade then do not update the SYCINST [Media ] 
*E303076,3 TMI 02/23/2012 Call the gfSetPath to remove the PATH.DAT after first run [Media] 
*E303364,1 consider the field cVer in A271stRun TMI 03/09/2013 [Start] 
****************************************************************************************************

*!*************************************************************
*! Name      : gfCrtModul 
*! Developer : Hesham El-Sheltawi
*! Date      : 12/10/95
*! Purpose   : create upmodule txt file if needed
*!*************************************************************
*! Called by : 
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : 
*!*************************************************************
*
PARAMETERS gcSysHome

*E303062,4 TMI 02/15/2012 [Start] for test only
llDebug = FILE('tmi-in-aria.txt')
*E303062,4 TMI 02/15/2012 [End  ] 

*E303059,1 TMI 02/09/2012 [Start] if there is more than one client then do not run , provided that this program runs from the 
*                                 same folder where aas_win was installed
*E303062,1 TMI 02/13/2012 [Start] Check the file name while called
*IF FILE('clients.DBF') 
IIF(llDebug,MESSAGEBOX(UPPER(JUSTFNAME(SYS(16)))),'')
IF FILE('clients.DBF') AND ALLTRIM(UPPER(JUSTFNAME(SYS(16))))=='A271STRUN.EXE'
  IIF(llDebug,MESSAGEBOX('now to rename the sysfiles and dbfs folders'),'')
*E303062,1 TMI 02/13/2012 [End  ] 
  SELECT 0
  use clients
  lcDel = SET("Deleted")
  SET DELETED ON
  LOCATE
  COUNT TO lnCnt
  IF lnCnt>1
    RETURN
  ENDIF
  *E303062,1 TMI 02/13/2012 [Start] When only one client then get the path of  the client and copy the program itself and call it from the path it was copied to
  *                                 copy also the media sysfiles and dbfs demo company
  lcSuppMsg = 'Aria27 Installation'
  lcContact = "Please contact with Aria Suppoet team to resolve this problem."
  *- Case there is no lines, Error message will popup
  IF lnCnt = 0
    lcMsg = 'There is not any record in the CLIENTS.DBF table, &lcContact'
    MESSAGEBOX(lcMsg ,0,lcSuppMsg)
    RETURN
  ENDIF 

  *- Case when there is only one line, SaaS with one client
  IF lnCnt=1
    GO TOP IN CLIENTS
    lcMe = SYS(16)
    lcCurrPath = ADDBS(JUSTPATH(SYS(16)))
    lcClientPath = UPPER(ADDBS(ALLTRIM(CLIENTS.CDATAPATH)))
    IF EMPTY(lcClientPath)
      lcMsg = 'Client path field cannot be empty, &lcContact'
      MESSAGEBOX(lcMsg ,0,lcSuppMsg)
      RETURN
    ENDIF 
    
    IF lcCurrPath == lcClientPath 
      *just run the program normally
      IIF(llDebug,MESSAGEBOX('when lcCurrPath == lcClientPath, just run the program normally'),'')
    ELSE
      *- if SYSFILES folder not found then the 1st run has been already run before
      IF !DIRECTORY(lcCurrPath+'SYSFILES\')
        lcMsg = "You cannot run this program, it has already been run by Aria27 installation"
        MESSAGEBOX(lcMsg ,0,lcSuppMsg)
        RETURN
      ENDIF
      
      lcClientSysPath = lcClientPath+'SYSFILES\'
      IF !FILE(lcClientSysPath+'SYDAPPL.DBF')
        lcMsg = 'Invalid Aria27 path (CLINETS.DBF), &lcContact'
        MESSAGEBOX(lcMsg ,0,lcSuppMsg)
        RETURN
      ENDIF

      USE (lcClientSysPath+'SYDAPPL.DBF') ORDER CAPP_ID IN 0        
      !move sysfiles SaaS_sysfiles
      *- loop just as a wait for the folder to be moved
      FOR i=1 TO 1000
      ENDFOR
        
      lcLocalSysPath = lcCurrPath+'SaaS_SYSFILES\'
      IF !DIRECTORY(lcLocalSysPath)
        lcMsg = "Not able to rename the SYSFILES (Aria27 installation) folder to SaaS_SYSFILES, &lcContact"
        MESSAGEBOX(lcMsg ,0,lcSuppMsg)
        RETURN 
      ENDIF 
      
      SET SAFETY OFF 
      *E303062,4 TMI 02/15/2012 [Start] set exact on
      lcExact = SET("Exact")
      SET EXACT OFF
      *E303062,4 TMI 02/15/2012 [End  ]   
      CD (lcLocalSysPath)
      DIMENSION laDir[1, 5]
      lnfls = ADIR(ladir, '*.*')
      FOR lnflindex = 1 TO lnfls
         IF SUBSTR(ladir[lnflindex, 5], 5, 1)='D'
            LOOP
         ENDIF
         WAIT WINDOW NOWAIT 'Copying the file '+ladir(lnflindex, 1)
         lcleft = UPPER(LEFT(ladir[lnflindex, 1], 2))
         IF (lcleft=="XX") .OR. SEEK(lcleft,'SYDAPPL')
            *E303062,4 TMI 02/15/2012 [Start] do not copy syccomp,sydappl or sycinst in upgrade case
            IF UPPER(ladir[lnflindex, 1])='SYCCOMP' OR ;
              UPPER(ladir[lnflindex, 1])='SYDAPPL' OR ;
              UPPER(ladir[lnflindex, 1])='SYCINST'
              LOOP
            ENDIF
            *E303062,4 TMI 02/15/2012 [End  ] 
            COPY FILE (lcLocalSysPath+ladir(lnflindex, 1)) TO (lcClientSysPath+ladir(lnflindex, 1))
         ENDIF
      ENDFOR
      USE IN sydappl
      *E303062,4 TMI 02/15/2012 [Start] restore exact settings
      SET EXACT &lcExact
      *E303062,4 TMI 02/15/2012 [End  ] 
      
      *-move the dbfs
      CD (lcCurrPath)
      COPY FILE A27_Release12.XML TO (lcClientPath+'*.*')
      !move DBFS SaaS_DBFS
      *- loop just as a wait for the folder to be moved
      FOR i=1 TO 1000
      ENDFOR
      IF !DIRECTORY(lcCurrPath+'SaaS_DBFS\')
        lcMsg = "Not able to rename the DBFS (Aria27 installation) folder to SaaS_DBFS, &lcContact"
        MESSAGEBOX(lcMsg ,0,lcSuppMsg)
        RETURN 
      ENDIF 
      
      IF !DIRECTORY(lcClientPath+'DBFS\99\')
        MD (lcClientPath+'DBFS\99\')
      ENDIF
      WAIT WINDOW NOWAIT 'Copying demo company files ..'
      CD (lcCurrPath+'SaaS_DBFS\99\')
      COPY FILE *.* TO (lcClientPath+'DBFS\99\*.*')
      WAIT CLEAR 

      *- Run this program with its new name  
      CD (lcCurrPath)
      lcCl1stRun = JUSTSTEM(lcMe)+'_CL.EXE'
      COPY FILE (lcCl1stRun) TO (lcClientPath+lcCl1stRun)
IIF(llDebug,MESSAGEBOX('NOW CALL CLIENT PROGRAM'),'')
      DO (lcClientPath+lcCl1stRun)
IIF(llDebug,MESSAGEBOX('CallED the program in the client path'),'')
      RETURN
    ENDIF
  ENDIF 
  *E303062,1 TMI 02/13/2012 [End  ] 
  
  SET DELETED &lcDel
ENDIF     
*E303059,1 TMI 02/09/2012 [End  ] 

*E303062,4 TMI 02/15/2012 [Start] TEST ONLY
IIF(llDebug,MESSAGEBOX('IN THE CLIENT PROGRAM'),'')
*E303062,4 TMI 02/15/2012 [End  ]  

*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
IF EMPTY(gcSysHome)
  gcSysHome = ADDBS(JUSTPATH(SYS(16)))+'Sysfiles\'
ENDIF
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 

*B609764,1 TMI 12/07/2011 [Start] change settings
SET DELETED ON
SET RESOURCE OFF
SET SAFETY OFF 
_Screen.WindowState = 2
_Screen.AutoCenter = .T. 
_Screen.Caption = 'Aria27 Media - Update files structure'
*B609764,1 TMI 12/07/2011 [End  ] 

SET CPDIALOG OFF 
*C201317,1 TMI 07/04/2011 [Start] 
DO WHILE .T.
  lcA27Path = IIF(EMPTY(gcSysHome),GETDIR('','A27 SysPath'),gcSysHome)
  IF EMPTY(lcA27Path)
    RETURN
  ENDIF
  SET DEFAULT TO (lcA27Path)
  DIMENSION laFiles[1]
  laFiles = ''
  ADIR(laFiles,'XX*.DBF')
  IF EMPTY(laFiles[1])
    MESSAGEBOX('Media has not been setuped for this installation, pls try again..',0,'Aria27 1st run Updates')
    *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
    RETURN
    *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
  ELSE
    CD..
    EXIT
  ENDIF
ENDDO
*C201317,1 TMI 07/04/2011 [End  ] 

*T20110704.0013 TMI 07/04/2011 [Start] THIS LINE IS FOR TEST ONLY
gcOrgPath = ''
*    gcSysHome = FULLPATH("")+"SYSFILES\"    
    gcSysHome = IIF(EMPTY(gcSysHome),lcA27Path,gcSysHome)
    gcWorkDir = SYS(5)+CURDIR()+'\WORK\'
*    gcImagDir = FULLPATH("")+"IMAGES\"
*    gcLibDir  = FULLPATH("")+"LIB\"
*    gcScrDir  =  FULLPATH("")+"SCREENS\"
llEXEzaped = .F.
*T20110704.0013 TMI 07/04/2011 [End  ] 
IF EMPTY(gcSysHome)
  RETURN
ENDIF

*T20110704.0013 TMI 07/05/2011 [Start] 
lcInitHome  = gcSysHome 
lcSysFiles=gcsyshome
*T20110704.0013 TMI 07/05/2011 [End  ] 

*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
lcAria27Dir = FULLPATH('')
GCMULTIINST  = .F.
IF FILE(lcAria27Dir+'Clients.DBF')
  GCMULTIINST  = .T.
  *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
  *gcSysHome  = 'X:\Aria27\SysFiles\'
  *E302876,1 TMI 03/20/2011 [End  ] 
ENDIF 
IF GCMULTIINST  
  *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
  *lcSysFiles =  'X:\Aria27\SysFiles\'
  *B609580,2 TMI 05/10/2011 [Start] this line is no more needed as it is updated anyway by the lcInitHome in the start of 
  *          the function where lcInitHome is passed to aas_win from the shortcut indicating the client folder contians 
  *          system files
  *lcSysFiles =  lcInitHome
  *B609580,2 TMI 05/10/2011 [End  ] 
  *E302876,1 TMI 03/20/2011 [End  ] 
ENDIF 
*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]

PRIVATE laFiles,llFound,lnCount,laModuls,lcDefa
=ADIR(laFiles,lcSysFiles+'*.DBF')
DIMENSION laModuls[1]
*T20110704.0013 TMI 07/04/2011 [Start] 
*STORE '' TO laModuls
laModuls = ''
*T20110704.0013 TMI 07/04/2011 [End  ] 

llFound = .F.
*E300441,4 HESHAM EL-SHELTAWI (START)
IF ASCAN(laFiles,'XXDAPPL')>0
  laModuls[ALEN(laModuls,1)] ='SY'
  llFound = .T.
ENDIF
*E300441,4 HESHAM EL-SHELTAWI (END)

*B801893,1 AMM check if SM exist, put it to be first of all after SY directly.
IF ASCAN(laFiles,'SMDAPPL')>0
  IF !EMPTY(laModuls[1])
    DIMENSION laModuls[ALEN(laModuls,1)+1]
  ENDIF
  laModuls[ALEN(laModuls,1)] ='SM'
  llFound = .T.
ENDIF
*B801893,1 AMM end

FOR lnCount = 1 TO ALEN(laFiles,1)
  IF SUBSTR(laFiles[lnCount,1],3,5)='DAPPL' AND LEFT(laFiles[lnCount,1],2)<>'SY'
    *E300441,4 HESHAM EL-SHELTAWI (START)
    *laModuls[ALEN(laModuls,1)] =IIF(LEFT(laFiles[lnCount,1],2)<>'XX',LEFT(laFiles[lnCount,1],2),'SY')
    *B801893,1 AMM If any module except SY and SM.
    *IF LEFT(laFiles[lnCount,1],2)<>'XX'
    IF LEFT(laFiles[lnCount,1],2)<>'XX' .AND. LEFT(laFiles[lnCount,1],2)<>'SM'
    *B801893,1 AMM end
      llFound = .T.
      IF !EMPTY(laModuls[1])
        DIMENSION laModuls[ALEN(laModuls,1)+1]
      ENDIF
      laModuls[ALEN(laModuls,1)] = LEFT(laFiles[lnCount,1],2)
    ENDIF  
    *E300441,4 HESHAM EL-SHELTAWI (End)
  ENDIF
ENDFOR

IF llFound
  *T20110704.0013 TMI 07/05/2011 [Start] 
  *SET TEXTMERGE TO (SET('DEFAULT')+'UPDMODUL.DAT') NOSHOW
  *E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
  *SET TEXTMERGE TO (FULLPATH(SET('DEFAULT'))+'UPDMODUL.DAT') NOSHOW
  SET TEXTMERGE TO (SYS(5)+CURDIR()+'UPDMODUL.DAT') NOSHOW  &&<*>
  *E303062,3 TMI 02/14/2012 [End  ] 
  *T20110704.0013 TMI 07/05/2011 [End  ] 
  SET TEXTMERGE ON
  FOR lnCount = 1 TO ALEN(laModuls,1)
    \<<laModuls[lnCount]>> <<laModuls[lnCount]>>
  ENDFOR
  SET TEXTMERGE TO 
  SET TEXTMERGE OFF
  
  *E300613,1 YMA 06/22/97 Changed the winapps directory to be PRGS...
  *E300613,1 YMA 06/22/97 and added the screens and the images
  *E300613,1 YMA 06/22/97 directories
  *\<<lcDefa>>WINAPPS\
  
  *E301060,1 YMA 11/10/98 Added to save the full path of the new
  *E301060,1 YMA 11/10/98 added directories (CLASSES and EDI)
  
  *B609580,2 TMI 05/10/2011 [Start] create the file PATH.DAT on the client path with the same name
  *SET TEXTMERGE TO (SET('DEFAULT')+'PATH.DAT') NOSHOW
  SET TEXTMERGE TO (lcInitHome+'PATH.DAT') NOSHOW
  *B609580,2 TMI 05/10/2011 [End  ] 
  SET TEXTMERGE ON

  *B609580,2 TMI 05/10/2011 [Start] update the following fields of SYCINST in the gfSetPath to start with the client 
  *B609580,2                        folder path :
  *B609580,2                        cinsysfdr,CINSALLCMP, CINSDOSWD, CINSWINWD  & cinsrsrdr
  *B609580,2                        They are numbered 1,2,5,8 & 10 resp.
  PRIVATE lcClientRt
  lcClientRt = SUBSTR(lcInitHome,1,RAT('\',lcInitHome,2))
  *B609580,2 TMI 05/10/2011 [End  ]     
  
  *A27_1stRun,1 TMI 08/17/2011 [Start] 
  *lcDefa = FULLPATH(SET('DEFAULT'))
  *E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
  *lcDefa = ADDBS(FULLPATH(SET('DEFAULT')))<*>
  lcDefa = SYS(5)+CURDIR()  &&<*>
  *E303062,3 TMI 02/14/2012 [End  ] 
  *A27_1stRun,1 TMI 08/17/2011 [End  ] 
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\\<<lcDefa>>SYSFILES\
  *\<<lcDefa>>DBFS\
  \\<<lcClientRt>>SYSFILES\
  \<<lcClientRt>>DBFS\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>DOSAPPS\    
  \<<lcDefa>>REPORTS\
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\<<lcDefa>>WORK\
  \<<lcClientRt>>WORK\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>PRGS\
  \<<lcDefa>>REPORTS\
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\<<lcDefa>>WORK\
  \<<lcClientRt>>WORK\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>BMPS\
  *B609580,2 TMI 05/10/2011 [Start]  replace lcDefa with lcClientRt
  *\<<lcDefa>>RESOURCE\
  \<<lcClientRt>>RESOURCE\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>IMAGES\
  \<<lcDefa>>SCREENS\
  \<<lcDefa>>CLASSES\
  \<<lcDefa>>EDI\
  *E301603,5 Hesham (Start)
  *E301603,5 Check For Unupdated Service Packs
  \<<lcDefa>>SPACK\
  *E301603,5 Hesham (End)
  SET TEXTMERGE TO 
  SET TEXTMERGE OFF  
  *E301060,1 YMA 11/10/98 End.
  *E300613,1 YMA 06/22/97 End.
  
  *B609601,5 TMI 06/16/2011 [Start] check if the file is there
  IF FILE(lcInitHome+'SYUEROR.DBF')
    *B609601,5 TMI 06/16/2011 [End  ] 
  
    *B609601,4 TMI 06/09/2011 [Start] Delete the recored in SYUEROR 6 months before the first run[media]  
    USE (lcInitHome+'SYUEROR') IN 0 EXCLUSIVE
    SELECT SYUEROR
    DELETE FOR DDATE<GOMONTH(DATE(),-6)
    PACK
    USE IN SYUEROR
    *B609601,4 TMI 06/09/2011 [End  ] 

    *B609601,5 TMI 06/16/2011 [Start] close the above IF
  ENDIF
  *B609601,5 TMI 06/16/2011 [End  ] 
  
ENDIF
*B600875,1 END

*!*************************************************************
*! Name      : gfUpdModul
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Update system files with module data
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!          Calls: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : lcNewMod    any installed modules for app. system
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*B600989,1 Oraby 03/03/1996 The GFUPDMODUL is duplicating the records is SYDFILES
*
*FUNCTION gfUpdModul
*PARAMETERS lcNewMod

*C201317,1 TMI 07/05/2011 [Start] 
    IF _WINDOWS .AND. !WEXIST('fndation')
      DEFINE WINDOW fndation   ;
                  FONT "FoxFont", 9 ;
                  AT 0,0 SIZE SROWS(),SCOLS() ;
                  NONE 
      ACTIVATE WINDOW fndation
    ENDIF
*C201317,1 TMI 07/05/2011 [End  ] 



*B600975,1 Hesham El-Sheltawi (START)
*B600975,1 get if it is a fresh installation or upgrading
lcNewMod = IIF(TYPE('lcNewMod')<>'C','',lcNewMod)
lcSetComp = SET('COMP')
SET COMP ON
llFreshInst = !FILE(gcSysHome+"SYCMENU.DBF")

*E301416,1 Hesham (Start)
*E301416,1 Check if there is any transm. send through CM module
*E301416,1 in the inbox before upgrading
IF !llFreshInst AND FILE(gcSysHome+"SYCSELOG.DBF")
  USE (gcSysHome+"SYCSELOG") IN 0 ORDER TAG CCOMTRNST DESC
  USE (gcSysHome+"SYCSELOG") AGAIN ALIAS SYLOGSE IN 0 ORDER TAG CCOMTRNST 
  SELECT SYCSELOG
  SET RELATION TO 'U'+ctrnsses+CCENTRY INTO SYLOGSE ADDI
  GO TOP	
  IF SEEK('R')
    llCantUp = .F.
    SCAN REST WHILE CCOMTRNST+ctrnsses+CCENTRY+CFILE_NAM = 'R'
      llCantUp = EOF('SYLOGSE')
      IF llCantUp
        EXIT
      ENDIF
    ENDSCAN
    SET ORDER TO TAG CCOMTRNST IN SYCSELOG ASCE
    IF llCantUp
      USE IN SYCSELOG
      USE IN SYLOGSE
      = gfMsgBox("TR","There is a transmission in the inbox directory."+CHR(13)+CHR(10)+;
                      "you have to run the update program before upgrading the system","\!\?\<Ok","ALERT")
    
      RETURN
    ENDIF
  ENDIF  
  USE IN SYCSELOG
  USE IN SYLOGSE
ENDIF
*E301416,1 Hesham (End)
SET COMP &lcSetComp
*B600975,1 Hesham El-Sheltawi (End)
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*IF !FILE(FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
IF !FILE(SYS(5)+CURDIR()+"UPDMODUL.DAT") &&<*>
  *E303062,3 TMI 02/14/2012 [End  ] 
  RETURN
ENDIF

*B602265,1 (Start)
*B602265,1 Checking if there is any one else updating the system
*llUPDError = .F.
*lcUpDError = ON('ERROR')
*ON ERROR llUPDError = .T.
*SELECT 0 
*llStaticUs = .F.
*IF FILE(gcSysHome+"syustatc.dbf")
*  llStaticUs = .T.
*  USE (gcSysHome+"syustatc")  EXCL      
*ENDIF  
*USE (gcSysHome+"sycresrc")  IN 0 EXCL      
*ON ERROR &lcUpDError
*IF llUPDError
*Cannot access the system now. The system is under upgrade from another session. Try later.
*  WAIT WINDOW 'Cannot upgrade. The system is running or already under upgrade '+;
              'in another session.'
*  =gfModalGen(.F.,.F.,.F.,.F.,'Someone else is upgrading or running the system at the moment.'+;
              'The system will be terminated!')
*  CLEAR ALL
*  CANCEL    
*ENDIF
*B602265,1 (End)

*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 define array to hold the module information for all the paltforms
*E300441,4 array element 1,1 in DOS , 1,2 the build # ,1,3 .t. if it is the
*E300441,4 recent platform upgrade
DIMENSION laModBuild[4,3]
STORE .F. TO laModBuild
laModBuild[1,1] = 'DOS'
laModBuild[2,1] = 'WIN'
laModBuild[3,1] = 'MAC'
laModBuild[4,1] = 'UNIX'
*E300441,4 Hesham El-Sheltawi (End)
lcSetSafe = SET('SAFETY')
SET SAFETY OFF
CREATE CURSOR UPDMODUL (mModules M)
APPEND BLANK
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*APPEND MEMO UPDMODUL.mModules FROM (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
APPEND MEMO UPDMODUL.mModules FROM (SYS(5)+CURDIR()+"UPDMODUL.DAT")
*E303062,3 TMI 02/14/2012 [End  ] 
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*ERASE (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
ERASE (SYS(5)+CURDIR()+"UPDMODUL.DAT")
*E303062,3 TMI 02/14/2012 [End  ] 

*E300441,4 Hesham El-Sheltawi (Start) 
=lfUpdAppl()
*E300441,4 Hesham El-Sheltawi (End) 
*** In case of updating SM module we have to make sure that the
*** structure of all system files are updated before updatind the data
FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
  IF UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2)) = "SM"
    *E300441,4 Hesham El-Sheltawi (Start) 
     llContinue = .T.
    IF !llFreshInst
      SELECT 0 
      USE (gcSysHome+"SYDAPPL") ORDER TAG  CAPP_ID  EXCL
      lcMdToUP='SM'
      lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
      SELECT SYDAPPL
      =SEEK(lcMdToUP)
      IF lcBuildIns < ALLT(CMDLBUILD)
        lnOption = gfMsgBox("TR","You have installed module("+lcMdToUp+") with a build number ("+lcBuildIns+;
                            "), which is older than the one currently installed ("+ALLT(CMDLBUILD)+;
                            ")!"+CHR(10)+CHR(13)+"If you proceed with the installation, some data may be lost."+;
                            " It is highly recommended to abort now and reinstall files from the latest build available." ,;
                            "\!\?\<Abort;\<Proceed","ALERT")
        IF lnOption = 2
          SELECT SYDAPPL
          REPLACE CMDLBUILD WITH lcBuildIns
        ELSE
          llContinue = .F.
        ENDIF  
        FOR lnPlat= 1 TO ALEN(laModBuild,1)
          lcField='C'+laModBuild[lnPlat,1]+'BUILD'
          IF !EMPTY(laModBuild[lnPlat,2])
            REPLACE &lcField WITH laModBuild[lnPlat,2]
          ENDIF
        ENDFOR
        IF !llContinue
          FOR lnCount = 1 TO MEMLINES(UPDMODUL.mModules)
            lcMdToUP = UPPER(LEFT(MLINE(UPDMODUL.mModules,lnCount),2))
            IF !EMPTY(lcMdToUP)
              IF SEEK(lcMdToUP)
                lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
                FOR lnPlat= 1 TO ALEN(laModBuild,1)
                  lcField='C'+laModBuild[lnPlat,1]+'BUILD'
                  IF !EMPTY(laModBuild[lnPlat,2])
                    REPLACE &lcField WITH laModBuild[lnPlat,2]
                  ENDIF
                ENDFOR
              ENDIF
              =lfDelSplit(lcMdToUp)
            ENDIF
          ENDFOR
          IF USED('SYDAPPL')
            USE IN SYDAPPL  
          ENDIF  
          CLEAR ALL
          CANCEL    
        ELSE   
          IF USED('SYDAPPL')
            USE IN SYDAPPL  
          ENDIF  
          =gfUpdatSYS()
          EXIT        
        ENDIF
        IF USED('SYDAPPL')
          USE IN SYDAPPL  
        ENDIF  
      ELSE  
        USE IN SYDAPPL
        =gfUpdatSYS()
        EXIT        
      ENDIF
    ELSE
      =gfUpdatSYS()
      EXIT
    ENDIF  
*E300441,4 Hesham El-Sheltawi (End) 
  ENDIF
ENDFOR  

*E301199,1 Hesham (Start)
IF !EMPTY(UPDMODUL.mModules)
  DECLARE laCompany [1,3] 
  STORE '' TO laCompany
  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1

  FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
    IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
      lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
      IF lcMd_id <> 'SM' AND lcMd_id <> 'SY'
        lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
        lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
        WAIT 'Running fix programs for module '+lcMd_name WINDOW NOWAIT
       *++NAD40
        *= gfRunFxPrg(lcMd_id)
        = gfRunFxPrg(lcMd_id,.F.)
        
       *++NAD40 
      ENDIF
    ENDIF
  ENDFOR    
ENDIF
*E301199,1 Hesham (End)

IF !EMPTY(UPDMODUL.mModules)
  *B600975,10  Hesham El-Sheltawi (Start)
  DECLARE laCompany [1,3] 
  STORE '' TO laCompany
  *E301098,1 Hesham (Start)
  *SELECT ccomp_id+" - "+cCom_Name,cCom_dDir,syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1
  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1
  *E301098,1 Hesham (End)  
  IF _TALLY=0
    STORE '' TO laCompany
  ENDIF  
  USE IN SYCCOMP  
  *B600975,10 Hesham El-Sheltawi (End)

  SELECT 0 
  USE (gcSysHome+"SYDFILES")  EXCL      && Check Append / Modify
  SELECT 0
  USE (gcSysHome+"SYDFIELD")  EXCL     && Check Append
  SELECT 0 
  USE (gcSysHome+"SYDFLFLD")  EXCL     && Check Append 
  SELECT 0 
  USE (gcSysHome+"SYDINDEX")  EXCL     && Check Append

  *E301065,1 AMM start, Open system form codes files to update
  SELECT 0
  USE (gcSysHome+"SYFRMCDH") ORDER TAG FORMCDHD EXCL
  SELECT 0
  USE (gcSysHome+"SYFRMCDD") ORDER TAG FORMCDDT EXCL
  *E301065,1 AMM end

  *E301252,1 AMM Open file
  SELECT 0
  USE (gcSysHome+"SYCCONFG") ORDER TAG Modvar EXCL
  *E301252,1 AMM end  

  SELECT 0
  USE (gcSysHome+"SYCMENU")   EXCL     && Append
  lcAppPath = ''
  *B600975,1 Hesham El-Sheltawi (START)
  *B600975,1 Change the apparel bar to default
  LOCATE FOR CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
  IF FOUND()
    lcAppPath = CPROCPATH
  ENDIF
  *B600975,1 Hesham El-Sheltawi (END)         
  SELECT 0 
  USE (gcSysHome+"SYDAPPL")   EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDDLOBJ")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDOBJCT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDREPRT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDSCOBJ")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYREPSRT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYREPUVR")  EXCL     && Append
*--hesham
  SELECT 0 
  USE (gcSysHome+"SYCPRINT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYCP_ESC")  EXCL     && Append
*B802980,1 Hesham Start
  SELECT 0 
  USE (gcSysHome+"SYSZONES")  EXCL     && Append
*B802980,1 Hesham END

  SET MOUSE OFF

  *C200443,1 Define variables used in copying custom related fields to stanard code. [Begin]
  PRIVATE lcSyFldTag , lnPipeN1 , lnPipeN2 , lcSyFldKey , laRltField , laNewRFld
  DECLARE laRltField[1] , laNewRFld[1]
  STORE 1 TO lnPipeN1 , lnPipeN2
  STORE '' TO lcSyFldKey , laRltField
  SELECT *;
  FROM SydField ;
  WHERE lVldEntry AND !EMPTY(mRltFields) ;
  INTO CURSOR TmpFields
  *C200443,1 Define variables used in copying custom related fields to stanard code. [End]
  
  *B606832,1 Building Temp. Index on SyRepuvr file. [Begin]
  PRIVATE lcTmpIndx , lcCurAlias , lnRpVarPos , lcRpUvrTag
  lnRpVarPos = 0
  lcCurAlias = ALIAS()
  lcTmpIndx = gfTempName()
  SELECT SyRepUvr

  *BSAMEH Define Array to hold SyRepuvr structure. [Begin]
  PRIVATE laRepVrArr
  =AFIELDS(laRepVrArr)
  *BSAMEH Define Array to hold SyRepuvr structure. [End]
  
  lcRpUvrTag = ORDER()
  INDEX ON cRep_ID + cUpGrdLvl + STR(nVarPos) TAG (lcTmpIndx) OF (gcWorkDir + lcTmpIndx + '.CDX')
  
  *BSAMEH Create Temp cursors for Syrepuvr & SycConfg. [Begin]
  CREATE CURSOR RepVrCur FROM ARRAY laRepVrArr
  PRIVATE laConfgArr
  SELECT SycConfg
  =AFIELDS(laConfgArr)
  CREATE CURSOR ConfgCur FROM ARRAY laConfgArr
  *BSAMEH Create Temp cursors for Syrepuvr & SycConfg. [End]

  IF !EMPTY(lcCurAlias)
    SELECT (lcCurAlias)
  ENDIF
  *B606832,1 Building Temp. Index on SyRepuvr file. [End]
  
  FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)

    IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
      lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
      lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
      lcMdToUP = lcMd_id
      *--hesham start
      lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
      lcMd_ID = IIF(lcMd_id='SY','XX',lcMd_id)     
      *--hesham end
      *E300441,4 HESHAM EL-SHELTAWI (START)
      
      *T20110704.0013 TMI 07/05/2011 [Start] 
      lnNSrvPak=0
      *T20110704.0013 TMI 07/05/2011 [End  ] 
      SELECT UPDMODUL

      llContinue = .T.
      IF FILE (gcSysHome+lcMd_id+"DAPPL.DBF")
        
        SELECT 0
        USE (gcSysHome+lcMd_id+"DAPPL") ORDER TAG  CAPP_ID
        SELECT (lcMd_id+"DAPPL")
        lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
        SELECT SYDAPPL
        SET ORDER TO TAG  CAPP_ID
        IF lcMdToUP <> 'SY' AND lcMdToUP <> 'SM'
          IF SEEK(lcMdToUP)
            SELECT SYDAPPL
            IF lcBuildIns < ALLT(CMDLBUILD)
              lnOption = gfMsgBox("TR","You have installed module("+lcMdToUp+") with a build number ("+lcBuildIns+;
                                   "), which is older than the one currently installed ("+ALLT(CMDLBUILD)+;
                                   ")!"+CHR(10)+CHR(13)+"If you proceed with the installation, some data may be lost."+;
                                   " It is highly recommended to abort now and reinstall files from the latest build available." ,;
                                   "\!\?\<Abort;\<Proceed","ALERT")
              IF lnOption = 2
                SELECT SYDAPPL
                *B803757,1 NAD 11/02/2000 (Start) Update the nServcPak Field.
                *REPLACE CMDLBUILD WITH lcBuildIns
                REPLACE CMDLBUILD WITH lcBuildIns,;
                        NSRVCPAK  WITH lnNSrvPak
                *B803757,1 NAD 11/02/2000 (End) 

              ELSE
                llContinue = .F.
              ENDIF  
            ELSE
                *B604944,1 NAD 09/20/2001  (START)Fix Sydtrans is Zapped after runinig any 
                *B604944,1           standered fix program
                *IF lcBuildIns > ALLT(SYDAPPL.CMDLBUILD)    
                 * DO lpDelTrans 
                *ENDIF
                *B604944,1 NAD (END)                     
                SELECT SYDAPPL
                *B803757,1 NAD 11/02/2000 (Start) Update the nServcPak Field.
                *REPLACE CMDLBUILD WITH lcBuildIns
                REPLACE CMDLBUILD WITH lcBuildIns,;
                        NSRVCPAK  WITH lnNSrvPak
                *B803757,1 NAD 11/02/2000 (End) 

            ENDIF
          ELSE
            USE IN (lcMd_id+"DAPPL")
            APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
            FOR lnPlat= 1 TO ALEN(laModBuild,1)
              lcField='C'+laModBuild[lnPlat,1]+'BUILD'
              REPLACE &lcField WITH laModBuild[lnPlat,2]
            ENDFOR
          ENDIF
        ELSE
          DELETE ALL FOR SEEK(CAPP_ID,lcMd_id+"DAPPL")
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
          *PACK
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
          USE IN (lcMd_id+"DAPPL")
          APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
        ENDIF          
        SELECT SYDAPPL
        FOR lnPlat= 1 TO ALEN(laModBuild,1)
          lcField='C'+laModBuild[lnPlat,1]+'BUILD'
          IF !EMPTY(laModBuild[lnPlat,2])
            REPLACE &lcField WITH laModBuild[lnPlat,2]
          ENDIF
        ENDFOR
        IF USED(lcMd_id+"DAPPL")
          USE IN (lcMd_id+"DAPPL")        
        ENDIF  
      ENDIF  
      IF !llContinue
        =lfDelSplit(lcMdToUp)
        LOOP
      ENDIF
      *E300441,4 HESHAM EL-SHELTAWI (END)            
      
      WAIT "Updating system files for "+lcMd_name+" , Please wait...!" WINDOW NOWAIT

      *E300717,1 Hesham (Start)
      *E300717,1 Update the user file with the system default user
      *E300717,1 the system default user is the user have id = 'ADMIN'
      IF FILE (gcSysHome+lcMd_id+"UUSER.DBF")
        SELECT 0 
        USE (gcSysHome+lcMd_id+"UUSER") ORDER TAG CUSER_ID
        SELECT 0 
        USE (gcSysHome+"SYUUSER")  EXCL 
        DELETE FOR CUSER_ID = PADR('ADMIN',LEN(CUSER_ID))
        USE IN (lcMd_id+"UUSER")
        APPEND FROM (gcSysHome+lcMd_id+"UUSER")
        USE IN SYUUSER
      ENDIF
      *E300717,1 Hesham (End)
      
      IF FILE (gcSysHome+lcMd_id+"CMENU.DBF")
         
        SELECT 0 
        USE (gcSysHome+lcMd_id+"CMENU") ORDER TAG APPPOPBAR
        SELECT SYCMENU
        SET ORDER TO TAG APPPOPBAR
        IF lcMd_id = "SM"
          DECLARE laExtProg [1]
          laExtProg = ""
          SELECT *;
            FROM SYCMENU;
            WHERE SYCMENU.CAPP_ID = 'SY';
            AND SYCMENU.CPROCTYPE = 'E' INTO ARRAY laExtProg
         ENDIF
         *E301141,1 Hesham (Start)
         *E301141,1 check if the module we are updating
         *E301141,1 belog to another module menu bars
         lcMenuToUp = lcMdToUp
         IF SEEK(lcMdToUp,'SYDAPPL')
           lcMenuToUp = IIF(TYPE('SYDAPPL.CMODPARENT')='C' AND !EMPTY(SYDAPPL.CMODPARENT),SYDAPPL.CMODPARENT,lcMenuToUp)
         ENDIF
         *E301141,1 Hesham (End)
        *B601052,1Hesham El_Sheltawi (START)
        *B601052,1select all the custom bars for the current install app.
        *B601052,1to add these bars at the end of the menu popups
        *E301141,1 Hesham (Start)
        *E301141,1 update the menu file for the main module that 
        *E301141,1 the module we are updating belog to
*        SELECT *;
        FROM SYCMENU ;
        WHERE CAPP_ID=lcMdToUp ;
              AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
              AND !EMPTY(CPROCTYPE);
        INTO CURSOR TMPMENU ORDER BY CMSTR_NAM
        *B038431,1 MHM 09/04/2004 use table insted of cursor to update in [Start]
        *SELECT *;
        *FROM SYCMENU ;
        *WHERE CAPP_ID=lcMenuToUp ;
        *      AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
        *      AND !EMPTY(CPROCTYPE);
        *INTO CURSOR TMPMENU ORDER BY CMSTR_NAM
        
        TMPMENU = gfTempName()
        SELECT *;
        FROM SYCMENU ;
        WHERE CAPP_ID=lcMenuToUp ;
              AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
              AND !EMPTY(CPROCTYPE);
        INTO DBF (gcWorkDir+TMPMENU) ORDER BY CMSTR_NAM
        *B038431,1 MHM [End]
        
       *B605903,1 Create Temp file for all Sub Menus. [Begin]
       *B038431,1 MHM 09/04/2004 use table insted of cursor to update in [Start]
       *SELECT *;
       *FROM SycMenu ;
       *WHERE CAPP_ID=lcMenuToUp AND cSub_Typ = "S";
       *INTO CURSOR TmpSbMnu ORDER BY cMstr_Nam , cPross_ID

       TmpSbMnu = gfTempName()
       SELECT *;
       FROM SycMenu ;
       WHERE CAPP_ID=lcMenuToUp AND cSub_Typ = "S";
       INTO DBF (gcWorkDir+TmpSbMnu) ORDER BY cMstr_Nam , cPross_ID
       *B038431,1 MHM  [End]
       *B605903,1 Create Temp file for all Sub Menus. [Begin]
        
       *E301141,1 Hesham (End)
        SELECT SYCMENU
        ** delete all the install Module bars         
*        DELETE ALL FOR SEEK(CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS,lcMd_id+"CMENU") ;
                       .OR. (CAPP_ID = lcMdToUP AND CPROCTYPE<>'C')
        *B602329,1 Remove extra separator in the modules menu
        IF lcMdToUP='SY'
          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMdToUP AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND cProcType <> 'M') 
        ELSE
        *B602329,1 end
        *E301141,1 Hesham (Start)
        *E301141,1 update the menu file for the main module that 
        *E301141,1 the module we are updating belog to
*          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMdToUP AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND CPROSS_ID=lcMdToUP)
          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMenuToUp AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND CPROSS_ID=lcMenuToUp)
        *E301141,1 Hesham (End)                      
        *B602329,1 Add an ENDIF
        ENDIF   
        *B602329,1 end
        
        *B601052,1Hesham El-Sheltawi (END)                       
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"CMENU")
       
        *B609764,1 TMI 12/07/2011 [Start] pack the SYCMENU before using it
        SELECT SYCMENU
        PACK
        *B609764,1 TMI 12/07/2011 [End  ] 
       
        *B605903,1 Shift all menus records after inserting lines. [Begin]
        *APPEND FROM (gcSysHome+lcMd_id+"CMENU")
        IF lcMenuToUp = "SY"
          APPEND FROM (gcSysHome+lcMd_id+"CMENU")
        ELSE
          DO lpMenuPad WITH "01"
          DO lpMenuPad WITH "04"
          DO lpMenuPad WITH "05"
          APPEND FROM (gcSysHome+lcMd_id+"CMENU") FOR cApp_ID + cPad_Pos + cPop_Pos + cPop_Levl + cBar_Pos = 'SY07' AND cPross_ID = lcMenuToUp
        ENDIF  

        *B609764,1 TMI 12/07/2011 [Start]  pack the SYCMENU after using it
        SELECT SYCMENU
        PACK
        *B609764,1 TMI 12/07/2011 [End  ] 

        *B605903,1 Shift all menus records after inserting lines. [Begin]
       
        *B601052,1Hesham El-Sheltawi (START)
        *B601052,1scan through the module custom bars and check the popup it belong
        *B601052,1to and add this bar at the end of the popup it belongs to
        
        *B605903,1 SSE Commented out. [Begin]
        *-- No need for these lines of codes 
        *SELECT TMPMENU
        *lcMstname=''               
        *SCAN
        *  IF lcMstName <> cMstr_Nam
        *    lnBarno=0
        *    lnPopPos=0
        *    lcMstName = cMstr_Nam
        *    SELECT SYCMENU
        *    *E301141,1 Hesham (Start)
        *    *E301141,1 we have to defferentiate between updating the main system
        *    *E301141,1 and any other module 
        *    ** get the last bar # defined in the popup that the bar we want to add belongs            
        *    *CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos            
        *    IF lcMdToUP = 'SY'
        *      CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos
        *    ELSE
        *      CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMenuToUp AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos            
        *    ENDIF  
        *    *E301141,1 Hesham (End)            
        *    ** check if this bar is a seperator bar or not            
        *    llIsBar=.F.       
        *    *E301141,1 Hesham (Start)
        *    *E301141,1 we have to defferentiate between updating the main system
        *    *E301141,1 and any other module 
        *    *LOCATE FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')            
        *    IF lcMdToUP = 'SY'     
        *      LOCATE FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')
        *    ELSE
        *      LOCATE FOR capp_id = lcMenuToUp AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')
        *    ENDIF
        *    *E301141,1 Hesham (End)            
        *    llIsBar=FOUND() AND CSUB_PRPT='\-' AND EMPTY(CPROSS_ID)
        *    lnBarPos=IIF(llIsBar,RECNO(),0)
        *    lnBarNo  = lnBarNo+IIF(llIsBar,0,1)
        *    lnPopPos = lnPopPos+IIF(llIsBar,0,1)
        *    SELECT TMPMENU
        *  ENDIF            
        *  **get the custom bar we want to add inf.          
        *  SCATTER MEMVAR MEMO
        *  SELECT SYCMENU
        *  **append the custom bar to the menu and change the position
        *  ** of it at the end of the popup          
        *  APPEND BLANK
        *  GATHER MEMVAR MEMO
        *  REPLACE CBAR_POS WITH STRTRAN(STR(lnBarNo,2),' ','0');
        *          CPop_Pos WITH STRTRAN(STR(lnPopPos,2),' ','0')
        *  ** if the last bar in the popup was a seperator then increment
        *  ** the position of this bar by one to keep it at the end of the popup                  
        *  IF llIsBar AND lnBarPos>0
        *    GO lnBarPos
        *    REPLACE CBAR_POS WITH STRTRAN(STR(lnBarNo+1,2),' ','0');
        *            CPop_Pos WITH STRTRAN(STR(lnPopPos+1,2),' ','0')
        *  ENDIF        
        *  lnBarNo=lnBarNo+1
        *  lnPopPos = lnPopPos+1          
        *ENDSCAN
        *B601052,1Hesham El_Sheltawi (END)                                       
        *B605903,1 SSE Commented out. [End]
                                             
        
        IF lcMd_id = "SM"
          IF !EMPTY(laExtProg[1])
            FOR lnExt = 1 TO ALEN(laExtProg,1)
              IF SEEK(laExtProg[lnExt,1]+laExtProg[lnExt,2]+laExtProg[lnExt,3]+;
              laExtProg[lnExt,5]+laExtProg[lnExt,4],"SYCMENU")
                REPLACE sycmenu.cprocpath WITH laExtProg[lnExt,15]
              ENDIF
            ENDFOR
          ENDIF
        ENDIF

        *B600975,1 Hesham El-Sheltawi (Start)
        *B600975,1 check for the bar of the apparel system to change
        *B600975,1 the path
        ** If updating the main system 
        IF lcMdToUP = 'SY'
          ** IF the aria apparel branching bar exist        
          LOCATE FOR CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
          IF FOUND()
            DO CASE
              ** if fresh installation and installing app. system too
              CASE llFreshInst AND !EMPTY(lcNewMod)
                REPLACE CPROCPATH WITH LCARIAPATH+'ARIA.FXP'
              ** if fresh installation and not installing app. system
              CASE llFreshInst AND EMPTY(lcNewMod)
                 ** ask the user for the installation directory of app. system 
                 lcAriaFxp = ''
                 DO WHILE EMPTY(lcAriaFxp)
                   lcAriaFxp = GETDIR('','Select directory for Apparel System')
                   ** if the user select a directory
                   IF !EMPTY(lcAriaFxp)
                     ** check for existing of any of the files aria.exe or aria.fxp
                     lcLastComp = SET('COMP')
                     SET COMP ON
                     llFxpFound = FILE(lcAriaFxp+'ARIA.FXP') 
                     llExeFound = FILE(lcAriaFxp+'ARIA.EXE') 
                     SET COMP &lcLastComp
                     ** if found that the apparel system is installed in the
                     ** selected directory
                     IF llFxpFound OR llExeFound
                       REPLACE CPROCPATH WITH lcAriaFxp+IIF(llExeFound,'ARIA.EXE','ARIA.FXP')
                     ELSE
                       *REPLACE CPROCPATH WITH ''
                       lcAriaFxp = ''
                       lcSysName = gcSysName
                       lnMsgRec = gnMsgRec
                       gcSysName ='Aria Systems Installation'
                       gnMsgRec = 0
                       =gfModalGen(.F.,.F.,.F.,.F.,'Apparel System not installed in directory '+;
                                    ALLTRIM(lcAriaFxp)+;
                                    '? You have to select the right path or select Cancel. ')
                       gcSysName = lcSysName
                       gnMsgRec  = lnMsgRec                                      
                     ENDIF
                   ELSE
                     REPLACE CPROCPATH WITH ''  
                     DELETE
                     EXIT
                   ENDIF
                 ENDDO
              ** if Upgrade installation and installing app. system too               
              CASE !llFreshInst AND !EMPTY(lcNewMod)   
                REPLACE CPROCPATH WITH LCARIAPATH+'ARIA.FXP'
              ** if Upgrade installation and not installing app. system
              CASE !llFreshInst AND EMPTY(lcNewMod)
                REPLACE ALL CPROCPATH WITH lcAppPath FOR ;
                CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
            ENDCASE
          ENDIF
        ENDIF  
        *B600975,1 Hesham El-Sheltawi (END)
 
        
*E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"CMENU.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CMENU.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CMENU.FPT")
*E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  
      
      *E300441,4 HESHAM EL-SHELTAWI (START)
 *     IF FILE (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       SELECT 0
 *       USE (gcSysHome+lcMd_id+"DAPPL") ORDER TAG  CAPP_ID
 *       SELECT SYDAPPL
 *       DELETE ALL FOR SEEK(CAPP_ID,lcMd_id+"DAPPL")
 *       PACK
 *       USE IN (lcMd_id+"DAPPL")
 *       APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.CDX")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.FPT")
 *     ENDIF  
      *E300441,4 HESHAM EL-SHELTAWI (END)

*--HESHAM
      *B601021,1 Hesham (Start)
      *B601021,1 remarkingi the next file updating
      *B601021,1 Because it is not with a default data
*      IF FILE (gcSysHome+lcMd_id+"CPRINT.DBF") 
*        SELECT 0
*        USE (gcSysHome+lcMd_id+"CPRINT") ORDER TAG CPRINT_ID
        *SELECT SYDDLOBJ
*        DELETE ALL FOR SEEK(CPRINT_ID,lcMd_id+"CPRINT")
*        PACK
*        USE IN (lcMd_id+"CPRINT")
*        APPEND FROM (gcSysHome+lcMd_id+"CPRINT")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.FPT")
*      ENDIF 
      *B601021,1 Hesham (End)       
       
      IF FILE (gcSysHome+lcMd_id+"CP_ESC.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"CP_ESC") ORDER TAG P_NAME
        SELECT SYCP_ESC
        DELETE ALL FOR SEEK(P_NAME,lcMd_id+"CP_ESC")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"CP_ESC")
        APPEND FROM (gcSysHome+lcMd_id+"CP_ESC")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF        

*--HESHAM END

       *** CHANGE TO THE OTHER TAG
      IF FILE (gcSysHome+lcMd_id+"DDLOBJ.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DDLOBJ") ORDER TAG CDLOBJID
        SELECT SYDDLOBJ
        DELETE ALL FOR SEEK(CDLOBJTYP+CDLOBJID,lcMd_id+"DDLOBJ")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DDLOBJ")
        APPEND FROM (gcSysHome+lcMd_id+"DDLOBJ")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  
 
      IF FILE (gcSysHome+lcMd_id+"DOBJCT.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DOBJCT") ORDER TAG CAPP_ID
        SELECT SYDOBJCT
        DELETE ALL FOR SEEK(CAPP_ID+CAPOBJNAM,lcMd_id+"DOBJCT")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DOBJCT")
        APPEND FROM (gcSysHome+lcMd_id+"DOBJCT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DREPRT.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DREPRT") ORDER TAG CREP_ID
        SELECT SYDREPRT
        *E038033,1 HMA 04/03/2004 Select only Records belong to ARIA27 [BEGIN]
        *DELETE ALL FOR SEEK(CREP_ID,lcMd_id+"DREPRT")
        DELETE ALL FOR SEEK(CREP_ID,lcMd_id+"DREPRT") .AND. cVer <>"A40"
        *E038033,1 HMA [END]
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DREPRT")
        APPEND FROM (gcSysHome+lcMd_id+"DREPRT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  
      
      IF FILE (gcSysHome+lcMd_id+"DSCOBJ.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DSCOBJ") ORDER TAG CSCRNAM
        SELECT SYDSCOBJ
        DELETE ALL FOR SEEK(ALLTRIM(CSCRNAM)+CSCOBJTYP,lcMd_id+"DSCOBJ")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        
        *B602329,1 Update SYDSCOBJ file so as not to duplicate records 
        *B602329,1 shared between modules (e.g. APVENDR records)
        *USE IN (lcMd_id+"DSCOBJ")
        *APPEND FROM (gcSysHome+lcMd_id+"DSCOBJ")
        
        PRIVATE lnCurAlias, laUpdArr, lcTmpExp, lnCurTag
        lnCurAlias = SELECT(0)
        
        SELECT SYDSCOBJ
        lnCurTag = VAL(SYS(21))
        
        SET ORDER TO TAG VAR_NAME
        SELECT (lcMd_id+"DSCOBJ")
        SCAN
          *-- Append the record in the AYDSCOBJ only if it does not exist.
          lcTmpExp = ALLTRIM(cScrNam) + cscobjnam
          IF !SEEK(lcTmpExp, 'SYDSCOBJ')	
         	SCATTER TO laUpdArr MEMO
          	INSERT INTO SYDSCOBJ FROM ARRAY laUpdArr
		  ENDIF
        ENDSCAN
        RELEASE laUpdArr
        USE IN (lcMd_id+"DSCOBJ")
	    SET ORDER TO (lnCurTag) IN SYDSCOBJ
        SELECT (lnCurAlias)
        *B602329,1 end

        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"REPSRT.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPSRT") ORDER TAG CSORT_ID
        SELECT SYREPSRT
        DELETE ALL FOR SEEK(CSORT_ID+CREP_ID,lcMd_id+"REPSRT")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"REPSRT")
        APPEND FROM (gcSysHome+lcMd_id+"REPSRT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"REPUVR.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPUVR") ORDER TAG FLD_NAME
        SELECT SYREPUVR
        *B602871,1 AMM Update the required record types (standard or USER)
        *DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *B603837,1 Hesham (Start)
        *B603837,1 delete all records with the same upgrade level that is installed
        lcRpVUpgrd = EVAL(lcMd_id+"REPUVR.cupgrdlvl")
        IF lcRpVUpgrd $ "AS" 
          DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR") AND CUPGRDLVL $ "AS"
        ELSE
          DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR") AND CUPGRDLVL $ "UC"
        ENDIF
        *IF EVAL(lcMd_id+"REPUVR.cupgrdlvl") = 'A'
        *  SELECT (lcMd_id+"REPUVR")
        *  LOCATE FOR cupgrdlvl='U' 
        *  IF FOUND()
        *    SELECT SYREPUVR
        *    DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ELSE
        *    SELECT SYREPUVR
        *    DELETE ALL FOR cupgrdlvl#'U' .AND. SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ENDIF
        *ELSE   && EVAL(lcMd_id+"REPUVR.cupgrdlvl") = 'U'
        *  SELECT (lcMd_id+"REPUVR")
        *  LOCATE FOR cupgrdlvl='A' 
        *  IF FOUND()
        *    SELECT SYREPUVR
        *    DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ELSE
        *    SELECT SYREPUVR
        *    DELETE ALL FOR cupgrdlvl#'A' .AND. SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ENDIF
        *ENDIF
        *B602871,1 AMM end
        *B603837,1 Hesham (End)
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"REPUVR")
        APPEND FROM (gcSysHome+lcMd_id+"REPUVR")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.DBF")
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.CDX")
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.FPT")
        *E300441,4 Hesham El-Sheltawi (End) 
        
        *B606832,1 Update the custom records after installing standard ones. [Begin]
        lcCurAlias = ALIAS()
        SET ORDER TO TAG (lcTmpIndx) IN SyRepuvr 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPUVR") ORDER TAG cRepVar DESCENDING
        SELECT 0
        USE (gcSysHome+lcMd_id+"DREPRT")
        SCAN
          IF SEEK(cRep_ID,lcMd_id+"REPUVR") AND SEEK(cRep_ID+'U','SyRepuvr')
            lnRpVarPos = EVALUATE(lcMd_id+"REPUVR.nVarPos")

            *BSAMEH ZAP the temp cursor. [Begin]
            SELECT RepVrCur 
            ZAP
            *BSAMEH ZAP the temp cursor. [End]
            
            SELECT SyRepuvr
            SCAN REST WHILE cRep_ID + cUpGrdLvl + STR(nVarPos) = EVALUATE(lcMd_id+"DREPRT.cRep_ID")+"U"
              
              *BSAMEH Move all "U" records to temp cursor. [Begin]            
              *IF nVarPos > 0
              *  lnRpVarPos = lnRpVarPos + 1
              *  REPLACE nVarPos WITH lnRpVarPos
              *ENDIF
              IF nVarPos > 0
                SCATTER MEMVAR MEMO
                INSERT INTO RepVrCur FROM MEMVAR
                DELETE
              ENDIF
              *BSAMEH Move all "U" records to temp cursor. [End]

            ENDSCAN
            
            *BSAMEH Update all "U" records position. [Begin]            
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
          *PACK
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
            SELECT RepVrCur
            SCAN
              lnRpVarPos = lnRpVarPos + 1
              REPLACE nVarPos WITH lnRpVarPos            
            ENDSCAN
            SELECT RepVrCur
            SCAN
              SCATTER MEMVAR MEMO
              SELECT SyRepUvr
              APPEND BLANK
              GATHER MEMVAR MEMO  
            ENDSCAN
            *BSAMEH Update all "U" records position. [End]

          ENDIF
        ENDSCAN
        USE IN (lcMd_id+"DREPRT")
        USE IN (lcMd_id+"REPUVR")
        SET ORDER TO TAG (lcRpUvrTag) IN SyRepuvr 
        IF !EMPTY(lcCurAlias)
          SELECT (lcCurAlias)
        ENDIF
        *B606832,1 Update the custom records after installing standard ones. [End]

      ENDIF  


      IF FILE (gcSysHome+lcMd_id+"DFIELD.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFIELD")  ORDER TAG CFLD_NAME
        SELECT SYDFIELD
        DELETE ALL FOR SEEK(CFLD_NAME,lcMd_id+"DFIELD")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DFIELD")
        APPEND FROM (gcSysHome+lcMd_id+"DFIELD")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DFLFLD.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFLFLD") ORDER TAG CFILE_NAM
        IF lcMdToUP <> 'SM'
          SELECT SYDFIELD
          SET ORDER TO TAG CFLD_NAME
          SELECT SYDFLFLD        
          SET RELATION TO CFLD_NAME INTO SYDFIELD
          *B038431,1 ASH 10/04/2004 (Begin) Fix bug of deleting custom records from SYDFLFLD file if the field in SYDFIELD is upgrdlvl 'A'.
          *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND SYDFIELD.CUPGRDLVL<>'U'
          DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND SYDFIELD.CUPGRDLVL<>'U' AND CUPGRDLVL<>'U'
          *B038431,1 ASH 10/04/2004 (End)
          SET RELATION OFF INTO SYDFIELD          
        ELSE
          *B038431,1 ASH 10/04/2004 (Begin) Fix bug of deleting custom records from SYDFLFLD file if the field in SYDFIELD is upgrdlvl 'A'.          
          SELECT SYDFLFLD        
          *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") 
          DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND CUPGRDLVL<>'U'
          *B038431,1 ASH 10/04/2004 (End)
        ENDIF
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DFLFLD")
        APPEND FROM (gcSysHome+lcMd_id+"DFLFLD")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DINDEX.DBF")
        SELECT 0
        *B802818,1 Use Cfile_nam tag to delete specific records in SYDINDEX
        *B802818,1 so as to be able to upgrade custom indeces, and, so as 
        *B802818,1 not to overwrite them when updating a new release
        *USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG CFILE

        *B603497,1 KHM 03/03/2000 (Begin) Opening the file with cFile tag
        *B603497,1                instead of cfile_nam.
        *USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG Cfile_nam
        USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG CFILE
        *B603497,1 KHM 03/03/2000 (End)
        
        *B802818,1 end
        SELECT SYDINDEX
        *B802818,1 Delete all index tags in the module index system files
        *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DINDEX")

        *B603497,1 KHM 03/03/2000 (Begin) Changing the clause of the delete
        *B603497,1                command by adding the checking of the 
        *B603497,1                upgrade level.
        *DELETE ALL FOR SEEK(CFILE_NAM+cFILE_TAG,lcMd_id+"DINDEX")
        DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DINDEX") AND CUPGRDLVL $ "AS"
        *B603497,1 KHM 03/03/2000 (End)
        *B802818,1 end
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DINDEX")
        APPEND FROM (gcSysHome+lcMd_id+"DINDEX")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF   

      IF FILE (gcSysHome+lcMd_id+"DFILES.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFILES") ORDER TAG CFILE_NAM
        lcAlias = lcMd_id+"DFILES"  

        SELECT SYDFILES
        SET ORDER TO TAG  CFILE_NAM
        *B602640,1 Hesham (Start)
        *B602798,1 Hesham (Start)
        *B602798,1 don't remove the user defined files for the module when upgrading
        *REPLACE ALL MFILE_APP WITH STRTRAN(STRTRAN(ALLT(MFILE_APP),lcMdToUP+'$'),lcMdToUP) 
        REPLACE ALL MFILE_APP WITH STRTRAN(STRTRAN(ALLT(MFILE_APP),lcMdToUP+'$'),lcMdToUP) FOR !(CUPGRDLVL$'UC')
        *B602798,1 Hesham (End)
        *B602640,1 Hesham (End)        
        *B600989,1 Stop the replacing of the module in the SYDFILES
        *REPLACE ALL sydfiles.mfile_app ;
           WITH ALLTRIM(mfile_app)+","+ALLTRIM(&lcAlias..mfile_app);
            FOR SEEK(cfile_nam,lcMd_ID+"DFILES") .AND. ;
                AT(lcMd_ID,mfile_app)=0
        
        SELECT (lcAlias)
        *B600989,1 Replace in the Application ??DFILES by the file modules from the SYDFILES
        *B602640,1 Hesham (Start)        
        *REPLACE ALL mfile_app ;
           WITH ALLTRIM(SYDFILES.mfile_app)+IIF(AT(lcMd_ID,SYDFILES.mfile_app)=0,","+ALLTRIM(&lcAlias..mfile_app),"");
            FOR SEEK(cfile_nam,"SYDFILES") 

        REPLACE ALL mfile_app ;
           WITH ALLTRIM(SYDFILES.mfile_app)+IIF(AT(lcMdToUP+'$',&lcAlias..mfile_app)=0,","+IIF(lcMdToUP='SM' AND LEFT(CFILE_NAM,2)<>'SY','SY',lcMdToUP),","+lcMdToUP+'$');
            FOR SEEK(cfile_nam,"SYDFILES") 
        *B602640,1 Hesham (End)            
        *B600989  Go to the SYDFILES work area to delete the unneeded records
        SELECT SYDFILES        
        *B600989,1 Changed the next line. Delete all the records that exist in the ??DFILES of
        *B600989,1 the installed module in SYDFILES  (No need to check the cUpgrdLvl <> "C" 
        *B600989,1 because it the file exist in the ??DFILES, it is a system of application file
        *DELETE ALL FOR SEEK(CFILE_NAM,"SYDFILES")
        DELETE ALL FOR SEEK(CFILE_NAM,lcMd_ID+"DFILES")


        USE IN (lcMd_id+"DFILES") 
        SELECT SYDFILES
        APPEND FROM (gcSysHome+lcMd_id+"DFILES")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFILES.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFILES.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFILES.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF llFreshInst AND lcMdToUP='SY'
          SELECT 0
          USE (gcSysHome+'SYCINT')
          APPEND FROM (gcSysHome+lcMd_id+"CINT")
      ENDIF
      *E300441,4 Hesham El-Sheltawi (Start)
*      ERASE (gcSysHome+lcMd_id+"CINT.DBF") 
*      ERASE (gcSysHome+lcMd_id+"CINT.CDX")
      *E300441,4 Hesham El-Sheltawi (End)

      *E301252,1 AMM comment out, use another function to update (LFUSETUP)
      *E300454,1 Hesham El-Sheltawi (Start)
      *IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP = 'SY'
      *  =gfUpdSetup(@laCompany)
      *ENDIF
      *E300454,1 Hesham El-Sheltawi (End)
      *E301252,1 AMM end
          
      *E301065,1 AMM Update SYFRMCDH, SYFRMCDD with the new records.
      IF FILE (gcSysHome+lcMd_id+"FRMCDH.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"FRMCDH") ORDER TAG FORMCDHD
        SELECT SYFRMCDH
        DELETE ALL FOR SEEK(cFormMaj,lcMd_ID+"FRMCDH")
        USE IN (lcMd_id+"FRMCDH")
        APPEND FROM (gcSysHome+lcMd_id+"FRMCDH")
      ENDIF  
      IF FILE (gcSysHome+lcMd_id+"FRMCDD.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"FRMCDD") ORDER TAG FORMCDDT
        SELECT SYFRMCDD
        DELETE ALL FOR SEEK(cFormMaj+cFormCode,lcMd_ID+"FRMCDD")
        USE IN (lcMd_id+"FRMCDD")
        APPEND FROM (gcSysHome+lcMd_id+"FRMCDD")
      ENDIF  
      *E301065,1 AMM end 
      
      *E301252,1 AMM Update SYCCONFG with the splitted files
      =lfUSetup('S',lcMd_id)
      *E301252,1 AMM end
      
      *B600975,10 Hesham El-Sheltawi (START)
      *E300645,1 Hesham El-Sheltawi (Start)
      *E300645,1 force the system to update all the system data files in all
      *E300645,1 companies "EX. codes,sequence files"
*      IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP <> 'SY' AND lcMdToUP <> 'SM'
*        =gfUpdModFl('UPDATE',lcMdToUP)      
*      ENDIF  
      *Ren
      *IF !llFreshInst AND !EMPTY(laCompany[1,1])  AND lcMdToUP <> 'SM'
      IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP <> 'SY'  
      *Ren end
        =gfUpdModFl('UPDATE',lcMdToUP)      
      ENDIF  
      *E300645,1 Hesham El-Sheltawi (End)
      *B802980,1 Hesham Start
      IF FILE(gcSysHome+lcMd_id+"SZONES.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"SZONES") ORDER TAG Frtzones
        SELECT SYSZONES
        SET ORDER TO TAG Frtzones
        lcZonKey = KEY()
        SELECT (lcMd_id+"SZONES")
        GO TOP
        SCAN
          IF !SEEK(EVAL(lcZonKey),'SYSZONES')
            SCATT MEMVAR MEMO
            INSERT INTO SYSZONES FROM MEMVAR
          ENDIF
        ENDSCAN
      ENDIF
      *B802980,1 Hesham END
      
      *B600975,10 Hesham El-Sheltawi (START)      
      *E300441,4 Hesham El-Sheltawi (Start)        
      =lfDelSplit(lcMdToUp)        
      *E300441,4 Hesham El-Sheltawi (End)        
    ENDIF
  ENDFOR
  
  
  
  *++nad40
  
  PRIVATE lcOrdAPPL ,lnRecnAPPL ,llclsAPPl
  lcOrdAPPL=""
  lnRecnAPPL=1
  llclsApl =.F.
  
  IF USED ("SYDAPPL")
    
    lcOrdAPPL =ORDER('SYDAPPL')
    lnRecnAPPL =RECNO('SYDAPPL') 
    USE IN SYDAPPL
    llclsApl =.T.
  ENDIF
  
  IF !EMPTY(UPDMODUL.mModules)
    DECLARE laCompany [1,3] 
    STORE '' TO laCompany
    SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
      FROM (gcSyshome+"syccomp") ;
      INTO ARRAY laCompany ;
      ORDER BY 1

    FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
      IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
        lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
        IF lcMd_id <> 'SM' AND lcMd_id <> 'SY'
          lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
          lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
          WAIT 'Running fix programs for module '+lcMd_name WINDOW NOWAIT
          
          = gfRunFxPrg(lcMd_id,.T.)
         
        ENDIF
        lcMd_ID =IIF(lcMd_id='SY','XX',lcMd_id)
        IF USED(lcMd_id+'DFXPRG') 
          USE IN (lcMd_id+'DFXPRG')
        ENDIF
        ERASE gcSysHome+lcMd_id+'DFXPRG.DBF'
        ERASE gcSysHome+lcMd_id+'DFXPRG.FPT'
        ERASE gcSysHome+lcMd_id+'DFXPRG.CDX'
      ENDIF
    ENDFOR    
 ENDIF
  
  IF llclsApl 
     
     USE (gcSysHome+"SYDAPPL.DBF") in 0  ORDER TAG lcOrdAPPL EXCL
     
     IF BETWEEN(lnRecnAPPL,1,RECCOUNT("SYDAPPL"))
       GOTO lnRecnAPPL IN SYDAPPL
     ENDIF
  ENDIF
 *++NAD40

  *C200443,1 Copy custom related fields to standard code. [Begin]
  lcSyFldTag = ORDER('SydField')
  SET ORDER TO TAG cFld_Name IN SydField
  SELECT TmpFields
  SCAN
    IF SEEK(cFld_Name,'SydField') AND !(ALLTRIM(STRTRAN(mRltFields,' ','')) == ALLTRIM(STRTRAN(SydField.mRltFields,' ','')))
      =gfSubStr(mRltFields,@laRltField,'|')
      =gfSubStr(SydField.mRltFields,@laNewRFld,'|')
      FOR lnPipeN2 = 1 TO ALEN(laNewRFld,1)
        laNewRFld[lnPipeN2] = PADR(ALLTRIM(laNewRFld[lnPipeN2]),10)
      ENDFOR
      FOR lnPipeN1 = 1 TO ALEN(laRltField,1)
        IF !ASCAN(laNewRFld,PADR(ALLTRIM(laRltField[lnPipeN1]),10)) > 0
          SELECT SydField
          lcSyFldKey = EVALUATE(KEY())
          IF SEEK(ALLTRIM(laRltField[lnPipeN1])) AND SydField.cUpgrdLvl = 'U' AND SEEK(lcSyFldKey)
            REPLACE mRltFields WITH mRltFields + IIF(RIGHT(mRltFields,1)='|','','|') + ALLTRIM(laRltField[lnPipeN1])
          ENDIF
        ENDIF
      ENDFOR
    ENDIF
  ENDSCAN
  SET ORDER TO TAG (lcSyFldTag) IN SydField
  *C200443,1 Copy custom related fields to standard code. [End]
  
  *B606832,1 Close the temp index. [Begin]
  SELECT SyRepuvr
  CLOSE INDEX
  ERASE (gcWorkDir + lcTmpIndx + '.CDX')
  *B606832,1 Close the temp index. [End]
  
  SELECT SYDAPPL
  SET ORDER TO TAG CAPP_ID
  SELECT SYCMENU
  SET ORDER TO TAG APPPOPBAR

  *B604063,1 HS 12/12/2000 Change these lines to fix the EDI modules menu update error [Begin]
  *SET RELATION TO ALLTRIM(sycmenu.cpross_id) INTO SYDAPPL ADDITIVE  
  *
  *IF SEEK("SY"+"07")
  *  SCAN WHILE capp_id = "SY" .AND. cpad_pos ="07" FOR cproctype ="M"
  *     IF EOF("SYDAPPL") 
  *       DELETE
  *     ENDIF
  *  ENDSCAN
  *ENDIF

  *SAMEH     SSE            Fix problem with custom Modules in SycMenu Build 40. [Begin]
  IF SEEK("SY07")
    SKIP
    PRIVATE lnCurPos
    lnCurPos = VAL(cPop_Pos)
    IF lnCurPos > 0
      SCAN REST WHILE cApp_ID = "SY" AND cPad_Pos = "07" FOR !EMPTY(cPop_Pos)
        REPLACE cPop_Pos WITH PADL(ALLTRIM(STR(lnCurPos)),2,"0") , cBar_Pos WITH PADL(ALLTRIM(STR(lnCurPos)),2,"0")
        lnCurPos = lnCurPos + 1
      ENDSCAN
    ENDIF  
  ENDIF
  *SAMEH     SSE            Fix problem with custom Modules in SycMenu Build 40. [End]
  
  *-- Seek for the first module bar record
  IF SEEK("SY" + "07")
    *-- Scan the module bar records
    SCAN WHILE cApp_ID = "SY" .AND. cPad_Pos = "07";
           FOR cProcType = "M"
      
      *-- If the menu bar is assigned to only one module
      IF EMPTY(cBarModule)
        *-- Check if the module doesn't exist (not installed)
        IF !SEEK(ALLTRIM(cPross_ID) , "SYDAPPL")
          *-- Delete the module bar record
          DELETE
        ENDIF
      ELSE    && Else, if the menu bar is assigned to more than one module
        PRIVATE lcBarModul
        
        *-- Variable to hold the bar modules
        lcBarModul = ALLTRIM(cBarModule)
        *-- Do while, there are still modules that has not been checked yet
        DO WHILE !EMPTY(lcBarModul)
          *-- If the first character is the ","character remove it from the string
          lcBarModul = IIF(LEFT(lcBarModul , 1) = "," , SUBSTR(lcBarModul , 2) , lcBarModul)
          
          *-- Check if the first module in the bar modules string exist (installed)
          IF SEEK(LEFT(lcBarModul , 2) , "SYDAPPL")
            *-- If the module is installed exit the DO WHILE loop
            EXIT
          ELSE    && Else, if the module doesn't exist (not installed)
            *-- Remove the module name from the bar modules string
            lcBarModul = SUBSTR(lcBarModul , 3)
          ENDIF
        ENDDO
        
        *-- If none of the bar modules is installed
        IF EMPTY(lcBarModul)
          *-- Delete the module bar record
          DELETE
        ENDIF
      ENDIF
    ENDSCAN
  ENDIF
  *B604063,1 HS 12/12/2000 Change these lines to fix the EDI modules menu update error [End]

  SET MOUSE ON
  
  USE IN UPDMODUL
  USE IN SYCMENU
  USE IN SYDAPPL
  USE IN SYDDLOBJ
  USE IN SYDFIELD
  USE IN SYDFILES
  USE IN SYDFLFLD
  USE IN SYDINDEX
  USE IN SYDOBJCT
  USE IN SYDREPRT
  USE IN SYDSCOBJ
  USE IN SYREPSRT
  USE IN SYREPUVR
  *E301077,78 Hesham (Start)
  IF USED('SYCINT')
    USE IN SYCINT
  ENDIF
  *E301077,78 Hesham (End)
  *hesham start
  USE IN SYCPRINT
  USE IN SYCP_ESC
  *hesham end
  *E301065,1 AMM start, Close files
  USE IN SYFRMCDH
  USE IN SYFRMCDD
  *E301065,1 AMM end  

  *E301252,1 AMM Close file 
  IF USED('SYCCONFG')
    USE IN SYCCONFG
  ENDIF
  *E301252,1 AMM end

  *B802980,1  Hesham (Start)
  IF USED('SYSZONES')
    USE IN SYSZONES
  ENDIF
  *B802980,1  Hesham (End)
  
  USE (gcSysHome+"SYUSTATC") EXCL
  lcSafty = SET('SAFETY')
  SET SAFETY OFF 
  ZAP
  USE

  *B803990,1 MAB 02/04/2001 Zap the SYDTRANS. [Begin]
  *B604944,1 NAD 09/20/2001  Not to zap the sydtrans (START)
  *DO lpZapTrans
  *B604944,1 NAD (END)
  *B803990,1 MAB 02/04/2001 Zap the SYDTRANS. [End  ]

  SET SAFETY &lcSafty
  *E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*  ERASE (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
  ERASE (SYS(5)+CURDIR()+"UPDMODUL.DAT")
  *E303062,3 TMI 02/14/2012 [End  ] 
  WAIT CLEAR
  *B601052,1Hesham El_Sheltawi (Start)                                       
  *B038431,1 MHM 09/04/2004 no need to use it [Start]
  *IF USED('TMPMENU')
  *  USE IN TMPMENU  
  *ENDIF  
  *B038431,1 MHM [End]
  *B601052,1Hesham El_Sheltawi (END) 
  
  *B605903,1 Erase temp files used. [Begin]
  *B038431,1 MHM 09/04/2004 no need to use it [Start]
  *IF USED('TmpSbMnu')
  *  USE IN TmpSbMnu
  **ENDIF
  *B038431,1  [End]
  IF USED('TmpEmpMn')
    USE IN TmpEmpMn
    ERASE (gcWorkDir + 'TmpEmpMn.DBF')
    ERASE (gcWorkDir + 'TmpEmpMn.CDX')
    ERASE (gcWorkDir + 'TmpEmpMn.FPT')
  ENDIF
  *B605903,1 Erase temp files used. [Begin]                                      
  
  *E300613,1 YMA 06/24/97 Update the SYCCOMP with the sample '99' company
  *E300613,1 YMA 06/24/97 record if it was installed.
  = lfUSmpData()
  *E300613,1 YMA End.
ENDIF

*B605445,1 NAD 01/30/2002 Fix Bug in the Realease 
=lfUpdTrans()
*B605445,1 NAD 01/30/2002 Fix Bug in the Realease 
*B602265,1 (Start)
*B602265,1 Checking if there is any one else updating the system
*USE IN sycresrc
*IF llStaticUs
*  USE IN SYUSTATC
*ENDIF  
*B602265,1 (End)

*E303076,3 TMI 02/23/2012 [Start] Call the gfSetPath to remove the PATH.DAT after first run [Media] 
=gfSetPath()
*E303076,3 TMI 02/23/2012 [End  ] 

SET SAFETY &lcSetSafe

close all
*B609764,1 TMI 12/07/2011 [Start] no need for this messagebox
*messagebox('Update completed',0,'Aria')
RELEASE ALL 
*B609764,1 TMI 12/07/2011 [End  ] 

*E300441,4 Hesham El-Sheltawi (Start) 
*E300441,4 FUNCTION TO CHECK THE VERSION OF THE SYDAPPL FILE
*E300441,4 IF the file does not contain the fields that hold 
*E300441,4 the platform build# it create new file with these
*E300441,4 fields and copy the existing file records
FUNCTION lfUpdAppl
PRIVATE lcTmpName,lnCount
lcTmpName = gfTempName()
IF FILE(gcSysHome+'SYDAPPL.DBF')
  SELECT 0
  USE (gcSysHome+'SYDAPPL.DBF')
  IF TYPE('SYDAPPL.CDOSBUILD')$'UL'
    DIME laApplField[1,4]
    STORE '' TO laApplField
    =AFIELDS(laApplField)
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CDOSBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CWINBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CMACBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CUNIXBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplIndex[1,2]
    STORE '' TO laApplIndex
    lnCount = 1
    DO WHILE !EMPTY(TAG(lnCount))
      IF !EMPTY(laApplIndex[1,1])
        DIME laApplIndex[ALEN(laApplIndex,1)+1,2]
      ENDIF
      laApplIndex[ALEN(laApplIndex,1),1] = TAG(lnCount)
      laApplIndex[ALEN(laApplIndex,1),2] = SYS(14,lnCount)
      lnCount = lnCount+1
    ENDDO
    USE IN SYDAPPL
    *C201350,1 TMI 07/05/2011 [Start] 
    *CREATE DBF (gcSysHome+lcTmpName) FROM ARRAY laApplField
    CREATE DBF (gcSysHome+lcTmpName+'FOX9') FROM ARRAY laApplField
    COPY TO (gcSysHome+lcTmpName) FOX2X
    USE (gcSysHome+lcTmpName) EXCLUSIVE
    ERASE (gcSysHome+lcTmpName+'FOX9.*')
    *C201350,1 TMI 07/05/2011 [End  ] 
    FOR lnCount = 1 TO ALEN(laApplIndex,1)
      IF !EMPTY(laApplIndex[lnCount,1])
        INDEX ON &laApplIndex[lnCount,2] TAG &laApplIndex[lnCount,1] ADDI
      ENDIF
    ENDFOR
    APPEND FROM (gcSysHome+'SYDAPPL.DBF')
    REPLACE ALL CDOSBUILD WITH CMDLBUILD,;
                CWINBUILD WITH CMDLBUILD,;
                CUNIXBUILD WITH CMDLBUILD,;
                CMACBUILD WITH CMDLBUILD
    USE IN (lcTmpName)
    ERASE (gcSysHome+'SYDAPPL.DBF')
    ERASE (gcSysHome+'SYDAPPL.FPT')
    ERASE (gcSysHome+'SYDAPPL.CDX')        
    RENAME (gcSysHome+lcTmpName+'.DBF') TO (gcSysHome+'SYDAPPL.DBF')
    RENAME (gcSysHome+lcTmpName+'.CDX') TO (gcSysHome+'SYDAPPL.CDX')    
    IF FILE (gcSysHome+lcTmpName+'.FPT')
      RENAME (gcSysHome+lcTmpName+'.FPT') TO (gcSysHome+'SYDAPPL.FPT')        
    ENDIF
  ENDIF
ENDIF
IF USED('SYDAPPL')
  USE IN SYDAPPL
ENDIF
*E300441,4 Hesham El-Sheltawi (End) 

*!*************************************************************
*! Name      : gfTempName
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Creat temp file name
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfTempName
*E301164,1 Hesham (Start)
*E301164,1 store all temprory files created by the program 
lcRetName = ("X"+SUBSTR(SYS(2015),4))

*B606953,1 AMH Fix bug of gfTempName create temp names of currently exist files [Start]
IF TYPE('gcWorkDir') = 'C'
  DO WHILE FILE(gcWorkDir+lcRetName+'.DBF')
    lcRetName = ("X"+SUBSTR(SYS(2015),4))
  ENDDO
ENDIF 
*B606953,1 AMH [End]

IF TYPE('laPrgTemps')#'U' 
  IF !EMPTY(laPrgTemps[1])
    DIMEN laPrgTemps[ALEN(laPrgTemps,1)+1,1]
  ELSE  
    DIMEN laPrgTemps[1,1]  
  ENDIF
  laPrgTemps[ALEN(laPrgTemps,1),1] = lcRetName
ENDIF
RETURN lcRetName
*RETURN ("X"+SUBSTR(SYS(2015),4))
*E301164,1 Hesham (End)
*!*************************************************************
*! Name      : gfUpdatSYS
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO update the structure of the system files
*!*************************************************************
*! Calls     : 
*!      Called by: GFUPDMODUL()             (function  in ARIA3.PRG)
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!          Calls: GFADEL()                 (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfUpdatSYS
*--while the system files does not exist yet so we have to remark
*--the usable of the sycinst file
*IF !USED('SYCINST')
*  SELECT 0
*  USE(gcSysHome+"SYCINST")
*ELSE
*  SELECT SYCINST
*ENDIF    
*gcWorkDir = ALLTRIM(cinsdoswd)
*USE
*E301199,1 Hesham (Start)
IF !llFreshInst
  DECLARE laCompany [1,3] 
  STORE '' TO laCompany
  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1
    IF USED('SYCCOMP')
      USE IN SYCCOMP
    ENDIF
ENDIF
*++NAD40
*=gfRunFxPrg('SM')
=gfRunFxPrg('SM',.F.)
*++NAD40
*E301199,1 Hesham (End)
SELECT 0
USE (gcSysHome+"SMDFILES")
SELECT 0
USE (gcSysHome+"SMDFIELD")

*SAMEH     SSE Add all the upgrade level 'U' or 'C'. [Begin]
IF FILE(gcSysHome+"SYDFIELD.DBF")
  SET ORDER TO TAG cFld_Name

  USE (gcSysHome+"SYDFIELD") IN 0

  *BSAMEH Change this code. [Begin]
  *APPEND FROM (gcSysHome+"SYDFIELD") FOR cUpGrdLvl $ 'UC' AND ;
  *            !SEEK(SydField.cFld_Name,'SMDFIELD')
  *USE IN SydField            
  *SET ORDER TO 
  SELECT SydField
  SCAN FOR cUpGrdLvl $ 'UC'
    IF !SEEK(cFld_Name,'SMDFIELD')
      SCATTER MEMVAR MEMO
      SELECT SMDFIELD
      APPEND BLANK
      GATHER MEMVAR MEMO
    ENDIF
  ENDSCAN
  SELECT SMDFIELD  
  SET ORDER TO
  *BSAMEH Change this code. [End]

ENDIF
*SAMEH     SSE  Add all the upgrade level 'U' or 'C'. [End]

SELECT 0
USE (gcSysHome+"SMDFLFLD")
SELECT 0
USE (gcSysHome+"SMDINDEX")

SET SAFETY OFF 

SELECT SMDFILES
DECLARE laMdlFiles[1,2]
*** get the name of all system files
*E303364,1 consider the field cVer in A271stRun TMI 03/09/2013 [Start] 
*SELECT CFILE_NAM,CFILE_TTL ;
       FROM (gcSysHome+"SMDFILES") ;
       WHERE LEFT(CFILE_NAM,2) = "SY"  .AND. CFILE_NAM <> 'SYCERROR' ;  
       INTO ARRAY laMdlFiles 
SELECT CFILE_NAM,CFILE_TTL ;
       FROM (gcSysHome+"SMDFILES") ;
       WHERE LEFT(CFILE_NAM,2) = "SY"  .AND. CFILE_NAM <> 'SYCERROR' ;  
       AND LSQLFILE = .F. ;
       INTO ARRAY laMdlFiles 
*E303364,1 consider the field cVer in A271stRun TMI 03/09/2013 [End  ] 
*.AND.  !lsys_data

lnRecords  = _TALLY
lcTempName = 'x'+RIGHT(SYS(3),7)
lcPathTemp = gcSysHome+lcTempName  


FOR lnCounter = 1 TO ALEN(laMdlFiles,1)
  lcFileNam  = UPPER(ALLTRIM(laMdlFiles[lnCounter,1]))
  lcPathFile = gcSysHome+lcFileNam

  =gfThermo(lnRecords,lnCounter,"Updating system file : ",laMdlFiles[lnCounter,2])
  
  ** Select the file structure in Array **
  DECLARE laFileStrc[1,5]
  laFileStrc = " "
  *** Get the structure of the file
  *C201317,1 TMI 07/05/2011 [Start] 
  *SELECT smdflfld.cfld_name,smdfield.cdata_typ, ;
         smdfield.nfld_wdth,smdfield.nfld_dec, ;
         smdflfld.nfld_pos ;
    FROM (gcSysHome+"smdflfld"),(gcSysHome+"smdfield") ;
         ORDER BY smdflfld.nfld_pos ;
         GROUP BY smdField.cFld_Name ;
    WHERE UPPER(smdflfld.cfile_nam) = lcFileNam .AND. ;
          smdfield.cfld_name = smdflfld.cfld_name ;
          INTO ARRAY laFileStrc

  lcCursor = gfTempName()  && cursor to save fields to ride of duplicates

  *E303364,1 consider the field cVer in A271stRun TMI 03/09/2013 [Start] 
*!*	  SELECT smdflfld.cfld_name,smdfield.cdata_typ, ;
*!*	         smdfield.nfld_wdth,smdfield.nfld_dec, ;
*!*	         smdflfld.nfld_pos ;
*!*	    FROM (gcSysHome+"smdflfld"),(gcSysHome+"smdfield") ;
*!*	         ORDER BY smdflfld.nfld_pos ;         
*!*	    WHERE UPPER(smdflfld.cfile_nam) = lcFileNam .AND. ;
*!*	          smdfield.cfld_name = smdflfld.cfld_name ;
*!*	          INTO TABLE (gcWorkDir+lcCursor)
  SELECT smdflfld.cfld_name,smdfield.cdata_typ, ;
         smdfield.nfld_wdth,smdfield.nfld_dec, ;
         smdflfld.nfld_pos ;
    FROM (gcSysHome+"smdflfld"),(gcSysHome+"smdfield") ;
         ORDER BY smdflfld.nfld_pos ;         
    WHERE UPPER(smdflfld.cfile_nam) = lcFileNam .AND. ;
          smdfield.cfld_name = smdflfld.cfld_name .AND. ;
          EMPTY(CVER) OR CVER='A27' ;
          INTO TABLE (gcWorkDir+lcCursor)
   *E303364,1 consider the field cVer in A271stRun TMI 03/09/2013 [End  ] 
   INDEX ON cfld_name TAG cfld_name
   LOCATE
   DO WHILE !EOF()
     lcFld = cfld_name
     SKIP
     DELETE REST WHILE cfld_name = lcFld
   ENDDO
   PACK
   SELECT * FROM &lcCursor INTO ARRAY laFileStrc
   USE IN &lcCursor
   ERASE (gcWorkDir+lcCursor+'.*')
   *C201317,1 TMI 07/05/2011 [End  ] 
   
     
  =gfAdel(@laFileStrc,5,2)  && An additional colum holding the position 
                            && of each field has to be removed from the
                            && Array befor verification or building.
  
  SELECT SMDINDEX
  DECLARE laFileCDX[1,4]
  laFileCDX = " "
  ** Select the file index in Array **
  SELECT smdindex.cindx_exp,smdindex.cfile_tag, ;
         smdindex.lascend,smdindex.lunique ;
         FROM (gcSysHome+"smdindex") ;
         WHERE UPPER(smdindex.cfile_nam) = lcFileNam ;
         INTO ARRAY laFileCDX

  IF !FILE(lcPathFile+".DBF")
    *C201350,1 TMI 07/05/2011 [Start]     
    *CREATE DBF (lcPathFile) FROM ARRAY laFileStrc
    CREATE DBF (lcPathFile+'FOX9') FROM ARRAY laFileStrc
    COPY TO (lcPathFile) FOX2X 
    USE (lcPathFile) EXCLUSIVE
    ERASE (lcPathFile+'FOX9.*')
    *C201350,1 TMI 07/05/2011 [End  ] 

    IF !EMPTY(laFileCDX[1])
      FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
        lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
        lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')

        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
        *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2]; 
        *         ADDITIVE &lcAscend &lcUnique
        ON ERROR llErr=.T.
        lcNdx = laFileCDX[lnTagNo,1]
        lcTag = laFileCDX[lnTagNo,2]
        INDEX ON &lcNdx TAG &lcTag ; 
                 ADDITIVE &lcAscend &lcUnique
        ON ERROR
        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ]          
      ENDFOR            
    ENDIF
    USE 
  ELSE 
    *C201350,1 TMI 07/05/2011 [Start] 
    *CREATE DBF (lcPathTemp) FROM ARRAY laFileStrc
    CREATE DBF (lcPathTemp+'FOX9') FROM ARRAY laFileStrc
    COPY TO (lcPathTemp) FOX2X
    USE (lcPathTemp) EXCLUSIVE
    ERASE (lcPathTemp+'FOX9.*')    
    *C201350,1 TMI 07/05/2011 [End  ] 

    IF !EMPTY(laFileCDX[1])
      FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
        lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
        lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')
        
        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
        *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2];
        *         ADDITIVE &lcAscend &lcUnique
        ON ERROR llErr=.T.
        lcNdx = laFileCDX[lnTagNo,1]
        lcTag = laFileCDX[lnTagNo,2]
        INDEX ON &lcNdx TAG &lcTag ; 
                 ADDITIVE &lcAscend &lcUnique
        ON ERROR
        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
                 
      ENDFOR            
    ENDIF
    SELECT (lcTempName)
    APPEND FROM (lcPathFile)
    USE 
    
    *--Ramy
    IF USED(lcFileNam)
      USE IN (lcFileNam)
    ENDIF
    
    IF FILE(lcPathFile+'.DBF')
      ERASE (lcPathFile+'.DBF')
    ENDIF  
    IF FILE(lcPathFile+'.FPT')
      ERASE (lcPathFile+'.FPT')
    ENDIF  
    IF FILE(lcPathFile+'.CDX')
      ERASE (lcPathFile+'.CDX')
    ENDIF  
    
    
     
    IF FILE(lcPathTemp+'.DBF')            
      RENAME (lcPathTemp+'.DBF') TO (lcPathFile+'.DBF')
      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
      *T20110704.0013 TMI 07/05/2011 [Start] removing this part as it is now called from VFP
      *wait window 'Flushing...' timeout 0.5
      *flush
      *wait window 'Flushing...' timeout 0.5
      *T20110704.0013 TMI 07/05/2011 [End  ] 
      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
    ENDIF
    IF FILE(lcPathTemp+'.FPT') 
      RENAME (lcPathTemp+'.FPT') TO (lcPathFile+'.FPT')
      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
      *T20110704.0013 TMI 07/05/2011 [Start] removing this part as it is now called from VFP
      *wait window 'Flushing...' timeout 0.5
      *flush
      *wait window 'Flushing...' timeout 0.5
      *T20110704.0013 TMI 07/05/2011 [End  ] 
      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
    ENDIF
    IF FILE(lcPathTemp+'.CDX')
      RENAME (lcPathTemp+'.CDX') TO (lcPathFile+'.CDX')
      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
      *T20110704.0013 TMI 07/05/2011 [Start] removing this part as it is now called from VFP
      *wait window 'Flushing...' timeout 0.5
      *flush
      *wait window 'Flushing...' timeout 0.5
      *T20110704.0013 TMI 07/05/2011 [End  ] 
      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
    ENDIF  

  ENDIF
ENDFOR

USE IN SMDFILES
USE IN SMDFIELD
USE IN SMDFLFLD
USE IN SMDINDEX



*!*************************************************************
*! Name      : gfRunFxPrg
*! Developer : Hesham El-Sheltawi
*! Date      : 04/13/1999
*! Purpose   : Function To run fix programs before update file
*!             structure and to update the sydfxprg file
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : lcModToRun    Module ID to run its fix prgs
*!*************************************************************
*! Returns            : NONE
*!*************************************************************
*! Called Form        : gfupdmodul
*!*************************************************************
*! Example            : = gfRunFxPrg('AP')
*!*************************************************************
*! Due To E301199,1
*!*************************************************************
FUNCTION gfRunFxPrg

*++NAD40
*PARAMETERS lcModToRun
PARAMETERS lcModToRun , llRunAfter
*++NAD40


*-- if the module id that we pass is not the SM module then we are running
*-- data fix programs
*B609580,2 TMI 05/10/2011 [Start] whether gcAppHome is defined or not, gcAppHome should be the same as the path of AAS_WIN.EXE
*B609580,2                        exactly as the value built in the SYCINST and retrived later in the normal run
*IF TYPE('gcAppHome')#'C'
*  gcAppHome = STRTRAN(UPPER(gcSysHome),'\SYSFILES\','\PRGS\')
*ENDIF
gcAppHome = FULLPATH('')+'PRGS\'
*B609580,2 TMI 05/10/2011 [End  ] 
gcFxPrgDir = gcAppHome+'SM\'
*-- if the module we are updating does not have the file than hold fix programs
IF !FILE(gcSysHome+lcModToRun+'DFXPRG.DBF')
  RETURN
ENDIF
*-- if the system file than hold fix programs does not exit in the system path
*-- directory then copy the module fix programs file
IF !FILE(gcSysHome+'SYDFXPRG.DBF')
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.DBF') TO (gcSysHome+'SYDFXPRG.DBF')
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.FPT') TO (gcSysHome+'SYDFXPRG.FPT')  
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.CDX') TO (gcSysHome+'SYDFXPRG.CDX')  
ENDIF

*B603392,1 Hesham (Start)
*B603392,1 Open application file
llOpenApp = .F.
llMdFreshInst = .T.  
IF !llFreshInst AND !USED('SYDAPPL')
  SELECT 0 
  USE (gcSysHome+"SYDAPPL") ORDER TAG  CAPP_ID  EXCL
  llOpenApp = .t.      
  llMdFreshInst = !SEEK(lcModToRun,"SYDAPPL")  
ENDIF  

*B603392,1 Hesham (End)

*-- if not fresh installation then start running the fix programs
DIMEN laFxPrg[1,4]
STORE '' TO laFxPrg
*B603392,1 Hesham (Start)
*B603392,1 Check if moule we are running fix programs for is
*B603392,1 not a fresh installation
IF !llMdFreshInst
*IF !llFreshInst
*B603392,1 Hesham (End)
  *-- open the system fix programs file
  USE (gcSysHome+'SYDFXPRG') IN 0 ORDER TAG COBJECTID
  *-- open the installed module fix program file
  USE (gcSysHome+lcModToRun+'DFXPRG') IN 0 AGAIN ALIAS FLFLDPRG ORDER TAG COBJECTTYP
  SELECT 0
  USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ALIAS PRGFILE ORDER TAG COBJECTTYP
  lcPrgAlias = lcModToRun+'DFXPRG'
  SET RELATION TO COBJECTID+COBJECTTYP INTO FLFLDPRG ADDI
  SELECT 0
 
  *++NAD40
  *USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ORDER TAG COBJECTTYP
  IF USED(lcModToRun+'DFXPRG')
    SELECT (lcModToRun+'DFXPRG')
    SET ORDER TO COBJECTTYP
    LOCATE
  ELSE
    USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ORDER TAG COBJECTTYP
  ENDIF
  *++NAD40
 
  *-- build relation to the system fix program file
  SET RELATION TO COBJECTID INTO SYDFXPRG ADDI
  SET RELATION TO COBJECTID+'File' INTO PRGFILE ADDI
  *-- if there is any program information exist in the module fix programs file 
  IF SEEK(SPACE(10)+'Program')
    *-- scan through the records that hold fix programs in the installed module
    *++NAD40
    *SCAN REST WHILE CPARENTID+COBJECTTYP = SPACE(10)+'Program'
    SCAN REST WHILE CPARENTID+COBJECTTYP = SPACE(10)+'Program' FOR ;
              IIF(TYPE(lcPrgAlias+'.LRUNAFTER')="L",&lcPrgAlias..LRUNAFTER = llRunAfter,.T.)
    *++NAD40
    
      *-- if the the fix program was not deleted and the program was not runned before
      *-- or the fix program is installed for the first time
      IF (CSTATUS<>'D' AND !SYDFXPRG.LPRGRUN) OR EOF('SYDFXPRG')
        llRunData = CUPGRDLVL = 'A'
        *-- if the fix program exist
        IF FILE(gcFxPrgDir+ALLT(COBJECTNAM)+'.FXP') 
          *-- redimention the array that hold the fix programs to be run
          IF !EMPTY(laFxPrg[1,1])
            DIMEN laFxPrg[ALEN(laFxPrg,1)+1,ALEN(laFxPrg,2)]
          ENDIF
          *-- variable to hold the companies that the fix program can run on it's data
          lcCompToRun = ''
          SELECT PRGFILE
          *-- check if there is any data files the program need to check for existence
          llFound = !SEEK(&lcPrgAlias..COBJECTID+'File ')
          llTagErr = .F.
          lcCompToRun = ''
          lcOnErr = ON('ERROR')
          llTagErr = .F.
          ON ERROR llTagErr = .T.
          *-- loop through the comapanies installed if we are running a data fix programs
          *-- if we are running a system fix programs then loop only one time
          IF llRunData 
            IF EMPTY(laCompany[1,1])
              LOOP
            ENDIF
          ENDIF  
          FOR lnCount = 1 TO IIF(llRunData,ALEN(laCompany,1),1)
            =SEEK(&lcPrgAlias..COBJECTID+'File ')
            *-- scan through all files need by the fix program
            SCAN REST WHILE CPARENTID+COBJECTTYP = &lcPrgAlias..COBJECTID+'File '
              IF CSTATUS='D'
                LOOP
              ENDIF
              *-- if the file needed by the fix program exist then check the fields
              *-- and indexes
              IF FILE(IIF(llRunData,ALLT(laCompany[lnCount,2]),gcSysHome)+ALLT(COBJECTNAM)+'.DBF')
                SELECT FLFLDPRG
                *-- if there is any field or index needed to be checked in the file structure
                IF SEEK(PRGFILE.COBJECTID)
                  *-- if the data file used then close it
                  IF USED(ALLT(PRGFILE.COBJECTNAM))
                    USE IN (ALLT(PRGFILE.COBJECTNAM))
                  ENDIF
                  *-- open the data or system file needed by the fix program
                  USE (IIF(llRunData,ALLT(laCompany[lnCount,2]),gcSysHome)+ALLT(PRGFILE.COBJECTNAM)+'.DBF') IN 0
                  SELECT FLFLDPRG
                  llTagErr = .F.
                  *--scan through the fields and indexes needed by the file that the fix program
                  *--need to be in the file structure
                  SCAN REST WHILE CPARENTID+COBJECTTYP = PRGFILE.COBJECTID
                    IF CSTATUS='D'
                      LOOP
                    ENDIF
                    SELECT (ALLT(PRGFILE.COBJECTNAM))
                      *--check if the field or index exist in the file structure
                      DO CASE
                        CASE FLFLDPRG.COBJECTTYP = 'Field'
                          llTagErr = TYPE(ALLT(PRGFILE.COBJECTNAM)+'.'+ALLT(FLFLDPRG.COBJECTNAM))='U'
                        CASE FLFLDPRG.COBJECTTYP = 'Index'
                          SET ORDER TO TAG (ALLT(FLFLDPRG.COBJECTNAM))
                          IF !llTagErr AND !EMPTY(FLFLDPRG.COBJECTEXP)
                            llTagErr = UPPER(SYS(14,VAL(SYS(21))))<>UPPER(ALLT(FLFLDPRG.COBJECTEXP))
                          ENDIF
                      ENDCASE
                    *-- if there is any field or index does not exist in the file structure then
                    *-- exit and dont check for the rest  
                    IF llTagErr
                      EXIT
                    ENDIF
                  ENDSCAN
                  *-- close the data or system file needed by the fix program
                  IF USED(ALLT(PRGFILE.COBJECTNAM))
                    USE IN (ALLT(PRGFILE.COBJECTNAM))
                  ENDIF
                ENDIF  
              *-- if the data or system file needed by the fix program  does not
              *-- exist then notify the program that this fix program cannot be run
              ELSE  
                llTagErr = .T.
              ENDIF
              *-- if the fix program can not be run for any reason  like the file
              *-- we are checking does not exist or a field needed in the file
              *-- structure does not exist then do not check the rest of file 
              IF llTagErr
                EXIT
              ENDIF
            ENDSCAN            
            *-- if the files and file structure needed by the fix program is ok
            *-- then add the company id to the companies that we can run the fix
            *-- program on it's data
            IF !llTagErr
              lcCompToRun = lcCompToRun+IIF(EMPTY(lcCompToRun),'',',')+IIF(llRunData,LEFT(laCompany[lnCount,1],2),'SYSTEM')
            ENDIF
          ENDFOR
          ON ERROR &lcOnErr
          *-- IF The fix program can be runing on any company or on the system files
          *-- then add the program name and id to the fix programs list needed to be run 
          IF NOT EMPTY(lcCompToRun) &&!llTagErr 
            laFxPrg[ALEN(laFxPrg,1),1] = &lcPrgAlias..COBJECTID
            laFxPrg[ALEN(laFxPrg,1),2] = ALLT(&lcPrgAlias..COBJECTNAM)
            laFxPrg[ALEN(laFxPrg,1),3] = llRunData
            laFxPrg[ALEN(laFxPrg,1),4] = IIF('SYSTEM' $ lcCompToRun,'',lcCompToRun)
          ELSE
             *--Ramy
            IF ALEN(laFxPrg,1) > 1
              DIMEN laFxPrg[ALEN(laFxPrg,1)-1,ALEN(laFxPrg,2)]
            ENDIF  
          ENDIF  
        ENDIF
      ENDIF
    ENDSCAN
  ENDIF
  *-- close the fix programs files  
  IF USED('SYDFXPRG')
    USE IN SYDFXPRG
  ENDIF  

  IF USED('FLFLDPRG')
    USE IN FLFLDPRG
  ENDIF  

  IF USED('PRGFILE')
    USE IN PRGFILE
  ENDIF  
  *-- if there is any programs in the fix program list 
  
  IF !EMPTY(laFxPrg[1,1])
    *--loop through the fix programs needed to be run
    FOR lnFxPrg = 1 TO ALEN(laFxPrg,1)
      *-- loop through the companies installed in the system or just once if we are
      *-- running a system fix programs
      IF laFxPrg[lnFxPrg,3]
        IF EMPTY(laCompany[1,1])
          LOOP
        ENDIF
      ENDIF  
      FOR lnCount = 1 TO IIF(laFxPrg[lnFxPrg,3],ALEN(laCompany,1),1)
        *-- check if the company exist in the fix program list
        IF IIF(laFxPrg[lnFxPrg,3],LEFT(laCompany[lnCount,1],2) $ laFxPrg[lnFxPrg,4],.T.)
          *-- run the fix program and pass the system files dir. or the data path to it 
          *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
          *DO (gcFxPrgDir+laFxPrg[lnFxPrg,2]) WITH IIF(laFxPrg[lnFxPrg,3],ALLT(laCompany[lnCount,2]),gcSysHome)
          DO (laFxPrg[lnFxPrg,2]) WITH IIF(laFxPrg[lnFxPrg,3],ALLT(laCompany[lnCount,2]),gcSysHome)
          *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
        ENDIF
      ENDFOR
    ENDFOR
  ENDIF
ENDIF

*B603392,1 Hesham (Start)
*B603392,1 Close application file
IF llOpenApp 
  USE IN SYDAPPL
ENDIF  
*B603392,1 Hesham (End)

*-- open the fix programs system file again
USE (gcSysHome+'SYDFXPRG') IN 0 ORDER TAG COBJECTID
SELECT 0
USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ALIAS MDFXPRG ORDER TAG COBJECTID
SET RELATION TO COBJECTID INTO SYDFXPRG ADDI
*--scan through all objects in the installed module fix programs file
SCAN
  *-- if the object does not exist in the system file that hold the fix programs info.
  *-- then add it to the system file
  IF EOF('SYDFXPRG')
    SCATT FIELDS EXCEPT LPRGRUN MEMVAR MEMO
    INSERT INTO SYDFXPRG FROM MEMVAR
  *-- if the object exist in the system file that hold the fix programs info.  
  *-- then change the status with the installed module object status
  ELSE
    SELECT SYDFXPRG
    REPLACE SYDFXPRG.CSTATUS WITH MDFXPRG.CSTATUS
  ENDIF
ENDSCAN
*-- if there is any fix programs in the list
IF !EMPTY(laFxPrg[1,1])
  SELECT SYDFXPRG
  FOR lnFxPrg = 1 TO ALEN(laFxPrg,1)
    *-- change the system file to now in the next upgrade that this program
    *-- was run before
    IF SEEK(laFxPrg[lnFxPrg,1])
      REPLACE LPRGRUN WITH .T.
    ENDIF
  ENDFOR
ENDIF

*-- close the fix programs files
IF USED('SYDFXPRG')
  USE IN SYDFXPRG
ENDIF  
IF USED('MDFXPRG')
  USE IN MDFXPRG
ENDIF

*!*************************************************************
*! Name      : gfThermo
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display a thermometer for any running action
*!*************************************************************
*! Calls     : 
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!      Called by: GPCHNGDATA               (procedure in ARIA3.PRG)
*!      Called by: GFTMP2MAST()             (function  in ARIA3.PRG)
*!      Called by: GFBLDSTATC()             (function  in ARIA3.PRG)
*!      Called by: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Total count
*!                      Current action
*!                      Fixed messag on top
*!                      variable messag with each count
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfThermo
PARAMETERS lnToBeDone,lnDone,lcMessage,lcVariable

*lnToBeDone
*lnDone

*B605445,1 (Begin) If the file is empty.
IF lnToBeDone = 0
  STORE 100 TO lnToBeDone,lnDone
ENDIF
*B605445,1 (End)

lcMessage   =IIF(TYPE('lcMessage')='C' ,lcMessage ,' ')
lcVariable  =IIF(TYPE('lcVariable')='C',lcVariable,' ')

*C201350,1 TMI 07/05/2011 [Start] 
*#IF _DOS
*	IF ! WEXIST("gwdThermo")
*	  DEFINE WINDOW gwdThermo ;
*		   	FROM INT((SROW()-11)/2),INT((SCOL()-58)/2) ;
*			TO INT((SROW()-11)/2)+6,INT((SCOL()-58)/2)+57 ;
*			NOCLOSE DOUBLE SHADOW COLOR SCHEME 5
*
*	  ACTIVATE WINDOW gwdThermo
*
*	  @ 0,2 SAY lcMessage
*	  @ 2,1 TO 5,54 
*	  @ 3,3 SAY CHR(219)
*
*	ENDIF  
*
*
*	lnPersent = INT((lnDone /lnToBeDone )*100)
*
*	@ 1,3 SAY SPACE(54)
*	@ 1,3 SAY lcVariable
*	@ 3,3 SAY REPLICATE(CHR(219),lnPersent*50/100)
*
*	IF lnToBeDone <= lnDone
*	  RELEASE WINDOW gwdThermo
*	ENDIF
*#ELSE
    gcFontFace	=	"MS Sans Serif"
    gcFontSize	=	8.000
    gcFontStyle	=	"B"
    gntherwidth =  57
    IF NOT WEXIST("gwdThermo")
	  DEFINE WINDOW gwdThermo ;
        IN WINDOW fndation ;
	    AT  INT((SROW() - (( 5.615 * ;
	    FONTMETRIC(1, gcFontFace, gcFontSize, gcFontStyle )) / ;
	    FONTMETRIC(1, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2), ;
	    INT((SCOL() - (( 63.833 * ;
	    FONTMETRIC(6, gcFontFace, gcFontSize, gcFontStyle )) / ;
	    FONTMETRIC(6, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2) ;
	    SIZE 5.615,63.833 ;
	    FONT gcFontFace, gcFontSize ;
	    STYLE gcFontStyle ;
	    NOFLOAT ;
	    NOCLOSE ;
	    NONE ;
	    COLOR RGB(0, 0, 0, 192, 192, 192)

	  MOVE WINDOW gwdThermo CENTER
	  ACTIVATE WINDOW gwdThermo NOSHOW

	  @ 0.5,3 SAY lcMessage FONT gcFontFace, gcFontSize STYLE gcFontStyle
	  @ 0.000,0.000 TO 0.000,63.833 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 0.000,0.000 TO 5.615,0.000 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 0.385,0.667 TO 5.231,0.667 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.308,0.667 TO 0.308,63.167 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.385,63.000 TO 5.308,63.000 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 5.231,0.667 TO 5.231,63.167 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 5.538,0.000 TO 5.538,63.833 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.000,63.667 TO 5.615,63.667 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 3.000,3.333 TO 4.300,3.333 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 3.000,60.333 TO 4.308,60.333 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 3.000,3.333 TO 3.000,60.333 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 4.300,3.333 TO 4.300,60.500 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  

	  SHOW WINDOW gwdThermo TOP
	    
    ENDIF
	lnPersent = INT((lnDone /lnToBeDone )*100)
    lnblocks  = lnPersent*gntherwidth/100

    @ 1.7,3 SAY lcVariable+SPACE(gntherwidth-LEN(lcVariable)) FONT gcFontFace, gcFontSize STYLE gcFontStyle
    
    @ 3.039,gntherwidth/2 SAY ALLTRIM(STR(lnPersent))+"%" FONT "SYSTEM",8 ;
       COLOR RGB(0,0,0,192, 192, 192)
    @ 3.000,3.333 FILL TO 4.300,lnblocks + 3.333 ;
            COLOR RGB(255,255,255,128,128,128)

       
	IF lnToBeDone <= lnDone
	  RELEASE WINDOW gwdThermo
	ENDIF
*C201350,1 TMI 07/05/2011 [Start] 
*#ENDIF   
*C201350,1 TMI 07/05/2011 [End  ] 

*!*************************************************************
*! Name      : gfADel
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To delete a colum or row from array
*!*************************************************************
*! Calls     : 
*!      Called by: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : array name
*!                      number of colum or row to be deleted
*!                      1 -> row  / 2 -> colum   
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfADel
PARAMETERS laDel,lnDelWch,lnSubScrp

*B601481,1 This line was added by HS [Begin]
PRIVATE laTemp
*B601481,1 This line was added by HS [End]

lnSubScrp=IIF(TYPE("lnSubScrp") $ "UL",1,lnSubScrp)
DO CASE
  CASE lnSubScrp=1
    =ADEL(laDel,lnDelWch)
    IF ALEN(laDel,2)<>0
      IF ALEN(laDel,1)>1
        DIMENSION laDel[ALEN(laDel,1)-1,ALEN(laDel,2)]
      ENDIF  
    ELSE
      IF ALEN(laDel,1)>1
        DIMENSION laDel[ALEN(laDel,1)-1,1]
      ENDIF  
    ENDIF
    RETURN .T.
  CASE lnSubScrp=2
    DIMENSION laTemp[ALEN(laDel,1),ALEN(laDel,2)-1]
    FOR I=0 TO ALEN(laDel,1)-1
      IF lnDelWch>1 .AND. lnDelWch<ALEN(laDel,2)
        =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+1,lnDelWch-1,i*ALEN(laTemp,2)+1)
        =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+lnDelWch+1,ALEN(laDel,2)-lnDelWch,;
              i*ALEN(laTemp,2)+lnDelWch)
      ELSE
        IF lnDelWch=1
          =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+2,ALEN(laDel,2)-1,i*ALEN(laTemp,2)+1)
        ELSE
          =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+1,Alen(laDel,2)-1,i*ALEN(laTemp,2)+1)
        ENDIF        
      ENDIF        
    ENDFOR
   DIMENSION laDel[ALEN(laTemp,1),ALEN(laTemp,2)]
   RETURN (ACOPY(laTemp,laDel)>0)
ENDCASE





*E301098,1 Hesham (Start)
*E301098,1 if user defined an env. data path then use it
*!*************************************************************
*! Name      : gfGetDataDir
*! Developer : Hesham El-Sheltawi
*! Date      : 12/16/1998
*! Purpose   : Function to return company data directory
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : 1) company data dir
*!*************************************************************
*! Example	      	 : lcDataDir=gfGetDataDir(syccomp.ccom_ddir)
*!*************************************************************
*E301078,1 HSS 11/29/98 Add this function.
*!*************************************************************
*
FUNCTION gfGetDataDir
PARAMETERS lcDataDir
lcDataDir = ALLT(lcDataDir)
lcDataDir = lcDataDir+IIF(RIGHT(lcDataDir,1)='\','','\')

*B609556,3 TMI 03/31/2011 [Start] If this is SaaS then keep the same folder data path
IF FILE('CLIENTS.DBF')
  RETURN lcDataDir
ENDIF
*B609556,3 TMI 03/31/2011 [End  ] 

gcDataEnv = ALLT(GETENV('DATA27'))
*E301109,1 end
IF !EMPTY(gcDataEnv)
  gcDataEnv = IIF(RIGHT(gcDataEnv,1)='\',gcDataEnv,gcDataEnv+'\')
ENDIF
IF !EMPTY(gcDataEnv)
  lcDataDir = gcDataEnv+SUBSTR(lcDataDir,RAT('\',lcDataDir,2)+1)
ELSE
  PRIVATE lcSysPath,lcFullSet, lcOrgPath
  lcFullSet = SET('FULL')
  SET FULL ON
  *E301109,1 At installation, gcOrgPath is empty.
  *lcSysPath = UPPER(SUBSTR(gcOrgPath,1,ATC('\SYSFILES',gcOrgPath)))
  lcOrgPath = IIF(!EMPTY(gcOrgPath), gcOrgPath, gcSysHome)
  lcSysPath = UPPER(SUBSTR(lcOrgPath,1,ATC('\SYSFILES',lcOrgPath)))
  *E301109,1 end
  *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
  *IF lcSysPath = UPPER(SUBSTR(lcDataDir,1,LEN(lcSysPath)))
  *  lcDataDir = FULLPATH(SET('DEFAULT'))+SUBSTR(lcDataDir,LEN(lcSysPath)+1)
  *ENDIF
  *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
  SET FULL &lcFullSet
ENDIF  
RETURN ALLTRIM(lcDataDir)




*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 FUNCTION TO RETURN THE PLATFORMS BUILD# AND THE RECENT PLATFORM
FUNCTION lfGetPlatBuild
PARAMETERS lcModID,laBuildMod
PRIVATE lnCount,lcCurrsorName,llUsedBy,lcCurArea,lcRecBuild,lnCount,lcModId,;
lcModUp
llUsedBy = .f.
lcModUp=lcModID
lcModID = IIF(lcModID='SY','XX',lcModID)
lcCurArea = SELECT()
lcCurrsorName = gfTempName()
IF FILE (gcSysHome+lcModID+"DAPPL.DBF") AND !USED(lcModID+"DAPPL")
  SELECT 0
  USE (gcSysHome+lcModID+"DAPPL") ORDER TAG  CAPP_ID
  llUsedBy= .T.
ENDIF
CREATE CURS &lcCurrsorName (MdlBuild M,cPlatBuild M)
APPEND BLANK
REPLACE MdlBuild WITH EVAL(lcModID+"DAPPL.cMdlBuild")
lcRecBuild = ALLT(MdlBuild)

*B803757,1 NAD 11/02/2000 (Start) Assign the value of the nSrvcPak 
lnNSrvPak=EVAL(lcModID+"DAPPL.nSrvcPak")
*B803757,1 NAD 11/02/2000 (End)

FOR lnCount = 1 TO ALEN(laBuildMod,1)
  lcFileToCheck = gcSysHome+lcModUp+laBuildMod[lnCount,1]+'.TXT'
  IF FILE(lcFileToCheck)
     APPEND MEMO cPlatBuild FROM (lcFileToCheck) OVERWRITE
     laBuildMod[lnCount,2] = cPlatBuild
     laBuildMod[lnCount,3] = ALLT(MdlBuild) == ALLT(cPlatBuild)
  ELSE
    laBuildMod[lnCount,2] = ''
    laBuildMod[lnCount,3] = .F.
  ENDIF
ENDFOR
USE IN (lcCurrsorName)
IF llUsedBy AND USED(lcModID+"DAPPL")
  USE IN (lcModID+"DAPPL")
ENDIF
SELECT (lcCurArea)
RETURN lcRecBuild
*E300441,4 Hesham El-Sheltawi (End)

*!*************************************************************
*! Name      : lfUSetup
*! Developer : Ahmed Mohamed Ibrahim [AMM]
*! Date      : 06/15/1999
*! Purpose   : Function to Update SYCCONFG and SETUPS files
*!*************************************************************
*! Calls     : -----
*!*************************************************************
*! Passed Parameters  : lcParam,lcMod_ID,lcDataDr
*!                      lcParam : indicate whether update SYCCONFG or SETUPS
*!                      lcMod_ID: Module ID
*!                      lcDataDr: company Data directory
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Called Form        : 
*!*************************************************************
*! Example            : =lfUSetup('A',lcMod_ID,lcFilePath)
*!*************************************************************
*! Ref : *E301252,1 AMM
*!*************************************************************
FUNCTION lfUSetup
PARAMETERS lcParam,lcMod_ID,lcDataDr
PRIVATE laCFGVrPos, laSplVrPos, lcModule, lnPAlias, lnElem, lnStToPos,;
	    llStUpdate, llUsUpdate
lnPAlias = SELECT(0)
DECLARE laCFGVrPos[1,2], laSplVrPos[1,2]
lcModule = IIF(lcMd_id='SM',CHR(255),lcMd_id)
DO CASE
  CASE lcParam = 'S'
    IF FILE (gcSysHome+lcMd_id+"CCONFG.DBF") 
      USE (gcSysHome+lcMd_id+"CCONFG") ORDER TAG NVARPOS IN 0
      SELECT SYCCONFG
      SET ORDER TO TAG MODVAR

      SELECT CUPGRDLVL, MAX(NVARPOS) FROM SYCCONFG;
      		 WHERE CAPP_ID+STR(NVARPOS) = lcModule;
      		 GROUP BY CUPGRDLVL;
      		 INTO ARRAY laCFGVrPos
	  
	  SELECT CUPGRDLVL, MAX(NVARPOS) FROM (lcMd_id+"CCONFG");
      		 WHERE CAPP_ID+STR(NVARPOS) = lcModule;
      		 GROUP BY CUPGRDLVL;
      		 INTO ARRAY laSplVrPos
      lnElem = ASCAN(laSplVrPos, "S")
      IF lnElem > 0
        lnStToPos  = laSplVrPos[ASUBSCRIPT(laSplVrPos, lnElem, 1), 2]
        llStUpdate = .T.
      ELSE
        lnStToPos  = 0
        llStUpdate = .F.
      ENDIF
      llUsUpdate = ASCAN(laSplVrPos, "U") > 0
      IF !llStUpdate
        lnElem     = ASCAN(laCFGVrPos, "S")
        IF lnElem > 0
          lnStToPos = laCFGVrPos[ASUBSCRIPT(laCFGVrPos, lnElem, 1), 2]
        ENDIF
      ENDIF       		 
      *-- If upgrading standard records, 
      IF llStUpdate
        
        *-- If updating "U"ser records, or, there are no "U"ser records,
        *-- delete all existing records and append from SYCCONFG
        IF llUsUpdate .OR. ASCAN(laCFGVrPos, "U") = 0
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule 
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
            *B609764,2 TMI 12/08/2011 [Start] restore the pack command
            PACK
            *B609764,2 TMI 12/08/2011 [End  ]           
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG") 
        ELSE
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule FOR cUpgrdLvl = "S"
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
            *B609764,2 TMI 12/08/2011 [Start] restore the pack command
            PACK
            *B609764,2 TMI 12/08/2011 [End  ]           
            =lfShiftUsr(lnStToPos + 1, lcModule)                        
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG")  
        ENDIF
      ELSE
        IF llUsUpdate
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule FOR cUpgrdLvl = "U"
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
            *B609764,2 TMI 12/08/2011 [Start] restore the pack command
            PACK
            *B609764,2 TMI 12/08/2011 [End  ]           
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG") 
          =lfShiftUsr(lnStToPos + 1, lcModule)            
        ENDIF
      ENDIF        
    ENDIF  
  CASE lcParam = 'A'
    IF USED('SETUPS')
      USE IN SETUPS
    ENDIF
    USE (lcDataDr+"SETUPS") ORDER TAG MODVAR IN 0
    *-- Delete any extra settings..
    SET ORDER TO TAG MODVAR IN SYCCONFG
    SET RELATION TO cApp_Id+cFld_Name INTO SYCCONFG
    IF SEEK(lcModule)
      DELETE REST WHILE cApp_ID = lcModule FOR EOF('SYCCONFG')
      SET RELATION OFF INTO SYCCONFG
      SELECT SYCCONFG
      SET RELATION TO cApp_Id+cFld_Name INTO SETUPS
      IF SEEK(lcModule)
        SCAN WHILE cApp_ID = lcModule
          SCATTER MEMVAR MEMO
          IF EOF('SETUPS')
            *E301252,1 AMM If new setup variable, insert it
            INSERT INTO SETUPS FROM MEMVAR
          ELSE
            *E301252,1 AMM If existing setup variable, update it
            SELECT SETUPS
            GATHER MEMVAR MEMO FIELDS EXCEPT mData_Def,cDefa_Typ
          ENDIF
          SELECT SYCCONFG
        ENDSCAN
      ENDIF
    ELSE
      SET RELATION OFF INTO SYCCONFG
    ENDIF  
    USE IN SETUPS
ENDCASE
SELECT (lnPAlias)

*B600975,10 Hesham El-Sheltawi (START)
*B600975,1 function to update specific module files in all companies
*!*******************************************************************
*!
*!      Function: gfUpdModFl
*!
*!*******************************************************************
*
FUNCTION gfUpdModFl
PARAMETERS lcAction,lcMod_ID
DIMENSION laSelected[1,2]
STORE '' TO laSelected
lcUpGrdLvl = IIF(lcMod_ID='SY','S','A')
*E301077,78 Hesham (Start)
llfiles = gfSysOpen(gcSysHome+'sydfiles')
*E301077,78 Hesham (End)

*Ren 
*SELECT cFile_nam,cfile_ttl ;
   FROM (gcSyshome+"sydfiles") ;
   INTO ARRAY laSelected ;
   WHERE LEFT(cFile_nam,2) <> "SY" .AND. CUPGRDLVL=lcUpGrdLvl .AND. lcMod_ID $ ALLTRIM(mfile_app);
   ORDER BY 1

lcMod_ID = IIF(lcMod_ID='SM', 'SY', lcMod_ID) 
SELECT cFile_nam,cfile_ttl ;
   FROM (gcSyshome+"sydfiles") ;
   INTO ARRAY laSelected ;
   WHERE LEFT(cFile_nam,2) <> "SY" .AND. lcMod_ID $ ALLTRIM(mfile_app);
   ORDER BY 1
*Ren end

*E301077,78 Hesham (Start)
USE IN IIF(llfiles,'sydfiles',0)
*E301077,78 Hesham (End)

PRIVATE lnCount
IF !EMPTY(laSelected [1,1])   && Exit if None 

  DECLARE laFileStrc[1,1],laFileAStr[1,1]

  llOpenRep  = .F.               && Open Report flage
  lcFilHandl = ''
  lcTempNam  = ''
  lnRepLine  = 0
  llYes2All  = .F.
  lcTherMesg  = "Updating file structure..."
  *** Verify files for all companies
    *** Check all selected files
    lnLastComp = ALEN(laCompany,1)

    *** Loop all or one company
    FOR lnCompNo = 1 TO lnLastComp
      lcFilePath = ALLTRIM(laCompany[lnCompNo,2])
      lnSelected = ALEN(laSelected,1)

      *B801893,1 AMM if SM module, behave as if SY module
      lcMod_ID = IIF(lcMod_ID='SM', 'SY', lcMod_ID) 
      *B801893,1 AMM end

      *** Check if there is one module selecet if this module is not installed to
      *** the company in the loop skip this company
      *B602329,1 Update file structure of data files used by 'SY' as well
      *IF !EMPTY(lcMod_ID) .AND. !(lcMod_ID $ ALLTRIM(laCompany[lnCompNo,3]))
      IF !EMPTY(lcMod_ID) .AND. !(lcMod_ID $ 'SY'+ALLTRIM(laCompany[lnCompNo,3]))
	  *B602329,1 end
        LOOP
      ENDIF
      
      *** Loop all selected files
      FOR lnCount = 1 TO lnSelected
        lcFileNam = UPPER(ALLTRIM(laSelected[lnCount,1]))
        lcTargDir = UPPER(IIF(UPPER(LEFT(lcFileNam ,2))='SY',gcSysHome,lcFilePath))

        IF lcMod_ID $ ALLTRIM(laCompany[lnCompNo,3]) OR lcMod_ID='SY'
          *** If the to be cheked file belong to one of the installed modules
          *** for this company, then verify it
          lcSubsVar = ALLTRIM(laSelected[lnCount,2])
          =gfThermo(lnSelected ,lnCount-.01,lcTherMesg,lcSubsVar)
          IF !lfVer_Upd(lcFileNam,.T.)  
            EXIT
          ENDIF
          =lfClrLock(lcFileNam)
          =gfThermo(lnSelected ,lnCount,lcTherMesg,lcSubsVar)
        ELSE
          *** If not skip this files but keep the thermometer running
          lcSubsVar = " "
          =gfThermo(lnSelected ,lnCount,lcTherMesg,lcSubsVar)
        ENDIF
      ENDFOR
      *E301065,1 AMM, Update Form Codes files of the current module and company.
      *Ren Restore lcMod_ID
      lcMod_ID = IIF(lcMod_ID='SY','SM',lcMod_ID)
      =lfUpFCode(lcMod_ID,lcFilePath)
      *Ren end
      *E301065,1 AMM end

      *E301252,1 AMM Update setups file due to SYCCONFG file 
      =lfUSetup('A',lcMod_ID,lcFilePath)
      *E301252,1 AMM end
    ENDFOR
ENDIF

*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 Function to delete all the module splitted files
FUNCTION lfDelSplit
PARAMETERS lcMd_id
PRIVATE laModFiles,lcMd_id,lcMdUpd,lnCount

*E301065,1 start. Add two elements for SYFRMCDH, SYFRMCDD files
*DIMEN laModFiles[15,1]
*E301199,1 Hesham (Start)
*DIMEN laModFiles[17,1]
*E301252,1 AMM Add a new element SYCCONFG file to the array
*DIMEN laModFiles[18,1]
*B802980,1 Hesham (Start)
*DIMEN laModFiles[19,1]

*++NAD40
*DIMEN laModFiles[20,1]
DIMEN laModFiles[19,1]
*++NAD40

*B802980,1 Hesham (End)
*E301252,1 AMM end

*E301199,1 Hesham (End)
*E301065,1 end

lcMdUpd = lcMd_id
lcMd_id = IIF(lcMd_id='SY','XX',lcMd_id)
laModFiles[1,1] = lcMd_id+"DAPPL"
laModFiles[2,1] = lcMd_id+"DFILES"
laModFiles[3,1] = lcMd_id+"DFIELD"
laModFiles[4,1] = lcMd_id+"DFLFLD"
laModFiles[5,1] = lcMd_id+"DINDEX"
laModFiles[6,1] = lcMd_id+"CMENU"
laModFiles[7,1] = lcMd_id+"DDLOBJ"
laModFiles[8,1] = lcMd_id+"DOBJCT"
laModFiles[9,1] = lcMd_id+"DREPRT"
laModFiles[10,1] = lcMd_id+"DSCOBJ"
laModFiles[11,1] = lcMd_id+"REPSRT"
laModFiles[12,1] = lcMd_id+"REPUVR"
laModFiles[13,1] = lcMd_id+"CPRINT"
laModFiles[14,1] = lcMd_id+"CP_ESC"
laModFiles[15,1] = lcMd_id+"CINT"
*E301065,1 start. Add two elements for SYFRMCDH, SYFRMCDD files
laModFiles[16,1] = lcMd_id+"FRMCDD"
laModFiles[17,1] = lcMd_id+"FRMCDH"
*E301065,1 end
*E301199,1 Hesham (Start)

*++NAD40
*laModFiles[18,1] = lcMd_id+"DFXPRG"
*++NAD40
*E301199,1 Hesham (End)

*E301252,1 AMM Add the file to be closed

*++NAD40
*laModFiles[19,1] = lcMd_id+"CCONFG"
laModFiles[18,1] = lcMd_id+"CCONFG"
*++Nad40

*E301252,1 AMM end
*B802980,1 Hesham (Start)
*++Nad40
*laModFiles[20,1] = lcMd_id+"SZONES"
laModFiles[19,1] = lcMd_id+"SZONES"
*++Nad40

*B802980,1 Hesham (End)
ERASE (gcSysHome+lcMdUpd+'DOS.TXT')
ERASE (gcSysHome+lcMdUpd+'WIN.TXT')
ERASE (gcSysHome+lcMdUpd+'UNIX.TXT')
ERASE (gcSysHome+lcMdUpd+'MAC.TXT')

FOR lnCount = 1 TO ALEN(laModFiles,1)
  IF USED(laModFiles[lnCount,1]) 
    USE IN laModFiles[lnCount,1]
  ENDIF
  ERASE gcSysHome+laModFiles[lnCount,1]+'.DBF'
  ERASE gcSysHome+laModFiles[lnCount,1]+'.FPT'
  ERASE gcSysHome+laModFiles[lnCount,1]+'.CDX'
ENDFOR

*E300441,4 Hesham El-Sheltawi (End)


*E300441,4 Hesham El-Sheltawi (Start) 
*E300441,4 FUNCTION TO CHECK THE VERSION OF THE SYDAPPL FILE
*E300441,4 IF the file does not contain the fields that hold 
*E300441,4 the platform build# it create new file with these
*E300441,4 fields and copy the existing file records


*!***************************************************************************
*! Name      : lpMenuPad
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 05/15/2002
*! Purpose   : Add either pad 1 or 4 or 5 for any module.
*!***************************************************************************
*! Example   : DO lpMenuPad
*!***************************************************************************
*B605903,1 Handle all the shifting of menu lines after inserting records.
PROCEDURE lpMenuPad
PARAMETERS lcCurPadPo

PRIVATE lcAlias , lcSetDelet
lcAlias = ALIAS()

APPEND FROM (gcSysHome+lcMd_id+"CMENU") FOR cPad_Pos = lcCurPadPo
       
*-- Create Temp file for all lines that need to be shifted.
PRIVATE laTmpMnu
=AFIELDS(laTmpMnu)
CREATE TABLE (gcWorkDir + 'TmpEmpMn') FROM ARRAY laTmpMnu
*E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
=lfCrFox2x()
*E303074,1 TMI 02/20/2012 [End  ] 
       
PRIVATE lnCurBarPo , lnCurPopPo , lnCurSubPo , lnPrvBarPo
STORE 0 TO lnCurBarPo , lnCurPopPo , lnCurSubPo , lnPrvBarPo

*B038431,1 MHM 09/04/2004  [Start]
*-- we are replacing Custom menu with new value (cMstr_Nam ,cPross_ID)
*-- assigned with menu which come from Build for sub menu
SELECT SycMenu
=SEEK(lcMd_id)
SCAN REST WHILE capp_id+cpad_pos+cpop_pos+cpop_levl+cbar_pos = lcMd_id
  IF (csub_typ <> "S") OR (cPad_Pos <> "05")
    LOOP
  ENDIF
  SELECT (TmpSbMnu)
  *B609601,3 TMI 06/07/2011 [Start] remove the '\<' from the comparison
  *LOCATE FOR cApp_ID + cpad_pos + csub_typ + cSub_Prpt = SycMenu.cApp_ID + SycMenu.cpad_pos + SycMenu.csub_typ + SycMenu.cSub_Prpt 
  LOCATE FOR cApp_ID + cpad_pos + csub_typ + PADR(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) = SycMenu.cApp_ID + SycMenu.cpad_pos + SycMenu.csub_typ + PADR(chrtran(SycMenu.cSub_Prpt,'\<',''),LEN(cSub_Prpt))
  *B609601,3 TMI 06/07/2011 [End  ] 
  *
  IF FOUND()
    IF (cMstr_Nam <>  SycMenu.cMstr_Nam) OR (cPross_ID <>  SycMenu.cPross_ID)
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
      IF FOUND()
        *--check if this record updated befor or not
        SCAN FOR cMstr_Nam = &TmpSbMnu..cPross_ID AND cAdd_User <> "*****"
          REPLACE cMstr_Nam WITH SycMenu.cPross_ID ,;
                  cAdd_User WITH  "*****"
          
        ENDSCAN
      ENDIF  
      SELECT (TmpSbMnu)
      REPLACE &TmpSbMnu..cMstr_Nam WITH SycMenu.cMstr_Nam ,;
              &TmpSbMnu..cPross_ID WITH SycMenu.cPross_ID 
    ENDIF
  ENDIF
ENDSCAN

*B038431,1 MHM 09/04/2004  [End]

SELECT (TmpSbMnu)
*-- Scan all Sub types = "S"
SCAN FOR cPad_Pos = lcCurPadPo
  *-- Check this Sub Menu if it exists in standard menu file.
  SELECT SycMenu
  *B038431,1 MHM 09/04/2004 change key to get correct record  [Start]
  *LOCATE FOR cApp_ID + cMstr_Nam + cPross_ID = TmpSbMnu.cApp_ID + TmpSbMnu.cMstr_Nam + TmpSbMnu.cPross_ID
  *B609601,3 TMI 06/07/2011 [Start]  remove the '\<' from the comparison
  *LOCATE FOR cApp_ID + cpad_pos + csub_typ + cSub_Prpt = &TmpSbMnu..cApp_ID + &TmpSbMnu..cpad_pos + &TmpSbMnu..csub_typ+&TmpSbMnu..cSub_Prpt 
  LOCATE FOR cApp_ID + cpad_pos + csub_typ + padr(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) = &TmpSbMnu..cApp_ID + &TmpSbMnu..cpad_pos + &TmpSbMnu..csub_typ+ padr(chrtran(&TmpSbMnu..cSub_Prpt,'\<',''),LEN(cSub_Prpt))
  *B609601,3 TMI 06/07/2011 [End  ] 
  
  *B038431,1 MHM 09/04/2004 [End]

         
  *-- This Sub Menu EXISTS in standard menu file.
  IF FOUND()
    *-- If Sub Menu title is the same 
    *B609601,3 TMI 06/07/2011 [Start]  remove the '\<' from the comparison
    *IF cSub_Prpt == &TmpSbMnu..cSub_Prpt
    IF PADR(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) == PADR(chrtran(&TmpSbMnu..cSub_Prpt,'\<',''),LEN(cSub_Prpt))
      *B609601,3 TMI 06/07/2011 [End  ] 
      *-- We have to check for all Childs in this Sub Menu 
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
             
      *-- Childs for this Sub Menu EXISTS (we have to add them)
      IF FOUND()
        *-- Get Pop up position of previous Sub Menus or main bars.
        SELECT SycMenu
        LOCATE FOR cApp_ID + cMstr_Nam = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        lnPrvBarPo = 0
        SKIP -1
        IF !BOF()
          lnPrvBarPo = VAL(cBar_Pos)   
        ENDIF
        SKIP 1
               
        *-- Get last record in the child menus to delete rest of records after it.
        SET ORDER TO TAG AppPopBar DESCENDING
        LOCATE FOR cApp_ID + cMstr_Nam = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        SET ORDER TO TAG AppPopBar ASCENDING
        IF !FOUND()
          LOCATE FOR cApp_ID + cPross_ID = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        ENDIF
        lnCurBarPo = VAL(cBar_Pos)
        lnCurPopPo = VAL(cPop_Pos)
        lnCurSubPo = VAL(cSub_Pos)
                 
        SKIP
        IF !EOF()
          DELETE REST WHILE cApp_ID = lcMenuToUp
          IF USED('TmpEmpMn')
            USE IN TmpEmpMn
          ENDIF
          lcSetDelet = SET('DELETE')        && Save Delete settings
          SET DELETE OFF
          *B609764,1 TMI 12/07/2011 [Start] copy to a temp file only the lines that have been removed
          *COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED()
          COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED() AND cApp_ID = lcMenuToUp
          *B609764,1 TMI 12/07/2011 [End  ] 
          SET DELETE &lcSetDelet
          USE (gcWorkDir + 'TmpEmpMn') IN 0
          PACK
          GO BOTTOM
        ENDIF
               
        *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
        SELECT (TmpMenu)
        LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
        IF FOUND()
          SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
            SCATTER MEMVAR MEMO
            SELECT SycMenu
            APPEND BLANK
            GATHER MEMVAR MEMO
            lnCurBarPo = lnCurBarPo + 1
            lnCurPopPo = lnCurPopPo + 1
            lnCurSubPo = lnCurSubPo + 1
            REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                    cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                    cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
          ENDSCAN
        ENDIF  
               
        *-- Scan rest of records in Temp. Menu file to adjust there positions.
        SELECT TmpEmpMn
        RECALL ALL
        LOCATE

        lnCurBarPo = 0
        SCAN
          lnCurPopPo = lnCurPopPo + 1
          lnCurSubPo = lnCurSubPo + 1
          IF VAL(cPop_Levl) > 1
            lnCurBarPo = lnCurBarPo + 1
            REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
          ELSE
            lnPrvBarPo = lnPrvBarPo + 1
            IF cSub_Typ = "S"
              lnCurBarPo = 0
              lnCurSubPo = lnCurSubPo + 1
            ENDIF
            REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
          ENDIF
          REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                  cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
        ENDSCAN

        *-- Finally append all the records to Master Menu file (SycMenu).
        SELECT SycMenu
        APPEND FROM (gcWorkDir + 'TmpEmpMn')
      ENDIF
    ELSE        && Sub Menu title is NOT THE SAME (it means a new Sub Menu is added.)
 
      *-- We have to add this Sub Menu and all its child.
      STORE 0 TO lnPrvBarPo , lnCurBarPo , lnCurPopPo , lnCurSubPo
      
      lnCurPopPo = VAL(cPop_Pos)
      lnCurSubPo = VAL(cSub_Pos)
      lnCurBarPo = VAL(cBar_Pos)
      lnPrvBarPo = VAL(cBar_Pos)        && not used in this case
                       
      IF !EOF()
        DELETE REST WHILE cApp_ID = lcMenuToUp
        IF USED('TmpEmpMn')
          USE IN TmpEmpMn
        ENDIF  
        lcSetDelet = SET('DELETE')        && Save Delete settings
        SET DELETE OFF
        *B609764,1 TMI 12/07/2011 [Start] copy to a temp file only the lines that have been removed
        *COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED()
        COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED() AND  cApp_ID = lcMenuToUp
        *B609764,1 TMI 12/07/2011 [End  ] copy to a temp file only the lines that have been removed
        SET DELETE &lcSetDelet
        USE (gcWorkDir + 'TmpEmpMn') IN 0
        PACK
        GO BOTTOM
      ENDIF  
             
      SELECT (TmpSbMnu)
      SCATTER MEMVAR MEMO
                          
      SELECT SycMenu
      APPEND BLANK
      GATHER MEMVAR MEMO
      REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
              cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
              cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
             
      *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
      IF FOUND()
        lnCurBarPo = 0
        SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
          SCATTER MEMVAR MEMO
          SELECT SycMenu
          APPEND BLANK
          GATHER MEMVAR MEMO
          lnCurBarPo = lnCurBarPo + 1
          lnCurPopPo = lnCurPopPo + 1
          lnCurSubPo = lnCurSubPo + 1
          REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                  cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                  cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
        ENDSCAN
      ENDIF  

      *-- We have to change all the sub menus names in cMstr_Nam and cPross_ID      
      SELECT TmpEmpMn
      RECALL ALL
      LOCATE

      lnCurBarPo = 0
      SCAN
        lnCurPopPo = lnCurPopPo + 1
        lnCurSubPo = lnCurSubPo + 1
        IF VAL(cPop_Levl) > 1
          lnCurBarPo = lnCurBarPo + 1
          REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
          REPLACE cMstr_Nam WITH ALLTRIM(SUBSTR(cMstr_Nam,1,7)) + STRTRAN(STR(VAL(SUBSTR(cMstr_Nam,8,2))+1,2),' ','0')
        ELSE
          lnPrvBarPo = lnPrvBarPo + 1
          IF cSub_Typ = "S"
            lnCurBarPo = 0
            lnCurSubPo = lnCurSubPo + 1
            REPLACE cPross_ID WITH ALLTRIM(SUBSTR(cPross_ID,1,7)) + STRTRAN(STR(VAL(SUBSTR(cPross_ID,8,2))+1,2),' ','0')
          ENDIF
          REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
        ENDIF
        REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
      ENDSCAN
      SELECT SycMenu
      APPEND FROM (gcWorkDir + 'TmpEmpMn')
    ENDIF
  ELSE       && This Sub Menu DOES NOT EXIST in standard menu file.
    STORE 0 TO lnPrvBarPo , lnCurBarPo , lnCurPopPo , lnCurSubPo
    SET ORDER TO TAG AppPopBar DESCENDING
    SEEK lcMenuToUp + lcCurPadPo
    lnCurPopPo = VAL(cPop_Pos)
    lnCurSubPo = VAL(cSub_Pos)
    lnCurBarPo = VAL(cBar_Pos)
    lnPrvBarPo = VAL(cBar_Pos)

    IF VAL(cPop_Levl) > 1
      PRIVATE lcMenuKey
      lcMenuKey = EVALUATE(KEY())
      LOCATE FOR cApp_ID = lcMenuToUp AND cPop_Levl = "01" AND cSub_Typ = "S"
      IF FOUND()
        lnPrvBarPo = VAL(cBar_Pos)
      ENDIF
      SEEK lcMenuKey
    ELSE
      lnPrvBarPo = VAL(cBar_Pos)
    ENDIF
    SET ORDER TO TAG AppPopBar ASCENDING
           
    SELECT (TmpSbMnu)
    SCATTER MEMVAR MEMO
                          
    SELECT SycMenu
    APPEND BLANK
    GATHER MEMVAR MEMO
    lnPrvBarPo = lnPrvBarPo + 1
    lnCurBarPo = lnCurBarPo + 1
    lnCurPopPo = lnCurPopPo + 1
    lnCurSubPo = lnCurSubPo + 1
    IF m.cSub_Typ = "S"
      lnCurSubPo = lnCurSubPo + 1
    ENDIF
    REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0') , ;
            cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
            cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')

    *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
    SELECT (TmpMenu)
    LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
    IF FOUND()
      lnCurBarPo = 0
      SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
        SCATTER MEMVAR MEMO
        SELECT SycMenu
        APPEND BLANK
        GATHER MEMVAR MEMO
        lnCurBarPo = lnCurBarPo + 1
        lnCurPopPo = lnCurPopPo + 1
        lnCurSubPo = lnCurSubPo + 1
        REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
      ENDSCAN
    ENDIF  

    SELECT TmpEmpMn
    RECALL ALL
    LOCATE
             
    lnCurBarPo = 0
    SCAN
      lnCurPopPo = lnCurPopPo + 1
      lnCurSubPo = lnCurSubPo + 1
      IF VAL(cPop_Levl) > 1
        lnCurBarPo = lnCurBarPo + 1
        REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
      ELSE
        lnPrvBarPo = lnPrvBarPo + 1
        IF cSub_Typ = "S"
          lnCurBarPo = 0
          lnCurSubPo = lnCurSubPo + 1
        ENDIF
        REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
      ENDIF
      REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
              cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
    ENDSCAN
    SELECT SycMenu
    APPEND FROM (gcWorkDir + 'TmpEmpMn')
  ENDIF
ENDSCAN
       
*-- After adding all the Sub Menus and all its Child we have to add the Main bars.
SELECT (TmpMenu)
LOCATE FOR cPad_Pos = lcCurPadPo AND cSub_Typ <> "S" AND VAL(cPop_Levl) = 1 
IF FOUND()
  SELECT SycMenu
  SET ORDER TO TAG AppPopBar DESCENDING
  SEEK lcMenuToUp + lcCurPadPo
  SET ORDER TO TAG AppPopBar ASCENDING
       
  lnCurBarPo = VAL(cBar_Pos)
  lnCurPopPo = VAL(cPop_Pos)
  lnCurSubPo = VAL(cSub_Pos)
                 
  *SAMEH     SSE    Fix problem with the menu in biuld 40 
  IF ALLTRIM(cPop_Levl) <> '01'
    SET ORDER TO TAG AppPopBar DESCENDING            
    LOCATE FOR cApp_ID = lcMenuToUp AND cPad_Pos = lcCurPadPo AND cSub_Typ = "S" AND VAL(cPop_Levl) = 1 
    IF FOUND()
      lnCurBarPo = VAL(cBar_Pos)
    ENDIF
    SET ORDER TO TAG AppPopBar ASCENDING      
  ENDIF
  *SAMEH     SSE  FiX problem with the menu in build 40 
  
  *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
  SELECT (TmpMenu)
  SCAN FOR cPad_Pos = lcCurPadPo AND cSub_Typ <> "S" AND VAL(cPop_Levl) = 1 
    SCATTER MEMVAR MEMO
    SELECT SycMenu
    APPEND BLANK
    GATHER MEMVAR MEMO
    lnCurBarPo = lnCurBarPo + 1
    lnCurPopPo = lnCurPopPo + 1
    lnCurSubPo = lnCurSubPo + 1
    REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
            cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
            cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
  ENDSCAN
               
  *-- Finally append all the records to Master Menu file (SycMenu).
  SELECT SycMenu
  APPEND FROM (gcWorkDir + 'TmpEmpMn')
ENDIF  
SELECT (lcAlias)
*-- End of lpMenuPad.

*!*************************************************************
*! Name     : lfUSmpData.
*! Auth     : Yasser Mohammed Aly (YMA).
*! Date     : 06/24/97
*! Task ID  : E300613,1 
*!*************************************************************
*! Synopsis : Update the SYCCOMP with the sample '99' company
*!            record if it was installed.
*!*************************************************************
FUNCTION lfUSmpData
PRIVATE lnActAlias, llFound

llFound    = .F.
llEndSlash = (RIGHT(gcSysHome,1) = "\")
lc99Path   = IIF(llEndSlash, LEFT(gcSysHome,LEN(gcSysHome)-1), gcSysHome)
lc99Path   = LEFT(lc99Path , ATC("\",gcSysHome,OCCUR("\",lc99Path)))
lc99Path   = lc99Path + "DBFS\99\"
lnActAlias = SELECT()

IF FILE(lc99Path+"SYCCOMP.DBF")
  USE (lc99Path+"SYCCOMP.DBF") IN 0 AGAIN ALIAS InsComp
  SELECT InsComp
  GOTO TOP
  SCATTER MEMVAR MEMO
  USE (gcSysHome+"SYCCOMP") ORDER cComp_ID AGAIN ALIAS SysComp
  IF !SEEK("99")
    APPEND BLANK
    *A27_1stRun,1 TMI 08/21/2011 [Start] 
    llFound = .T.
    GATHER MEMVAR MEMO
    *A27_1stRun,1 TMI 08/21/2011 [End  ]     
  ENDIF
*!*	  llFound = .T.
*!*	  GATHER MEMVAR MEMO
  ERASE (lc99Path+"SYCCOMP.DBF")
  ERASE (lc99Path+"SYCCOMP.CDX")
  ERASE (lc99Path+"SYCCOMP.FPT")
ELSE
  USE (gcSysHome+"SYCCOMP") IN 0 ORDER cComp_ID AGAIN ALIAS SysComp
  SELECT SysComp
  llFound = SEEK("99")
  IF llFound
     *E301098,1 Hesham (Start)
     *lc99Path = ALLT(ccom_ddir)  
     lc99Path = gfGetDataDir(ALLT(ccom_ddir))
     *E301098,1 Hesham (End)
  ENDIF   
ENDIF  

IF llFound
  *E300712,1 Hesham El-Sheltawi (Start)
  *E300712,1 Update the currency file & the exchange file from
  *E300712,1 the sample data dir. if exist
  =gfUpdCurr(lc99Path)
  *E300712,1 Hesham El-Sheltawi (End)
  USE (gcSysHome+"SYDAPPL") IN 0 AGAIN ALIAS SysAppl
  SELECT SysAppl
  lcMod = SPACE(0)
  SCAN
    lcModule = UPPER(ALLTRIM(cApp_ID))
    IF lcModule # "SY" AND lcModule # "SM"
      lcMod = lcMod + IIF(EMPTY(lcMod),"","|") + lcModule
    ENDIF
    *E300717,1 Hesham (Start)
    *E300717,1 if the module that is being installed one of the list
    *E300717,1 then update the schedule file for company 99 for
    *E300717,1 the installed module
    IF INLIST(lcModule,'SM','PO','AP','AR')
      =gfUpdSched(lc99path,lcModule)
    ENDIF
    *E300717,1 Hesham (End)    
  ENDSCAN
  *E300717,1 Hesham (Start)
  *E300717,1 Erase the schedule file from the company 99 directory
  ERASE (lc99Path+"SYSCHDUL.DBF")
  ERASE (lc99Path+"SYSCHDUL.FPT")
  ERASE (lc99Path+"SYSCHDUL.CDX")
  *E300717,1 Hesham (End)  
  USE

  SELECT SysComp
  *MAN 07/18/2000 Start 
  *REPLACE mComp_Mdl WITH lcMod ,;
          mModlSet  WITH lcMod ,;
          cCom_DDir WITH lc99Path
   *-- The following code is written to make sure that only the modules that 
   *-- have demo data are replaced in mComp_Mdl and mModlSet with the exception 
   *-- of the modules that have not been installed. We know what modules have 
   *-- demo data installed by checking the mComp_Mdl and mModlSet in the splited
   *-- syccomp
   DECLARE laMod99[1]       
   laMod99 = ' '
   lcInstMod = ""
   lcSetMod  = ""
   = gfSubStr(SysComp.mComp_Mdl,@laMod99,'|')    
   FOR lnCount = 1 TO ALEN(laMod99,1)
     IF laMod99[lnCount] $ lcMod 
       lcInstMod = lcInstMod + IIF(EMPTY(lcInstMod),"","|") + laMod99[lnCount]
     ENDIF  
   ENDFOR     
   DECLARE laMod99[1]       
   laMod99 = ' '
   = gfSubStr(SysComp.mModlSet,@laMod99,'|')    
   FOR lnCount = 1 TO ALEN(laMod99,1)
     IF laMod99[lnCount] $ lcMod 
       lcSetMod = lcSetMod + IIF(EMPTY(lcInstMod),"","|") + laMod99[lnCount]
     ENDIF  
   ENDFOR
   SELECT SysComp     
   REPLACE mComp_Mdl WITH lcInstMod ,;
           mModlSet  WITH lcSetMod  ,;
           cCom_DDir WITH lc99Path
   *MAN 07/18/2000 End
        
ENDIF

*B609765,1 TMI 12/08/2011 [Start] update the SYCINST.cCompPath field if empty 
llOpenSYCINST = .F.
IF !USED('SYCINST')
  llOpenSYCINST = .T.
  USE (gcSysHome+"SYCINST") IN 0 
ENDIF
SELECT SYCINST
LOCATE
SELECT SYCCOMP
LOCATE 
PRIVATE lcDataPath
lcDataPath = ALLTRIM(SYCCOMP.CCOM_DDIR)+;
             IIF(RIGHT(ALLTRIM(SYCCOMP.CCOM_DDIR),1)='\','','\')
lcDataPath = SUBSTR(lcDataPath,1, RAT('\',lcDataPath,2))
IF EMPTY(SYCINST.CCOMPATH)
  REPLACE SYCINST.CCOMPATH WITH lcDataPath
ENDIF
IF EMPTY(SYCINST.CINSALLCMP)
  REPLACE SYCINST.CINSALLCMP WITH lcDataPath  
ENDIF
IF llOpenSYCINST
  USE IN SYCINST
ENDIF
*B609765,1 TMI 12/08/2011 [End  ] 

USE IN SysComp

SELECT(lnActAlias)




*!*************************************************************
*! Name      :lfUpdTrans
*! Developer : NAD(Nader Anis Mitry)
*! B605445,1 NAD 01/30/2002 Fix Bug in the Realease             
*!**************************************************************
PROCEDURE lfUpdTrans

*BADRAN    MAB 01/05/2002 Run this process once... BEGIN
IF llEXEzaped
  RETURN .T.
ELSE
  *-- BADRAN 02/16/2003 Check the existance of the transmission file.
  IF !FILE(gcSysHome+"HDDTRANS.DBF")
    llEXEzaped = .T.
    RETURN .T.
  ENDIF
ENDIF 
*BADRAN    MAB 01/05/2002 Run this process once... END

lnOAlias = SELECT(0)
llUseAppl = .F.
IF USED("SYDAPPL")
  llUseAppl = .T.
  lcAppOrd = ORDER("SYDAPPL")
  USE IN SYDAPPL
ENDIF  
USE(gcSysHome+"SYDAPPL") IN 0 SHARED ORDER cApp_ID

llUseTrans = .F.
IF USED("SYDTRANS")
  llUseTrans = .T.
  lcTransOrd = ORDER("SYDTRANS")
  USE IN SYDTRANS
ENDIF  
USE(gcSysHome+"SYDTRANS") IN 0 EXCL ORDER cExeNam DESC

*BADRAN    MAB 01/05/2002 ... BEGIN
*-- Open the history transaction table
USE(gcSysHome+"HDDTRANS") ORDER 1 IN 0 EXCL

*-- Open the EXEs table.
USE(gcSysHome+"SYDEXES") IN 0 EXCL
SELECT SYDEXES
ZAP
USE IN SYDEXES
llEXEzaped = .T.  && Avoid making this process again.
*BADRAN    MAB 01/05/2002 ... END

llPack = .F.
SELECT SYDAPPL
SCAN
  lcExe2Comp = PADR(SYDAPPL.cApp_Id,2) + RIGHT(ALLTRIM(SYDAPPL.cMdlBuild),3)
  IF SEEK(PADR(SYDAPPL.cApp_Id,2),"SYDTRANS") AND (lcExe2Comp > LEFT(ALLTRIM(SYDTRANS.cExeNam),5))
    REPLACE nSrvcPak WITH 0
    SELECT SYDTRANS
    DELETE REST WHILE LEFT(cExeNam,2) = PADR(SYDAPPL.cApp_Id,2)
    llPack = .T.
  ENDIF

  *BADRAN    MAB 01/05/2002 ... (Add the history record.) BEGIN
  IF SEEK(PADR(SYDAPPL.cApp_Id,2),"HDDTRANS")
    SELECT HDDTRANS
    SCATTER MEMVAR MEMO
    INSERT INTO SYDTRANS FROM MEMVAR
  ENDIF
  *BADRAN    MAB 01/05/2002 ... (Add the history record.) END

ENDSCAN

IF llPack
  SELECT SYDTRANS
  PACK
ENDIF

IF llUseTrans
  USE(gcSysHome+"SYDTRANS") IN 0 ORDER &lcTransOrd SHARED
ELSE
   USE IN SYDTRANS
ENDIF

IF llUseAppl
  USE(gcSysHome+"SYDAPPL") IN 0 ORDER &lcAppOrd SHARED 
ELSE
  USE IN SYDAPPL
ENDIF

*BADRAN    MAB 01/05/2002 ... (Erase the history table.) BEGIN
USE IN HDDTRANS
ERASE (gcSysHome+"HDDTRANS.CDX")
ERASE (gcSysHome+"HDDTRANS.DBF")
*BADRAN    MAB 01/05/2002 ... (Erase the history table.) END

SELECT  (lnOAlias)
RETURN .T.
*-- end of the update transaction process.



*E300712,1 Hesham (Start)
*E300712,1 check if the currency file exist in the sample data direc.
*E300712,1 then update the currency file in system dir.
*!*************************************************************************
*! Name      : gfUpdCurr
*! Developer : Hesham El-Sheltawi 
*! Date      : 
*! Purpose   : function to update the currency files for the sample company 
*!             "company 99"
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION gfUpdCurr
PARAMETERS lc99Path
IF FILE(lc99Path+"SYCCURR.DBF")
  USE (gcSysHome+"SYCCURR") ORDER CCURRCODE IN 0 AGAIN ALIAS SysCurr
  USE (lc99Path+"SYCCURR.DBF") IN 0 AGAIN ALIAS CompCurr ORDER CCURRCODE
  SELECT CompCurr
  GO TOP
  SCAN
    IF !SEEK(CompCurr.ccurrcode,'SysCurr')
      SCATT MEMVAR MEMO
      SELECT SysCurr
      APPEND BLANK
      GATHER MEMVAR MEMO
    ENDIF
  ENDSCAN  
  USE IN SysCurr
  USE IN CompCurr
  ERASE (lc99Path+"SYCCURR.DBF")
  ERASE (lc99Path+"SYCCURR.CDX")
  ERASE (lc99Path+"SYCCURR.FPT")
  
ENDIF

IF FILE(lc99Path+"SYCEXCH.DBF")
  USE (gcSysHome+"SYCEXCH") ORDER CURRENCY IN 0 AGAIN ALIAS SysExch
  USE (lc99Path+"SYCEXCH.DBF") IN 0 AGAIN ALIAS CompExch ORDER CURRENCY
  SELECT CompExch
  GO TOP
  SCAN
    IF !SEEK(cbasecurr+ccurrcode+DTOS(dratedate),'SysExch')
      SCATT MEMVAR MEMO
      SELECT SysExch
      APPEND BLANK
      GATHER MEMVAR MEMO
    ENDIF
  ENDSCAN  
  USE IN SysExch
  USE IN CompExch
  ERASE (lc99Path+"SYCEXCH.DBF")
  ERASE (lc99Path+"SYCEXCH.CDX")
  ERASE (lc99Path+"SYCEXCH.FPT")
ENDIF

*E300712,1 Hesham (End)

*E300717,1 Hesham (Start)
*!*************************************************************************
*! Name      : gfUpdSched
*! Developer : Hesham El-Sheltawi 
*! Date      : 02/02/97    
*! Purpose   : function to update the schedule file for the sample company
*!             "company 99"
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION gfUpdSched
PARAMETERS lc99path,lcModule
IF FILE(lc99Path+"SYSCHDUL.DBF")
  USE (gcSysHome+"SYSCHDUL") ORDER Schuser IN 0 AGAIN ALIAS SysShed
  SELECT SysShed
  lcContType = IIF(lcModule $ 'POAP',[CCONTTYPE = 'V'],IIF(lcModule $ 'AR',[CCONTTYPE = 'C'],[!(CCONTTYPE $ 'VC')]))
  DELETE ALL FOR CCOMP_ID = '99' AND CUSER_ID = 'ADMIN' AND &lcContType
  APPEND FROM lc99Path+"SYSCHDUL.DBF" FOR CUSER_ID = 'ADMIN'
  USE IN SysShed
ENDIF
*E300717,1 Hesham (End)



*!*************************************************************
*! Name      : gfSubStr
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To extract element from string or to convert string to array
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GFSCRINI()               (function  in ARIA3.PRG)
*!      Called by: GFMODALGEN()             (function  in ARIA3.PRG)
*!      Called by: GFSEEKREC()              (function  in ARIA3.PRG)
*!      Called by: GFDBFFIELD()             (function  in ARIA3.PRG)
*!      Called by: GFFLOCK()                (function  in ARIA3.PRG)
*!      Called by: GFRLOCK()                (function  in ARIA3.PRG)
*!      Called by: GFWAIT()                 (function  in ARIA3.PRG)
*!      Called by: GFGETVLD()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : String to be used
*!                      poiter to array or element position
*!                      sparators used in the string
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will return eather a string part # OR an array of all
* the string parts according to the type of the second parameter. The
* firest parameter will be the string or string variable. If the
* second parameter have a numeric type, the function will return the
* but if it is an array the function will return the array with each
*  element having a part from the string.
* 
*:->
FUNCTION gfSubStr
PARAMETERS lcString,lnAryOrPos,lcSepta

lcSubstr  =' '
lnAryDim  = 1
lnAryRows = 1
lnAryCols = 1
lcSepta   = IIF(TYPE('lcSepta')='C',lcSepta,',') 

IF LEN(ALLTRIM(lcSepta))>1
  lcColSep  = SUBSTR(lcSepta,2,1)
  lcSepta   = LEFT(lcSepta,1)
  lnAryDim  = IIF(OCCURS(lcSepta,lcString)>0,;
              OCCURS(lcSepta,lcString)+;
              IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
              lnAryDim)
  lnAryCols = IIF(OCCURS(lcColSep,lcString)>0,;
              OCCURS(lcColSep,lcString)+;
              IIF(RIGHT(lcString,1)<>lcColSep,1,0),;
              lnAryDim)
  lnAryRows = (lnAryDim+(lnAryCols-1)) / lnAryCols
  lnAryDim  = lnAryDim +(lnAryCols-1)     
  lcString  = STRTRAN(lcString,lcColSep,lcSepta)
ELSE
  lnAryDim = IIF(OCCURS(lcSepta,lcString)>0,;
             OCCURS(lcSepta,lcString)+;
             IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
             lnAryDim)
ENDIF

*** Chek if second parameter array or numeric
DO CASE
  *** If no parameter found assume firest part of string
  CASE TYPE ('lnAryOrPos')='U'
    lnAryOrPos = 1

  *** If array strich it to hold all string parts
  CASE TYPE ('lnAryOrPos') $ 'C,L'    
    IF lnAryCols > 1
      DIMENSION lnAryOrPos[lnAryRows,lnAryCols]
    ELSE
      IF ALEN(lnAryOrPos,2) > 0
        DIMENSION lnAryOrPos[lnAryDim,ALEN(lnAryOrPos,2)]
      ELSE
        DIMENSION lnAryOrPos[lnAryDim]
      ENDIF  

    ENDIF
    lnAryOrPos  = ' '

ENDCASE

FOR lnArElem  = 1 TO lnAryDim
  IF TYPE ('lnAryOrPos')='N'
    lnArElem = lnAryOrPos
  ENDIF  

  DO CASE
    *** In case of firest string part
    CASE lnArElem = 1
      lcSubstr = SUBSTR(lcString,1,;
      IIF(lcSepta $ lcString,AT(lcSepta,lcString)-1,LEN(lcString)))

    *** In case of last string part
    CASE lnArElem = lnAryDim
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1)
      lcSubstr = IIF(RIGHT(lcSubstr,1)=lcSepta,;
                 SUBSTR(lcSubstr,1,LEN(lcSubstr)-1),lcSubstr)
    *** In case of any string part from the meddel
    CASE lnArElem > 1
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1,;
                 AT(lcSepta,lcString,lnArElem)-;
                 AT(lcSepta,lcString,lnArElem-1)-1)
  ENDCAS

  IF TYPE ('lnAryOrPos')='N'
    RETURN lcSubstr
  ENDIF  
  
  IF lnAryCols > 1
    lnAryOrPos[((lnArElem-1)%lnAryRows)+1,INT((lnArElem-1)/lnAryRows)+1] = lcSubstr
  ELSE
    lnAryOrPos[lnArElem] = lcSubstr
  ENDIF
ENDFOR





*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*****************************************************************************
* From this line and downward this is a copy of the whole prgs\sy\Aria27.prg
* I added it as we found that some system functions are missing while running the program
* This will include commenting out functions used in the down part
*****************************************************************************


*!*************************************************************
*! Name      : gfReadWhen
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To restore old environment in case of ubnormal termination
*!*************************************************************
*! Calls     : 
*!             GPCHNGMODL               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Restore last enviroment if requird in case of ubnormal termination
*:->
FUNCTION gfReadWhen

IF glRestore
  glReadWhen = .F.
  DECLARE laScreens[1,3]
  
  SELECT COBJ_NAME, CAPP_ID, CADD_TIME;
         FROM (gcSysHome+"SYUSTATC");
         WHERE cobj_typ = "WIN"      .AND.;
               cuser_id  = gcUser_ID .AND.;
               cstation  = gcStation      ;
         ORDER BY CADD_TIME               ;
         INTO ARRAY laScreens
  
  IF !EMPTY (laScreens[1,1])
    FOR lnScreen = 1 TO ALEN(laScreens,1)

      IF gcAct_Appl <> laScreens[lnScreen,2]
        DO gpChngModl WITH laScreens[lnScreen,2]
        gcAct_Appl  = laScreens[lnScreen,2]
        lcAppName   = gcAppHome+gcAct_Appl+'.APP'
      ENDIF  


      glFirsTime= .F.
      gcWin2Rest= laScreens [lnScreen,1]
      DO (lcAppName) WITH SUBSTR(gcWin2Rest,4)
    ENDFOR
    RELEASE lnScreen
  ENDIF  
  
  glReadWhen = .T.
  glRestore  = .F.

ENDIF  


*!*************************************************************
*! Name      : gpMenuBar
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To get the name of program to be run from the menu
*!*************************************************************
*! Calls     : 
*!      Called by: GFMENUBLD()              (function  in ARIA3.PRG)
*!          Calls: GPDOPROG                 (procedure in ARIA3.PRG)
*!          Calls: GFSTATIC()               (function  in ARIA3.PRG)
*!          Calls: GPRPPRINT                (procedure in ARIA3.PRG)
*!          Calls: GPCHNGMODL               (procedure in ARIA3.PRG)
*!          Calls: GPAPPLINK                (procedure in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Popup name
*!                      Bar number
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This procedure is going to be called from all the menu bars
* and the from this point i will call all deferant programs, reports
*
PROCEDURE gpMenuBar
PARAMETERS lcPopName,lnBarNo

glPopAct  = .F.
gcAct_Pad = ''

*E300279,1  SET Help Topic to the related one in the menu file.
IF "P05" $ lcPopName
  =gfHlpTopic(lcPopName,lnBarNo)
ENDIF


*#IF _DOS
*    lcWonTop = WONTOP()
*    ACTIVATE SCREEN
*    @ SROWS()-1,0 SAY  SPACE(51)+gcMesg_Str COLOR (SCHEME(1,5))
*    IF !EMPTY(lcWonTop)
*      ACTIVATE WINDOW (lcWonTop) SAME
*    ENDIF
*#ELSE
    SET MESSAGE TO ALLTRIM(gcSysName)
*#ENDIF

*** Get the array row no for this popup-bar
lcSavExact = SET ('EXACT')

SET EXACT OFF


lnProgNum = ASCAN(gaProcess,ALLTRIM(lcPopName)+"-"+PADL(lnBarNo,2,'0'))

SET EXACT &lcSavExact

*** Check if this option have any process to run 
IF lnProgNum > 0 
  lcPross  = ASUBSCRIPT('gaProcess',lnProgNum,1)
  DO CASE
    *** Running module system program
*E300306,1 M.H Update the program to work with the custom program with the 
*E300306,1 M.H gcAppHome path.
*    CASE gaProcess[lcPross,3] = 'P'
    CASE gaProcess[lcPross,3] $ 'CP'
*E300306,1 M.H End.

      *E039995,1 AMH Add Enhancment to update system audit [Start]
      IF gcUsr_audt $ "PB" .AND. !EMPTY(gcUser_ID)
        USE (gcSysHome+"SYAUDIT") IN 0
        SELECT SYAUDIT
        INSERT INTO SYAUDIT (cComp_ID  , cEvent_ID  , cApObjNam         , cAdd_User, dAdd_Date, cAdd_Time) ;
                     VALUES (gcAct_Comp, "SCR_LOGIN", ;
                             IIF(EMPTY(gaProcess[lcPross,5]),ALLTRIM(gaProcess[lcPross,2]),ALLTRIM(gaProcess[lcPross,5])),;
                             gcUser_ID, DATE(), gfGetTime())
        USE IN SYAUDIT
      ENDIF
      IF FILE(gcSysHome + "User.txt") .AND. !EMPTY(gcUser_ID)
        USE (gcSysHome+"SYAUDITB") IN 0
        SELECT SYAUDITB
        INSERT INTO SYAUDITB (cComp_ID  , cEvent_ID  , cApObjNam         , cAdd_User, dAdd_Date, cAdd_Time) ;
                     VALUES (gcAct_Comp, "SCR_LOGIN", ;
                             IIF(EMPTY(gaProcess[lcPross,5]),ALLTRIM(gaProcess[lcPross,2]),ALLTRIM(gaProcess[lcPross,5])),;
                             gcUser_ID, DATE(), gfGetTime())
        USE IN SYAUDITB
      ENDIF
      *E039995,1 AMH [End]

      *E300581,1 Hesham El-Sheltawi (Start)
      *E300581,1 Check if Empty of Base window name
      *E300581,1 then define the main window for the apparel
      *E300581,1 old programs and run the module with the
      *E300581,1 process id
*      DO gpDoProg WITH (ALLTRIM(gaProcess[lcPross,5]))      
      IF !EMPTY(gaProcess[lcPross,5])
      *E300710,1 Hesham (Start)
      *E300710,1 make the menu call the SM module in case the menu bar is a program
      *E300710,1 and the bar is defined for the main system
*        DO gpDoProg WITH (ALLTRIM(gaProcess[lcPross,5])),.f.,.f.,gaProcess[lcPross,8]
        DO gpDoProg WITH (ALLTRIM(gaProcess[lcPross,5])),.f.,;
        IIF(gaProcess[lcPross,9]='S','SM',.F.),gaProcess[lcPross,8]
      *E300710,1 Hesham (End)        
      ELSE
        IF !WEXIST('MainWin')
          DEFINE WINDOW MainWin FROM 0,0 SIZE 25,80 ;
           FLOAT NONE NOCLOSE FONT "FoxFont", 10 STYLE "R" 
        ENDIF   
        MOVE WINDOW MainWin CENTER
        ACTIVATE WINDOW MainWin
      *E300710,1 Hesham (Start)
      *E300710,1 make the menu call the SM module in case the menu bar is a program
      *E300710,1 and the bar is defined for the main system
*        DO gpDoProg WITH (ALLTRIM(gaProcess[lcPross,2])),.f.,.f.,gaProcess[lcPross,8]
        DO gpDoProg WITH (ALLTRIM(gaProcess[lcPross,2])),.f.,;
        IIF(gaProcess[lcPross,9]='S','SM',.F.),gaProcess[lcPross,8]
      *E300710,1 Hesham (End)        
      ENDIF  
      RELEASE WINDOW MainWin
      *E300581,1 Hesham El-Sheltawi (End)   
    *** Running System global procedure
    CASE gaProcess[lcPross,3] = 'G'
       IF !EMPTY(gaProcess[lcPross,8])
         DO (ALLTRIM(gaProcess[lcPross,2])) WITH gaProcess[lcPross,8]
       ELSE
         DO (ALLTRIM(gaProcess[lcPross,2]))
       ENDIF  

    *** Running Module system report
    CASE gaProcess[lcPross,3] = 'R'

      *E039995,1 AMH Add Enhancment to update system audit [Start]
      IF gcUsr_audt $ "PB" .AND. !EMPTY(gcUser_ID)
        USE (gcSysHome+"SYAUDIT") IN 0
        SELECT SYAUDIT
        INSERT INTO SYAUDIT (cComp_ID  , cEvent_ID  , cApObjNam         , cAdd_User, dAdd_Date, cAdd_Time) ;
                     VALUES (gcAct_Comp, "REP_LOGIN", ALLTRIM(gaProcess[lcPross,2]), gcUser_ID, DATE(), gfGetTime())
        USE IN SYAUDIT
      ENDIF
      IF FILE(gcSysHome + "User.txt") .AND. !EMPTY(gcUser_ID)
        USE (gcSysHome+"SYAUDITB") IN 0
        SELECT SYAUDITB
        INSERT INTO SYAUDITB (cComp_ID  , cEvent_ID  , cApObjNam         , cAdd_User, dAdd_Date, cAdd_Time) ;
                     VALUES (gcAct_Comp, "REP_LOGIN", ALLTRIM(gaProcess[lcPross,2]), gcUser_ID, DATE(), gfGetTime())
        USE IN SYAUDITB
      ENDIF
      *E039995,1 AMH [End]

      IF RDLEVEL() > 1
        IF TYPE('lcBaseWind') = 'U'
          CLEAR READ
        ELSE
          *** Get the current object at this moment
          lnCurObj   = _CUROBJ          && Save current object to variable
          =gfStatic()                   && Save inviroment before terminate
          CLEAR READ                    && Terminat old program
          *B602746,1 MAN 4/5/99 Call Function to release browse windows
          =gfClrBro()
          *B602746,1 end
          IF glFromBrow 
            glFromBrow = .F.
            ON KEY LABEL CTRL+Q
            KEYBOARD "{CTRL+Q}" PLAIN CLEAR
          ENDIF  
        ENDIF  
        gcNextRepo = ALLTRIM(gaProcess[lcPross,2])     
      ELSE
        DO gpRpPrint WITH (ALLTRIM(gaProcess[lcPross,2]))
      ENDIF

    *** Selecting mew module 
    CASE gaProcess[lcPross,3] = 'M'
       DO gpChngModl WITH (ALLTRIM(gaProcess[lcPross,2]))

*E300306,1 M.H Update the program to work with the custom program with the 
*E300306,1 M.H gcAppHome path.
    *** Running Custome program
*    CASE gaProcess[lcPross,3] = 'C'
*      WAIT "Run Custom program "+gaProcess[lcPross,2] WINDOW NOWAIT        
*E300306,1 M.H End.

    *** Running External program
    CASE gaProcess[lcPross,3] = 'E'
       DO gpAppLink WITH (ALLTRIM(gaProcess[lcPross,2])),;
                         (ALLTRIM(gaProcess[lcPross,4]))
  ENDCASE

*** If no link was don through the menu program
ELSE
  *** Bar Process was not defined, 
  *** you have to link this bar to a program through the menu program
  =gfModalgen("INM00147B00000","DIALOG")
ENDIF


*!*************************************************************
*! Name      : gpQuit
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To quit the system in case of run time
*!*************************************************************
*! Calls     : 
*!          Calls: GPEXIT                   (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpQuit

glRetVal = .t.
glQuit   = .t.

DO gpExit

*!*************************************************************
*! Name      : gpExit
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To exit the system in case of developing time
*!*************************************************************
*! Calls     : 
*!      Called by: GPQUIT                   (procedure in ARIA3.PRG)
*!      Called by: GPAPPLINK                (procedure in ARIA3.PRG)
*!          Calls: GFGETTIME()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpExit

glRetVal  = .T.
glEndprog = .T.

IF USED('syuuser')
  SELECT syuuser
  SET ORDER TO 1
ELSE
  SELECT 0
  USE (gcSysHome+"syuuser") ORDER 1
ENDIF

SEEK gcUser_ID

REPLACE  lusr_logd WITH .F.;
         cUsr_llot WITH gfGetTime()

*E039995,1 AMH Add Enhancment to update system audit [Start]
IF gcUsr_audt $ "AB" .AND. !EMPTY(gcUser_ID)
  USE (gcSysHome+"SYAUDIT") IN 0
  SELECT SYAUDIT
  INSERT INTO SYAUDIT (cComp_ID  , cEvent_ID   , cApObjNam, cAdd_User, dAdd_Date, cAdd_Time) ;
               VALUES (gcUser_Com, "USR_LOGOFF", ""       , gcUser_ID, DATE(), gfGetTime())
  USE IN SYAUDIT
ENDIF
IF FILE(gcSysHome + "User.txt") .AND. !EMPTY(gcUser_ID)
  USE (gcSysHome+"SYAUDITB") IN 0
  SELECT SYAUDITB
  INSERT INTO SYAUDITB (cComp_ID  , cEvent_ID   , cApObjNam, cAdd_User, dAdd_Date, cAdd_Time) ;
               VALUES (gcUser_Com, "USR_LOGOFF", ""       , gcUser_ID, DATE(), gfGetTime())
  USE IN SYAUDITB
ENDIF
*E039995,1 AMH [End]

CLEAR READ ALL

*!*************************************************************
*! Name      : gpDoProg
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To run any program from menu or another program
*!*************************************************************
*! Calls     : 
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!      Called by: GFVTOOLVLD()             (function  in ARIA3.PRG)
*!          Calls: GFSTATIC()               (function  in ARIA3.PRG)
*!          Calls: GFRUNPROG()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Program name
*!                      not used
*!                      Source module ID 
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This procedure is called from the menu to run any program or to  
* activate any program from any other active program.
* If no program is activated befor, do the program through it's module
* header program. But if there is on or more active program(s), just 
* assine the program name to be done in the gcNextProg variable
* and terminat the current one then fall under the contol of the
* foundation read which will activate the program
*
*:->>
PROCEDURE gpDoProg

PARAMETER gcProg_Nam,lcProgOrWin,gcSrceModl,lcPrgPram


*** If comming from the menu gcSrceModl will not be defined so we will
*** use the gcAct_Appl variable to point to the window source module
*** If comming from another program from the same module so we will
*** use the same variable , but if the to be run program is from 
*** another module use  gcSrceModl to point to the window source module

*gcWinAppl   = ALLTRIM(UPPER(IIF(TYPE('gcSrceModl')='C',gcSrceModl,;
                      gcAct_Appl)))
lcPatSet = SET('FULLPATH')
SET FULLPATH ON

*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
*gcWinAppl   = ALLTRIM(UPPER(IIF(TYPE('gcSrceModl')='C',gcSrceModl,;
                      IIF(FILE(gcAppHome+SUBSTR(gcProg_Nam,4,2)+'\'+SUBSTR(gcProg_nam,4)+'.FXP'),SUBSTR(gcProg_nam,4,2),gcAct_Appl) )))
gcWinAppl   = ALLTRIM(UPPER(IIF(TYPE('gcSrceModl')='C',gcSrceModl,;
                      IIF(GCMULTIINST And (FILE(gcCappHome+SUBSTR(gcProg_Nam,4,2)+'\'+SUBSTR(gcProg_nam,4)+'.FXP')) Or;
                      FILE(gcAppHome+SUBSTR(gcProg_Nam,4,2)+'\'+SUBSTR(gcProg_nam,4)+'.FXP'),SUBSTR(gcProg_nam,4,2),gcAct_Appl) )))
*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]

SET FULLPATH &lcPatSet


*** Get the name of the base window in the program that going to be done
gcBaseWind  = ALLTRIM(UPPER(IIF(' ' $ gcProg_Nam,;
                  SUBSTR(gcProg_Nam,1,ATC(' ',gcProg_Nam)-1),gcProg_Nam)))

gnProgCopy  = 0
FOR lnAscii = 65 TO 90
  gnProgCopy = gnProgCopy + 1
  gcBaseWind =STUFF(gcBaseWind,2,1,CHR(lnAscii))
  IF WVISIBLE(gcBaseWind)
    LOOP
  ELSE
    EXIT 
  ENDIF
ENDFOR
**************


*** Define glFirsTime with .T. to be checked in the setup function to
*** intializ the program for first time 
glFirsTime = .T.

*** If there is on or more active program on disktop while calling another
*** program from the menu or another program
IF RDLEVEL() > 1

   *** Load the name of the program to be activated into the gcNextProg
   *** and terminat the current program so you will fall under the
   *** controle of the foundation read which will check the content of 
   *** this variable and activate the program
   gcNextprog  = gcProg_Nam
   gcPrgPram = lcPrgPram
   IF TYPE('lcBaseWind') = 'U'
     CLEAR READ
   ELSE
     *** Get the current object at this moment
     lnCurObj   = _CUROBJ            && Save current object to variable
     =gfStatic()                      && Save inviroment before terminate
     CLEAR READ                      && Terminat old program

     *B602746,1 MAN 4/5/99 Call Function to release browse windows
     =gfClrBro()
     *B602746,1 end
     IF  glFromBrow 
       glFromBrow = .F.
       ON KEY LABEL CTRL+Q
       ON KEY LABEL CTRL+W
       KEYBOARD "{CTRL+Q}" PLAIN CLEAR
     ENDIF  
   ENDIF  
*** This is the first program to be activated from the menu
ELSE
   *** From the menu you can only call programs from the current module   
   *** so you can use the gcAct_Appl to point to the name of the module
   =gfRunProg(gcProg_Nam,lcPrgPram)
ENDIF


*!*************************************************************
*! Name      : gfMainCont
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the foundation read that keep the system running
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!          Calls: GFPOPMESAG()             (function  in ARIA3.PRG)
*!          Calls: GPRPPRINT                (procedure in ARIA3.PRG)
*!          Calls: GFRUNPROG()              (function  in ARIA3.PRG)
*!          Calls: GFGETWNAME()             (function  in ARIA3.PRG)
*!          Calls: &GCMODPRG                
*!          Calls: GFTOOLBAR()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfMainCont
PRIVATE gcWinType,gcModPrg,gcPathMod

*B606744,1 AMH Trigger to run the task list screen when system log in [Start]
IF !USED('TODOMBI')
  =gfDoTriger('TASKLST',PADR('TODOMBI',10))
ENDIF
*B606744,1 AMH [End]

*B600613,1 If the global variables is not defined after we return from external prg.
*B600613,1 redifine it
IF TYPE("glEndprog") = "U"
  RETURN .F.                            
ENDIF                                   


*** If Exit option was selected from the menu this flag will be
*** .T. so we have to terminate the program
IF glEndprog
  RETURN .T.                            && Only when 'Exit' is selected
ENDIF                                   && from the menu.

*** If this function was enterd on the timout enterval 
*** it,s going to be used to detect message sent to the current user
*IF INLIST(READKEY(),15,20,276)
*E300252,1 The messaging check system was stopeed as we do not use it now
*  IF gnMsgRec > 0 .AND. USED('syuckmsg')
*    GO gnMsgRec IN syuckmsg
*    IF !EMPTY(syuckmsg.cmessage)
*      =gfPopMesag()
*    ENDIF
*  ENDIF  

*  RETURN .F.
*ENDIF  


IF !EMPTY(gcNextRepo)
  gcRunRepo  = gcNextRepo
  gcNextRepo = ''
  DO gpRpPrint WITH gcRunRepo
ENDIF

*** If comming from the menu while one or more active program
IF !EMPTY(gcNextprog)            
  gcRunProg  = gcNextprog
  lcPrgPram = gcPrgPram
  gcPrgPram = ''
  gcNextprog = ''
  =gfRunProg(gcRunProg,lcPrgPram)

*** If comming from another active program
ELSE
  *** You may have three cases"
  *** Case activate another base window -> get prg name and call it
  *** Case activate child window        -> get the name of it's base
  ***                                      window and then prg name and run
  *** Case activate the controll screen -> this case will never happen
  ***                                      because the control will be hidden 

  gcWin2Run = gfGetWName()
 
  *** If there is windows on disktop run their program
  *** else return to foundation read
  IF !EMPTY(gcWin2Run)
    gcWinType = LEFT(gcWin2Run,1)
    DO CASE
      CASE gcWinType = 'G'
        gcModPrg = SUBSTR(gcWin2Run,4)
        DO (gcModPrg)
      CASE gcWinType = 'A' .OR. gcWinType = 'C'

        gnWinNo = ASCAN(gaAct_wind,gcWin2Run)
        IF gnWinNo > 0 
          gcWinAppl  = gaAct_wind [ASUBSCRIPT(gaAct_wind,gnWinNo,1),2]
          gcBaseWind = IIF(gcWinType='A',gcWin2Run,;
                        gaAct_wind [ASUBSCRIPT(gaAct_wind,gnWinNo,1),3])
          gcPathMod  = gcAppHome+gcWinAppl+".APP"          
          gcModPrg   = "(gcPathMod) WITH '"+SUBSTR(gcBaseWind,4)+"'"
          DO &gcModPrg
        ENDIF
*E300306,1 M.H Add a new case for the custom program.
      CASE gcWinType = 'T'
        gnWinNo = ASCAN(gaAct_wind,gcWin2Run)
        IF gnWinNo > 0 
          gcWinAppl  = gaAct_wind [ASUBSCRIPT(gaAct_wind,gnWinNo,1),2]
          gcBaseWind = gcWin2Run
          gcPathMod  = gcAppHome+gcWinAppl+".APP"          
          gcModPrg   = "(gcPathMod) WITH '"+SUBSTR(gcBaseWind,4)+"'"
          DO &gcModPrg
        ENDIF
*E300306,1 M.H End.
    ENDCASE
  ELSE
*E000000,1 Hesham El_Sheltawi (Start)
*    #IF _DOS
*        IF glUser_Tsk
*          =gfUsrTsk('NO')
*          IF !glUser_Tsk 
*            IF  glInitMenu  
*              KEYBOARD "{ALT+M}" PLAIN CLEAR
*            ELSE
*              KEYBOARD "{ALT+F}" PLAIN CLEAR      
*            ENDIF
*          ENDIF
*        ENDIF
*    #ELSE
*        IF glUser_Tsk
*          IF glToolActv
*            =gfToolbar("NOWAIT")
*            CLEAR GETS
*          ENDIF
        
        
*          =gfUsrTsk('NO')
*          IF !glUser_Tsk 
*            IF  glInitMenu  
*              KEYBOARD "{ALT+M}" PLAIN CLEAR
*            ELSE
*              KEYBOARD "{ALT+F}" PLAIN CLEAR      
*            ENDIF
*          ENDIF
*        ELSE
          IF glToolActv
            =gfToolbar()
          ENDIF
*        ENDIF
*   #ENDIF
*E000000,1 Hesham El_Sheltawi (End)
  ENDIF  
ENDIF

RETURN glRetVal

*!*************************************************************
*! Name      : gfGetWName
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Get the name of ontop window
*!*************************************************************
*! Calls     : 
*!      Called by: GFMAINCONT()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfGetWName
PRIVATE gcWindName,gcCheckWind

gcWindName  = ''
gcCheckWind = ''

*** If window on top is one of the base windows return with it's name
IF SUBSTR(WONTOP(),3,1) $ "R,D" .AND. WVISIBLE(WONTOP())
  gcWindName = WONTOP()
ELSE
  *** Check all the windows from bottom to top of stack and get the 
  *** highest base window to run it's program
  lcMainWind = IIF(_WINDOWS,"FNDATION","")
  gcCheckWind = WCHILD(lcMainWind,0)
  DO WHILE !EMPTY(gcCheckWind)
    IF SUBSTR(gcCheckWind,3,1) $ "R,D" .AND. WVISIBLE(gcCheckWind)
      gcWindName = gcCheckWind  
    ENDIF
    gcCheckWind = WCHILD(lcMainWind,1)
  ENDDO
ENDIF

gcWindName = IIF(gcWindName="FNDATION"," ",gcWindName)
RETURN gcWindName


*!*************************************************************
*! Name      : gfRunProg
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To run any program
*!*************************************************************
*! Calls     : 
*!      Called by: GFMAINCONT()             (function  in ARIA3.PRG)
*!      Called by: GPDOPROG                 (procedure in ARIA3.PRG)
*!          Calls: &GCMODPRG                
*!*************************************************************
*! Passed Parameters  : Name of program to be run
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfRunProg
PARAMETERS gcPrgToRun,lcPrgPram
PRIVATE gcWinType,gcModPrg

*E038621,1 WAM 04/05/2005 Prevent Aria4XP programs & reports from running under Aria27
USE gcSysHome+'SYDOBJCT' ORDER TAG cApobjNam AGAIN IN 0 ALIAS 'A4xpObj'
llA4xpPrg = glRunFrmA4 AND SEEK(PADR(SUBSTR(gcPrgToRun,4),10),'A4xpObj') AND A4xpObj.lRunFromA4
USE IN 'A4xpObj'
IF llA4xpPrg
  =gfModalgen("TRM00418B00000","ALERT")
  RETURN
ENDIF
*E038621,1 WAM 04/05/2005 (End)

lcPrgPram = IIF(TYPE('lcPrgPram')='C',ALLT(lcPrgPram),'')
gcWinType   = UPPER(LEFT(gcPrgToRun,1))

*E300306,1 M.H Update the program to work with the custom program
*E300306,1 M.H by includ the path of the app befor the custom program.
*IF gcWinType $ 'AG'
*  gcPathMod = gcAppHome+gcWinAppl+".APP"
*  gcModPrg  = IIF(gcWinType = 'G',SUBSTR(gcPrgToRun,4),;
                 "(gcPathMod) WITH '"+SUBSTR(gcPrgToRun,4)+"'")
*E300306,1 M.H Update the program to work with the custom program
*E300306,1 M.H by includ the path of the app befor the custom program.
*gcModPrg  = IIF(gcWinType = 'G',SUBSTR(gcPrgToRun,4),;
               "(gcPathMod) WITH '"+IIF(gaProcess[lcPross,3]='C',;
                (gcAppHome),'')+SUBSTR(gcPrgToRun,4)+"'")
*  DO &gcModPrg                         && Call program
*ENDIF

DO CASE
  CASE gcWinType $ 'AG'
    gcPathMod = gcAppHome+gcWinAppl+".APP"    
    gcModPrg  = IIF(gcWinType = 'G',SUBSTR(gcPrgToRun,4),;
                 "(gcPathMod) WITH '"+SUBSTR(gcPrgToRun,4)+"'"+IIF(EMPTY(lcPrgPram),'',",[&lcPrgPram"+"]"))
    DO &gcModPrg  && Call program
  CASE gcWinType = 'T'
    gcPathMod = gcAppHome+gcWinAppl+".APP"    
    gcModPrg  = "(gcPathMod) WITH '"+(gcAppHome)+SUBSTR(gcPrgToRun,4)+"'"+IIF(EMPTY(lcPrgPram),'',",[&lcPrgPram"+"]")
    DO &gcModPrg  && Call program
  *E300581,1 Hesham (Start)  
  OTHERWISE
    IF RDLEVEL() > 1
      IF TYPE('lcBaseWind') = 'U'
        CLEAR READ
      ELSE
        *** Get the current object at this moment
        lnCurObj   = _CUROBJ          && Save current object to variable
        =gfStatic()                   && Save inviroment before terminate
        CLEAR READ                    && Terminat old program
        *B602746,1 MAN 4/5/99 Call Function to release browse windows
        =gfClrBro()
        *B602746,1 end
        IF glFromBrow 
          glFromBrow = .F.
          KEYBOARD "{CTRL+Q}" PLAIN CLEAR
        ENDIF  
      ENDIF  
    ENDIF

    gcPathMod = gcAppHome+gcAct_Appl+".APP"    
    gcModPrg  = "(gcPathMod) WITH '"+gcPrgToRun+"'"+IIF(EMPTY(lcPrgPram),'',",[&lcPrgPram"+"]")
    CLEAR TYPEAHEAD
    DO &gcModPrg  && Call program
  *E300581,1 Hesham (End)    
ENDCASE
*E300306,1 M.H End.

*!*************************************************************
*! Name      : gfStopRead()
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To terminat the current program or not in defferant cases
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFCPSAVE()               (function  in ARIA3.PRG)
*!          Calls: GFCHCLOSE()              (function  in ARIA3.PRG)
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!          Calls: GFSTATIC()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*  This function will called in these cases :
*   1_ Case closing the window from the close marker at the top left corner: 
*              a. If it is the program base window , set glQuitting 
*                 flag to .T. and return tru to quit the program
*              b. If it is one of the program child windows ,     
*                 return with .F. flag to stay in the same read and
*                 remove the window name from the dinamic window array
*                 and release the bar from the window popup
*   2_ Case activating any other window visible on the disktop :
*              a. If the activated window belong to the same read   
*                 return with .F. flag so the program will not be terminated
*              b. If activating window not in the same read but in window
*                 gcBaseWind like browse window ,
*                 return with .F. flag to stay in the same read 
*              c. If the activated window dos not belong to the same
*                 read return with .T. to terminat the currunt program
*                 and fall under the control of foundation read
*
*:->
FUNCTION gfStopread
EXTERNAL ARRAY laScrMode


*** If you close the window from the closing marker

IF !WVISIBLE(WOUTPUT())
  DO CASE 
    *** Closing a child window
    CASE LEFT(WOUTPUT(),1) = 'C'
      =gfChClose(WOUTPUT())
       RETURN .F.
    *** Closing a child window with windows stoping on a window insid it
*    CASE LEFT(WPARENT(WOUTPUT()),1) = 'C'
    CASE LEFT(gfGetWPrnt(WOUTPUT()),1) = 'C'

      RETURN .F.
  
    *** Closing the program base window
    *CASE WOUTPUT() = gcBaseWind .OR. WPARENT(WOUTPUT()) = gcBaseWind
    CASE WOUTPUT() = gcBaseWind .OR. gfGetWprnt(WOUTPUT()) = gcBaseWind
      *** If edit or add mode, dont leave the program
      
      IF laScrMode[3] .OR. laScrMode[4] 
        *** Reactivate the window becouse it's olredy hided
        ACTIVATE WINDOW (gcBaseWind)
        ACTIVATE WINDOW (WOUTPUT())
        *** Do you want to save chanes befor closing this progrm
        *** Yes, No , Cancel
        lnOption = gfModalGen("QRM00140B00025","ALERT")
        DO CASE
          CASE lnOption = 1
           IF gfCpSave()
             glQuitting = .T.
             RETURN .T.                                     
           ELSE
             RETURN .F.
           ENDIF  
          CASE lnOption = 2
            glQuitting = .T.
            IF !laDefProc[10]
              DO lpClsScr
            ELSE
              IF TYPE("lcBaseFile")='C' AND !EMPTY(lcBaseFile)
                  lnActAls = SELECT(0)
                  SELECT (lcBaseFile)
                  =gfObj_Lock(.F.)   && Unlock the record
                  SELECT (lnActAls )
              ENDIF  
            ENDIF  
            RETURN .T.                                     
          CASE lnOption = 3
            RETURN .F.                             
        ENDCASE
      *** If select or view mode you may quit this program  
      ELSE 
        glQuitting = .T.
        RETURN .T. 
      ENDIF

    *** Closing Base window stoping on window insid it
*   CASE WPARENT(WOUTPUT()) = gcBaseWind
*       glQuitting = .T.
*       RETURN .T. 
    
  ENDCASE        
ELSE
  IF WREAD() 
    *** If the activated window belong to the same read just rearrang the 
    *** window register popup and return back to the same read with a .F.
    *** flag
    IF glCh1stAct .OR. (SUBSTR(WONTOP(),2,2) <> 'WC' .AND. ;
                        SUBSTR(WLAST() ,2,2) <> 'WC')

*!*	      *#IF _DOS 
*!*	      *DO CASE
*!*	      *  *** Comming from child window to base window
*!*	      *  CASE SUBSTR(WLAST(),1,2 ) = 'CW' .AND.;
*!*	      *       SUBSTR(WONTOP(),1,2) <> 'CW' .AND. !glCh1stAct
*!*	      *    lnFromWin = ASCAN(laWndObj,WLAST())
*!*	      *    IF lnFromWin > 0 
*!*	      *      lcFromWObj = laWndObj[ASUBSCRIPT(laWndObj,lnFromWin,1),3]
*!*	      *      SHOW GET &lcFromWObj,1 PROMPT "Close"
*!*	      *    ENDIF  
*!*	*
*!*	*          IF WVISIBLE('GWCCONTRL1')
*!*	      *      IF laScrMode[1] .OR. laScrMode[2]
*!*	      *        SHOW GET pbCls,1  PROMPT "\!\?\<Close" 
*!*	      *      ELSE
*!*	      *        SHOW GET pbCls,1  PROMPT "\?\<Cancel" 
*!*	      *        SHOW GET pbSav,1  PROMPT "\!\<Save"        
*!*	      *      ENDIF  
*!*	      *    ELSE
*!*	      *      SHOW GET pbClose,1 PROMPT "\?\!\<Close"
*!*	      *    ENDIF 
*!*	*

*!*	        *** Comming from child window to another child
*!*	        CASE SUBSTR(WLAST(),1,2 ) = 'CW' .AND.;
*!*	             SUBSTR(WONTOP(),1,2) = 'CW' .AND. !glCh1stAct
*!*	          
*!*	          lnFromWin = ASCAN(laWndObj,WLAST())
*!*	          IF lnFromWin > 0 
*!*	            lcFromWObj = laWndObj[ASUBSCRIPT(laWndObj,lnFromWin,1),3]
*!*	            SHOW GET &lcFromWObj,1 PROMPT "Close"
*!*	          ENDIF  
*!*	            
*!*	          lnToWin = ASCAN(laWndObj,WONTOP())
*!*	          IF lnToWin > 0 
*!*	            lcToWObj = laWndObj[ASUBSCRIPT(laWndObj,lnToWin,1),3]
*!*	            SHOW GET &lcToWObj,1 PROMPT "\!\?Close"
*!*	          ENDIF  


*!*	        *** Going to child window from base window
*!*	        CASE SUBSTR(WONTOP(),1,2) = 'CW' .AND. !glCh1stAct

*!*	          lnToWin = ASCAN(laWndObj,WONTOP())
*!*	          IF lnToWin > 0 
*!*	            lcToWObj = laWndObj[ASUBSCRIPT(laWndObj,lnToWin,1),3]
*!*	            SHOW GET &lcToWObj,1 PROMPT "\!\?Close"
*!*	          ENDIF  

*!*	          IF WVISIBLE('GWCCONTRL1')
*!*	            IF laScrMode[1] .OR. laScrMode[2]
*!*	              SHOW GET pbCls,1  PROMPT "\<Close" 
*!*	            ELSE
*!*	              SHOW GET pbCls,1  PROMPT "\<Cancel" 
*!*	              SHOW GET pbSav,1  PROMPT "\<Save"        
*!*	            ENDIF  
*!*	          ELSE
*!*	            SHOW GET pbClose,1 PROMPT "\<Close"
*!*	          ENDIF 
*!*	      ENDCASE
*!*	      #ENDIF
      =gfWinArng()
    ENDIF

       
    RETURN .F. 
  ELSE

    IF LEFT(UPPER(WONTOP()),8) $ "CALCULATOR/CALENDAR/HELP"
      RETURN .F.
    ENDIF     
    
    *** If the activated window dose not belong to the same read but 
    *** it's in window gcBaseWind return back to the same read
    
    DO CASE
      *CASE WPARENT(WONTOP()) = gcBaseWind
      CASE gfGetWPrnt(WONTOP()) = gcBaseWind
        RETURN .F. 
 
      CASE  WREAD(WPARENT(WONTOP())) OR WPARENT(WPARENT(WONTOP())) = gcBaseWind ;
            OR WPARENT(WONTOP())  = gcBaseWind 
        RETURN .F. 
      OTHERWISE 
        *** If the activated window dose not belong to the same read
        *** Get the current object at this moment and leave the read
        lnCurObj   = _CUROBJ               && Save current object to variable
        =gfStatic() 
        =gfWinArng()
        RETURN .T.
    ENDCASE
  ENDIF  
ENDIF

*!*************************************************************
*! Name      : gfSetup
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To open files and prepare the environment for the current program
*!*************************************************************
*! Calls     : 
*!          Calls: GFSCRINI()               (function  in ARIA3.PRG)
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFSUSRPRG()              (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFSTATIC()               (function  in ARIA3.PRG)
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!          Calls: GFNOCONTRL()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will be called from all the programs activated from the 
* menu or from any other program.
* The main action of this function is to load the initial valus of the 
* vaiables used in the program if called for first time or to restore the
* last valus if reactivating the program window for second time from the 
* static file. In the same time it will do some validation to enter this 
* program or not .
*
*:->
FUNCTION gfSetUp
*E300680,1 MAN Temporary until we convert all screens to MS Font
IF INLIST(SUBSTR(gcBaseWind,4,2),'AP','GL','SM')
  gnPhonSize= LEN(ALLTRIM(gcTelTemp))
  gnDateWdth= IIF('ON'$SET('CENT'),10,8)
ENDIF
*E300680,1 MAN end
*** If Opening this program for first time ether from the menu
*** or called from another program

*E301316,1 [Start]
PRIVATE lcMacroSub
lcMacroSub=""
*E301316,1 [End..]

IF glFirsTime

  gcIniName = STUFF(gcBaseWind,2,1,"W")

  *** Look for window initializ record in static file
  IF SEEK(ALLTRIM('INI'+gcIniName),'syustatc')    
    *** Restore initial data for this Window
    RESTORE FROM MEMO syustatc.mObj_Data  ADDITIVE
    lcBaseWind  = mcBaseWind
    lcWinAppl   = mcWinAppl
    lcScFields  = mcScFields
    lcPop_Name  = mcPop_Name
    lcWindTitl  = mcWindTitl
    lcBaseFile  = mcBaseFile
    lcFile_ttl  = mcFile_ttl
    lcBrFields  = mcBrFields
    lnDataNo    = mnDataNo
    lnBar_no    = mnBar_no
	*- HDM E301176,1 03/21/1999 Re-Store notepad variables[Start]
	lcSydKey    = mcSydKey    
	lcNoteType  = mcNoteType  
	lcNoteKey   = mcNoteKey   
	*- HDM E301176,1 [End]
    
    **MAN No need for array decl. since ACOPY Declares them    
    DECLARE  laData     [lnDataNo]             ,;
             laFld_Msg  [ALEN(maFld_Msg ,1),2] ,;
             laField_H  [ALEN(maField_H ,1),1] ,;
             laField_N  [ALEN(maField_N ,1),1] ,;
             laFileName [ALEN(maFileName,1),2] ,;
             laArrayes  [ALEN(maArrayes ,1),2]

    =ACOPY( maFld_Msg  , laFld_Msg  )
    =ACOPY( maField_H  , laField_H  )
    =ACOPY( maField_N  , laField_N  ) 
    =ACOPY( maFileName , laFileName )
    =ACOPY( maArrayes  , laArrayes  )
 
    *E301297,1 Restore the Event Triggers variables [Begin]
    DIMENSION laEvntTrig[ALEN(maEvntTrig , 1)]
    =ACOPY(maEvntTrig , laEvntTrig)
    *E301297,1 Restore the Event Triggers variables [End]
  ELSE
    *** Make fresh copy of window initializ record
    =gfScrIni()
  ENDIF  

  *** Check if there is any user related initial information related to
  *** this program
  IF llUserSet
    IF SEEK (ALLTRIM('USR'+gcBaseWind+gcUser_Id+gcStation),'syustatc')
      RESTORE FROM MEMO syustatc.mObj_Data  ADDITIVE    
    ENDIF
  ENDIF

  *E000001,1 Hesham (Start)
  DECLARE laTmpFile [ALEN(laFileName,1),4]
  FOR lnFileCount = 1 TO ALEN(laFileName,1)
    laTmpFile[lnFileCount,1] = laFileName[lnFileCount,1]
    laTmpFile[lnFileCount,2] = laFileName[lnFileCount,2]
    laTmpFile[lnFileCount,3] = ''
    laTmpFile[lnFileCount,4] = laFileName[lnFileCount,1]
  ENDFOR
  DECLARE laFileName [ALEN(laTmpFile,1),4]
  =ACOPY(laTmpFile,laFileName)
  *E000001,1 Hesham (End)
  
  *** Load local variable with the base window name
  *** to be saved with all the local variables in this program 
  lcBaseWind = gcBaseWind

  *** Add the program copy number starting from the secound one
  IF gnProgCopy > 1
    lcWindTitl = lcWindTitl+" /"+STR(gnProgCopy,2)
  ENDIF  



*** ymo
*IF gfCkOpnFls()
*  WAIT "CAN NOT OPEN SCREEN" WINDOW
*  glNoLog    = .T.
*  glFirsTime = .F.
*  glQuitting = .T.
*  RETURN .F.
*ENDIF
*** ymo
  
  *** Check if the program is multiuser or single user
  *** and load programs name not workable with in array
  *E301077,78 Hesham (Start)
  llObjctUse=gfSysOpen(gcSysHome+'SYDOBJCT','CAPP_ID')
  *SET ORDER TO TAG CAPP_ID IN SYDOBJCT  
  *E301077,78 Hesham (End)  

  *IF SEEK(gcAct_appl+ALLTRIM(SUBSTR(gcBaseWind,4)),"SYDOBJCT")
  IF SEEK(ALLTRIM(SUBSTR(gcBaseWind,4,2))+ALLTRIM(SUBSTR(gcBaseWind,4)),"SYDOBJCT")
    DECLARE laPrgNames [1]
   *E300693,1 Hesham El_Sheltawi (Start)    
   *E300693,1 restore variables and arrays 
   *E300693,1 for the program default report
    lcReportID = sydObjct.CREP_ID
    IF !EMPTY(sydObjct.MREPFXFLT)
      RESTORE FROM MEMO sydObjct.MREPFXFLT ADDI
    ENDIF
    IF !EMPTY(sydObjct.MREPVRFLT)  
      RESTORE FROM MEMO sydObjct.MREPVRFLT ADDI  
    ENDIF  

    IF !EMPTY(sydObjct.MREPFLTR)  
      RESTORE FROM MEMO sydObjct.MREPFLTR ADDI  
    ENDIF  
   *E300693,1 Hesham El_Sheltawi (End)
    
    llSusrPrg  = SYDOBJCT.lSingUsr
    llMultiRun = glMultiRun .AND. SYDOBJCT.lMultinst 
    laPrgNames = ' '
    = gfSubStr(SYDOBJCT.mPrgNames,@laPrgNames,'|')    
    *C101459,1 Hesham (Start)
    *B603273,1[START] Also check that lcBaseFile is not empty
    *IF TYPE('laUsrFields')#'U'
    IF TYPE('laUsrFields')#'U' AND TYPE('lcBaseFile') = 'C' AND !EMPTY(lcBaseFile)
    *B603273,1[END]
      llSysFlFld=gfSysOpen(gcSysHome+'SYDFLFLD')
      llSysField=gfSysOpen(gcSysHome+'SYDFIELD')
      *B604087,1 (Begin) Sort custom fields by thier positions.
      *SELECT SYDFLFLD.CFLD_NAME,'F',SYDFIELD.CDATA_TYP,;
             .T.,'Like','','V',PADR(MVALD_STR,160),CFLD_HEAD;
             FROM SYDFLFLD,SYDFIELD;
             WHERE SYDFLFLD.CFILE_NAM = PADR(UPPER(lcBaseFile),8);
             AND   SYDFLFLD.CFLD_NAME=SYDFIELD.CFLD_NAME;
             AND   SYDFIELD.CUPGRDLVL='U';
             INTO ARRAY laUsrFields
      *B606478,1 ABD - Any field starts with UI_ is an uninstall field and 
      *B606478,1 ABD - Shouldn't appear in the user defined fields list. [Begin]
      *SELECT SYDFLFLD.CFLD_NAME,'F',SYDFIELD.CDATA_TYP,;
             .T.,'Like','','V',PADR(MVALD_STR,160),CFLD_HEAD;
             FROM SYDFLFLD,SYDFIELD;
             WHERE SYDFLFLD.CFILE_NAM = PADR(UPPER(lcBaseFile),8);
             AND   SYDFLFLD.CFLD_NAME=SYDFIELD.CFLD_NAME;
             AND   SYDFIELD.CUPGRDLVL='U';
             INTO ARRAY laUsrFields;
             ORDER BY SYDFLFLD.NFLD_POS
             
      SELECT SYDFLFLD.CFLD_NAME,'F',SYDFIELD.CDATA_TYP,;
             .T.,'Like','','V',PADR(MVALD_STR,160),CFLD_HEAD;
             FROM SYDFLFLD,SYDFIELD;
             WHERE SYDFLFLD.CFILE_NAM = PADR(UPPER(lcBaseFile),8);
             AND   SYDFLFLD.CFLD_NAME=SYDFIELD.CFLD_NAME;
             AND   SYDFIELD.CUPGRDLVL='U';
             AND   LEFT(SYDFIELD.CFLD_NAME,3) #'UI_';
             INTO ARRAY laUsrFields;
             ORDER BY SYDFLFLD.NFLD_POS
      *B606478,1 ABD - [End]
      *B604087,1 (End)

      USE IN (IIF(llSysFlFld,'SYDFLFLD',0))
      USE IN (IIF(llSysField,'SYDField',0))
    ENDIF
    *C101459,1 Hesham (End)

    *** Check if the program is Single user
    IF llSusrPrg
      IF !gfSUsrPrg(ALLTRIM(SUBSTR(gcBaseWind,4)))
        glNoLog    = .T.
        glFirsTime = .F.
        glQuitting = .T.
       *E301077,78 Hesham (Start)
       USE IN IIF(llObjctUse,'SYDOBJCT',0)
       *E301077,78 Hesham (End)  
        RETURN .F.
      ENDIF  
    ENDIF

    *** Check if any of non workable with programs are activ
    IF !EMPTY(laPrgNames[1])
      FOR lnCountp = 1 TO ALEN(laPrgNames,1)
        lcPrgWind  = LOOKUP(sydobjct.cbasewind,laPrgNames[lnCountp],;
                     sydobjct.capobjnam)

        lcPrgWind  = STUFF(lcPrgWind,2,1,"A")

 
        IF SEEK('WIN'+lcPrgWind,'SYUSTATC')  .AND. ;
                SYUSTATC.ccomp_id = gcAct_comp
          lcUser    = syuStatc.cUser_ID        
          lcStion   = syuStatc.cStation

        
          lcPrglName = LOOKUP(sydObjct.cPrgLName,laPrgNames[lnCountp];
                      ,sydObjct.cApObjNam)
      
          IF lcUser = gcUser_Id .AND. lcStion = gcStation
            =gfModalGen('TRM00093B00000','ALERT',PROPER(lcPrglName))
            glNoLog    = .T.
            glFirsTime = .F.
            glQuitting = .T.
            *E301077,78 Hesham (Start)
            USE IN IIF(llObjctUse,'SYDOBJCT',0)
            *E301077,78 Hesham (End)  
            RETURN .F.
          ELSE
            IF SEEK ('INI'+'OLDVARS'+lcUser+lcStion,'SYUSTATC')
              lcOldRep = SET('REPROCESS')
              SET REPROCESS TO 1
              IF RLOCK('SYUSTATC')
                UNLOCK IN ALIAS('SYUSTATC')
                GO gnMyStRec IN SYUSTATC
                =RLOCK('SYUSTATC')
                SET REPROCESS TO lcOldRep
              ELSE
               =gfModalGen('TRM00094B00000','ALERT',lcPrglName+'|'+;
               ALLTRIM(LOOKUP(syuUser.cUsr_Name,lcUser,syuUser.cUser_id,"CUSER_ID")))
                SET REPROCESS TO lcOldRep
                glNoLog    = .T.
                glFirsTime = .F.
                glQuitting = .T.
                *E301077,78 Hesham (Start)
                USE IN IIF(llObjctUse,'SYDOBJCT',0)
                *E301077,78 Hesham (End)  
                RETURN .F.
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDFOR
    ENDIF  
  ENDIF
  *E301077,78 Hesham (Start)
  USE IN IIF(llObjctUse,'SYDOBJCT',0)
  *E301077,78 Hesham (End)  

  *** Disable bar line of this window
  IF !llMultiRun
    IF lnBar_No > 0  .AND. !EMPTY(lcPop_Name)
      SET SKIP OF BAR (lnBar_No) OF (lcPop_Name) .T.
    ENDIF  
  ENDIF  

  *** Resize the laData array
*E300252,1 We had already defined laData so why again
*  DIMENSION laData [lnDataNo] 
  laData = ' '

  *** Check if all files used in this program is opend
  IF !EMPTY(laFileName[1,1])
    lcOldExact = SET('EXACT')
    SET EXACT ON
    
    *E300999,1 Hesham (Start)
    *E300999,1 Add the local file array to the global so if
    *E300999,1 any file could not be opened and the file was used
    *E300999,1 by another program the file will not be closed
    FOR lnCount = 1 TO ALEN(laFileName,1)    
      lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
      IF lnFileElm > 0 
        lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
        gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
      ELSE
        DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
        =AINS(gaMnu_Fl,1)
        gaMnu_Fl[1,1] = laFileName[lnCount,1]
        gaMnu_Fl[1,2] = laFileName[lnCount,2]
        gaMnu_Fl[1,3] = SELECT(0)
*        gaMnu_Fl[1,4] = IIF(USED(laFileName[lnCount,1]),2,1)
*        gaMnu_Fl[1,5] = "P"
        gaMnu_Fl[1,4] = 1
        gaMnu_Fl[1,5] = IIF(USED(laFileName[lnCount,1]),'S','P')
        gaMnu_Fl[1,6] = " "
      ENDIF
    ENDFOR
    *E300999,1 Hesham (End)    
    FOR lnCount = 1 TO ALEN(laFileName,1)

      IF  !USED(laFileName[lnCount,1])
        SELECT 0
        *E000001,1 Hesham (Start)
        *lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                     gcSysHome,gcDataDir)        
        IF EMPTY(laFileName[lnCount,3])
          lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                       gcSysHome,gcDataDir)
  	      *E301316,1 [Start]
  	      *USE (lcPath+laFileName[lnCount,1])
          *C121114,3  TMI [Start] Add Again Cluse
          *lcMacroSub="USE (lcPath+laFileName[lnCount,1])"
          lcMacroSub="USE (lcPath+laFileName[lnCount,1]) AGAIN"
          *C121114,3  TMI [End  ] 
          &lcMacroSub
          *E301316,1 [End..]
        ELSE
          *E301316,1 [Start]
          *USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1])
          lcMacroSub="USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1])"
          &lcMacroSub
          *E301316,1 [End..]
        ENDIF  
        *E000001,1 Hesham (End)
        IF !EMPTY(laFileName[lnCount,2])
          SET ORDER TO TAG (laFileName[lnCount,2])
        ENDIF  
        *E300999,1 Comment out this part, It is included in the outer loop
        *lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
        *IF lnFileElm > 0 
        *  lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
        *  gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
        *ELSE
        *  DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
        *  =AINS(gaMnu_Fl,1)
        *  gaMnu_Fl[1,1] = laFileName[lnCount,1]
        *  gaMnu_Fl[1,2] = laFileName[lnCount,2]
        *  gaMnu_Fl[1,3] = SELECT(0)
        *  gaMnu_Fl[1,4] = 1
        *  gaMnu_Fl[1,5] = "P"
        *  gaMnu_Fl[1,6] = " "
        *ENDIF
        *E300999,1 end
      ELSE
        *E300999,1 Hesham (Start)      
        *E300999,1 Do not add the local files to the global array
        *E300999,1 because it was added before
        lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
	    *IF lnFileElm > 0 
	    *  lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
 	    *  gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
	    *ENDIF
        *E300999,1 Hesham (End)
        *E300999,1 Hesham (Start)
        *E300999,1 Check if the file is opened before changing the tag
        IF !USED(laFileName[lnCount,1])
        *E000001,1 Hesham (Start)
        *lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                     gcSysHome,gcDataDir)        
        IF EMPTY(laFileName[lnCount,3])
          lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                       gcSysHome,gcDataDir)
          *E301316,1 [Start]
          *USE (lcPath+laFileName[lnCount,1])
          *C121114,3  TMI [Start] Add Again Cluse
          *lcMacroSub="USE (lcPath+laFileName[lnCount,1])"
          lcMacroSub="USE (lcPath+laFileName[lnCount,1]) AGAIN"
          *C121114,3  TMI [End  ] 
          &lcMacroSub
          *E301316,1 [End..]
        ELSE
          *E301316,1 [Start]
          *USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1])
          lcMacroSub="USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1])"
          &lcMacroSub
          *E301316,1 [End..]
        ENDIF  
        *E000001,1 Hesham (End)
        ENDIF  
        *E300999,1 Hesham (End)
        IF !EMPTY(laFileName[lnCount,2])
          SET ORDER TO TAG (laFileName[lnCount,2]) IN (laFileName[lnCount,1])
        ENDIF  
        
      ENDIF
      *** IF one error occered there is no resone to contenu with others
      IF glErrOccur 
        SET EXACT &lcOldExact 

        glErrOccur = .F.
        glFirsTime = .F.
        glQuitting = .T.
        RETURN .F.
      ENDIF  

    ENDFOR
    SET EXACT &lcOldExact 
   
  ENDIF

  *C101459,1 Hesham (Start)
  *MAN
  *IF TYPE('laUsrFields')#'U'
  IF TYPE('laUsrFields')#'U' AND TYPE('lcBaseFile')#'U' AND !EMPTY(lcBaseFile)
    SELECT (lcBaseFile)
    lnDeleted = 0
    FOR lnUsrFld = 1 TO ALEN(laUsrFields,1)
      *Ren
      *IF TYPE(laUsrFields[lnUsrFld-lnDeleted,1])='U'
      IF TYPE('laUsrFields[lnUsrFld-lnDeleted,1]')='U'
        =gfAdel(@laUsrFields,lnUsrFld-lnDeleted)
        lnDeleted = lnDeleted + 1
      ENDIF
    ENDFOR  
  ENDIF
  *C101459,1 Hesham (End)

  *** Check if user has ADD EDIT DELETE privelage in this program
  lcPross_ID =UPPER(SUBSTR(gcBaseWind,4)) 

  *** Check if the user Admin or operator to get the ADD/EDIT/DELETE
  *** Rights for the current user in current compant and Cerrunt module
  IF glLog_Requ
    *E301077,78 Hesham (Start)
    llUsrPrv=gfSysOpen(gcSysHome+"SYUUSRPR",'CUSER_ID')
    *E301077,78 Hesham (End)
    SELECT SYUUSRPR
    SET ORDER TO TAG cUser_ID
    *E300709,1 Hesham (Start)
    *E300709,1 make the system check for the program if define to 
    *E300709,1 main system get the program priv.
*    IF SEEK(ALLTRIM(gcUser_ID)+gcAct_Appl+gcAct_Comp+lcPross_ID)
    IF SEEK(ALLTRIM(gcUser_ID)+gcAct_Appl+gcAct_Comp+lcPross_ID) OR SEEK(ALLTRIM(gcUser_ID)+'SY'+gcAct_Comp+lcPross_ID)
    *E300709,1 Hesham (End)    
      llAddRec   = SYUUSRPR.lAddRec   
      llEditRec  = SYUUSRPR.lEditRec
      llDeleRec  = SYUUSRPR.lDeleRec
      IF !EMPTY(SYUUSRPR.mSubProc)
        =gfSubStr(SYUUSRPR.mSubProc,@laSubProc,"|")
      ENDIF

    *** Check if the user is a member of any groups that have access
    *** for Add/Edit/Delete in this program 
    ELSE
      IF SEEK(ALLTRIM(gcUser_Grp)+gcAct_Appl+gcAct_Comp+lcPross_ID) OR SEEK(ALLTRIM(gcUser_Grp)+'SY'+gcAct_Comp+lcPross_ID)
        llAddRec   = SYUUSRPR.lAddRec   
        llEditRec  = SYUUSRPR.lEditRec
        llDeleRec  = SYUUSRPR.lDeleRec
      
        IF !EMPTY(SYUUSRPR.mSubProc)
          =gfSubStr(SYUUSRPR.mSubProc,@laSubProc,"|")
        ENDIF

      ENDIF  
    ENDIF
    *E301077,78 Hesham (Start)
    IF llUsrPrv
      USE IN SYUUSRPR
    ENDIF
    *E301077,78 Hesham (End)
  *** This user is admen give hime every thing
  ELSE
    STORE .T. TO llAddRec,llEditRec,llDeleRec           
  ENDIF    

*** Screen opend for the second time or resoring from last session
*******************************************************************
ELSE 
  *** Check if the window old data still there 
  IF SEEK (ALLTRIM('WIN'+gcBaseWind+gcUser_Id+gcStation),'syustatc')
          *** Restore data for this window
    RESTORE FROM MEMO syustatc.mObj_Data  ADDITIVE
  ELSE
    *** Record was deleted from static file for any reason 
    *** data was lost. give the user option to restart session or terminat
    wait "Record was deleted from static file ,data was lost" window 
    glQuitting = .T.
    RETURN .F.
  ENDIF  
  
  *E301077,1 Hesham (Start)
  *E301077,1 Add the local file array to the global so if
  *E301077,1 any file could not be opened and the file was used
  *E301077,1 by another program the file will not be closed
  FOR lnCount = 1 TO ALEN(laFileName,1)    
    lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
    IF lnFileElm > 0 
      lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
      gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
    ELSE
      DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
      =AINS(gaMnu_Fl,1)
      gaMnu_Fl[1,1] = laFileName[lnCount,1]
      gaMnu_Fl[1,2] = laFileName[lnCount,2]
      gaMnu_Fl[1,3] = SELECT(0)
      gaMnu_Fl[1,4] = 1
      gaMnu_Fl[1,5] = "P"
      gaMnu_Fl[1,6] = " "
    ENDIF
  ENDFOR
  *E301077,1 Hesham (End)    

  *** We have to recheck the right tages for all opend files for this program
  IF !EMPTY(laFileName[1,1])
    FOR lnCount = 1 TO ALEN(laFileName,1)
      *E300999,1 Hesham (Start)
      *E300999,1 Check if the file is opened before changing the tag
      IF !USED(laFileName[lnCount,1])
        *E000001,1 Hesham (Start)
        *lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                     gcSysHome,gcDataDir)        
        IF EMPTY(laFileName[lnCount,3])
          lcPath = IIF(UPPER(LEFT(laFileName[lnCount,1],2))='SY',;
                       gcSysHome,gcDataDir)
          *E301316,1 [Start]
          *USE (lcPath+laFileName[lnCount,1]) IN 0
          *C121114,3  TMI [Start] Add Again Cluse
          *lcMacroSub="USE (lcPath+laFileName[lnCount,1]) IN 0"
          lcMacroSub="USE (lcPath+laFileName[lnCount,1]) AGAIN IN 0"
          *C121114,3  TMI [End  ] 
          &lcMacroSub 
          *E301316,1 [End..]
        ELSE
          *E301316,1 [Start]
          *USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1]) IN 0
          lcMacroSub="USE (laFileName[lnCount,3]) AGAIN ALIAS (laFileName[lnCount,1]) IN 0"
          &lcMacroSub 
          *E301316,1 [End..]
        ENDIF  
        *E000001,1 Hesham (Start)
      ENDIF  
      *E300999,1 Hesham (End)
      IF !EMPTY(laFileName[lnCount,2])
        SET ORDER TO TAG (laFileName[lnCount,2]) IN (laFileName[lnCount,1])
      ENDIF  
    ENDFOR
  ENDIF  

ENDIF


*E300279,1  SET Help Topic to the related one in the menu file.
=gfHlpTopic(lcPop_Name,lnBar_no)

***************************************************************************
*** To be done in both cases first time and reactivate
***************************************************************************

*** Check if custum pad have to be defined 
* IF !EMPTY(laCustPad[1])
*   FOR lnPadArry = 1 TO ALEN(laCustPad,1) 
*     &laCustPad[lnPadArry]    && Do command saved in the array
*   ENDFOR
* ENDIF


*** Select the program base file and go to last record or top
IF !EMPTY(lcBaseFile)

  SELECT (lcBaseFile)

  IF glFirsTime
    GO TOP
  ELSE 
    IF lnRecNo <= RECCOUNT()
      GO lnRecNo
    ENDIF  

  ENDIF

ENDIF


*** Actions to be done in case of first time or restoring from last
*** login 
IF glFirsTime  .OR. glRestore
  glFirsTime = .F.
  *** Creat temp record for this program
  =gfStatic()

  
  *** Update Dinamic Windows Array 
  IF !EMPTY(gaAct_Wind[1,1])
    DIMENSION gaAct_Wind [ALEN(gaAct_Wind,1)+1,4]
    =AINS(gaAct_Wind,1)
  ENDIF  

  gaAct_wind [1,1] = UPPER(gcBaseWind) && Window name
  gaAct_wind [1,2] = gcWinAppl         && Window source module
  gaAct_wind [1,3] = ''                && Window home window
  gaAct_wind [1,4] = lcWindTitl        && Window long name
  =gfWinArng(gcBaseWind)
ENDIF


*** Check if controll is used with this program and release it if not
IF llNoContrl
  =gfNoContrl()
ENDIF

*E301469,1 AMH Not Alow Adding , editing or deleting for History Company [Start]
*** Check if the current company is a History company
IF !EMPTY(gcAct_Comp) .AND. gfGetMemVar('LLHIST',gcAct_Comp)
  llAddRec   = .F.
  llEditRec  = .F.
  llDeleRec  = .F.
ENDIF
*E301469,1 AMH [End]
*-- end of gfSetup.

*!*************************************************************
*! Name      : gfScrInI 
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To build the initial record for any program
*!*************************************************************
*! Calls     : 
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GFBLDSTATC()             (function  in ARIA3.PRG)
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFDBFFIELD()             (function  in ARIA3.PRG)
*!          Calls: GFADD_INFO()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*   These variables have to be loaded with initial valus:
*
*   lcBaseWind = Program base window name
*   lcPop_Name = Popup name from which the program activated
*   lcScFields = Fields names to be scatterd and gatherd
*   lcBaseFile = Base files name to be selected upon activation 
*   lcBrFields = Fields to be browsd and filerd
*   lcFile_ttl = File title to be used in the browse window
*   lcWindTitl = Window title and program long name in the same time
*   lnBar_No   = Bar No. from which the program activated
*   lnDataNo   = Dimention of the laData array used in the program
*   laFld_msg  = Array to hold all objects messages to be displayed
*   laFileName = Array to hold all files have to be opend in this program
*   laField_H  = Array to hold fileds long name according to lcBrFields
*   laField_N  = Array to hold fileds phisical name according to lcBrFields
*   laCustPad  = Array to hold commands to define custum pad to this program
*
*   Files used in this function to collect data from :
*  
*   sycMenu .DBF
*   sydScObj.DBF
*   sydFiles.DBF
*   sydField.DBF
*   sydFlFld.DBF
*
*   Target file is syuStatc.DBF
********************************************************************************
*B602347,1 MAB 12/14/98  Adjust code of this function to be as faster as possible 
*B602347,1               in case of calling screen does not have base file.
********************************************************************************
*
FUNCTION gfScrIni
PRIVATE gnArrayln
EXTERNAL ARRAY laFileName,laFld_msg 

*** Check if all files used are opend
STORE .F. TO glOpnMenu,glOpnScObj,glOpnFiles,glOpnField,glOpnFlFld,glOpnObjct
STORE  0  TO gnOrdMenu,gnOrdScObj,gnOrdFiles,gnOrdField,gnOrdFlFld,gnOrdObjct


IF USED('sycMenu')
  SELECT sycMenu
  gnOrdMenu = INT(VAL(SYS(21)))
ELSE
  glOpnMenu = .T.
  SELECT 0
  USE (gcSysHome+"sycMenu") 
ENDIF  

SET ORDER TO TAG PROSS_ID

IF USED('sydScObj')
  SELECT sydScObj
  gnOrdScObj = INT(VAL(SYS(21)))
  SET ORDER TO TAG CSCRNAM IN ALIAS('sydScObj')
ELSE
  glOpnScObj = .T.
  SELECT 0
  USE (gcSysHome+"sydScObj") ORDER TAG CSCRNAM
ENDIF  

IF USED('sydFiles')
  SELECT sydFiles
  gnOrdFiles = INT(VAL(SYS(21)))
  SET ORDER TO 1 IN ALIAS('sydFiles')
ELSE
  glOpnFiles = .T.
  SELECT 0
  USE (gcSysHome+"sydFiles") ORDER 1
ENDIF  

IF USED('sydField')
  SELECT sydField 
  gnOrdField = INT(VAL(SYS(21)))
  SET ORDER TO 1 IN ALIAS('sydField')
ELSE
  glOpnField  = .T. 
  SELECT 0
  USE (gcSysHome+"sydField") ORDER 1
ENDIF  

IF USED('sydFlFld')
  SELECT sydFlFld
  gnOrdFlFld = INT(VAL(SYS(21)))
  SET ORDER TO 1 IN ALIAS('sydFlFld')
ELSE
  glOpnFlFld = .T.
  SELECT 0
  USE (gcSysHome+"sydFlFld") ORDER 1
ENDIF  

IF USED('sydObjct')
  SELECT sydObjct
  gnOrdObjct = INT(VAL(SYS(21)))
ELSE
  glOpnObjct = .T.
  SELECT 0
  USE (gcSysHome+"sydObjct") 
ENDIF  

DECLARE  laFld_Msg [1,2],laField_H [1,1],laField_N [1,1],laFileName [1,2],laArrayes[1,2]

laFld_Msg   = " " 
laField_H   = " "
laField_N   = " "
laFileName  = " "
laArrayes   = " "

*E301297,1 Define some new variables for the Object/Events triggers system,
*          a new array for the Event/Triggers system, this array will hold
*          the names of events that has one or more triggers to be executed
*          with for the current program [Begin]
DIMENSION laEvntTrig[1,1]
laEvntTrig = ''

*--  Flag to know if we are going to close the Trigger file (SYCTRIGG) or not
PRIVATE llClosTrig
llClosTrig = !USED('SYCTRIGG')

*-- Get the names of the events that has one or more triggers to be executed
*-- with for the current program
SELECT cEvent_ID;
  FROM (gcSysHome + 'SYCTRIGG');
 WHERE cApObjNam + cEvent_ID + STR(nTrigOrder,3) = PADR(lcProgName , 10);
 GROUP BY cEvent_ID;
  INTO ARRAY laEvntTrig

*-- Prepare the variables that will be saved in the INI Static record
=ACOPY(laEvntTrig , maEvntTrig)

*-- Close the trigger file if necessary
IF llClosTrig .AND. USED('SYCTRIGG')
  USE IN SYCTRIGG
ENDIF    && End of IF llClosTrig .AND. USED('SYCTRIGG')
*E301297,1 Define some new variables for the Object/Events triggers [End]

lcBaseWind  = " "
lcWinAppl   = " "
lcScFields  = " " 
lcPop_Name  = " "
lcWindTitl  = " "
lcBaseFile  = " "
lcFile_ttl  = " "
lcBrFields  = " "

*- HDM E301176,1 [Start] 03/21/1999 Define Notepad Variables
*-               To be used while calling NotePad Program
lcSydKey    = " "
lcNoteType  = " "
lcNoteKey   = " "
*- HDM E301176,1 [End]

lnDataNo    = 1
lnBar_no    = 0

*** Load variable with the program base window name to be used in case
*** of cleanup or stop read
lcBaseWind = gcBaseWind
lcWinAppl  = gcWinAppl


*** Load variables with popup name and bar no. from which the
*** program is activated
*B601024,1 (S) Change the technique for getting the bar number and pop name
*IF SEEK(SUBSTR(gcBaseWind,4),'sycMenu')
*B601024,1  Get the current Alias
lcOldAlias = ALIAS()
*B601024,1  Select the menu file
SELECT SYCMENU
*B601024,1  Locate for the menu option
LOCATE FOR CPross_ID = SUBSTR(gcBaseWind,4) .AND. cProcType = "P"
IF FOUND()
*B601024,1 (F) Change the technique for getting the bar number and pop name
  lcPop_Name = ALLTRIM(sycMenu.cMstr_nam)
  lnBar_No   = INT(VAL(sycMenu.cBar_pos))
ENDIF   

*B601024,1  Return to the previous Alias
SELECT &lcOldAlias
       
**MAN What is the semicolon doing in the end of the select
*** Load an Array with objects' messages
SELECT DISTINCT cScObjNam,cScObjMsg  FROM (gcSysHome+"sydscobj");
      WHERE !EMPTY(cScObjNam)   .AND.;
            !EMPTY(cScObjMsg)   .AND.;
            VAL(cScObjNum) <> 0 .AND.;                
            ((CSCRNAM+CSCOBJTYP = gcIniName) .OR.;
            (CSCRNAM+CSCOBJTYP ='GWCCONTRL1')) ;
       INTO ARRAY laFld_msg;

FOR gnMsg = 1 TO ALEN(laFld_msg,1)
  laFld_msg[gnMsg,1] = ALLTRIM(laFld_msg[gnMsg,1])
ENDFOR  

RELEASE gnMsg

*** Load variable with window titel
SELECT SYDOBJCT
SET ORDER TO TAG CAPOBJNAM

IF SEEK (SUBSTR(gcBaseWind,4))
  *** Load program logical name
  lcWindTitl = ALLTRIM(cPrgLName)

  *** Load program base file 
  lcBaseFile = ALLTRIM(sydObjct.cBaseFile)

  *** Load array with all program files to be open
  =gfSubStr(sydObjct.mPrgFiles,@laFileName,",|")

  *B602347,1 Execute the following code between if not empty of base file block, 
  *B602347,1 to avoid doing unrequired code if there is no base file  
  IF !EMPTY(lcBaseFile)
  *B602347,1 end 

    *** Get the base file long name
    lcFile_ttl = PROPER(ALLTRIM(LOOKUP(sydFiles.cFile_ttl,lcBaseFile,;
                 sydFiles.cFile_Nam)))

    *- HDM E301176,1 03/21/1999 [Start] Collect Notepad Key Information From SydFiles.DBF
    IF !EMPTY(SYDFILES.cNoteKey)
      lcSydKey = sydFiles.cNoteKey
    ENDIF 
    *- HDM E301176,1 03/21/1999 [End]

    *** Load variable with browse fields string 
    lcBrFields = gfDbfField(lcBaseFile)

  *B602347,1 else, store '' to file title and browse fields variables. 
  ELSE
    STORE '' TO lcFile_Ttl, lcBrFields
  ENDIF  
  *B602347,1 end 

ELSE
  lcWindTitl = PROPER(SUBSTR(gcBaseWind,4))
ENDIF

*** Load 2 arraies with the logical and phisical fields name 
*** According to the lcBrFields variable content to be used in both 
*** browse and filter

*B602347,1 Add the following if condition to save more memory and faster code if the 
*B602347,1 calling screen does not have base file.
IF !EMPTY(lcBaseFile)
*B602347,1 end

  DIMENSION gaTmpArray[1,3]
  gaTmpArray = ' '

  IF !EMPTY(lcBrFields)
    **MAN Instead of SYDFLFLD.CFLD_NAME Put SYDFLFLD.CFLD_NAME+STR(SYDFLFLD.NFLD_POS)
    *B600750,1 the where condition sydflfld.cfile_name = lcBaseFile changed to
    *B600750,1 sydflfld.cfile_name == lcBaseFile 
    SELECT DIST SYDFIELD.CFLD_NAME, SYDFIELD.cfld_head, SYDFLFLD.NFLD_POS;
         FROM SYDFLFLD, SYDFIELD;
        WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME  .AND. ;
              sydflfld.cfile_nam == lcBaseFile          .AND. ;
              ALLTRIM(sydfield.cfld_name) $  lcBrFields ;
     ORDER BY SYDFLFLD.NFLD_POS;
     INTO ARRAY gaTmpArray

    **MAN Instead of SYDFLFLD.CFLD_NAME Put SYDFLFLD.CFLD_NAME+STR(SYDFLFLD.NFLD_POS)
    *B609556,1 TMI 03/24/2011 [Start] do not select the fields duplicated
    *SELECT SYDFIELD.CFLD_NAME,SPACE(10) ;
      FROM SYDFLFLD, SYDFIELD;
     WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME   .AND. ;
           sydflfld.cfile_nam == lcBaseFile           .AND. ;
           ALLTRIM(sydfield.cfld_name) $  lcBrFields .AND.;
           !EMPTY (sydfield.mventries) ;
     INTO ARRAY laArrayes
    SELECT DIST SYDFIELD.CFLD_NAME,SPACE(10) ;
      FROM SYDFLFLD, SYDFIELD;
     WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME   .AND. ;
           sydflfld.cfile_nam == lcBaseFile           .AND. ;
           ALLTRIM(sydfield.cfld_name) $  lcBrFields .AND.;
           !EMPTY (sydfield.mventries) ;
     INTO ARRAY laArrayes
     *B609556,1 TMI 03/24/2011 [End  ] 

  ELSE

    **MAN Instead of SYDFLFLD.CFLD_NAME Put SYDFLFLD.CFLD_NAME+STR(SYDFLFLD.NFLD_POS)
    *B600750,1 the where condition sydflfld.cfile_name = lcBaseFile changed to
    *B600750,1 sydflfld.cfile_name == lcBaseFile   
     SELECT DIST SYDFIELD.CFLD_NAME, SYDFIELD.cfld_head, SYDFLFLD.NFLD_POS;
         FROM SYDFLFLD, SYDFIELD;
        WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME  .AND. ;
                sydflfld.cfile_nam == lcBaseFile                ;
       ORDER BY SYDFLFLD.NFLD_POS;
       INTO ARRAY gaTmpArray

       *B609556,1 TMI 03/24/2011 [Start] do not select the fields duplicated
       *SELECT SYDFIELD.CFLD_NAME,SPACE(10) ;
           FROM SYDFLFLD, SYDFIELD;
          WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME  .AND. ;
                sydflfld.cfile_nam = lcBaseFile          .AND. ;
                !EMPTY (sydfield.mventries) ;
           INTO ARRAY laArrayes
       SELECT DIST SYDFIELD.CFLD_NAME,SPACE(10) ;
           FROM SYDFLFLD, SYDFIELD;
          WHERE SYDFIELD.CFLD_NAME = SYDFLFLD.CFLD_NAME  .AND. ;
                sydflfld.cfile_nam = lcBaseFile          .AND. ;
                !EMPTY (sydfield.mventries) ;
           INTO ARRAY laArrayes
       *B609556,1 TMI 03/24/2011 [End  ] 

  ENDIF

  gnArrayln = ALEN(gaTmpArray,1)

  DECLARE laField_H [gnArrayln,1] ,laField_N [gnArrayln,1]
  
  FOR lnElem = 1 TO gnArrayln
    laField_N[lnElem,1] = ALLTRIM(gaTmpArray[lnElem,1])
  
    laField_H[lnElem,1] = IIF(EMPTY(gaTmpArray[lnElem,2]),;
                  ALLTRIM(gaTmpArray[lnElem,1]),ALLTRIM(gaTmpArray[lnElem,2]))
  ENDFOR

  RELEASE gaTmpArray,gnArrayln

  IF !EMPTY(laArrayes[1,1])
    FOR lnNewAry = 1 TO ALEN(laArrayes,1)
      laArrayes[lnNewAry,2]  = "la"+PROPER(SUBSTR(SYS(2015),3,8))

      IF AT(laArrayes[lnNewAry,1],lcBrFields)>0
        lcAscanStr = 'cDummi'+ALLTRIM(STR(lnNewAry))+'=IIF(ASCAN(&laArrayes[lnNewAry,2],&laArrayes[lnNewAry,1])>0,&laArrayes[lnNewAry,2] [ASUBS(&laArrayes[lnNewAry,2],ASCAN(&laArrayes[lnNewAry,2],&laArrayes[lnNewAry,1]),1),1]," ")'
        lcBrFields = STRTRAN(lcBrFields ,laArrayes[lnNewAry,1],lcAscanStr)
      ENDIF 
    ENDFOR
  ENDIF

*B602347,1 Add an EndIf end if we have a base file 
ENDIF  
*B602347,1 end 

*'dummi=IIF(ASCAN(&laArrayes[1,2],cDlobjTyp)>0,&laArrayes[1,2] [ASUBS(&laArrayes[1,2],ASCAN(&laArrayes[1,2],cdlobjtyp),1),1]," ")'


*** Load string with screen display fields
*** To be modified : Array may not start with 1, Array may not be in sequance
SELECT sydScObj
SET ORDER TO TAG CSCRNAMNUM     && CSCRNAM+CARYELM

IF SEEK(gcIniName+' 1','sydScObj')
  lcScFields = ''
  lnDataNo   = 0
  
  SCAN REST WHILE cScrNam=gcIniName .AND. cScObjTyp='FD'
    lcScFields = lcScFields+IIF(EMPTY(lcScFields),'',',')+;
       IIF(ALLTRIM(cflalias)=ALLTRIM(lcBaseFile),'',ALLTRIM(cflalias)+'.');
        +ALLTRIM(cFld_name)
    lnDataNo = lnDataNo + 1
  ENDSCAN

  lnDataNo = IIF(lnDataNo = 0 , 1 , lnDataNo )
  DECLARE  laData [lnDataNo]
ENDIF
           

*** Serch for empty deleted record to be reuse
SELECT syuStatc

SET DELETE OFF

IF SEEK(' ')                           && Check if any deleted records
  IF RLOCK()
    RECALL                               && Use it again
  ELSE
    APPEND BLANK
  ENDIF  
ELSE  
  APPEND BLANK                         && If there isn't, open new one
ENDIF

SET DELETE ON

REPLACE syuStatc.cObj_typ    WITH 'INI';
        syuStatc.cObj_Name   WITH gcIniName;
        syuStatc.lKeep_It    WITH .T.  

=gfAdd_info('SYUSTATC') 
 

mcBaseWind  = lcBaseWind
mcWinAppl   = lcWinAppl
mcScFields  = lcScFields
mcPop_Name  = lcPop_Name
mcWindTitl  = lcWindTitl
mcBaseFile  = lcBaseFile
mcFile_ttl  = lcFile_ttl
mcBrFields  = lcBrFields
mnDataNo    = lnDataNo
mnBar_no    = lnBar_no

*- HDM E301176,1 03/21/1999 [Start]
*-     Prepare Varialbles that used in Notepad Calling to be saved
*-     in Static File

mcSydKey    = lcSydKey
mcNoteType  = lcNoteType
mcNoteKey   = lcNoteKey

*- HDM E301176,1 03/21/1999 [End]


DECLARE  maFld_Msg  [IIF(ALEN(laFld_Msg ,1) > 0 ,ALEN(laFld_Msg ,1),1),2] ,;
         maField_H  [IIF(ALEN(laField_H ,1) > 0 ,ALEN(laField_H ,1),1),1] ,;
         maField_N  [IIF(ALEN(laField_N ,1) > 0 ,ALEN(laField_N ,1),1),1] 

DECLARE  maFileName [IIF(ALEN(laFileName,1) > 0 ,ALEN(laFileName,1),1),2] ,;
         maArrayes  [IIF(ALEN(laArrayes ,1) > 0 ,ALEN(laArrayes ,1),1),2]


=IIF(ALEN(laFld_Msg ,1) > 0 , ACOPY( laFld_Msg  , maFld_Msg  ),'')
=IIF(ALEN(laField_H ,1) > 0 , ACOPY( laField_H  , maField_H  ),'')
=IIF(ALEN(laField_N ,1) > 0 , ACOPY( laField_N  , maField_N  ),'') 
=IIF(ALEN(laFileName,1) > 0 , ACOPY( laFileName , maFileName ),'')
=IIF(ALEN(laArrayes ,1) > 0 , ACOPY( laArrayes  , maArrayes  ),'')

SAVE TO MEMO mObj_Data  ALL LIKE m* 


*** Close all opend system files if opend by the program
IF glOpnMenu
  USE IN ALIAS('sycMenu')
ELSE
  SET ORDER TO gnOrdMenu IN ALIAS('sycMenu')
ENDIF  

IF glOpnScObj
  USE IN ALIAS('sydScObj')
ELSE
  SET ORDER TO gnOrdScObj IN ALIAS('sydScObj')
ENDIF  

IF glOpnFiles
  USE IN ALIAS('sydFiles')
ELSE
 SET ORDER TO gnOrdFiles IN ALIAS('sydFiles')
ENDIF  

IF glOpnField
  USE IN ALIAS('sydField')
ELSE
  SET ORDER TO gnOrdField IN ALIAS('sydField')
ENDIF  

IF glOpnFlFld
  USE IN ALIAS('sydFlFld')
ELSE
  SET ORDER TO gnOrdFlFld IN ALIAS('sydFlFld')
ENDIF  

IF glOpnObjct
  USE IN ALIAS('sydObjct')
ELSE
  SET ORDER TO gnOrdObjct IN ALIAS('sydObjct')
ENDIF  

*!*************************************************************
*! Name      : gfCleanup
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To close files and release windows when terminat any program
*!*************************************************************
*! Calls     : 
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will be called from any program activated from the menu
* or from any other program in both cases leaving the program window to 
* retern back or in case of quitting the program and close it's window
* The function will lear the temp record in the statin file and release
* the program windows
*
*:->
FUNCTION gfCleanUp

*B602483,1 Hesham (Start)
*B602483,1 check if the function is called from a returned function and not a
*B602483,1 program before closing files
IF TYPE('llFunCall')='L' AND llFunCall
  RETURN
ENDIF
*B602483,1 Hesham (End)

*E300680,1 MAN Temporary until we convert all screens to MS Font
gnPhonSize= LEN(ALLTRIM(gcTelTemp))*(fontme(7,'MS SANS SERIF',9)/9)
gnDateWdth= IIF('ON'$SET('CENT'),10,8)*(fontme(7,'MS SANS SERIF',9)/9)
*E300680,1 MAN end

*** If you leav the window and not quitting , do nothing.
*E301077,1 Hesham (Start)
*IF !glQuitting
*  RETURN 
*ENDIF  

IF !glQuitting
  IF !EMPTY(laFileName[1,1])
    lcOldExact  = SET('EXACT')
    SET EXACT ON
    FOR lnCount = 1 TO ALEN(laFileName,1)
      *-- YMA MAN START
      *lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
      FOR lnFileElm = 1 TO ALEN(gaMnu_Fl,1)
        IF ALLTRIM(gaMnu_Fl[lnFileElm,1]) == ALLTRIM(laFileName[lnCount,1])
          EXIT
        ENDIF
      ENDFOR
      IF lnFileElm > ALEN(gaMnu_Fl,1)
        lnFileElm = 0
      ENDIF
      *-- YMA MAN END

      IF lnFileElm > 0 
        *-- YMA MAN
        *lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
        lnRowNo = lnFileElm
        *-- YMA MAN
        gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] - 1
        IF gaMnu_Fl[lnRowNo,5] ="P" .AND. USED(gaMnu_Fl[lnRowNo,1])
          USE IN gaMnu_Fl[lnRowNo,1]
        ENDIF
        IF gaMnu_Fl[lnRowNo,4]<=0 AND gaMnu_Fl[lnRowNo,5] ="P"
           =ADEL(gaMnu_Fl,lnRowNo)
           IF ALEN(gaMnu_Fl,1) > 1
             DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1) -1,ALEN(gaMnu_Fl,2)]
           ENDIF
        ENDIF  
      ENDIF
    ENDFOR
    SET EXACT &lcOldExact
  ENDIF  
  RETURN
ENDIF  
*E301077,1 Hesham (End)

IF !EMPTY(lcBaseFile)
  IF USED(lcBaseFile)
    SELECT (lcBaseFile)
    IF !EMPTY(FILTER())
      SET FILTER TO
    ENDIF
  ENDIF  
ENDIF

*** Get window name to be cleared

gnWind_No  = ASCAN(gaAct_Wind,lcBaseWind)
IF gnWind_No > 0
  gnWind_No  = ASUBSCRIPT(gaAct_Wind,gnWind_No,1)
ENDIF  

gnAryElm   = 1


FOR lcCount = 1 TO ALEN(gaAct_wind,1)
  *** If any of the activ windows was branshed from this window
  IF gaAct_wind[gnAryElm,3]= lcBaseWind
    IF WEXIST(gaAct_wind[gnAryElm,1])
      RELEASE WINDOW (gaAct_wind[gnAryElm,1])
    ENDIF  
    =ADEL(gaAct_Wind,gnAryElm)
    IF ALEN(gaAct_Wind,1) > 1
      DIMENSION gaAct_Wind[ALEN(gaAct_Wind,1) - 1,4]
    ENDIF  

  ELSE   
    *** If You remove an element from the arraym, then use the 
    *** same element no., becouse in this case you are pointing 
    *** to the next element previasly 
    *** Otherwis increase the counter
    gnAryElm = gnAryElm + 1   
  ENDIF
ENDFOR 

*** Enable the bar of this window in the menu again 
IF !llMultiRun
  IF lnBar_No >0 .AND. !EMPTY(lcPop_Name) 
    SET SKIP OF BAR (lnBar_No) OF (lcPop_Name) .F.
  ENDIF  
ENDIF  

*** Close all child screens called from this window
*E301164,1 Hesham (Start)
*E301164,1 Close all Temprory files used by the program
*E301164,1 and errase it from disk
IF TYPE('laPrgTemps')#'U'
  lcUncmFiles = ''
  IF TYPE('lcMenUnProce')='C' AND !EMPTY(lcMenUnProce)
    IF SEEK('O'+PADR(lcMenUnProce,10)+gcUser_id,'UNCMSESS')
      lcUncmFiles = ALLT(UNCMSESS.MTMPFILES)
    ENDIF
  ENDIF
  FOR lnCount = 1 TO ALEN(laPrgTemps,1)
    IF !EMPTY(laPrgTemps[lnCount,1])
      IF USED(laPrgTemps[lnCount,1])
        USE IN (laPrgTemps[lnCount,1])
      ENDIF
      IF EMPTY(lcUncmFiles) OR !(laPrgTemps[lnCount,1]$lcUncmFiles)
        ERASE (gcWorkDir+laPrgTemps[lnCount,1]+'.DBF')
        ERASE (gcWorkDir+laPrgTemps[lnCount,1]+'.FPT')
        ERASE (gcWorkDir+laPrgTemps[lnCount,1]+'.CDX')
        ERASE (gcWorkDir+laPrgTemps[lnCount,1]+'.TXT')
      ENDIF  
    ENDIF
  ENDFOR
ENDIF
*E301164,1 Hesham (End)

*** Clear the temp record in static file
SELECT syuStatc
IF SEEK (ALLTRIM('WIN'+lcBaseWind+gcUser_ID+gcStation)) 
  *** Save the name of module from which the window was activated
  SCATTER MEMVAR MEMO BLANK
  GATHER  MEMVAR MEMO
  DELETE 
ENDIF   

IF !USED('SYDSUPRG')
  SELECT 0 
  USE (gcSysHome+'SYDSUPRG')
ELSE
  SELECT SYDSUPRG
ENDIF

SET ORDER TO TAG PRGCOMP

*** Check if the program was single user clear the locking
IF SEEK(SUBSTR(lcBaseWind,4)+gcAct_Comp,'SYDSUPRG')
  UNLOCK IN SYDSUPRG
ENDIF

*** If the window was acivated from other module,
*** Check if there any other windows still activ from the same module
*** Otherwis close all data files related to the other module

IF ! glNoLog 
  IF !EMPTY(laFileName[1,1])
    lcOldExact  = SET('EXACT')
    SET EXACT ON
    FOR lnCount = 1 TO ALEN(laFileName,1)
      *-- YMA MAN START
      *lnFileElm = ASCAN(gaMnu_Fl,laFileName[lnCount,1])
      FOR lnFileElm = 1 TO ALEN(gaMnu_Fl,1)
        IF ALLTRIM(gaMnu_Fl[lnFileElm,1]) == ALLTRIM(laFileName[lnCount,1])
          EXIT
        ENDIF
      ENDFOR
      IF lnFileElm > ALEN(gaMnu_Fl,1)
        lnFileElm = 0
      ENDIF
      *-- YMA MAN END
      IF lnFileElm > 0 
        *-- YMA MAN
        *lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
        lnRowNo = lnFileElm
        *-- YMA MAN
        gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] - 1
        *E300999,1 Hesham (Start)        
        *E300999,1 Check if the file was opened before closing it
        *IF gaMnu_Fl[lnRowNo,4] <= 0 .AND. gaMnu_Fl[lnRowNo,5] ="P" 

        *E301077,1 Hesham (Start)   
        *E301077,1 Check if the file is not used by module or main 
        *E301077,1 system then close it
        *IF gaMnu_Fl[lnRowNo,4] <= 0 .AND. gaMnu_Fl[lnRowNo,5] ="P" .AND.;
        *   USED(gaMnu_Fl[lnRowNo,1])
        *E300999,1 Hesham (End) 
        IF gaMnu_Fl[lnRowNo,5] ="P" .AND.;
           USED(gaMnu_Fl[lnRowNo,1])
           *E301077,1 Hesham (End)   
                                    
          USE IN gaMnu_Fl[lnRowNo,1]
          
          *E301077,1 Hesham (Start)             
          *=ADEL(gaMnu_Fl,lnRowNo)
          *IF ALEN(gaMnu_Fl,1) > 1
          *  DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1) -1,ALEN(gaMnu_Fl,2)]
          *ENDIF
          *E301077,1 Hesham (eND)    
        ENDIF
        
        *E301077,1 Hesham (Start)   
        *E301077,1 check if the file is not used any more from
        *E301077,1 any other program the delete the array
        *E301077,1 row that hold the file info
        IF gaMnu_Fl[lnRowNo,4]<=0 AND gaMnu_Fl[lnRowNo,5] ="P"
           =ADEL(gaMnu_Fl,lnRowNo)
           IF ALEN(gaMnu_Fl,1) > 1
             DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1) -1,ALEN(gaMnu_Fl,2)]
           ENDIF
        ENDIF  
        *E301077,1 Hesham (End)   
   
      ENDIF
    ENDFOR
    SET EXACT &lcOldExact
  ENDIF  
ENDIF

*** Readjust the dinamic window array
IF gnWind_No > 0
  =ADEL(gaAct_Wind,gnWind_No)

  IF ALEN(gaAct_Wind,1)  > 1             && Shrink the array till 1 colum
    DIMENSION gaAct_Wind[ALEN(gaAct_Wind,1) - 1,4]
  ELSE
    gaAct_Wind =' '   
  ENDIF 
ENDIF  

*** Release the main window if it is still exist
IF WEXIST(gcBaseWind)
  RELEASE WINDOW (gcBaseWind)
ENDIF  

*** Rearrang the window popup
=gfWinArng()

*** Check if ther is any open program using the controle pannel
lcMainWind = IIF(_WINDOWS,"FNDATION","")
lcWindChck = UPPER(WCHILD(lcMainWind,0))
DO WHILE !EMPTY(lcWindChck)
  IF SUBSTR(lcWindChck,3,1) = "R"
    RETURN
  ENDIF
  *** Get next open window
  lcWindChck=UPPER(WCHILD(lcMainWind,1))
ENDDO


*** If you close all windows and find the control screen still open
*** release it
IF WEXIST("gwcContrl1")
*!EMPTY(WONTOP()) .AND. SUBSTR(WONTOP(),2,2) = "WC"
  RELEASE WINDOW gwcContrl1         && Release the control pannel window
ENDIF

IF _DOS
  lcAct_Wind = WONTOP()
  ACTIVATE SCREEN 
  @ SROWS()-1,0 SAY SPACE(51)+ gcMesg_Str COLOR (SCHEME(1,5))
  IF !EMPTY(lcAct_wind)
     ACTIVATE WINDOW (lcAct_wind)
  ENDIF
ENDIF  

gcHelpTopc = " "
glNoLog    = .F.

*!*************************************************************
*! Name      : gfStatic
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To save the current variables for the current program
*!*************************************************************
*! Calls     : 
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!      Called by: GPDOPROG                 (procedure in ARIA3.PRG)
*!      Called by: GFSTOPREAD()             (function  in ARIA3.PRG)
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GFSTOPBROW()             (function  in ARIA3.PRG)
*!          Calls: GFADD_INFO()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will be called from deferant places
* the main action of this function is to creat a new temp record for the 
* currant program in the static file to hold all the local variables 
* values or to update this record if it's olredy exist
*
*:->
FUNCTION gfStatic

*** The name of current window name will be in variable lcBaseWind for all
*** main programes 

gcSavAlias = SELECT (0)                  && Save current work aria

*** Get the current record in current dbf at this moment
IF !EMPTY(lcBaseFile) 
  lnRecNo    = RECNO(lcBaseFile)
ENDIF  

llFromBrow = glFromBrow

SELECT syuStatc

*** Check if the temp record is not created yet
IF !SEEK (ALLTRIM('WIN'+lcBaseWind+gcUser_ID+gcStation))
  SET DELETE OFF

  *** look for blank deleted record to reused
  IF SEEK(' ') .AND. DELETED()            && Check if any deleted records
    IF RLOCK()
      lnNewRec = RECNO()
      RECALL 
      UNLOCK
      GO gnMyStRec                        && Use it again
      =RLOCK()
      GO lnNewRec
    ELSE  
      APPEND BLANK
    ENDIF 
  ELSE  
    APPEND BLANK                          && If there isn't, open new one
  ENDIF
  
  SET DELETE ON

  REPLACE cObj_typ    WITH 'WIN' ,;
          cObj_Name   WITH lcBaseWind,;
          cUser_ID    WITH gcUser_ID ,;
          cStation    WITH gcStation ,;
          cApp_ID     WITH lcWinAppl ,;
          cComp_ID    WITH gcAct_Comp,;                    
          lKeep_It    WITH .F.

  =gfAdd_info('SYUSTATC')  
                 
ENDIF

*** Save all local variables values at this moment
SAVE TO MEMO mObj_Data   ALL LIKE l*

SELECT (gcSavAlias)                      && Restore active work area

*!*************************************************************
*! Name      : gfNoContrl
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To disable th pannel if the program dose not have one
*!*************************************************************
*! Calls     : 
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfNoContrl

IF WVISIBLE("GWCCONTRL1")
  RELEASE WINDOW GWCCONTRL1
ENDIF

*!*************************************************************
*! Name      : gfObj_msg
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display help message for any object
*!*************************************************************
*! Calls     : 
*!      Called by: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFPOPMESAG()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Message to be display
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfObj_msg
PARAMETERS lcMsg2Disp

IF gnMsgRec > 0 .AND. USED('syuckmsg')
  GO gnMsgRec IN syuckmsg

  IF !EMPTY(syuckmsg.cmessage)
    =gfPopMesag()
  ENDIF
ENDIF  


lcMesg_Str = " "

IF TYPE('lcMsg2Disp') = 'C'
  lcMesg_Str = SUBSTR(lcMsg2Disp,1,51)+IIF(_DOS,gcMesg_Str,'')
ELSE
  IF TYPE('laFld_msg[1]') <> "U"

    lnAryObj = ASCAN(laFld_msg,SYS(18))

    IF lnAryObj > 0
      lnAryObj = ASUBSCRIPT(laFld_msg,lnAryObj,1)
      lcMesg_Str = ' '+laFld_msg[lnAryObj,2]+IIF(_DOS,gcMesg_Str,'')
    ELSE
      lcMesg_Str = SPACE(51)+IIF(_DOS,gcMesg_Str,'')
    ENDIF   
  ELSE  
    lcMesg_Str = SPACE(51)+IIF(_DOS,gcMesg_Str,'')
  ENDIF  
ENDIF

RETURN lcMesg_Str

*!*************************************************************
*! Name      : gpChangCom
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To change curren selected company with new one
*!*************************************************************
*! Calls     : 
*!      Called by: GFMENUBLD()              (function  in ARIA3.PRG)
*!      Called by: GPRELOGIN                (procedure in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFCOMPSETS()             (function  in ARIA3.PRG)
*!          Calls: GFMENUBLD()              (function  in ARIA3.PRG)
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!          Calls: GPDISPSTAT               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Company ID
*!                      Flag if comming from menu
*!                      Check if there is any active program or not
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpChangCom
PARAMETERS lcComp_Id,llFroMnu,llChekFrst

llFroMnu   = IIF(TYPE('llFroMnu')  ='U',.T.,llFroMnu  )
IF PARAMETERS() < 3
  llChekFrst = .T.
ENDIF


*** Check if selecting the current company
IF lcComp_Id=gcAct_Comp
  IF llFroMnu
      =gfModalgen("INM00022B00000","ALERT",lcComp_Id)
   ENDIF   
   RETURN
ENDIF

IF llChekFrst
  *** Check if there is any active program
  IF RDLEVEL() > 1 .AND. (TYPE('lcProgName')='C' AND !EMPTY(lcProgName)) &&SUBSTR(WONTOP(),1,7) <> "TOOLBAR"
    =gfModalgen("INM00021B00000","ALERT")
    RETURN
  ENDIF  
ENDIF  

*E301077,78 Hesham (Start)
PRIVATE llCompUse
llCompUse=gfSysOpen(gcSysHome+'SYCCOMP','CCOMP_ID')
*IF USED("syccomp")
*  SELECT syccomp
*  SET ORDER TO cComp_Id
*ELSE
*  SELECT 0
*  USE (gcSysHome+"syccomp") ORDER 1
*ENDIF
*E301077,78 Hesham (End)



IF SEEK(lcComp_Id)

  IF !EMPTY(ccompprnt) .AND. glParntMdl .AND. gcAct_appl <>'SM' .AND. !EMPTY(gcAct_appl)
    =gfModalgen("INM00158B00000","ALERT",ALLTRIM(sycComp.cCom_Name)+"|"+ALLTRIM(gcApp_Name))
    *E301077,78 Hesham (Start)
    USE IN IIF(llCompUse,'SYCCOMP',0)
    *E301077,78 Hesham (End)
    RETURN 
  ENDIF 


  *** Check if the selected company have linke to the current module
  IF AT(gcAct_appl,ALLTRIM(mComp_Mdl)) = 0 .AND. gcAct_appl <>'SM' .AND. !EMPTY(gcAct_appl)
    =gfModalgen("INM00151B00000","ALERT",ALLTRIM(gcApp_Name)+"|"+ALLTRIM(sycComp.cCom_Name))
    *E301077,78 Hesham (Start)
    USE IN IIF(llCompUse,'SYCCOMP',0)
    *E301077,78 Hesham (End)
    RETURN 
  ENDIF 
  *B601027,1 (S) Check if the setup is done for the current module for the new Co.
  *B601027,1 Get the new company data dir.
  *E301098,1 Hesham (Start)
  *lcDataDir  = ALLTRIM(cCom_dDir)
   *B601081,1 Hesham (Start)
  * IF UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) = UPPER(SUBSTR(lcDataDir,1,ATC('\',lcDataDir,2))) AND ;
  *     UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) <>  UPPER(SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2)))
  *   lcDataDir= SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2))+SUBSTR(lcDataDir,ATC('\',lcDataDir,2)+1)
*   lcDataDir = gcAllCmp + RIGHT(lcDataDir, LEN(lcDataDir) - ATC("\DBFS",lcDataDir) - 5)   
  * ENDIF
   lcDataDir  = gfGetDataDir(ALLTRIM(cCom_dDir))
   *E301098,1 Hesham (End)
   *B601081,1 Hesham (End)
  

  *B601027,1 Check if the current application is set for the new company
  IF  !EMPTY(gcAct_Appl) AND  gcAct_Appl <> 'SM'
    *B601027,1 Check if setup required for the current module in the selected company
*E300633,1 Hesham El-Sheltawi (Start)
*E300633,1 Check if the module  is set for the new company selected
*E300633,1 through the company file new field mmodlset "Comp. Set Modules"
    *E301077,78 Hesham (Start)
    llAppUsd = gfSysOpen(gcSysHome+'SYDAPPL','CAPP_ID')
    =SEEK(gcAct_Appl)
    *E301077,78 Hesham (End) 
    llSetDon = .T.
    IF SYDAPPL.lsetreq 
      llSetDon = ATC(gcAct_Appl,SYCCOMP.MMODLSET)>0    
    ENDIF  
*    IF SYDAPPL.lsetreq
*      lcSetupFl = gcAct_Appl+"SETUP"
*      llSetDon  = .F.
*      SELECT 0
*      *B601027,1 Check if the setup file for the current module is exist in the selected company
*      IF FILE(lcDataDir+lcSetupFl+".DBF")  
*         USE (lcDataDir+lcSetupFl) ALIAS MODSETUP AGAIN
*         llSetDon  = lsetdon 
*         USE
*      ELSE
*         *B601027,1 The  setup file is not exist, 
*         *** you have to creat this file first befor attempt to 
*         *** select this module...!
*         =gfModalgen("INM00144B00000","ALERT",ALLTRIM(PROMPT()))        
*         *B500645,1 Check if the file [lcCerFile] is still used
*         IF !EMPTY(lcCerFile) AND USED(lcCerFile)
*           SELECT(lcCerFile)
*         ENDIF
*        *B600474,1 Hesham (Start)
*        *B600474,1 Show the menu    
*        SHOW MENU _MSYSMENU
*        *B600474,1 Hesham (End)
*         RETURN
*       ENDIF  
*      ENDIF  
*E300633,1 Hesham El-Sheltawi (End)       
      *E301077,78 Hesham (Start)
      IF llAppUsd 
        USE IN SYDAPPL
      ENDIF
      *E301077,78 Hesham (End) 
      *B601027,1 Check if the setup was done for the selected module 
      IF !llSetDon 
        *B601027,1 Setup was not done to this module yet,"+CHR(13)
        *** you have to setup the module through the company information 
        *** program...!
        =gfModalgen("INM00145B00000","ALERT")
        *E301077,78 Hesham (Start)
        USE IN IIF(llCompUse,'SYCCOMP',0)
        *E301077,78 Hesham (End)
        RETURN
      ENDIF     
    ENDIF
*  ENDIF
  SELECT sycComp
  *B601027,1 (F)

  gcAct_Comp = lcComp_Id

  *E301508,1 WAM Get current Site ID
  gcCurSite = gfGetMemVar('M_CURRSITE',gcAct_Comp)
  *E301508,1 (End)

  gcCom_Name = ALLTRIM(sycComp.cCom_Name)
  *E301098,1 Hesham (Start)  
  *gcDataDir  = ALLTRIM(cCom_dDir)
  gcDataDir  = gfGetDataDir(ALLTRIM(cCom_dDir))
  *E301098,1 Hesham (End)

  *E038621,1 WAM 04/05/2005 Prevent Aria4XP programs & reports from running under Aria27
  glRunFrmA4 = lRunFromA4 
  *E038621,1 WAM 04/05/2005 (End)
  
  *E300627,1 Hesham El-Sheltawi (Start)
  *E300627,1 restore the compony installed modules from the comp. file
  gcCmpModules = ALLT(mmodlset)
  *E300627,1  (End)  
  *300273,1 Change the drive to the currently mapped one
  *B601081,1 Hesham (Start)
  *E301098,1 Hesham (Start)
   *IF UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) = UPPER(SUBSTR(gcDataDir,1,ATC('\',gcDataDir,2))) AND ;
   *    UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) <>  UPPER(SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2)))
   *  gcDataDir= SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2))+SUBSTR(gcDataDir,ATC('\',gcDataDir,2)+1)
   * gcDataDir = gcAllCmp + RIGHT(gcDataDir, LEN(gcDataDir) - ATC("\DBFS",gcDataDir) - 5)
   *ENDIF
  *E301098,1 Hesham (End) 
  *B601081,1 Hesham (End)
  

  gcComp_Mdl = ALLTRIM(mComp_Mdl)
  gcComp_Lvl = IIF(EMPTY(ccompprnt),'P','C')
  gcPrnt_Cmp = IIF(EMPTY(ccompprnt),cComp_Id,ccompprnt)
  *E300266,5 MAN 08/08/95 Init. the default address code 
  gcContCode = IIF(EMPTY(cCont_code),'USA',cCont_code)
  gcBaseCurr = IIF(EMPTY(CCURRCODE),'USDLR',CCURRCODE)
  *E300713,1 Hesham (Start)
  *E300713,1 Initialize global variables for current year & period
  gcCurrYear = ccurr_yer
  gcCurrPrd  = sycComp.ccurr_Prd
  *E300713,1 Hesham (End)
  
  =gfCompSets(ALLTRIM(syccomp.ccont_code))

  *E302767,3 TMI 03/03/2011 [Start] update SYCMENU file based on chaange of the company
  =lfBldTmpMn()
  *E302767,3 TMI 03/03/2011 [End  ] 
  
  *E301077,78 Hesham (Start)
  USE IN IIF(llCompUse,'SYCCOMP',0)
  *E301077,78 Hesham (End)

  *E302767,5 TMI 03/12/2011 [Start] Always build the menu
  *IF glLog_Requ
    *E302767,5 TMI 03/12/2011 [End ] 
    =gfMenuBld(gcAct_Appl,'A')
    *E302767,5 TMI 03/03/2011 [Start] comment this 
  *ENDIF  
  *E302767,5 TMI 03/03/2011 [Start] 


  SET MARK OF POPUP _COMPANIES .F.

  IF llFroMnu 
    SET MARK OF BAR BAR() OF _COMPANIES .T.
    gnCompBar = BAR()  
  ELSE
    FOR lnChkBar  = 1 TO CNTBAR('_COMPANIES')
      IF ALLTRIM(UPPER(gcAct_Comp+"-"+gcCom_Name)) = ALLTRIM(UPPER(PRMBAR('_COMPANIES',lnChkBar)))
        SET MARK OF BAR lnChkBar OF _COMPANIES .T.
        gnCompBar = lnChkBar
        EXIT
      ENDIF
    ENDFOR
  ENDIF  

  *** Open data files of required applicaton
  lcOldAlias = ALIAS() 
  lcSaveWin  = WONTOP()
  ACTIVATE SCREEN
  *B602151,1 Hesham (Start)
  *B602151,1 Close all Data Files that was opened throught any program and
  *B602151,1 the program Didn't close it
  FOR lnCount = 1 TO 225
     SELECT (lnCount)
     IF !EMPTY(ALIAS()) AND LEFT(UPPER(ALIAS()),2)<>'SY'
       lnFileElm = ASCAN(gaMnu_Fl,UPPER(ALIAS()))
       IF lnFileElm = 0 
         USE
       ENDIF
     ENDIF  
  ENDFOR
  *B602151,1 Hesham (End)

  gnAllFiles = ALEN(gaMnu_Fl,1)
  gnThermNo  = 0

  FOR lnCount = 1 TO gnAllFiles
    IF USED(gaMnu_Fl[lnCount,1]) .AND. ;
      UPPER(LEFT(gaMnu_Fl[lnCount,1],2))<>'SY'

      gnThermNo = gnThermNo + 1
      =gfThermo(gnAllFiles,gnThermNo,"Opening data file...",PROPER(gaMnu_Fl[lnCount,6]))

      *B602329,1 Close alias name and not alias number
      *SELECT gaMnu_Fl[lnCount,3]
      SELECT gaMnu_Fl[lnCount,1]
      *B602329,1 end
      USE

      IF !EMPTY(gaMnu_Fl[lnCount,2])
        USE (gcDataDir+gaMnu_Fl[lnCount,1]) ORDER TAG (gaMnu_Fl[lnCount,2]) AGAIN
      ELSE
        USE (gcDataDir+gaMnu_Fl[lnCount,1]) AGAIN
      ENDIF
    ENDIF
  ENDFOR 

  IF gnThermNo < gnAllFiles .AND. gnThermNo > 0
    FOR lnThClose = gnThermNo TO gnAllFiles STEP 1
      =gfThermo(gnAllFiles,lnThClose,"Opening data file..."," ")
    ENDFOR
  ENDIF

  IF !EMPTY(lcOldAlias)
    IF USED(lcOldAlias) 
      SELECT (lcOldAlias)
    ENDIF  
  ENDIF  


  IF !EMPTY(lcSaveWin)
    ACTIVATE WINDOW (lcSaveWin) SAME 
  ENDIF  

  *#IF _DOS
  *    DO gpDispStat
  *#ELSE    
    *B600439 ADD THE ACTIVE COMPANY TO THE DISPLAY IN THE MAIN WINDOW TITLE
    MODIFY WINDOW SCREEN FONT"FOXFONT",9 STYLE 'N';
            TITLE ALLTRIM(gcSysName)+" - "+ALLTRIM(gcApp_Name)+;
            IIF(!EMPTY(gcAct_Comp),' ('+ALLTRIM(gcAct_Comp)+')','');
            FLOAT;
            ZOOM;
            GROW 
  *#ENDIF
  SELECT syustatc
  IF SEEK ('INI'+'OLDVARS'+gcUser_ID+gcStation,'syustatc')
    REPLACE syustatc.cComp_ID WITH gcAct_Comp
  ENDIF  
  
  *E300705,1 MAN 09/13/97 Open Company files (Not related to any module)
  *E300705,1              while changing the company
  DO gpOpnCmp
  *-- End Open Files Related to the company and not related to any module &&MAN
ENDIF  


*!*************************************************************
*! Name      : gfModalGen
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display any data driven dialog
*!*************************************************************
*! Calls     : 
*!      Called by: GFLOG_IN()               (function  in GFLOG_IN.PRG)
*!      Called by: GFMENUBLD()              (function  in ARIA3.PRG)
*!      Called by: GPCHNGMODL               (procedure in ARIA3.PRG)
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!      Called by: GFSTOPREAD()             (function  in ARIA3.PRG)
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!      Called by: GPRELOGIN                (procedure in ARIA3.PRG)
*!      Called by: GFSEEKREC()              (function  in ARIA3.PRG)
*!      Called by: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!      Called by: GFCPDELETE()             (function  in ARIA3.PRG)
*!      Called by: GFCPEDIT()               (function  in ARIA3.PRG)
*!      Called by: GFCPSAVE()               (function  in ARIA3.PRG)
*!      Called by: GFCPCLOSE()              (function  in ARIA3.PRG)
*!      Called by: GFSUSRPRG()              (function  in ARIA3.PRG)
*!      Called by: GPRECHIST                (procedure in ARIA3.PRG)
*!      Called by: GFACTPOP()               (function  in ARIA3.PRG)
*!      Called by: GFFLOCK()                (function  in ARIA3.PRG)
*!      Called by: GFRLOCK()                (function  in ARIA3.PRG)
*!      Called by: GPSQLBRAK                (procedure in ARIA3.PRG)
*!      Called by: GFUNDERDEV()             (function  in ARIA3.PRG)
*!      Called by: GPAPPLINK                (procedure in ARIA3.PRG)
*!      Called by: GFPOPMESAG()             (function  in ARIA3.PRG)
*!      Called by: GFESCAP()                (function  in ARIA3.PRG)
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFOBJ_MSG()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : 
*!                1-lcDlgID   (Dialog ID)
*!                          1st 2 characters are TR for Terminat icon
*!                                               QR for Quiry    icon
*!                                               IN for Inform   icon
*!                          2nd 4 characters are the messag ID 
*!                          3rd 4 characters are the button ID
*!                2-lcDlgTyp  (Dialog type)
*!                          'D' --> Dialog colors
*!                          'A' --> Alert  colors
*!                3-lcVarsStr  (variable(s) to be replased in the messag 
*!                4-lcDlgValid (Validation function name to be used in 
*!                              the valid of the dialog buttons)
*!                5-lcDlgMessg if you want to display a specific message
*!                            send the message string to this parameter         
*!
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Function to display any messag with any button from the 
* of dialog object file.  The width and hight of the dialog window 
* will be calculated according to the messag width and No. of buttons.
* Parameters are:
*:->
FUNCTION gfModalGen
PARAMETER lcDlgID,lcDlgTyp,lcVarsStr,lcDlgValid,lcDlgMessg

PRIVATE lcDlgID,lcDlgTyp,lcVarsStr,lcDlgValid,lcCurrDbf,lnButtons,lcDlgMessg,;
lcDevice

DECLARE laButtNo [1]         && Array to hold the buttons separetly
DECLARE laVarsStr[1]         && Array to hold variabels to be replaced
                             && in the messag
lcDevice = SET('DEVICE')
SET DEVICE TO SCREEN
PUSH KEY
ON KEY
lcCurrDbf   = ALIAS()
lcDlgID     = IIF(TYPE('lcDlgID'   ) $ "UL",'',lcDlgID   )
lcDlgTyp    = IIF(TYPE('lcDlgTyp'  ) $ "UL",'D',lcDlgTyp )
lcVarsStr   = IIF(TYPE('lcVarsStr' ) $ "UL",'',lcVarsStr )
lcDlgValid  = IIF(TYPE('lcDlgValid') $ "UL",'',lcDlgValid)
lcDlgMessg  = IIF(TYPE('lcDlgMessg') $ "UL",'',lcDlgMessg)
lcMsgCatgry = SUBSTR(lcDlgID,1,2)

lnColrSchm  = VAL(SUBSTR('57',AT(LEFT(lcDlgTyp,1),'DA'),1))  
lnDlgOpTion = 1              && Variable to get the result in
lnButtSize  = 1
lnOldRec    = 0
*B603228,1 AMM Consider the icon space if any
*lnTextStrt  = IIF(EMPTY(lcDlgMessg),7,2)
*lnRigtShft  = IIF(EMPTY(lcDlgMessg),10,5)
lnTextStrt  = IIF(!EMPTY(lcMsgCatgry),7,2)
lnRigtShft  = IIF(!EMPTY(lcMsgCatgry),10,5)
*B603228,1 AMM START, Get the buttons even with custom messages
*IF EMPTY(lcDlgMessg)
IF !EMPTY(lcDlgID)
*B603228,1 AMM end
  *** Open dialog file if it is not opend
  *E301077,78 Hesham (Start)
  llDlUse = gfOpenFile(gcSysHome+"syddlobj",'cdlobjid')
  *IF !USED('SydDlObj')
  *  SELECT 0
  *  USE (gcSysHome+"SydDlObj") 
  *ENDIF
  *SET ORDER TO TAG CDLOBJID IN ALIAS('SydDlObj')
  lnOldRec = IIF(llDlUse,0,RECNO('SydDlObj'))
  *E301077,78 Hesham (End)


  *** Get dialog button
  *B603228,1 AMM If the button sent, get it, else display by OK button
  *IF SEEK(SUBSTR(lcDlgID,9),'SydDlObj')
  IF !EMPTY(SUBSTR(lcDlgID,9)) .AND. SEEK(SUBSTR(lcDlgID,9),'SydDlObj')
  *B603228,1 AMM end
    lcButton = ALLTRIM(SydDlObj.mDlObj)
  ELSE
    *** If not found set default button to <ok>
    lcButton = "\!\?\<Ok"
  ENDIF
  *B603228,1 AMM end
  *** Get Dialog messag
  *B603228,1 AMM Get the message from table if there is no custom message
  IF EMPTY(lcDlgMessg)
  *B603228,1 AMM end
    IF SEEK(SUBSTR(lcDlgID,3,6),'SydDlObj')
      lcMessag    = ALLTRIM(SydDlObj.mDlObj)
      lcMsgCatgry = IIF(EMPTY(SydDlObj.cMsgCatgry),lcMsgCatgry,SydDlObj.cMsgCatgry)
    ELSE
      *** If not found set default message to null
      lcMessag = ""
    ENDIF
  *B603228,1 AMM If custom message, get it from the fifth parameter
  ELSE
    lcMessag   = ALLTRIM (lcDlgMessg)  
  ENDIF
  *B603228,1 AMM end
  *E301077,78 Hesham (Start)
  =IIF(llDlUse,gfSysClose('SYDDLOBJ'),'')
  *E301077,78 Hesham (eND)
  *** Collect variables to be replaced from string to array
  =gfSubStr(lcVarsStr,@laVarsStr,'|')

  *** Replace each  mark with variabe sent
  FOR lnVarsStr = 1  TO ALEN(laVarsStr,1)
    lcMessag = STRTRAN(lcMessag,'',laVarsStr[lnVarsStr],1,1)
  ENDFOR  

  *** Remove all controle characters " \ ! < ?" from the button string
  lcButtChk  = STRTRAN(STRTRAN(STRTRAN(STRTRAN(lcButton,'\',''),'!',''),;
             '<',''),'?','')

  *** Collect all Buttons in array 
  =gfSubStr(lcButtChk,@laButtNo,';')

  *** Get No of buttons from array len
  lnButtNo   = ALEN(laButtNo,1)

  *** Get the max width of button
  FOR lnButtons = 1 TO lnButtNo
    lnButtSize = MAX(lnButtSize,LEN(laButtNo[lnButtons]))
  ENDFOR

ELSE
  lcMessag   = ALLTRIM (lcDlgMessg)
  lcButton   = "\!\?\<Ok"  
  lnButtNo   = 1
  lnButtSize = 4
ENDIF


*** Buttons width should not be less than 10 after adding 4 (< >) 
lnButtSize = MAX(10,lnButtSize+ 4 )


*** Calculat window width accordin to total buttons size
lnWinWidth = MAX(50,(lnButtSize * lnButtNo)+6)

*** Calculat space between buttons 
lnBetwButt = INT((lnWinWidth -(lnButtSize * lnButtNo))/lnButtNo)

*** Calculat X position of the button to be centerd
lnButXPos  = (lnWinWidth/2)-((lnButtSize * lnButtNo)+;
             (lnBetwButt*(lnButtNo-1)))/2

*** Calculat window higth according to the length of the messag
lnWinHight = INT(LEN(ALLTRIM(lcMessag))/lnWinWidth) + 6 

*MAN Define the title Var.
IF TYPE("gcSysName") # "C"
  gcSysName = ""
ENDIF

*** Define dialog window with right width, hight and color
*#IF _DOS
*    DEFINE WINDOW gwdDialog ;
*           FROM 0,0 TO lnWinHight,lnWinWidth ;
*           SHADOW;
*           FLOAT ;
*           DOUBLE;
*           COLOR SCHEME lnColrSchm
*#ELSE
*B600914,1 Oraby 17/03/1996 Stop the user abilty to close the dialog messages, from the screen menu
*    DEFINE WINDOW gwdDialog ;
	       AT  0.000, 0.000  ;
		   SIZE lnWinHight,lnWinWidth;
		   FONT "System", 10 ;
		   STYLE "B" ;
		   FLOAT ;
           SYSTEM ;
           TITLE (gcSysName);
		   CLOSE ;
		   NOMINIMIZE ;
		   COLOR RGB(,,,192,192,192)
		   
    DEFINE WINDOW gwdDialog ;
	       AT  0.000, 0.000  ;
		   SIZE lnWinHight,lnWinWidth;
		   FONT "System", 10 ;
		   STYLE "B" ;
		   FLOAT ;
           SYSTEM ;
           TITLE (gcSysName);
		   NOMINIMIZE ;
		   COLOR RGB(,,,192,192,192)
*#ENDIF
			  
*** Activate dialog window no show so the window will pop with messag 
*** when activated
ACTIVATE WINDOW gwdDialog NOSHOW

*** Move the dialog window to center of the screen
MOVE WINDOW gwdDialog CENTER

*#IF _DOS
*      IF EMPTY(lcDlgMessg)
*        @ 0,1,2,5 BOX
*        @ 1,3  SAY SUBSTR ("!?I",(AT(lcMsgCatgry,"TRQRIN")+1)/2,1)
*      ENDIF  
*
*      @ 1,lnTextStrt  SAY lcMessag SIZE lnWinHight-3,lnWinWidth-lnRigtShft
*#ELSE
      @ 0.000,0.000 TO 0.000,lnWinWidth ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(255,255,255,255,255,255)
  	  @ 0.000,0.000 TO lnWinHight,0.000 ;
		PEN 1, 8 ;
		  COLOR RGB(255,255,255,255,255,255)
  	  @ 0.188,0.429 TO 0.188,lnWinWidth-.6 ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.188,0.429 TO lnWinHight-.3,0.429 ;
		PEN 1, 8 ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.000,lnWinWidth TO lnWinHight,lnWinWidth ;
		PEN 1, 8 ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.188,lnWinWidth-.6 TO lnWinHight-.3,lnWinWidth-.6 ;
		PEN 1, 8 ;
		  COLOR RGB(255,255,255,255,255,255)
	  @ lnWinHight,0.143 TO lnWinHight,lnWinWidth ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ lnWinHight-.3,0.4 TO lnWinHight-.3,lnWinWidth-.4 ;
		PEN 1, 8 ;
		STYLE "1" ;
	      COLOR RGB(255,255,255,255,255,255)
      *B603228,1 AMM Display the icon if sent as parameter
      *IF EMPTY(lcDlgMessg)
      IF !EMPTY(lcMsgCatgry)
      *B603228,1 AMM end
*        lcIcon = SUBSTR ("TR  QRY INFO",;
             ((AT(lcMsgCatgry,"TRQRIN")+1)/2-1)*4+1,4)+".BMP" 
 *       @ 1.5,1.5 SAY lcIcon BITMAP STYLE "T"
      ENDIF  

      @ 1.5,lnTextStrt SAY lcMessag SIZE lnWinHight-3,lnWinWidth-lnRigtShft
*#ENDIF

  
IF EMPTY(lcDlgValid )
  @ lnWinHight -2 ,lnButXPos ;
    GET lnDlgOpTion ;
    PICTURE "@*HT "+lcButton;
    SIZE 1.5,lnButtSize,lnBetwButt;
    MESSAGE gfObj_msg()
ELSE
  @ lnWinHight -2 ,lnButXPos ;
    GET lnDlgOpTion ;
    PICTURE "@*H "+lcButton;
    SIZE 1.5,lnButtSize,lnBetwButt;
    VALID &lcDlgValid;
    MESSAGE gfObj_msg()
ENDIF    

  
*** When the read is activated fox will activate the window 
ACTIVATE WINDOW gwdDialog

IF !EMPTY(lcDlgMessg)
  SET BELL TO 2000,2
  ?? CHR(7)
  SET BELL TO 
ENDIF  

READ CYCLE MODAL

IF lnOldRec > 0  .AND. lnOldRec <= RECCOUNT('SydDlObj')
  GO lnOldRec IN ALIAS('SydDlObj')
ENDIF

IF !EMPTY(lcCurrDbf)
  SELECT (lcCurrDbf)
ENDIF

RELEASE WINDOW gwdDialog
SET DEVICE TO &lcDevice
POP KEY
RETURN lnDlgOpTion

*!*************************************************************
*! Name      : gfFillPop
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To fill any popup from an array
*!*************************************************************
*! Calls     : 
*!      Called by: GFACTPOP()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Popup name
*!                      Array name
*!                      Colums number to be used in filling  
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfFillPop
PARAMETERS lcPopNam,laPopAray,lnColNum
lnColNum =IIF(TYPE('lnColNum')<>'N',1,lnColNum)

RELEASE BAR ALL OF &lcPopNam


FOR lnCount = 1 to ALEN(&laPopAray,1)
  DEFINE BAR lnCount OF &lcPopNam ;
         PROMPT (ALLTRIM(&laPopAray[lnCount,lnColNum]))
ENDFOR

*!*************************************************************
*! Name      : gfThermo
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display a thermometer for any running action
*!*************************************************************
*! Calls     : 
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!      Called by: GPCHNGDATA               (procedure in ARIA3.PRG)
*!      Called by: GFTMP2MAST()             (function  in ARIA3.PRG)
*!      Called by: GFBLDSTATC()             (function  in ARIA3.PRG)
*!      Called by: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Total count
*!                      Current action
*!                      Fixed messag on top
*!                      variable messag with each count
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfThermo
FUNCTION x_gfThermo
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lnToBeDone,lnDone,lcMessage,lcVariable

*lnToBeDone
*lnDone

*B605445,1 (Begin) If the file is empty.
IF lnToBeDone = 0
  STORE 100 TO lnToBeDone,lnDone
ENDIF
*B605445,1 (End)

lcMessage   =IIF(TYPE('lcMessage')='C' ,lcMessage ,' ')
lcVariable  =IIF(TYPE('lcVariable')='C',lcVariable,' ')

*#IF _DOS
*	IF ! WEXIST("gwdThermo")
*	  DEFINE WINDOW gwdThermo ;
*		   	FROM INT((SROW()-11)/2),INT((SCOL()-58)/2) ;
*			TO INT((SROW()-11)/2)+6,INT((SCOL()-58)/2)+57 ;
*			NOCLOSE DOUBLE SHADOW COLOR SCHEME 5
*
*	  ACTIVATE WINDOW gwdThermo
*
*	  @ 0,2 SAY lcMessage
*	  @ 2,1 TO 5,54 
*	  @ 3,3 SAY CHR(219)
*
*	ENDIF  
*
*
*	lnPersent = INT((lnDone /lnToBeDone )*100)
*
*	@ 1,3 SAY SPACE(54)
*	@ 1,3 SAY lcVariable
*	@ 3,3 SAY REPLICATE(CHR(219),lnPersent*50/100)
*
*	IF lnToBeDone <= lnDone
*	  RELEASE WINDOW gwdThermo
*	ENDIF
*#ELSE
    gcFontFace	=	"MS Sans Serif"
    gcFontSize	=	8.000
    gcFontStyle	=	"B"
    gntherwidth =  57
    IF NOT WEXIST("gwdThermo")
	  DEFINE WINDOW gwdThermo ;
        IN WINDOW fndation ;
	    AT  INT((SROW() - (( 5.615 * ;
	    FONTMETRIC(1, gcFontFace, gcFontSize, gcFontStyle )) / ;
	    FONTMETRIC(1, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2), ;
	    INT((SCOL() - (( 63.833 * ;
	    FONTMETRIC(6, gcFontFace, gcFontSize, gcFontStyle )) / ;
	    FONTMETRIC(6, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2) ;
	    SIZE 5.615,63.833 ;
	    FONT gcFontFace, gcFontSize ;
	    STYLE gcFontStyle ;
	    NOFLOAT ;
	    NOCLOSE ;
	    NONE ;
	    COLOR RGB(0, 0, 0, 192, 192, 192)

	  MOVE WINDOW gwdThermo CENTER
	  ACTIVATE WINDOW gwdThermo NOSHOW

	  @ 0.5,3 SAY lcMessage FONT gcFontFace, gcFontSize STYLE gcFontStyle
	  @ 0.000,0.000 TO 0.000,63.833 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 0.000,0.000 TO 5.615,0.000 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 0.385,0.667 TO 5.231,0.667 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.308,0.667 TO 0.308,63.167 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.385,63.000 TO 5.308,63.000 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 5.231,0.667 TO 5.231,63.167 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 5.538,0.000 TO 5.538,63.833 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 0.000,63.667 TO 5.615,63.667 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 3.000,3.333 TO 4.300,3.333 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 3.000,60.333 TO 4.308,60.333 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  @ 3.000,3.333 TO 3.000,60.333 ;
	    COLOR RGB(128, 128, 128, 128, 128, 128)
	  @ 4.300,3.333 TO 4.300,60.500 ;
	    COLOR RGB(255, 255, 255, 255, 255, 255)
	  

	  SHOW WINDOW gwdThermo TOP
	    
    ENDIF
	lnPersent = INT((lnDone /lnToBeDone )*100)
    lnblocks  = lnPersent*gntherwidth/100

    @ 1.7,3 SAY lcVariable+SPACE(gntherwidth-LEN(lcVariable)) FONT gcFontFace, gcFontSize STYLE gcFontStyle
    
    @ 3.039,gntherwidth/2 SAY ALLTRIM(STR(lnPersent))+"%" FONT "SYSTEM",8 ;
       COLOR RGB(0,0,0,192, 192, 192)
    @ 3.000,3.333 FILL TO 4.300,lnblocks + 3.333 ;
            COLOR RGB(255,255,255,128,128,128)

       
	IF lnToBeDone <= lnDone
	  RELEASE WINDOW gwdThermo
	ENDIF
*#ENDIF   

*!*************************************************************
*! Name      : gpChngData
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Close old module data files and open new ones for new modle
*!*************************************************************
*! Calls     : 
*!      Called by: GPCHNGMODL               (procedure in ARIA3.PRG)
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Flag to close files or not
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpChngData
PARAMETERS llClosFils

llClosFils = IIF(TYPE('llClosFils')='U',.T.,llClosFils)

lcOldAlias = ALIAS()

*** Close Unneeded data files 
IF llClosFils
   gnAllFiles = ALEN(gaMnu_Fl,1)
   gnAryElm   = 1
   FOR lnFClose = 1 TO gnAllFiles
     =gfThermo(gnAllFiles,lnFClose,"Checking data file for Closing...",PROPER(gaMnu_Fl[gnAryElm,6]))  
     DO CASE
       CASE gaMnu_Fl[gnAryElm,5] $ "KN"
       
         gaMnu_Fl[gnAryElm,5] = "M"
         gnAryElm = gnAryElm + 1
       CASE gaMnu_Fl[gnAryElm,5] ="M" .AND. gaMnu_Fl[gnAryElm,4] > 0  
         gaMnu_Fl[gnAryElm,5] = "P"
         gnAryElm = gnAryElm + 1
       OTHERWISE       
         IF (gaMnu_Fl[gnAryElm,5] ="M" .AND. USED(gaMnu_Fl[gnAryElm,1]).AND. gaMnu_Fl[gnAryElm,4] <= 0 ) .OR. ;
            (gaMnu_Fl[gnAryElm,5] ="P" .AND. gaMnu_Fl[gnAryElm,4] <= 0) .AND.;
            USED(gaMnu_Fl[gnAryElm,1])
                           
            USE IN  (gaMnu_Fl[gnAryElm,3])

           =ADEL(gaMnu_Fl,gnAryElm)
           IF ALEN(gaMnu_Fl,1) > 1 
             DIMENSION gaMnu_Fl[ALEN(gaMnu_Fl,1)-1,ALEN(gaMnu_Fl,2)]
           ENDIF           
         ELSE
          gnAryElm = gnAryElm + 1             
         ENDIF      
     ENDCASE
   ENDFOR
ENDIF
   
*** Open data files of required applicaton
lcSaveWin = WONTOP()
ACTIVATE SCREEN

gnAllFiles = ALEN(gaMnu_Fl,1)
gnThermNo  = 0

FOR lnCount = 1 TO gnAllFiles
  IF USED(gaMnu_Fl[lnCount,1])
    IF gaMnu_Fl[lnCount,3] = 0
      gaMnu_Fl[lnCount,5] = 'S'
    ENDIF      
  ELSE
    SELECT 0
    gnThermNo = gnThermNo + 1
    =gfThermo(gnAllFiles,gnThermNo,"Opening data file...",PROPER(gaMnu_Fl[lnCount,6]))
    lcPath = IIF(UPPER(LEFT(gaMnu_Fl[lnCount,1],2))='SY',gcSysHome,gcDataDir)
    gaMnu_Fl[lnCount,3] = SELECT(0)   
    IF !EMPTY(gaMnu_Fl[lnCount,1])     
      IF !EMPTY(gaMnu_Fl[lnCount,2])
        USE (lcPath+gaMnu_Fl[lnCount,1]) ORDER TAG (gaMnu_Fl[lnCount,2]) AGAIN
      ELSE
        USE (lcPath+gaMnu_Fl[lnCount,1]) AGAIN
      ENDIF
    ENDIF
  ENDIF
ENDFOR 

IF gnThermNo < gnAllFiles
  FOR lnThClose = gnThermNo TO gnAllFiles STEP 1
    =gfThermo(gnAllFiles,lnThClose,"Opening data file..."," ")
  ENDFOR
ENDIF

IF !EMPTY(lcOldAlias)
  IF USED(lcOldAlias) 
    SELECT (lcOldAlias)
  ENDIF  
ENDIF  


IF !EMPTY(lcSaveWin)
  ACTIVATE WINDOW (lcSaveWin) SAME 
ENDIF  

*!*************************************************************
*! Name      : gpMenuCls
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : close program called from menu
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Close/Cancel the current screen
*
*:->>
PROCEDURE gpMenuCls
_CUROBJ = OBJNUM(pbCls)
KEYBOARD CHR(13) PLAIN CLEAR

*!*************************************************************
*! Name      : gpMenuSav
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Save record called from the menu
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Save the current screen
*
*:->>
PROCEDURE gpMenuSav
_CUROBJ = OBJNUM(pbSav)
KEYBOARD CHR(13) PLAIN CLEAR

*!*************************************************************
*! Name      : gfSubStr
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To extract element from string or to convert string to array
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GFSCRINI()               (function  in ARIA3.PRG)
*!      Called by: GFMODALGEN()             (function  in ARIA3.PRG)
*!      Called by: GFSEEKREC()              (function  in ARIA3.PRG)
*!      Called by: GFDBFFIELD()             (function  in ARIA3.PRG)
*!      Called by: GFFLOCK()                (function  in ARIA3.PRG)
*!      Called by: GFRLOCK()                (function  in ARIA3.PRG)
*!      Called by: GFWAIT()                 (function  in ARIA3.PRG)
*!      Called by: GFGETVLD()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : String to be used
*!                      poiter to array or element position
*!                      sparators used in the string
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will return eather a string part # OR an array of all
* the string parts according to the type of the second parameter. The
* firest parameter will be the string or string variable. If the
* second parameter have a numeric type, the function will return the
* but if it is an array the function will return the array with each
*  element having a part from the string.
* 
*:->
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfSubStr
FUNCTION x_gfSubStr
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcString,lnAryOrPos,lcSepta

lcSubstr  =' '
lnAryDim  = 1
lnAryRows = 1
lnAryCols = 1
lcSepta   = IIF(TYPE('lcSepta')='C',lcSepta,',') 

IF LEN(ALLTRIM(lcSepta))>1
  lcColSep  = SUBSTR(lcSepta,2,1)
  lcSepta   = LEFT(lcSepta,1)
  lnAryDim  = IIF(OCCURS(lcSepta,lcString)>0,;
              OCCURS(lcSepta,lcString)+;
              IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
              lnAryDim)
  lnAryCols = IIF(OCCURS(lcColSep,lcString)>0,;
              OCCURS(lcColSep,lcString)+;
              IIF(RIGHT(lcString,1)<>lcColSep,1,0),;
              lnAryDim)
  lnAryRows = (lnAryDim+(lnAryCols-1)) / lnAryCols
  lnAryDim  = lnAryDim +(lnAryCols-1)     
  lcString  = STRTRAN(lcString,lcColSep,lcSepta)
ELSE
  lnAryDim = IIF(OCCURS(lcSepta,lcString)>0,;
             OCCURS(lcSepta,lcString)+;
             IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
             lnAryDim)
ENDIF

*** Chek if second parameter array or numeric
DO CASE
  *** If no parameter found assume firest part of string
  CASE TYPE ('lnAryOrPos')='U'
    lnAryOrPos = 1

  *** If array strich it to hold all string parts
  CASE TYPE ('lnAryOrPos') $ 'C,L'    
    IF lnAryCols > 1
      DIMENSION lnAryOrPos[lnAryRows,lnAryCols]
    ELSE
      IF ALEN(lnAryOrPos,2) > 0
        DIMENSION lnAryOrPos[lnAryDim,ALEN(lnAryOrPos,2)]
      ELSE
        DIMENSION lnAryOrPos[lnAryDim]
      ENDIF  

    ENDIF
    lnAryOrPos  = ' '

ENDCASE

FOR lnArElem  = 1 TO lnAryDim
  IF TYPE ('lnAryOrPos')='N'
    lnArElem = lnAryOrPos
  ENDIF  

  DO CASE
    *** In case of firest string part
    CASE lnArElem = 1
      lcSubstr = SUBSTR(lcString,1,;
      IIF(lcSepta $ lcString,AT(lcSepta,lcString)-1,LEN(lcString)))

    *** In case of last string part
    CASE lnArElem = lnAryDim
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1)
      lcSubstr = IIF(RIGHT(lcSubstr,1)=lcSepta,;
                 SUBSTR(lcSubstr,1,LEN(lcSubstr)-1),lcSubstr)
    *** In case of any string part from the meddel
    CASE lnArElem > 1
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1,;
                 AT(lcSepta,lcString,lnArElem)-;
                 AT(lcSepta,lcString,lnArElem-1)-1)
  ENDCAS

  IF TYPE ('lnAryOrPos')='N'
    RETURN lcSubstr
  ENDIF  
  
  IF lnAryCols > 1
    lnAryOrPos[((lnArElem-1)%lnAryRows)+1,INT((lnArElem-1)/lnAryRows)+1] = lcSubstr
  ELSE
    lnAryOrPos[lnArElem] = lcSubstr
  ENDIF
ENDFOR

*!*************************************************************
*! Name      : gfPopArang
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To rearrange array from any popup
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Popup name
*!                      array name
*!                      array colum to use in sort
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*  Collect new arrangement of popup
*
*:->
FUNCTION gfPopArang
PARAMETERS lcPopNam,laArray,lnPopUpRow

lnPopUpRow = IIF(TYPE('lnPopUpRow')<>'N',1,lnPopUpRow)

IF ALEN(laArray,2) <= 1 
  DECLARE laArray[CNTBAR(lcPopNam),1]

  FOR lnCount = 1 TO CNTBAR(lcPopNam)
    laArray[lnCount]=PRMBAR(lcPopNam,GETBAR(lcPopNam,lnCount))
  ENDFOR
ELSE  
  DECLARE laTmpAry [ALEN(laArray,1),ALEN(laArray,2)]
  =ACOPY(laArray,laTmpAry)

  FOR lnCount = 1 TO CNTBAR(lcPopNam)
    
    lnSourcRow = ASCAN(laTmpAry,PRMBAR(lcPopNam,GETBAR(lcPopNam,lnCount))) 

    IF lnSourcRow > 0
      lnSourcRow = ASUBSCRIPT(laTmpAry,lnSourcRow,1)
 
      FOR  lnColum = 1 TO ALEN(laTmpAry,2)
        laArray[lnCount,lnColum] = laTmpAry[lnSourcRow,lnColum] 
      ENDFOR
 
    ENDIF

  ENDFOR

ENDIF  

*!*************************************************************
*! Name      : gfDclick
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To do some action in case of dubble click
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Key to be send to keybord buffer
*!                      Name of program to be excuted  
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfDclick
PARAMETERS lcKeyLable,llProgram

*lnSecond = INKEY("MH")
lnSecond   = 0
lnMrow     = MROW(WONTOP())
lnTimelimt = SECONDS() + _DBLCLICK	

DO WHILE SECONDS() < lnTimelimt
  lnSecond = INKEY("MH")
  IF lnSecond = 151		           && Another click was just seen.
    IF !llProgram 
      IF lnMrow = MROW(WONTOP())
        KEYBOARD lcKeyLable PLAIN CLEAR
      ENDIF  
    ELSE
      IF lnMrow = MROW(WONTOP())
        DO (lcKeyLable)     
      ENDIF  
    ENDIF
    EXIT
  ENDIF
ENDDO

*!*************************************************************
*! Name      : gpDispStat
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display the status bar at the bottom line
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GPCHNGMODL               (procedure in ARIA3.PRG)
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!      Called by: GPSCRLINES               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpDispStat

*E301077,78 Hesham (Start)
llInstUse=gfSysOpen(gcSysHome+'SYCINST')
*E301077,78 Hesham (End)
*** Clock on or off, 12 or 24 hours
DO CASE
  CASE LEFT(sycinst.cinscltyp ,2) ='12' 
    SET HOURS TO 12
    SET CLOCK TO SROWS()-1,69
    IF _DOS 
      SET CLOCK ON 
    ELSE
      SET CLOCK STATUS ON 
    ENDIF  
    gnMesgAdd = 0
  CASE LEFT(sycinst.cinscltyp ,2) ='24'
    SET HOURS TO 24
    SET CLOCK TO SROWS()-1,72
    IF _DOS 
      SET CLOCK ON 
    ELSE
      SET CLOCK STATUS ON
    ENDIF  
    gnMesgAdd = 3
  OTHERWISE
    SET CLOCK OFF
    gnMesgAdd = 12
ENDCASE
*E301077,78 Hesham (Start)
USE IN IIF(llInstUse,'SYCINST',0)
*E301077,78 Hesham (End)

IF !_DOS
  RETURN
ENDIF  

*** Readjust the space before according to the century status
gnMesgAdd =gnMesgAdd + IIF(SET('CENTURY')='ON',0,2)     

lcSavWind = WONTOP()

ACTIVATE SCREEN

*** Default status line
gcMesg_Str =SPACE(gnMesgAdd)+''+gcAct_Appl+''+gcAct_Comp +''+DTOC(Date())+''

@ SROWS()-1,0 SAY SPACE(51) + gcMesg_Str COLOR (SCHEME(1,5))

IF !EMPTY(lcSavWind)
  ACTIVATE WINDOW (lcSavWind)
ENDIF 

*!*************************************************************
*! Name      : gfAdd_Info
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To add  audit information to any file
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GFSCRINI()               (function  in ARIA3.PRG)
*!      Called by: GFSTATIC()               (function  in ARIA3.PRG)
*!      Called by: GFSEQUENCE()             (function  in ARIA3.PRG)
*!      Called by: GFCPSAVE()               (function  in ARIA3.PRG)
*!      Called by: GFSUSRPRG()              (function  in ARIA3.PRG)
*!          Calls: GFGETTIME()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : File name to add to
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Update add user,date and time
*:->
FUNCTION gfAdd_Info
PARAMETERS lcFileName
PRIVATE    lcFileName,laFields,lcSavAlias

*E301817,1 WAB (START) - add edit fields  for the audit fields 
PRIVATE    llNoEdtFld
*E301817,1 WAB (END) 

*++NAD
PRIVATE    llNoVerFld
*++NAD
lcSavAlias = SELECT(0)
IF !(TYPE ('lcFileName') $ "UL")
  SELECT (lcFileName)
ENDIF  
*E301817,1 WAB (START) 
*REPLACE cAdd_User  WITH gcUser_ID ,;
          dAdd_Date  WITH DATE()    ,;
          cAdd_Time  WITH gfGetTime()
          
*B606385,1 SSE (START)   Variable cEdit_User not found         
*llNoEdtFld = (TYPE('cEdit_USER') = 'U') .OR. (TYPE('dEdit_Date') = 'U') .OR. (TYPE('cEdit_Time') = 'U')
IF TYPE ('lcFileName') $ "NUL"
  lcFileName = ALIAS()
ENDIF  
llNoEdtFld = (TYPE(EVAL('lcFileName')+'.'+'cEdit_User') = 'U') OR (TYPE(EVAL('lcFileName')+'.'+'dEdit_Date') = 'U') OR (TYPE(EVAL('lcFileName')+'.'+'cEdit_Time') = 'U')
*B606385,1 SSE (END) 

IF EMPTY(cAdd_user)  .OR. llNoEdtFld
  REPLACE cAdd_User  WITH gcUser_ID ,;
          dAdd_Date  WITH DATE()    ,;
          cAdd_Time  WITH gfGetTime()
ELSE
  REPLACE cEdit_User  WITH gcUser_ID ,;
          dEdit_Date  WITH DATE()    ,;
          cEdit_Time  WITH gfGetTime()
ENDIF
*E301817,1 WAB (END) 

*++NAD
llNoVerFld = (TYPE(EVAL('lcFileName')+'.'+'CADD_VER') = 'U') OR (TYPE(EVAL('lcFileName')+'.'+'CEDT_VER') = 'U')

IF  !llNoVerFld

  IF EMPTY(CADD_VER)  
    REPLACE CADD_VER  WITH "A27"          
  ELSE
    REPLACE CEDT_VER  WITH "A27"  
  ENDIF

ENDIF
*+++NAD
SELECT (lcSavAlias)


*!*************************************************************
*! Name      : gfSequence
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To get new sequance number for any item
*!*************************************************************
*! Calls     : 
*!          Calls: GFADD_INFO()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Sequance type
*!                      Default sequance
*!                      Compoany ID
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*E300632,1 Change the sequence function
FUNCTION OldgfSequence
PARAMETERS lcSeqType,lnStartWith,lcCompany
PRIVATE lcSavAlias

lnRetVal    = 0
lcSeqType   = ALLTRIM(UPPER(lcSeqType))
lcSavAlias  = SELECT(0)
lnStartWith = IIF(TYPE('lnStartWith')$"UL",0,lnStartWith)
lcCompany   = IIF(TYPE('lcCompany') <>'C',gcAct_Comp,ALLTRIM(UPPER(lcCompany)))

IF !USED('SYCSEQUN')
  SELECT 0
  USE &gcSysHome.SYCSEQUN ORDER 1
ELSE
  SELECT SYCSEQUN
  SET ORDER TO 1
ENDIF

IF SEEK(lcSeqType+lcCompany,'SYCSEQUN')
  REPLACE SYCSEQUN.nSeq_No  WITH nSeq_No + 1
  lnRetVal = nSeq_No
  =gfAdd_info('SYCSEQUN') 
ELSE
  INSERT INTO &gcSysHome.SYCSEQUN (cSeq_Type,cComp_ID,nSeq_No) ;
       VALUES (lcSeqType,lcCompany,lnStartWith)
  lnRetVal = nSeq_No         
  =gfAdd_Info('SYCSEQUN')
ENDIF

IF !EMPTY(lcSavAlias)
  SELECT (lcSavAlias)
ENDIF

RETURN (lnRetVal)

*!*************************************************************
*! Name      : gfSequence                    E:300632
*! Developer : Wael Aly Mohamed
*! Date      : 03/04/1997
*! Purpose   : To get new sequance number for any item
*!*************************************************************
*! Calls     :  GFADD_INFO()
*!              gfRltFld()
*!*************************************************************
*! Passed Parameters  : Sequance type
*!                      Company ID
*!                      Group ID
*!                      Division Code
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   :  lcData[1] = gfSequence('CINVOICE')
*!*************************************************************
*! Modifications
*! E300888 06/04/98 YMA Added to generate the required code 
*!                      prefixed with a unique 2 characters 
*!                      code that representthe current site 
*!                      in case if the "CM" Communication 
*!                      module is installed.
*!B802982,1 02/01/2000 HDM Don't GET the GroupID if the system is not set to
*!                     generate seq.# based on division
*!*************************************************************
FUNCTION gfSequence

*E300894,1 06/18/98 YMA Add an optional parameter to be used to 
*E300894,1              get the sequence propirities if the original
*E300894,1              requested sequence has no associated field.
*E301488,1 12/03/2000 MAB Get PreFix Value from SETUPS FILE.
*PARAMETERS lcSeqType,lcCompanyId,lcGroupId,lcDivision
PARAMETERS lcSeqType,lcCompanyId,lcGroupId,lcDivision,lcField

*E300894,1 06/18/98 YMA End.
*B603586,1 SSH 29/02/00 Add new Private variables .
*PRIVATE lnRetVal,lcSavAlias,lcDataDir
PRIVATE lnRetVal,lcSavAlias,lcDataDir, lnOldGenNm,lcExtraStr,lcToFind,lcKeyExp

*B606902,1 Define a variable for cSeq_Chr updating in sequence file. [Begin]
PRIVATE lcChrToUpd
lcChrToUpd = CHR(0)
*B606902,1 Define a variable for cSeq_Chr updating in sequence file. [End]

*B603586,1 SSH 29/02/00 (End)
*E300894,1 06/18/98 YMA Validate the optional passed parameter.
lcField    = IIF(TYPE("lcField")="C", ALLTRIM(UPPER(lcField)), SPACE(0))
*E300894,1 06/18/98 YMA End.

lcSavAlias = SELECT(0)
lcSeqType  = UPPER(lcSeqType)
lcDataDir  = gcDataDir

*E300888 06/04/98 YMA If the communication module is installed, then
*E300888              get the unique site prefix for the active site
*E300888              from the sites file.

*E301488,1 12/03/2000 MAB Get PreFix Value from SETUPS FILE. [Begin]
*lcUnqPreFx = SPACE(0)
*IF "CM" $ gcComp_Mdl
*  USE (gcSysHome+"SYCSITES") IN 0 AGAIN ALIAS Sites ORDER cSiteID
*  lcUnqPreFx = IIF(SEEK(gcCurSite, "Sites"), Sites.cUniqStPre, lcUnqPreFx)
*  USE IN Sites
*ENDIF
PRIVATE lcCmpCode
lcCmpCode = IIF(TYPE('lcCompanyId')='C' AND !EMPTY(lcCompanyId), lcCompanyId , gcAct_Comp)
lcUnqPreFx = gfGetMemVar("M_UNQSTPRX",lcCmpCode)
*E301488,1 12/03/2000 MAB Get PreFix Value from SETUPS FILE. [End  ]

*E300888 06/04/98 YMA End.

IF TYPE('lcCompanyId')='C' AND !EMPTY(lcCompanyId) AND lcCompanyId <> gcAct_Comp
  IF USED("sycComp")
    SELECT sycComp
    luSycComp = .F.
    ltSycComp = VAL(SYS(21))
    leSycComp = RECNO()
    SET ORDER TO TAG cComp_Id IN syccomp
  ELSE
    luSycComp = .T.
    USE (gcSysHome+"syccomp") ORDER TAG cComp_Id IN 0
  ENDIF

  IF SEEK(lcCompanyId,'syccomp')
    *E301098,1 Hesham (Start)
    *lcDataDir = ALLTRIM(syccomp.cCom_dDir)
    *IF UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) = ;
    *   UPPER(SUBSTR(lcDataDir,1,ATC('\',lcDataDir,2))) AND ;
    *   UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) <>  ;
    *   UPPER(SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2)))
    *  lcDataDir= SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2))+;
    *             SUBSTR(lcDataDir,ATC('\',lcDataDir,2)+1)
    *ENDIF
    lcDataDir = gfGetDataDir(ALLTRIM(syccomp.cCom_dDir))
    *E301098,1 Hesham (End)
  ENDIF

  IF luSycComp
    USE IN syccomp
  ELSE
    SET ORDER TO TAG ltSycComp IN syccomp
    IF BETWEEN(leSycComp,1,RECCOUNT('syccomp'))
      GOTO leSycComp IN 'syccomp'
    ENDIF
  ENDIF
ENDIF

*E301046,4 Assure that lcGroupId is 3 Char. only
*lcGroupId  = IIF(TYPE('lcGroupId') ='C', ALLTRIM(lcGroupId) , SPACE(2))
lcGroupId  = IIF(TYPE('lcGroupId') ='C' , PADR(lcGroupId,3)  , SPACE(2))
*E301046,4 end
lcDivision = IIF(TYPE('lcDivision')='C',ALLTRIM(lcDivision),SPACE(10))
lnRetVal   = 0

*300632,1 Get division sequence group
*B802982,1 [start] Don't GET the GroupID if the system is not set to
*                  generate seq.# based on division
llDivOnSeq = gfgetMemvar('M_DIV_SEQ' , lcCompanyId) = 'Y'
*Change this line to check the llDivOnSeq
*IF EMPTY(lcGroupId) .AND. !EMPTY(lcDivision)
IF llDivOnSeq AND EMPTY(lcGroupId) .AND. !EMPTY(lcDivision)
*B802982,1 [End]
  DECLARE laDivDlt[1,2]
  laDivDlt[1,1] = 'DIVGROUP'
  laDivDlt[1,2] = 'lcGroupId'
  =gfRltFld(PADR(lcDivision,6),@laDivDlt,'CDIVISION')
  *E301046,4 Change lcGroupId to be 3 Char. only
  *lcGroupId = SUBSTR(lcGroupId,1,10)
  lcGroupId = SUBSTR(lcGroupId,1,3)
  *E301046,4 end
ENDIF
*B802982,1 [start] make sure the group id is empty if the system 
*                  is not set to generate seq.# based on division
*                  This case will BE FEASABLE ONLY 
*                  IF llDivOnSeq = .F.
*                  AND !EMPTY(lcGroupId)
lcGroupId = IIF(llDivOnSeq , SUBSTR(lcGroupId,1,3) , SPACE(3))
*B802982,1 [End]
IF !USED('SEQUENCE')
  luSequence = .T.
  USE &lcDataDir.SEQUENCE IN 0 ORDER TAG 'cSeq_Type'
ELSE
  SELECT SEQUENCE
  luSequence = .F.
  ltSequence = VAL(SYS(21))
  leSequence = RECNO()
  SET ORDER TO TAG Cseq_type IN SEQUENCE
ENDIF

IF !SEEK(PADR(lcSeqType,10)+lcGroupId,'SEQUENCE')
  IF !USED('sydflfld')
    luSydflfld = .T.
    USE &gcSysHome.sydflfld ORDER TAG 'Cfld_name' IN 0 SHARED
  ELSE
    SELECT Sydflfld
    luSydflfld = .F.
    ltSydflfld = VAL(SYS(21))
    leSydflfld = RECNO()
    SET ORDER TO TAG Cfld_name IN 'sydflfld'
  ENDIF
  IF !USED('sydfield')
    luSydfield = .T.
    USE &gcSysHome.sydfield ORDER TAG 'Cfld_name' IN 0 SHARED
  ELSE
    SELECT Sydfield
    luSydfield = .F.
    ltSydfield = VAL(SYS(21))
    leSydfield  = RECNO()
    SET ORDER TO TAG Cfld_name IN 'sydfield'
  ENDIF

  *E300894,1 06/18/98 YMA Use the optional field to get the sequence
  *E300894,1              proprities instead of the sequence field
  *E300894,1              if any.
  lcPropFld = IIF(EMPTY(lcField), lcSeqType, lcField)
  = SEEK(PADR(lcPropFld,10),'sydfield')
  SELECT sydflfld
  = SEEK(PADR(lcPropFld,10))
  LOCATE REST WHILE cFld_Name=PADR(lcPropFld,10) FOR lEnumerate
  
  *=SEEK(PADR(lcSeqType,10),'sydfield')
  *SELECT sydflfld
  *=SEEK(PADR(lcSeqType,10))
  *LOCATE REST WHILE cFld_Name=PADR(lcSeqType,10) FOR lEnumerate
  *E300894,1 06/18/98 YMA End.

  lnDefSeq = sydflfld.nDef_Seq
  IF !EMPTY(lcGroupId) AND SEEK(PADR(lcSeqType,10),'SEQUENCE')
    SELECT SEQUENCE
    lnDefSeq = 0
    SCAN REST WHILE cseq_type+cseq_group = PADR(lcSeqType,10)
      lnDefSeq = MAX(lnDefSeq,nSeq_No)
    ENDSCAN
    lnDefSeq = (INT(lnDefSeq/50000)+1)*50000
  ENDIF

  *B606902,4 KHM 02/09/2003 (Begin) Replacing the cSeq_Chr with CHR(0)  
  *INSERT INTO SEQUENCE (cSeq_Type,nSeq_No,cSeq_Group,cData_Typ,nFld_Wdth) ;
       VALUES (lcSeqType,lnDefSeq,lcGroupId,sydfield.cData_Typ,;
       sydfield.nFld_Wdth)

  INSERT INTO SEQUENCE (cSeq_Type,nSeq_No,cSeq_Group,cData_Typ,nFld_Wdth,cSeq_Chr) ;
       VALUES (lcSeqType,lnDefSeq,lcGroupId,sydfield.cData_Typ,;
       sydfield.nFld_Wdth,CHR(0))
  *B606902,4 KHM 02/09/2003 (End)

  IF sydflfld.lEnumerate
    IF !USED('sydfiles')
      luSydfiles = .T.
      USE &gcSysHome.sydfiles ORDER TAG 'Cfile_nam' IN 0 SHARED
    ELSE
      SELECT Sydfiles
      luSydfiles = .F.
      ltSydfiles = VAL(SYS(21))
      leSydfiles = RECNO()
      SET ORDER TO TAG Cfile_nam IN 'sydfiles'
    ENDIF
    =SEEK(sydflfld.cFile_Nam,'sydfiles')
    SELECT SEQUENCE
    REPLACE cFile_Nam WITH sydfiles.cFile_Nam ,;
            cFile_Tag WITH sydfiles.cFile_Tag
    IF luSydfiles
      USE IN Sydfiles
    ELSE
      SET ORDER TO TAG ltSydfiles IN Sydfiles
      IF BETWEEN(leSydfiles,1,RECCOUNT('Sydfiles'))
        GOTO leSydfiles IN 'Sydfiles'
      ENDIF
    ENDIF
  ENDIF
  IF luSydflfld
    USE IN Sydflfld
  ELSE
    SET ORDER TO TAG ltSydflfld IN Sydflfld
    IF BETWEEN(leSydflfld,1,RECCOUNT('Sydflfld'))
      GOTO leSydflfld IN 'Sydflfld'
    ENDIF
  ENDIF
  IF luSydfield
    USE IN Sydfield
  ELSE
    SET ORDER TO TAG ltSydfield IN Sydfield
    IF BETWEEN(leSydfield,1,RECCOUNT('Sydfield'))
      GOTO leSydfield IN 'Sydfield'
    ENDIF
  ENDIF
ENDIF
*--MAN Added RLOCK Condition[Start]
   DO WHILE !RLOCK("SEQUENCE")
   ENDDO
  lnRetVal   = SEQUENCE.nSeq_No

  *B606902,1 Get the character expression. [Begin]
  lcChrToUpd = Sequence.cSeq_Chr
  *B606902,1 Get the character expression. [End]

*--MAN Added RLOCK Condition[End]

*E300888 06/04/98 YMA Compute the required code width assuming that
*E300888              the minemum code field width = 6.
lnRetLen = SEQUENCE.nFld_Wdth - LEN(lcUnqPreFx)
*E300888 06/04/98 YMA End.
*B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.
lnOldGenNm = SEQUENCE.nSeq_No
lcExtraStr = ''
IF !EMPTY(SEQUENCE.cSeq_Chr)
  
  *B606902,1 Get the Extra string added to the file. [Begin]
  *lcExtraStr = SEQUENCE.cSeq_Chr
  PRIVATE lcChar , lnCharPos , lnI
  IF !(SEQUENCE.cSeq_Chr = CHR(0))
    IF MOD(ASC(SEQUENCE.cSeq_Chr),26) = 0
      lcChar = "Z"
      lnCharPos = ASC(SEQUENCE.cSeq_Chr)/26
    ELSE
      lcChar =  CHR(MOD(ASC(SEQUENCE.cSeq_Chr),26)+64)
      lnCharPos = INT(ASC(SEQUENCE.cSeq_Chr)/26)+1
    ENDIF  
    FOR lnI = 1 TO lnCharPos - 1
      lcExtraStr = lcExtraStr + "Z"
    ENDFOR
    lcExtraStr = lcExtraStr + lcChar
  *++NAD
  ELSE
  lcChar=""
  *++NAD
  
  ENDIF
  *B606902,1 Get the Extra string added to the file. [End]
ENDIF
*B603586,1 SSH 29/02/00 (End)

IF !EMPTY(SEQUENCE.cFile_Nam) .AND. !EMPTY(SEQUENCE.cFile_Tag)
  lcSeqFile = ALLTRIM(SEQUENCE.cFile_Nam)
  lcSeqTag  = ALLTRIM(SEQUENCE.cFile_Tag)
  IF !USED(lcSeqFile)
    luSeqFile = .T.
    *B601946,1 Use the file again to prevent 'File is in use' message
    *USE &gcDataDir.&lcSeqFile ORDER TAG (lcSeqTag) IN 0 SHARED
    USE &gcDataDir.&lcSeqFile AGAIN ORDER TAG (lcSeqTag) IN 0 SHARED 
    *B601946,1 end
  ELSE
    SELECT (lcSeqFile)
    luSeqFile = .F.
    ltSeqFile = VAL(SYS(21))
    leSeqFile = RECNO()
    SET ORDER TO TAG (lcSeqTag) IN (lcSeqFile)
  ENDIF
  SELECT (lcSeqFile)
  lcKeyField = SUBSTR(KEY(),1,AT('+'+lcSeqType,KEY())-1)
  DECLARE laVldEnt[1]

  IF !EMPTY(lcKeyField) .AND. gfGetVld(lcKeyField,@laVldEnt) > 0
    FOR lnCount = 1 TO ALEN(laVldEnt,1)
      *E300888 06/04/98 YMA Search for the generated code prefixed with
      *E300888              the unique site prefix.
      *DO WHILE SEEK(laVldEnt[lnCount,2]+PADL(lnRetVal,SEQUENCE.nFld_Wdth,'0'),lcSeqFile)
      *B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.

      *B606902,1 Check if next sequence number is valid. [Begin]
      *lcKeyExp = IIF(EMPTY(lcExtraStr),PADL(lnRetVal,lnRetLen,"0"),;
      *                                 ALLTRIM(lcExtraStr)+PADL(lnRetVal,lnRetLen-1,"0")) 
      lcKeyExp = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
      *B606902,1 Check if next sequence number is valid. [End]

      *DO WHILE SEEK(laVldEnt[lnCount,2]+lcUnqPreFx+PADL(lnRetVal,lnRetLen,"0"),lcSeqFile)
      DO WHILE SEEK(laVldEnt[lnCount,2]+lcUnqPreFx+lcKeyExp,lcSeqFile)
      *B603586,1 SSH 29/02/00  (End)
      *E300888 06/04/98 YMA End.

        *B606902,1 Check if next sequence number is valid. [Begin]
        *lnRetVal = lnRetVal + 1
        =gfGetSeq(lnRetVal,lcChrToUpd)
        *B606902,1 Check if next sequence number is valid. [End]

        *B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.
        
        *B606902,1 SSE Commented out. [Begin]
        *IF !EMPTY(lcExtraStr) .AND. lnRetVal > 99999999
        *  lcExtraStr = CHR(ASC(lcExtraStr)+1)
        *ENDIF
        *B606902,1 SSE Commented out. [End]
                
        *B606902,1 Get the new key expression. [Begin]
        *lcKeyExp = IIF(EMPTY(lcExtraStr),PADL(lnRetVal,lnRetLen,"0"),;
        *                                 ALLTRIM(lcExtraStr)+PADL(lnRetVal,lnRetLen-1,"0")) 
        lcKeyExp = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
        *B606902,1 Get the new key expression. [end]

        *B603586,1 SSH 29/02/00  (End)
      ENDDO
    ENDFOR
  ELSE  
    *E300888 06/04/98 YMA Search for the generated code prefixed with
    *E300888              the unique site prefix.
    *B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.
    
    *B606902,1 Check if next sequence number is valid. [Begin]
    *lcKeyExp = IIF(EMPTY(lcExtraStr),PADL(lnRetVal,lnRetLen,"0"),;
    *                                 ALLTRIM(lcExtraStr)+PADL(lnRetVal,lnRetLen-1,"0")) 
    lcKeyExp = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
    *B606902,1 Check if next sequence number is valid. [End]

    *DO WHILE SEEK(PADL(lnRetVal,lnRetLen,'0'),lcSeqFile)
    DO WHILE SEEK(lcKeyExp,lcSeqFile)
    *B603586,1 SSH 29/02/00  (End)
    *DO WHILE SEEK(PADL(lnRetVal,SEQUENCE.nFld_Wdth,'0'),lcSeqFile)
    *E300888 06/04/98 YMA End.

      *B606902,1 Check if next sequence number is valid. [Begin]
      *lnRetVal = lnRetVal + 1
      =gfGetSeq(lnRetVal,lcChrToUpd)
      *B606902,1 Check if next sequence number is valid. [End]

      *B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.
      
      *B606902,1 SSE Commented out. [Begin]
      *IF !EMPTY(lcExtraStr) .AND. lnRetVal > 99999999
      *  lcExtraStr = CHR(ASC(lcExtraStr)+1)
      *ENDIF
      *B606902,1 SSE Commented out. [End]
      
      *B606902,1 Get the new key expression. [Begin]
      *lcKeyExp = IIF(EMPTY(lcExtraStr),PADL(lnRetVal,lnRetLen,"0"),;
      *                                 ALLTRIM(lcExtraStr)+PADL(lnRetVal,lnRetLen-1,"0")) 
      lcKeyExp = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
      *B606902,1 Get the new key expression. [end]

      *B603586,1 SSH 29/02/00  (End)
    ENDDO
  ENDIF  
  
  IF luSeqFile
    USE IN (lcSeqFile)
  ELSE
    SET ORDER TO TAG ltSeqFile IN (lcSeqFile)
    IF BETWEEN(leSeqFile,1,RECCOUNT(lcSeqFile))
      GOTO leSeqFile IN (lcSeqFile)
    ENDIF
  ENDIF
ENDIF
SELECT SEQUENCE
*B603586,1 SSH 29/02/00  (Begin) Check if [lnRetVal+1] exceed 6 digit.
*REPLACE nSeq_No WITH lnRetVal+1
REPLACE nSeq_No WITH IIF(lnRetVal + 1 > 999999,0,lnRetVal + 1)

*B606902,1 Always check if we used Characters before. [Begin]
*REPLACE nSeq_No WITH IIF(lnRetVal + 1 > 999999,0,lnRetVal + 1)
*lnRetVal = lnRetVal + 1
*lnRetVal = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
lnOldGenNm = lcExtraStr+PADL(lnRetVal,lnRetLen-LEN(lcExtraStr),"0")
=gfGetSeq(lnRetVal,lcChrToUpd)
REPLACE nSeq_No WITH lnRetVal , cSeq_Chr WITH lcChrToUpd
*B606902,1 Always check if we used Characters before. [End]

*B603586,1 SSH 29/02/00 (End)
=gfAdd_info('SEQUENCE')
*--MAN Added RLOCK Condition[Start]

*B606902,1 SSE Commented out. [Begin]
*IF  nSeq_No = 0 .AND. lnOldGenNm <> 0
*  REPLACE cSeq_Chr WITH IIF(EMPTY(cSeq_Chr),'A',CHR(ASC(cSeq_Chr)+1))
*ENDIF
*IF !EMPTY(lcExtraStr)
*  lnRetVal = ALLTRIM(lcExtraStr) + PADL(lnRetVal,lnRetLen-1,"0")
*ENDIF
*B606902,1 SSE Commented out. [End]

*B603586,1 SSH 29/02/00  (Begin) Use the new field (cSeq_Chr) from sequence file.
IF  nSeq_No = 0 .AND. lnOldGenNm <> 0
  REPLACE cSeq_Chr WITH IIF(EMPTY(cSeq_Chr),'A',CHR(ASC(cSeq_Chr)+1))
ENDIF
IF !EMPTY(lcExtraStr)
  lnRetVal = ALLTRIM(lcExtraStr) + PADL(lnRetVal,lnRetLen-1,"0")
ENDIF
*B603586,1 SSH 29/02/00 (End)

UNLOCK
*--MAN Added RLOCK Condition[End]
*E300888 06/04/98 YMA Never return a numeric code, and return the code
*E300888              prefixed with the active site unique prefix code 
*E300888              if any.
*lnRetVal = IIF(SEQUENCE.cData_Typ='N',lnRetVal,;
                PADL(lnRetVal,SEQUENCE.nFld_Wdth,'0'))

 *B606902,1 Get the value that will be displayed in message box. [Begin]
 *lnRetVal = lcUnqPreFx + PADL(lnRetVal, lnRetLen, "0")
 lnRetVal = lcUnqPreFx + PADL(lnOldGenNm, lnRetLen, "0")
 *B606902,1 Get the value that will be displayed in message box. [End]

*E300888 06/04/98 YMA End.

IF luSequence
  USE IN Sequence
ELSE
  SET ORDER TO TAG ltSequence IN Sequence
  IF BETWEEN(leSequence,1,RECCOUNT('Sequence'))
    GOTO leSequence IN 'Sequence'
  ENDIF
ENDIF
SELECT (lcSavAlias)
RETURN(lnRetVal)


*!*************************************************************
*! Name      : gfStation
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To get the station id number of the current one
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfStation

lcStation = ALLTRIM(GETENV('P_STATION'))

IF !EMPTY(lcStation)
  lcStation = ALLTRIM(SYS(2007,lcStation))
ELSE
  lcStation = SUBSTR(SYS(3),4) 
ENDIF

RETURN (lcStation)

*!*************************************************************
*! Name      : gpScrLines
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to change the display from 25 to 50 lines
*!*************************************************************
*! Calls     : 
*!          Calls: GPDISPSTAT               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpScrLines

lcSavWind = WONTOP()
ACTIVATE SCREEN

IF SROWS()=25
  SET DISPLAY TO VGA50
ELSE 
  SET DISPLAY TO EGA25
ENDIF   

@ 1,0,SROWS(),79 BOX REPLICATE("",9)

IF !EMPTY(lcSavWind)
  ACTIVATE WINDOW (lcSavWind) SAME
ENDIF  

DO gpDispStat
  
*!*************************************************************
*! Name      : gpReLogIn
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to open the login dialog in case of relog
*!*************************************************************
*! Calls     : 
*!          Calls: GFLOG_IN()               (function  in GFLOG_IN.PRG)
*!          Calls: GPCHANGCOM               (procedure in ARIA3.PRG)
*!          Calls: GPCHNGMODL               (procedure in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : .t. in case of login
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpReLogIn
*B601919,1 Declare private variable lnCurAlias to hold the current alias
PRIVATE lnCurAlias
*B601919,1 

lcOldUser =" "
glReLogIn  = .T. 

IF gfLog_In()
  =SEEK('INI'+'OLDVARS'+lcOldUser+gcStation,'syuStatc')
  *B601919,1 Select SYUSTATC
  lnCurAlias = SELECT(0)
  SELECT syuStatc
  *B601919,1 end
  REPLACE syuStatc.cUser_ID WITH gcUser_ID
  *B601919,1 Reset alias
  SELECT (lnCurAlias)
  *B601919,1 end

  IF !EMPTY(gcAct_appl)

    lcAct_Appl = gcAct_Appl
    lcAct_Comp = IIF(!EMPTY(gcUser_Com),gcUser_Com,gcDef_Comp)
    DO gpChangCom WITH lcAct_Comp,.F.
    DO gpChngModl WITH lcAct_Appl
  ENDIF    
     *** Now we are going to collect the companies names and link it's 
     *** bars to the change company procedure
    *E301077,78 Hesham (Start)
    PRIVATE llCompUse
    llCompUse=gfSysOpen(gcSysHome+'SYCCOMP','CCOMP_ID')
*     IF !USED("SYCCOMP")
*        SELECT 0
*        USE(gcSysHome+"SYCCOMP")
*     ELSE
*        SELECT SYCCOMP
*     ENDIF
*     SET ORDER TO TAG CCOMP_ID
    *E301077,78 Hesham (End)




    lnCompBar  = 0
    *** Collect all avalilabe companies to the compamies popup
    *E301077,78 Hesham (Start)
    llPrvuse = gfSysOpen(gcSysHome+'SYUUSRPR','cuser_id')
    *E301077,78 Hesham (End)
    *B603004,1 (Start)
    SELECT SYCCOMP    
    *B603004,1 (End)
    SCAN
      lnCompBar = lnCompBar + 1
    
      IF glLog_Requ
        SELECT SYUUSRPR
        LOCATE FOR INLIST(cUser_ID,gcUser_ID,gcUser_Grp) .AND.;
                       cComp_ID = SYCCOMP.cComp_ID
                     
        SELECT SYCCOMP
            
        IF FOUND('SYUUSRPR')      
          DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name)
        ELSE
          DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name) ;
                     SKIP FOR .T. 
        ENDIF  
      ELSE
        DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name)
      ENDIF  

      lcComp_Id = '"'+cComp_Id+'"'
      ON SELECTION BAR lnCompBar OF _COMPANIES ;
                   DO gpChangCom WITH &lcComp_Id

    ENDSCAN
    *E301077,78 Hesham (Start)
    IF llPrvuse
      USE IN SYUUSRPR
    ENDIF
    *E301077,78 Hesham (End)
    *E301077,78 Hesham (Start)
    USE IN IIF(llCompUse,'SYCCOMP',0)
    *E301077,78 Hesham (End)
  =gfModalgen("INM00016B00000","DIALOG",ALLTRIM(gcUserName))
ENDIF  
glReLogIn  = .F.  

*!*************************************************************
*! Name      : gfGetTime
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : get the current time with am,pm format
*!*************************************************************
*! Calls     : 
*!      Called by: GFLOG_IN()               (function  in GFLOG_IN.PRG)
*!      Called by: GFADD_INFO()             (function  in ARIA3.PRG)
*!      Called by: GPEXIT                   (procedure in ARIA3.PRG)
*!      Called by: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : current time
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfGetTime

lcCurrHour = IIF(VAL(SUBSTR(TIME(),1,2))=12 OR VAL(SUBSTR(TIME(),1,2))=0,;
             '12',ALLTRIM(STR(VAL(SUBSTR(TIME(),1,2))%12)))
             
lcCurrTime = IIF(VAL(lcCurrHour)<10,'0','')+lcCurrHour+;
             SUBSTR(TIME(),3)+IIF(VAL(SUBSTR(TIME(),1,2))>=12,' pm',' am')
             
RETURN (lcCurrTime)             

*!*************************************************************
*! Name      : gfSeekRec
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To seek any record and open the brow,add,reenter dialog
*!*************************************************************
*! Calls     : 
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfSeekRec

lcExacStat=SET("EXACT")
lcFld_Ttl = ''
llUnique  = .F.
lcCurrObj = SYS(18)
glDobrow  = IIF(TYPE('llBrowse')<>"U",llBrowse,.F.)
SELECT (lcBaseFile)
FOR lnCount = 1 TO ALEN(laKeyField,1)
  IF SUBSTR(laKeyField[lnCount,1],8, ATC(']',laKeyField[lnCount,1]) -8);
    = SUBSTR(SYS(18),8, ATC(')',SYS(18))-8)
    IF laKeyField[lnCount,2]
      llUnique = .T.
    ENDIF
    lcSeekTag = laKeyField[lnCount,3]
    SET ORDER TO TAG (lcSeekTag)
    lcSeekExp = laKeyField[lnCount,1]
    lnCount1  = laKeyField[lnCount,4]

    lcFld_Nam = gfSubStr(SYS(14,VAL(SYS(21))),lnCount1,'+') 
    lnFld_pos = ASCAN(laField_N,lcFld_Nam) 

    IF lnFld_pos > 0 
      lcFld_Ttl=PROPER(laField_H[lnFld_pos])+" :" 
    ELSE
      lcFld_Ttl=lcFld_Nam +" :"
    ENDIF    

    DO WHILE lnCount1 > 1
      lnCount1 = lnCount1 -1

      FOR lnCount = 1 TO ALEN(laKeyField,1) 
        IF laKeyField[lnCount,3] = lcSeekTag .AND.;
          laKeyField[lnCount,4] = lnCount1
          lcSeekExp = laKeyField[lnCount,1] + "+" + lcSeekExp  
          lcFld_Nam = gfSubStr(SYS(14,VAL(SYS(21))),lnCount1,'+') 
          lnFld_pos = ASCAN(laField_N,lcFld_Nam) 

          IF lnFld_pos > 0 
            lcFld_Ttl=PROPER(laField_H[lnFld_pos])+"\"+lcFld_Ttl
          ELSE
            lcFld_Ttl=lcFld_Nam +"\"+lcFld_Ttl
          ENDIF    

          EXIT && FOR loop
        ENDIF
      ENDFOR
    ENDDO
    EXIT && FOR loop
  ENDIF
ENDFOR


IF llUnique
 SET EXACT ON 
 IF SEEK(&lcSeekExp)
    laScrMode   = .F.
    laScrMode[2]= .T.
    SCATTER FIELDS &lcScFields MEMO TO laData
  ELSE
    
    IF RECNO(0) >0 .AND. RECNO(0) <= RECCOUNT()
      GO RECNO(0)
    ELSE
      GO TOP
    ENDIF
    
 
    IF TYPE(lcSeekExp) ='C' 
      IF ALLTRIM(&lcSeekExp) ='?' .OR. glDobrow
        lnOption = 1
      ELSE
        *E300647,1 Hesham El-Sheltawi (Start)
        *E300647,1 Add new button to the control panel
        *E300647,1 if the program is using the new button then
        *E300647,1 make the message Browse Reenter
        *E300647,1 else make it Browse Add Reenter
        *IF glAutoAdd
        *  lnOption = 2
        *ELSE
        *  lnOption = gfModalGen('QRM00001B00001','Dialog',lcFld_Ttl+" "+ALLTRIM(&lcSeekExp))
        *ENDIF  

        *E301469,1 AMH Alow Addation only for not History Company [Start]
        *IF TYPE('LLALOWNEW')='U' OR llAlowNew = .F.
        IF (TYPE('LLALOWNEW')='U' OR llAlowNew = .F.) .AND. ;
           IIF(EMPTY(gcAct_Comp),.T.,!(gfGetMemVar('LLHIST',gcAct_Comp)))
        *E301469,1 AMH Alow Addation only for not History Company [End  ]

          IF glAutoAdd
            lnOption = 2
          ELSE
            lnOption = gfModalGen('QRM00001B00001','Dialog',lcFld_Ttl+" "+ALLTRIM(&lcSeekExp))
          ENDIF  
        ELSE
          lnOption = gfModalGen('QRM00001B00014','Dialog',lcFld_Ttl+" "+ALLTRIM(&lcSeekExp))
          lnOption = lnOption+IIF(lnOption=2,1,0)
        ENDIF  
        *E300647,1 Hesham El-Sheltawi (End)        
      ENDIF  
    ELSE
      *E300647,1 Hesham El-Sheltawi (Start)
      *E300647,1 Add new button to the control panel
      *E300647,1 if the program is using the new button then
      *E300647,1 make the message Browse Reenter
      *E300647,1 else make it Browse Add Reenter
      *IF glAutoAdd
      *  lnOption = 2
      *ELSE
      *  lcFieldCon = ALLTRIM(STR(&lcSeekExp))
      *  lnOption   = gfModalGen('QRM00001B00001','Dialog',lcFld_Ttl+" "+lcFieldCon) 
      *ENDIF  

      *E301469,1 AMH Alow Addation only for not History Company [Start]
      *IF TYPE('LLALOWNEW')='U' OR llAlowNew = .F.
      IF (TYPE('LLALOWNEW')='U' OR llAlowNew = .F.) .AND. ;
         IIF(EMPTY(gcAct_Comp),.T.,!(gfGetMemVar('LLHIST',gcAct_Comp)))
      *E301469,1 AMH Alow Addation only for not History Company [End  ]

        IF glAutoAdd
          lnOption = 2
        ELSE
          lcFieldCon = ALLTRIM(STR(&lcSeekExp))
          lnOption   = gfModalGen('QRM00001B00001','Dialog',lcFld_Ttl+" "+lcFieldCon) 
        ENDIF  
      ELSE  
        lcFieldCon = ALLTRIM(STR(&lcSeekExp))      
        lnOption = gfModalGen('QRM00001B00014','Dialog',lcFld_Ttl+" "+lcFieldCon)
        lnOption = lnOption+IIF(lnOption=2,1,0)
      ENDIF  
      *E300647,1 Hesham El-Sheltawi (End)      
    ENDIF
    

    DO CASE
      CASE lnOption = 1
        DO WHILE .T.
          IF OCCURS('+',lcSeekExp) = 0
            SET EXACT &lcExacStat          
            =gfBrows()
            RETURN
          ENDIF
          lcSeekExp = IIF(OCCURS('+',lcSeekExp)<>0,;
                          LEFT(lcSeekExp,RAT('+',lcSeekExp)-1),;
                          lcSeekExp)
          IF SEEK(ALLTRIM(&lcSeekExp))
            EXIT
          ENDIF
        ENDDO
        SET EXACT &lcExacStat
        =gfBrows(lcSeekExp)
        RETURN

      CASE lnOption = 2
          IF !llAddRec
          =gfModalGen("TRM00088B00000","ALERT",'Adding') 
        ELSE
          lcCrFiler = SET('FILTER')
          IF EMPTY(lcCrFiler)
            laScrMode = .F.
            laScrMode[4]=.T.
          ELSE
            SET FILTER TO 
            IF SEEK(&lcSeekExp)
              =gfModalGen("TRM00096B00000","ALERT") 
            ELSE
              laScrMode = .F.
              laScrMode[4]=.T.
            ENDIF
            SET FILTER TO &lcCrFiler   
          ENDIF  
        ENDIF 
      CASE lnOption = 3
        SCATTER FIELDS &lcScFields MEMO TO laData  BLANK
        FOR lnkey = 1 TO ALEN(laKeyField,1)
          SHOW GET &laKeyField[lnkey,1]
        ENDFOR
        _CUROBJ = OBJNUM(&laKeyField[1,1])
        SET EXACT &lcExacStat
        RETURN
    ENDCASE
  ENDIF
  SET EXACT &lcExacStat
  SHOW GETS
ELSE
  DO WHILE !SEEK(&lcSeekExp)
    IF OCCURS('+',lcSeekExp) = 0
      lnOption = gfModalGen('INM00001B00000','Dialog',lcFld_Ttl+" "+&lcSeekExp) 
      _CUROBJ  = OBJNUM(&lcCurrObj)
      SET EXACT &lcExacStat      
      RETURN
    ENDIF
    lcSeekExp = LEFT(lcSeekExp,RAT('+',lcSeekExp)-1)
    IF SEEK(ALLTRIM(&lcSeekExp))
       EXIT
    ENDIF
  ENDDO
  SET EXACT &lcExacStat  
  =gfBrows(lcSeekExp)
  RETURN
ENDIF

SET EXACT &lcExacStat  

*!*************************************************************
*! Name      : gfADel
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To delete a colum or row from array
*!*************************************************************
*! Calls     : 
*!      Called by: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : array name
*!                      number of colum or row to be deleted
*!                      1 -> row  / 2 -> colum   
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfADel
FUNCTION x_gfADel
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS laDel,lnDelWch,lnSubScrp

*B601481,1 This line was added by HS [Begin]
PRIVATE laTemp
*B601481,1 This line was added by HS [End]

lnSubScrp=IIF(TYPE("lnSubScrp") $ "UL",1,lnSubScrp)
DO CASE
  CASE lnSubScrp=1
    =ADEL(laDel,lnDelWch)
    IF ALEN(laDel,2)<>0
      IF ALEN(laDel,1)>1
        DIMENSION laDel[ALEN(laDel,1)-1,ALEN(laDel,2)]
      ENDIF  
    ELSE
      IF ALEN(laDel,1)>1
        DIMENSION laDel[ALEN(laDel,1)-1,1]
      ENDIF  
    ENDIF
    RETURN .T.
  CASE lnSubScrp=2
    DIMENSION laTemp[ALEN(laDel,1),ALEN(laDel,2)-1]
    FOR I=0 TO ALEN(laDel,1)-1
      IF lnDelWch>1 .AND. lnDelWch<ALEN(laDel,2)
        =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+1,lnDelWch-1,i*ALEN(laTemp,2)+1)
        =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+lnDelWch+1,ALEN(laDel,2)-lnDelWch,;
              i*ALEN(laTemp,2)+lnDelWch)
      ELSE
        IF lnDelWch=1
          =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+2,ALEN(laDel,2)-1,i*ALEN(laTemp,2)+1)
        ELSE
          =ACOPY(laDel,laTemp,i*ALEN(laDel,2)+1,Alen(laDel,2)-1,i*ALEN(laTemp,2)+1)
        ENDIF        
      ENDIF        
    ENDFOR
   DIMENSION laDel[ALEN(laTemp,1),ALEN(laTemp,2)]
   RETURN (ACOPY(laTemp,laDel)>0)
ENDCASE

*!*************************************************************
*! Name      : gfAAppend
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to append elements to any array from another one
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : target array 
*!                      source srray
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfAAppend
PARAMETERS laToApp,laToAppFrm
EXTERNAL ARRAY laToAppFrm

FOR A=1 TO ALEN(laToAppFrm,1) 
  IF ASCAN(laToApp,UPPER(laToAppFrm[I]))=0 .AND.;
   !EMPTY(laToAppFrm[I])
  
    IF !EMPTY(laToApp[1])
      DIMENSION laToApp[ALEN(laToApp,1)+1]
      =AINS(laToApp,ALEN(laToApp))
    ENDIF  
    laToApp[ALEN(laToapp)]=UPPER(laToAppFrm[I])
  ENDIF
ENDFOR

*!*************************************************************
*! Name      : gfTempName
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Creat temp file name
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*FUNCTION gfTempName
*E301164,1 Hesham (Start)
*E301164,1 store all temprory files created by the program 
*lcRetName = ("X"+SUBSTR(SYS(2015),4))
*IF TYPE('laPrgTemps')#'U' 
*  IF !EMPTY(laPrgTemps[1])
*    DIMEN laPrgTemps[ALEN(laPrgTemps,1)+1,1]
*  ELSE  
*    DIMEN laPrgTemps[1,1]  
*  ENDIF
*  laPrgTemps[ALEN(laPrgTemps,1),1] = lcRetName
*ENDIF
*RETURN lcRetName
*RETURN ("X"+SUBSTR(SYS(2015),4))
*E301164,1 Hesham (End)


*!*************************************************************
*! Name      : gfTempName
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Creat temp file name
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfTempName
FUNCTION x_gfTempName
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
*E301164,1 Hesham (Start)
*E301164,1 store all temprory files created by the program 
lcRetName = ("X"+SUBSTR(SYS(2015),4))

*B606953,1 AMH Fix bug of gfTempName create temp names of currently exist files [Start]
IF TYPE('gcWorkDir') = 'C'
  DO WHILE FILE(gcWorkDir+lcRetName+'.DBF')
    lcRetName = ("X"+SUBSTR(SYS(2015),4))
  ENDDO
ENDIF 
*B606953,1 AMH [End]

IF TYPE('laPrgTemps')#'U' 
  IF !EMPTY(laPrgTemps[1])
    DIMEN laPrgTemps[ALEN(laPrgTemps,1)+1,1]
  ELSE  
    DIMEN laPrgTemps[1,1]  
  ENDIF
  laPrgTemps[ALEN(laPrgTemps,1),1] = lcRetName
ENDIF
RETURN lcRetName
*RETURN ("X"+SUBSTR(SYS(2015),4))
*E301164,1 Hesham (End)

*!*************************************************************
*! Name      : gfTogling
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : not used anymore
*!*************************************************************
*! Calls     : 
*!          Calls: GFTOGLEBAR()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : bar number
*!                      bar prompt
*!                      
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfTogling
PARAMETERS lcPopName,lcBarPrm,lcBarRep,lcBarRep1,lcInsct
&lcInsct=!&lcInsct
gfTogleBar(lcPopName,lcBarPrm,lcBarRep,lcBarRep1,&lcInsct)

*!*************************************************************
*! Name      : gfTogleBar
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : not used anymore
*!*************************************************************
*! Calls     : 
*!      Called by: GFTOGLING()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfTogleBar
PARAMETERS lcPopName,lcBarPrm,lcBarRep,lcBarRep1,llInsct
lcMsgToCh=UPPER(lcBarPrm)

IF EMPTY(lcBarRep) OR TYPE("lcBarRep") $ "LU"
  RETURN
ENDIF

IF !EMPTY(lcBarRep1) AND !(TYPE("lcBarRep") $ "LU")
  FOR lnCount=1 TO CNTBAR((lcPopName))
    IF GETBAR((lcPopName),lnCount)=lnCount
      IF SUBSTR(UPPER(PRMBAR((lcPopName),lnCount)),1,LEN(lcMsgToCh))=lcMsgToCh
        DEFINE BAR lnCount OF (lcPopName) PROMPT ;
        SUBSTR(PRMBAR((lcPopName),lnCount),1,LEN(lcMsgToCh))+;
        IIF(llInsct,lcBarRep,lcBarRep1)
      ENDIF
    ENDIF  
  ENDFOR
ELSE
  FOR lnCount=1 TO CNTBAR((lcPopName))
    IF GETBAR((lcPopName),lnCount)=lnCount
      IF SUBSTR(UPPER(PRMBAR((lcPopName),lnCount)),1,LEN(lcMsgToCh))=lcMsgToCh
        DEFINE BAR lnCount OF (lcPopName) PROMPT ;
        SUBSTR(PRMBAR((lcPopName),lnCount),1,LEN(lcMsgToCh))+lcBarRep
      ENDIF   
    ENDIF  
  ENDFOR  
ENDIF

*!*************************************************************
*! Name      : gfDbfField
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : To build the browse field names in string from dectionary
*!*************************************************************
*! Calls     : 
*!      Called by: GFSCRINI()               (function  in ARIA3.PRG)
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*  RETURN THE HEADER FOR THE FIELDS USED IN THE BROWSING
*:->
FUNCTION gfDbfField
PARAMETER lcDbfName

lcDbfName = ALLTRIM(UPPER(lcDbfName))

lcSavAlias=SELECT(0)
lcBrFields=''
llFilesByP=.F.
llFieldByP=.F.
llFlFldByP=.F.

IF USED("sydFlFld")
  SELECT sydflfld 
  lnFlFldRec=IIF(RECNO()>RECCOUNT(),0,RECNO())
ELSE
  llFlFldByP=.T.
  SELECT 0
  USE &gcSysHome.sydFlFld.dbf
ENDIF  

set order to tag cfile_nam

IF USED("sydField")
  SELECT sydfield 
  lnFldRec=IIF(RECNO()>RECCOUNT(),0,RECNO())
ELSE
  llFieldByP=.T.
  SELECT 0
  USE &gcSysHome.sydField.dbf
ENDIF  
set order to tag cfld_name

IF USED("sydFiles")
  SELECT sydfiles 
   lnFileRec=IIF(RECNO()>RECCOUNT(),0,RECNO())
ELSE
  llFilesByP=.T.
  SELECT 0
  USE &gcSysHome.sydFiles.dbf
ENDIF  
set order to tag cfile_nam

**********************************************************
IF SEEK(lcDbfName)

  lcbrFields=ALLTRIM(mbrow_fld)

  IF !EMPTY(lcBrFields)
    DIMENSION laHead[1]
    = gfSubStr(lcbrFields,@laHead,"|")
    SELECT sydField
    lcBrFields=""
    FOR lnCount=1 TO ALEN(laHead,1)
      laHead[lnCount] = UPPER(ALLTRIM(laHead[lnCount]))
      IF SEEK (laHead[lnCount],"sydfield")
      *E300631,1 YMA 04/06/97 Changed the lookup to use the "CODES"
      *E300631,1 YMA 04/06/97 instead of "SYCCodes"
*       lcBrFields=lcBrFields+laHead[lnCount]+;
*                  IIF(lvldEntry,'=LOOKUP(SYCCODES.cDiscrep,gcAct_Comp+'+lcDbfName;
*                  +'.'+laHead[lnCount]+',SYCCODES.cCode_No,"CODES")';
*                  ,'')+IIF(EMPTY(sydfield.cFld_Head),' ,'," :H='"+;
*                  ALLTRIM(sydfield.cFld_Head)+"',")

        *E300789,1 Heaham (Start)
        *lcBrFields=lcBrFields+laHead[lnCount]+;
                   IIF(lvldEntry,'=LOOKUP(CODES.cDiscrep,gcAct_Comp+'+lcDbfName;
                   +'.'+laHead[lnCount]+',CODES.cCode_No,"CODES")';
                   ,'')+IIF(EMPTY(sydfield.cFld_Head),' ,'," :H='"+;
                   ALLTRIM(sydfield.cFld_Head)+"',")

        lcBrFields=lcBrFields+laHead[lnCount]+;
                   IIF(lvldEntry,'=LOOKUP(CODES.cDiscrep,'+['N'+]+lcDbfName;
                   +'.'+laHead[lnCount]+',CODES.cCode_No,"CODES")';
                   ,'')+IIF(EMPTY(sydfield.cFld_Head),' ,'," :H='"+;
                   ALLTRIM(sydfield.cFld_Head)+"',")

        *E300789,1 Heaham (End)
        *E300631,1 YMA 04/06/97 End.
      ENDIF            

    ENDFOR
    lcBrFields=SUBSTR(lcBrFields,1,LEN(lcBrFields)-1)           
  *********************************************************************
  ELSE    
    SELECT sydFlFld
    SEEK lcDbfName
    SCAN REST WHILE cFile_nam=lcDbfName
      IF SEEK(UPPER(cFld_Name),"sydField")
        IF !(ALLTRIM(sydField.cFld_Name) $ "CADD_USER,CADD_TIME,DADD_DATE,LLOK_STAT"+;
                                 ",CLOK_USER,DLOK_DATE,CLOK_TIME")

          *E300631,1 YMA 04/06/97 Changed the lookup to use the "CODES"
          *E300631,1 YMA 04/06/97 instead of "SYCCodes"
*         lcBrFields=lcBrFields+ALLTRIM(sydFlFld.cFld_Name)+;
*              IIF(sydField.lvldEntry,'=LOOKUP(SYCCODES.cDiscrep,gcAct_Comp+'+lcDbfName;
*              +'.'+ALLTRIM(sydFlFld.cFld_Name)+',SYCCODES.cCode_No,"CODES")';
*              ,'')+IIF(EMPTY(sydField.cFld_Head),' ,'," :H='"+;
*                ALLTRIM(sydField.cFld_Head)+"',")
          *E300789,1 Heaham (Start)
          *lcBrFields=lcBrFields+ALLTRIM(sydFlFld.cFld_Name)+;
               IIF(sydField.lvldEntry,'=LOOKUP(CODES.cDiscrep,gcAct_Comp+'+lcDbfName;
               +'.'+ALLTRIM(sydFlFld.cFld_Name)+',CODES.cCode_No,"CODES")';
               ,'')+IIF(EMPTY(sydField.cFld_Head),' ,'," :H='"+;
                 ALLTRIM(sydField.cFld_Head)+"',")
        
          lcBrFields=lcBrFields+ALLTRIM(sydFlFld.cFld_Name)+;
               IIF(sydField.lvldEntry,'=LOOKUP(CODES.cDiscrep,'+['N'+]+lcDbfName;
               +'.'+ALLTRIM(sydFlFld.cFld_Name)+',CODES.cCode_No,"CODES")';
               ,'')+IIF(EMPTY(sydField.cFld_Head),' ,'," :H='"+;
                 ALLTRIM(sydField.cFld_Head)+"',")

        *E300789,1 Heaham (Start)
        *E300631,1 YMA 04/06/97 End.

        ENDIF           
      ENDIF          
    ENDSCAN
    lcBrFields=SUBSTR(lcBrFields,1,LEN(lcBrFields)-1)             
  ENDIF
ENDIF


IF llFilesByP
  USE IN sydFiles
ELSE
 SELECT sydFiles
 IF lnFileRec > 0 
   GO lnFileRec
 ENDIF  
ENDIF
IF llFieldByP
  USE IN sydField
ELSE
  SELECT sydField
  IF lnFldRec > 0
    GO lnFldRec
  ENDIF  
ENDIF
IF llFlFldByP
  USE IN sydFlFld
ELSE
 SELECT sydFlFld
 IF lnFlFldRec > 0 
   GO lnFlFldRec
 ENDIF  
ENDIF

SELECT(lcSavAlias)
RETURN lcBrFields

*!*************************************************************
*! Name      : gfObj_Lock
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To object lock any record in any file
*!*************************************************************
*! Calls     : 
*!      Called by: GFCPDELETE()             (function  in ARIA3.PRG)
*!      Called by: GFCPEDIT()               (function  in ARIA3.PRG)
*!      Called by: GFCPSAVE()               (function  in ARIA3.PRG)
*!      Called by: GFCPCLOSE()              (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFGETTIME()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : flage to lock or unlock
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfObj_Lock
PARAMETERS lLok_Set
PRIVATE lnRecNo,lRet_Flag

*B605239,1 BWA 23/12/2001 Declare variable to hold old value of reprocess.[START]
PRIVATE lnOldrpSt
*B605239,1 BWA 23/12/2001.[END]

lRet_Flag = .F.
lLok_It   = .F.
llLocked  = .F.
*** Go to the same record to get a fresh copy in the buffer
lnRecNo = RECNO()

DO WHILE .T.

  IF lnRecNo <= RECCOUNT()
    GO lnRecNo
   llLocked = RLOCK() 
   IF DELETED()
     UNLOCK
     =gfModalGen('INM00095B00000','ALERT')
     laScrMode     = .F.
     laScrMode [1] = .T.

     SHOW GETS
     RETURN .F.
   ENDIF
   
  ENDIF  

  *** Chek if the record is in use by another user
  IF lLok_Set 
    *** Chek if the field cLok_User in the structur
    IF !lLok_Stat .AND. llLocked
      *** Record is not locked you may lock it
      lLok_It   = .T.
    ELSE
      IF !EMPTY(cLok_User)
        IF ALLTRIM(cLok_User) = ALLTRIM(gcUser_ID)
          *!600396,1 Messaging the user that he cannot edit the same record
          *!600396,1 from more than one session and permit him from editing
          *!600396,1 the same record
          IF gfModalGen("INM00240B00006","ALERT")=2
            lLok_It    = .F.
            lRet_Flag  = .F.
          ELSE      
            lLok_It    = .T.
          ENDIF
        ELSE  
          *B605239,1 BWA 23/12/2001 We save old value of reprocess first.[START]
          lnOldrpSt = SET('REPROCESS')
          SET REPROCESS TO 1
          *B605239,1 BWA 23/12/2001.[END]
          IF SEEK ('INI'+'OLDVARS'+cLok_User,'syuStatc') 
            IF RLOCK('syuStatc')
              UNLOCK IN  syuStatc 
              GO gnMyStRec IN syuStatc 
              =RLOCK('syuStatc')
              lLok_It    = .T.
            ELSE
              UNLOCK

              *** Display the message "Record is in use by user AAAA"
              lnSavRec   = IIF(RECNO('SYUUSER')>RECCOUNT('SYUUSER'),0,;
                           RECNO('SYUUSER'))
              lcLok_User = ALLTRIM(PROPER(LOOKUP(syuUser.cUsr_name,cLok_User,;
                           syuUser.cUser_id,'cUser_id')))
              IF lnSavRec > 0
                GO lnSavRec IN SYUUSER
              ENDIF  
          
              *** Record is in use by user ????    
              IF  gfModalGen("INM00028B00015","ALERT",lcLok_User) = 1
                LOOP
              ENDIF  
              lLok_It    = .F.
              lRet_Flag  = .F.
            ENDIF
          ELSE
            lLok_It    = .T. 
          ENDIF          
          *B605239,1 BWA 23/12/2001 Return the old value of reprocess.[START]
          SET REPROCESS TO  lnOldrpSt
          *B605239,1 BWA 23/12/2001.[END]
        ENDIF
      ELSE
        *** Display the message "Record is in use by another"
        IF gfModalGen("INM00029B00015","ALERT") = 1
          LOOP
        ENDIF  
        lLok_It    = .F.
        lRet_Flag  = .F.
      ENDIF   
    ENDIF

  ELSE
    *** Chek if these three field in the file structur
    IF TYPE ('cLok_User') <> "U" .AND. ;
       TYPE ('dLok_Date') <> "U" .AND. ;
       TYPE ('cLok_Time') <> "U" 

      *** Unlock the record
      REPLACE lLok_Stat WITH .F. , ;   
              cLok_User WITH ""  , ;
              dLok_Date WITH {}  , ;
              cLok_Time WITH ""
      lRet_Flag  = .T.
    ENDIF  
  ENDIF

  EXIT
ENDDO

*** Chek if you have to lock the record or not
IF lLok_It  
  *** Chek if these three field in the file structur
  IF TYPE ('cLok_User') <> "U" .AND. ;
     TYPE ('dLok_Date') <> "U" .AND. ;
     TYPE ('cLok_Time') <> "U" 
    *** Lock the record for this user with date and time
    REPLACE lLok_Stat WITH .T.       , ;   
             cLok_User WITH gcUser_ID , ;
             dLok_Date WITH DATE()    , ;
             cLok_Time WITH gfGetTime()

    lRet_Flag  = .T.    
  ENDIF
ENDIF


UNLOCK


RETURN lRet_Flag


*!*************************************************************
*! Name      : gpCtrlShow
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To handle the enabled/disabled buttons in the pannel
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Name of local show function
*!                      Flag to run the local function  
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*! Modifications:
*!              C101425,1 HDM 03/18/1999 Control Notepad button 
*!                         1- Disable Notepad Button In Select Mode
*!                         2- Change its BMP According to 
*!                            &lcBaseFile..lHasNotes Value
*!                            IF .T. Notes2.bmp
*!                            IF .F. Notes2_f.bmp
*!                         3- NotePad Button has the element 13
*!                            in LACTRSTAT Array
*!*************************************************************
*:->>
PROCEDURE gpCtrlShow
PARAMETERS gcLoclShow,glDoLocal
EXTERNAL ARRAY laData,laScrMode,laKeyField,laCntrlObj,laWobjects,laCtrStat
EXTERNAL PROCEDURE lpShow

*--HDM C101425[Start] 03/18/1999 Define These Private variables
PRIVATE lnLastPos , lnStarPos , lnTagNo
STORE '' TO lnLastPos , lnStarPos
STORE 1 TO lnTagNo
*--HDM C101425[End]


glDoLocal = IIF(TYPE('glDoLocal')='U',.F.,glDoLocal)
IF TYPE('lcFolder')='C' AND SYS(2016)=lcFolder
  RETURN
ENDIF
*** Dont show the objects if comming to the screen as first entry
*** just enable and disable the bars in the record popup
IF llNoShow
  llNoShow = .F.

  DO CASE
    *** Entring in select mode
    CASE laScrMode[1]
      FOR lnObjcnt = 1 TO ALEN(laWobjects,1)
        IF UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'K'
          lcKeyObj = laWobjects[lnObjcnt,1]
          EXIT
        ENDIF  
      ENDFOR
      IF TYPE('lcKeyObj') = 'C' AND !EMPTY(lcKeyObj)
         _CUROBJ = OBJNUM(&lcKeyObj)
      ENDIF   
  ENDCASE      
      
  IF laScrMode[1] .OR. laScrMode[2]
    DEFINE BAR 52 OF P01PU01 PROMPT "\<Close" ;
           SKIP FOR IIF(TYPE('LACTRSTAT')='U',.T.,LACTRSTAT[12]="DISABLE")      
  ELSE
    DEFINE BAR 52 OF P01PU01 PROMPT "\<Cancel" ;
           SKIP FOR IIF(TYPE('LACTRSTAT')='U',.T.,LACTRSTAT[12]="DISABLE")      
  ENDIF
  *E300610,1 Hesham El-Sheltawi (Start)
  *E300610,1 if the new push button is used by the program then enable it
  *E300610,1 otherwise disable it
  IF laScrMode[1]  .OR. laScrMode[2]   

    *E301469,1 AMH Disable the new push button for History Company [Start]
    *laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec,"DISABLE","ENABLE")
    laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec OR;
                     IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
    *E301469,1 AMH Disable the new push button for History Company [End  ]

    SHOW GET pbCpNew,1  &laCtrStat[5]
  ENDIF
  *E300610,1 Hesham El-Sheltawi (End)
  IF glDoLocal .AND. !EMPTY(gcLoclShow)
    DO (gcLoclShow)
  ENDIF  

  RETURN

ENDIF  

*E301469,1 AMH Not alow edit and add mode for History Company [Start]
IF laScrMode[4] .AND. !EMPTY(gcAct_Comp) .AND. gfGetMemVar('LLHIST',gcAct_Comp)
  =gfModalGen("TRM00000B00000","DIALOG","ARIA Advantage Series",.F.,"You cannot add any record in a history company.")
  laScrMode = .F.
  laScrMode[1] = .T.
ENDIF

IF laScrMode[3] .AND. !EMPTY(gcAct_Comp) .AND. gfGetMemVar('LLHIST',gcAct_Comp)
  =gfModalGen("TRM00000B00000","DIALOG","ARIA Advantage Series",.F.,"You cannot edit any record in a history company.")
  laScrMode = .F.
  laScrMode[2] = .T.
ENDIF
*E301469,1 AMH [End]

*** Set the objects enable/disable status for
*** key fields, branshing buttons, normal objects
lcKeyEnDs = IIF(laScrMode[1],"ENABLE","DISABLE") 
lcObjEnDs = IIF(laScrMode[1].OR.laScrMode[2],"DISABLE","ENABLE")
lcBrnEnDs = IIF(laScrMode[1],"DISABLE","ENABLE")
lcKeyObj  = " " 
*E300704,1 Hesham El-Sheltawi (Start)
*E300704,1 check if the program have a base file or not 
*E300704,1 before SCATTERING THE DATA
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
  IF laScrMode[1] 
    SCATTER FIELDS &lcScFields MEMO TO laData BLANK
  ENDIF
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
*** Screen objectes
IF llglobShow
  FOR lnObjcnt = 1 TO ALEN(laWobjects,1)
    *** If the object refreshing is not controled from the program
    IF laWobjects[lnObjcnt,2]    

      DO CASE
        *** Key fields
        CASE UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'K'
          SHOW GET &laWobjects[lnObjcnt,1] &lcKeyEnDs

          IF EMPTY(lcKeyObj)
            lcKeyObj = laWobjects[lnObjcnt,1]
          ENDIF  

        *** Branshing buttons  
        CASE UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'B'
          SHOW GET &laWobjects[lnObjcnt,1] &lcBrnEnDs

        *** Objects disabled all the time  
        CASE UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'D'
          SHOW GET &laWobjects[lnObjcnt,1] DISABLE
      
        *** Objects enabled all the time
        CASE UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'E'
          SHOW GET &laWobjects[lnObjcnt,1] ENABLE

        *** Any other objects
        OTHERWISE 
          SHOW GET &laWobjects[lnObjcnt,1] &lcObjEnDs
      ENDCASE
    ENDIF
  ENDFOR
ELSE
  FOR lnObjcnt = 1 TO ALEN(laWobjects,1)
    IF UPPER(LEFT(laWobjects[lnObjcnt,3],1)) = 'K'
      lcKeyObj = laWobjects[lnObjcnt,1]
      EXIT
    ENDIF  
  ENDFOR
ENDIF


*** Navigation buttons
DO CASE
  *** Selecting view mode
*E300704,1 Hesham El-Sheltawi (Start)
*E300704,1 check if the program have a base file or not 
*E300704,1 before SCATTERING THE DATA
*  CASE laScrMode[2] 
  CASE laScrMode[2] AND !EMPTY(lcBaseFile)
*E300704,1 Hesham El-Sheltawi (END)  
    *** Check the position of the current record
    lnOldRec = RECNO()
    *B607021,1 NNA 05/03/2004 (Begin) if Not End of File Move to the next Record
    IF !EOF()
    *B607021,1 NNA (End)
      SKIP 1
    *B607021,1 NNA 05/03/2004 (Begin) End Of IF Statement
    ENDIF
    *B607021,1 NNA (End)    
    llEof = EOF()
    *E500442,5 ABD - Speed up the globel PROCEDURE gpCtrlShow , we will not
    *E500442,5 ABD - Use Skip -2  , because if you have any filter 
    *E500442,5 ABD - It will take a huge time to show the data . [Begin]
    *SKIP -2
    *llBof = BOF()
    LOCATE
    llBof = .F.
    IF lnOldRec = RECNO()
       llBof = .T. 
    ENDIF
    *E500442,5 ABD - [End]

    IF lnOldRec <=RECCOUNT()
      GO lnOldRec
    ENDIF

    DO CASE
      *** Record is the only record in the file
      CASE llBof .AND. llEof  
        *** First button
        SHOW GET pbTop   DISABLE
        laCtrStat[1]  =  "DISABLE" 

        *** Last button
        SHOW GET pbBtm   DISABLE
        laCtrStat[2]  =  "DISABLE" 

        *** Next button
        SHOW GET pbNxt   DISABLE
        laCtrStat[3]  =  "DISABLE" 
    
        *** Privious button
        SHOW GET pbPrvs  DISABLE
        laCtrStat[4]  =  "DISABLE" 

      *** Top record   
      CASE llBof
        *** First button
        SHOW GET pbTop   DISABLE
        laCtrStat[1]  =  "DISABLE" 

        *** Last button
        SHOW GET pbBtm   ENABLE
        laCtrStat[2]  =  "ENABLE" 

        *** Next button
        SHOW GET pbNxt   ENABLE
        laCtrStat[3]  =  "ENABLE" 
    
        *** Privious button
        SHOW GET pbPrvs  DISABLE
        laCtrStat[4]  =  "DISABLE" 

      *** Last record  
      CASE llEof
        *** First button
        SHOW GET pbTop   ENABLE
        laCtrStat[1]  =  "ENABLE" 

        *** Last button
        SHOW GET pbBtm   DISABLE
        laCtrStat[2]  =  "DISABLE" 

        *** Next button
        SHOW GET pbNxt   DISABLE
        laCtrStat[3]  =  "DISABLE" 
    
        *** Privious button
        SHOW GET pbPrvs  ENABLE
        laCtrStat[4]  =  "ENABLE" 
      
      *** Any other record  
      OTHERWISE
        *** First button
        SHOW GET pbTop   ENABLE
        laCtrStat[1]  =  "ENABLE" 

        *** Last button
        SHOW GET pbBtm   ENABLE
        laCtrStat[2]  =  "ENABLE" 

        *** Next button
        SHOW GET pbNxt   ENABLE
        laCtrStat[3]  =  "ENABLE" 
    
        *** Privious button
        SHOW GET pbPrvs  ENABLE
        laCtrStat[4]  =  "ENABLE" 
    ENDCASE   

  *** Select / Edit / Add modes
  OTHERWISE
    *** First button
    SHOW GET pbTop   DISABLE
    laCtrStat[1]  =  "DISABLE" 

    *** Last button
    SHOW GET pbBtm   DISABLE
    laCtrStat[2]  =  "DISABLE" 

    *** Next button
    SHOW GET pbNxt   DISABLE
    laCtrStat[3]  =  "DISABLE" 
    
    *** Privious button
    SHOW GET pbPrvs  DISABLE
    laCtrStat[4]  =  "DISABLE" 
    
ENDCASE


*** Other buttons
DO CASE
  *** Select mode
  CASE laScrMode[1]
   IF TYPE('lcKeyObj') = 'C' AND !EMPTY(lcKeyObj)
    _CUROBJ = OBJNUM(&lcKeyObj)
   ENDIF 
    *** New button
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300610,1 if the new push button is used by the program then enable it
    *E300610,1 otherwise disable it

    *E301469,1 AMH Disable the new push button for History Company [Start]
    *laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec,"DISABLE","ENABLE")
    laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec OR;
                     IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
    *E301469,1 AMH Disable the new push button for History Company [End  ]

    SHOW GET pbCpNew,1  &laCtrStat[5]
    *E300610,1 Hesham El-Sheltawi (End)    
    
    *** Print buttons
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300647,1 disable the print push button in the control panel it
    laCtrStat[6]  =  "DISABLE"     
    SHOW GET pbCpPrint  DISABLE
    *E300610,1 Hesham El-Sheltawi (End)
    
    *** Edit button
    SHOW GET pbEdt   DISABLE
    laCtrStat[7]  =  "DISABLE" 
    
    *** Delete button
    SHOW GET pbDlt   DISABLE
    laCtrStat[8]  =  "DISABLE" 

    *** Select button    
    SHOW GET pbSlct  DISABLE
    laCtrStat[9]  =  "DISABLE" 
    
    *** Browse button
  *E300704,1 Hesham El-Sheltawi (Start)
  IF !EMPTY(lcBaseFile)
    SHOW GET pbBrws  ENABLE
    laCtrStat[10]  =  "ENABLE" 
  ELSE  
    SHOW GET pbBrws  DISABLE
    laCtrStat[10]  =  "DISABLE" 
  ENDIF  
  *E300704,1 Hesham El-Sheltawi (END)    
    *** Save button 
    SHOW GET pbSav,1   DISABLE 
    *#IF _DOS
    *    SHOW GET pbSav,1   DISABLE PROMPT "\<Save"
    *#ENDIF
        
    laCtrStat[11]  =  "DISABLE" 
    
    *** Close button
    SHOW GET pbCls,1   ENABLE 
    
    *#IF _DOS
    *  IF SUBSTR(WLAST(),1,2) = "CW"
    *    SHOW GET pbCls,1  PROMPT "\<Close" 
    *  ELSE
    *    SHOW GET pbCls,1  PROMPT "\!\?\<Close" 
    *  ENDIF   
    *#ELSE 
         SHOW GET pbCls,1  PROMPT "Close.BMP"
    *#ENDIF

    laCtrStat[12]  =  "ENABLE" 
    DEFINE BAR 52 OF P01PU01 PROMPT "\<Close" ;
           SKIP FOR IIF(TYPE('LACTRSTAT')='U',.T.,LACTRSTAT[12]="DISABLE")      

    *-- C101425,1 HDM 03/18/1999[Start] Check If Notepad Button Displayed
    *-- C101425,1 HDM 03/18/1999 Just Disable it and make the bitmap 'notes2.bmp'
    
    IF TYPE('lcBaseFile')='C'.AND. !EMPTY(lcBaseFile) .AND. TYPE(lcBaseFile+'.lHasNotes') = "L"
      SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2.BMP"
      SHOW GET pbNotePad DISABLE
    ENDIF
  
    IF ALEN(laCtrStat,1) >= 13
      laCtrStat[13]  =  "DISABLE" 
    ENDIF  
    *-- C101425,1 HDM 03/18/1999[End]
    
    *E301299,1 Add these lines to control the Audit Trail button [Begin]
    *-- If the screen module is anything accept the report generator
    IF gcWinAppl <> 'RG'
      *-- Check if the Audit Trail button is displayed
      IF !EMPTY(lcSydKey)
        *-- Disable the Audit Trail button
        SHOW GET pbAudTrail DISABLE
        laCtrStat[15] = "DISABLE"
      ENDIF    && End of IF !EMPTY(lcSydKey)
    ENDIF    && End of IF gcWinAppl <> 'RG'
    *E301299,1 Add these lines to control the Audit Trail button [End]

  *** View mode
  CASE laScrMode[2]

    *** new button
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300610,1 if the new push button is used by the program then enable it
    *E300610,1 otherwise disable it

    *E301469,1 AMH Disable the new push button for History Company [Start]
    *laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec,"DISABLE","ENABLE")
    laCtrStat[5]  =  IIF(TYPE('LLALOWNEW')='U' OR llAlowNew = .F. OR !llAddRec OR;
                     IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
    *E301469,1 AMH Disable the new push button for History Company [End  ]

    SHOW GET pbCpNew,1  &laCtrStat[5]  
    *E300610,1 Hesham El-Sheltawi (End)    
    
    *** Print buttons
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300647,1 ENABLE the PRINT push button in the control panel it
    SHOW GET pbCpPrint  ENABLE
    laCtrStat[6]  =  "ENABLE" 
    *E300610,1 Hesham El-Sheltawi (End)    

    *** Edit button
    *E301469,1 AMH Disable the Edit button for History Company [Start]
    *SHOW GET pbEdt   ENABLE
    *laCtrStat[7]  =  "ENABLE" 
    laCtrStat[7]   = IIF(IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
    SHOW GET pbEdt &laCtrStat[7]
    *E301469,1 AMH [End]
    
    *** Delete button
    *E301469,1 AMH Disable the Delete button for History Company [Start]
    *SHOW GET pbDlt   ENABLE
    *laCtrStat[8]  =  "ENABLE" 
    laCtrStat[8]  = IIF(IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
    SHOW GET pbDlt   &laCtrStat[8]
    *E301469,1 AMH [End]

    *** Select button    
    SHOW GET pbSlct  ENABLE
    laCtrStat[9]  =  "ENABLE" 
    
    *** Browse button
    *E300704,1 Hesham El-Sheltawi (Start)
    IF !EMPTY(lcBaseFile)
      SHOW GET pbBrws  ENABLE
      laCtrStat[10]  =  "ENABLE" 
    ELSE  
      SHOW GET pbBrws  DISABLE
      laCtrStat[10]  =  "DISABLE" 
    ENDIF  
    *E300704,1 Hesham El-Sheltawi (END)    
    
    *** Save button 
    SHOW GET pbSav,1   DISABLE 
    
    *#IF _DOS
    *    SHOW GET pbSav,1   DISABLE PROMPT "\<Save"
    *#ENDIF
        
    laCtrStat[11]  =  "DISABLE" 
    
    *** Close button
    SHOW GET pbCls,1   ENABLE 

    *#IF _DOS
    *  IF SUBSTR(WLAST(),1,2) = 'CW' .OR. glChildTop
    *    SHOW GET pbCls,1  PROMPT "\<Close"            
    *  ELSE
    *    SHOW GET pbCls,1  PROMPT "\!\?\<Close"      
    *  ENDIF  
    *#ELSE  
        SHOW GET pbCls,1  PROMPT "Close.BMP"
    *#ENDIF
    laCtrStat[12]  =  "ENABLE" 
    DEFINE BAR 52 OF P01PU01 PROMPT "\<Close" ;
           SKIP FOR IIF(TYPE('LACTRSTAT')='U',.T.,LACTRSTAT[12]="DISABLE")      


    *-- C101425,1 HDM 03/18/1999[Start] Check If Notepad Button Displayed Enable It
    *-- C101425,1 HDM 03/18/1999        Change Its BMP Accoding to lHasNotes Value
    
    IF TYPE('lcBaseFile')='C' .AND. !EMPTY(lcBaseFile) .AND. TYPE(lcBaseFile+'.lHasNotes') = "L"
      
      IF &lcBaseFile..lHasNotes
        SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2_F.BMP"
      ELSE
        IF ATC('*',lcSydKey) <> 0
          lnStarPos = ATC('*',lcSydKey)
          lcNoteKey = ALLTRIM(SUBSTR(lcSydKey,lnStarPos+1))

          lnLastPos = ATC('|',lcNoteKey)
          *--GET TAG NUMBER
          IF lnLastPos <> 0
            lnTagNo = gfGetTagNo(lcBaseFile,ALLTRIM(SUBSTR(lcNoteKey,lnLastPos + 1)))
            *lnTagNo   = INT(VAL(SUBSTR(lcNoteKey,lnLastPos + 1)))
            lcNoteKey = SUBSTR(lcNoteKey,1,lnLastPos - 1)
          ENDIF
        ELSE
          lcNoteKey = SUBSTR(lcSydKey,2)

          lnLastPos = ATC('|',lcNoteKey)
          *--GET TAG NUMBER
          IF lnLastPos <> 0
            lnTagNo = gfGetTagNo(lcBaseFile,ALLTRIM(SUBSTR(lcNoteKey,lnLastPos + 1)))
            *lnTagNo   = INT(VAL(SUBSTR(lcNoteKey,lnLastPos + 1)))
            lcNoteKey = SUBSTR(lcNoteKey,1,lnLastPos - 1)
          ENDIF
          
        ENDIF
        lcXNoteKey = EVAL(lcNoteKey)

        lnXPrevAl = SELECT(0)
        SELECT (lcBaseFile)
        lnNotexRec = RECNO()
        *Renee
        *GO TOP
        PRIVATE lcRushKey,lnCurBFTag
        lnCurBFTag = VAl(SYS(21))
        lcRushKey  = KEY(lnTagNo)
        SET ORDER TO 
        *LOCATE FOR EVAL(KEY(lnTagNo)) = lcXNoteKey
        LOCATE FOR &lcRushKey. = lcXNoteKey
        SET ORDER TO (lnCurBFTag)

        IF FOUND()
          IF lHasNotes = .T.
            SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2_F.BMP"
          ELSE
            SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2.BMP"
          ENDIF
        ENDIF
        IF BETWEEN(lnNotexRec,1,RECCOUNT(lcBaseFile))
          GO (lnNotexRec) IN (lcBaseFile)
        ENDIF
        SELECT (lnXPrevAl)
      ENDIF
    ENDIF    
    
    
    
    IF ALEN(laCtrStat,1) >= 13
      *E301469,1 AMH Disable the Delete button for History Company [Start]
      *SHOW GET pbNotePad ENABLE
      *laCtrStat[13]  =  "ENABLE"           
      *SHOW GET pbNotePad &laCtrStat[13]
      *B606731,1 NAD (Start)
      *laCtrStat[13]  = IIF(IIF(EMPTY(gcAct_Comp),.F.,gfGetMemVar('LLHIST',gcAct_Comp)),"DISABLE","ENABLE")
      SHOW GET pbNotePad ENABLE
      laCtrStat[13]  =  "ENABLE"
      *B606731,1 NAD (END)
      *E301469,1 AMH [End]
    ENDIF  
    
    *-- C101425,1 HDM 03/18/1999[End]

    *E301299,1 Add these lines to control the Audit Trail button [Begin]
    *-- If the screen module is anything accept the report generator
    IF gcWinAppl <> 'RG'
      *-- Check if the Audit Trail button is displayed
      IF !EMPTY(lcSydKey)
        *-- Enable the Audit Trail button
        SHOW GET pbAudTrail ENABLE
        laCtrStat[15] = "ENABLE"
      ENDIF    && End of IF !EMPTY(lcSydKey)
    ENDIF    && End of IF gcWinAppl <> 'RG'
    *E301299,1 Add these lines to control the Audit Trail button [End]

  *** Edit or add mode
  CASE laScrMode[3] .OR. laScrMode[4]
    *** New button
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300647,1 disable the new push button in the control panel it
    SHOW GET pbCpNew  DISABLE
    laCtrStat[5]  =  "DISABLE" 
    *E300610,1 Hesham El-Sheltawi (End)    
    *** Print buttons
    *E300610,1 Hesham El-Sheltawi (Start)
    *E300647,1 Enable the Print push button in the control panel it
    *E300647,1 if we are in the edit mode else disable it
    laCtrStat[6]  =  IIF( laScrMode[3],"ENABLE" ,'DISABLE')
    SHOW GET pbCpPrint  &laCtrStat[6]
    *E300610,1 Hesham El-Sheltawi (End)    
    *** Edit button
    SHOW GET pbEdt   DISABLE
    laCtrStat[7]  =  "DISABLE" 
    
    *** Delete button
    SHOW GET pbDlt   DISABLE
    laCtrStat[8]  =  "DISABLE" 

    *** Select button    
    SHOW GET pbSlct  DISABLE
    laCtrStat[9]  =  "DISABLE" 
    
    *** Browse button
    SHOW GET pbBrws  DISABLE
    laCtrStat[10]  =  "DISABLE" 
    
    *** Save button 
    SHOW GET pbSav,1   ENABLE 
    *#IF _DOS
    *  IF SUBSTR(WLAST(),1,2) <> "CW"
    *    SHOW GET pbSav,1   ENABLE PROMPT "\!\<Save"
    *  ENDIF  
    *#ENDIF
        
    laCtrStat[11]  =  "ENABLE" 
    
    *** Close button
    SHOW GET pbCls,1   ENABLE  
    *#IF _DOS
    *  IF SUBSTR(WLAST(),1,2) = "CW"
    *    SHOW GET pbCls,1  PROMPT "\<Cancel"
    *  ELSE
    *    SHOW GET pbCls,1  PROMPT "\?\<Cancel"
    *  ENDIF  
    *#ELSE
        SHOW GET pbCls,1  PROMPT "Cancel.BMP"      
    *#ENDIF
    laCtrStat[12]  =  "ENABLE" 
    DEFINE BAR 52 OF P01PU01 PROMPT "\<Cancel" ;
           SKIP FOR IIF(TYPE('LACTRSTAT')='U',.T.,LACTRSTAT[12]="DISABLE")

    *-- C101425,1 HDM 03/18/1999[Start] -Check If Notepad Button Displayed Enable It
    *-- C101425,1 HDM 03/18/1999        in Edit Mode And Disable it in add mode
    *-- C101425,1 HDM 03/18/1999        -Change Its BMP Accoding to lHasNotes Value
    
    IF TYPE('lcBaseFile')='C'.AND. !EMPTY(lcBaseFile) .AND. TYPE(lcBaseFile+'.lHasNotes') = "L"
      IF laScrMode[3]
        
        IF &lcBaseFile..lHasNotes
          SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2_F.BMP"
        ELSE
          IF ATC('*',lcSydKey) <> 0
            lnStarPos = ATC('*',lcSydKey)
            lcNoteKey = ALLTRIM(SUBSTR(lcSydKey,lnStarPos+1))

            lnLastPos = ATC('|',lcNoteKey)
            *--GET TAG NUMBER
            IF lnLastPos <> 0
              lnTagNo = gfGetTagNo(lcBaseFile,ALLTRIM(SUBSTR(lcNoteKey,lnLastPos + 1)))
              *lnTagNo   = INT(VAL(SUBSTR(lcNoteKey,lnLastPos + 1)))
              lcNoteKey = SUBSTR(lcNoteKey,1,lnLastPos - 1)
            ENDIF
          ELSE

            lnLastPos = ATC('|',lcNoteKey)
            *--GET TAG NUMBER
            IF lnLastPos <> 0
              lnTagNo = gfGetTagNo(lcBaseFile,ALLTRIM(SUBSTR(lcNoteKey,lnLastPos + 1)))
              *lnTagNo   = INT(VAL(SUBSTR(lcNoteKey,lnLastPos + 1)))
              lcNoteKey = SUBSTR(lcNoteKey,1,lnLastPos - 1)
            ENDIF

          ENDIF
          lcXNoteKey = EVAL(lcNoteKey)
  
          lnXPrevAl = SELECT(0)
          SELECT (lcBaseFile)
          lnNotexRec = RECNO()
          *Renee
          *GO TOP
          PRIVATE lcRushKey,lnCurBFTag
          lnCurBFTag = VAl(SYS(21))
          lcRushKey  = KEY(lnTagNo)
          SET ORDER TO 
          *LOCATE FOR EVAL(KEY(lnTagNo)) = lcXNoteKey
          LOCATE FOR &lcRushKey. = lcXNoteKey
          SET ORDER TO (lnCurBFTag)

          IF FOUND()
            IF lHasNotes = .T.
              SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2_F.BMP"
            ELSE
              SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2.BMP"
            ENDIF
          ENDIF
          GO (lnNotexRec) IN (lcBaseFile)
          SELECT (lnXPrevAl)
      
          *SHOW GET pbNotePad,1  PROMPT gcBMPHome + "Notes2.BMP"
        ENDIF
        IF ALEN(laCtrStat,1) >= 13
          SHOW GET pbNotePad ENABLE
          laCtrStat[13]  =  "ENABLE"
        ENDIF
      ELSE
        IF laScrMode[4]
          SHOW GET pbNotePad DISABLE
          IF ALEN(laCtrStat,1) >= 13
            laCtrStat[13]  =  "DISABLE"
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    *-- C101425,1 HDM 03/18/1999[End]

    *E301299,1 Add these lines to control the Audit Trail button [Begin]
    *-- If the screen module is anything accept the report generator
    IF gcWinAppl <> 'RG'
      *-- Check if the Audit Trail button is displayed
      IF !EMPTY(lcSydKey)
        *-- If Edit mode
        IF laScrMode[3]
          *-- Enable the Audit Trail button
          SHOW GET pbAudTrail ENABLE
          laCtrStat[15] = "ENABLE"
        ELSE   && Else (If Add mode)
          *-- Disable the Audit Trail button
          SHOW GET pbAudTrail DISABLE
          laCtrStat[15] = "DISABLE"
        ENDIF    && End of IF laScrMode[3]
      ENDIF    && End of IF !EMPTY(lcSydKey)
    ENDIF    && End of IF gcWinAppl <> 'RG'
    *E301299,1 Add these lines to control the Audit Trail button [End]

ENDCASE

*C101459,1 Hesham (Start)
*B603273,1 [Start] Fixing bug of Alias '' Not found
*B603273,1 we have to check that lcBaseFile is not empty as well
*IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
   TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)
IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
   TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)    AND ;
   !EMPTY(lcBaseFile)
*B603273,1 [End]
  laCtrStat[14] = IIF(laScrMode[1],"DISABLE",'ENABLE')                && user define fields  button 
  SHOW GET pbUsrFields &laCtrStat[14]
  SELECT (lcBaseFile)
  DO CASE
    CASE laScrMode[1]
      FOR lnUsrFld = 1 TO ALEN(laUsrFields,1)
        *B603158,1 Assign default values according to data type [Begin]
        *laUsrFields[lnUsrFld,6] = ''
        DO CASE
          CASE laUsrFields[lnUsrFld,3] = "C"
            laUsrFields[lnUsrFld,6] = ''
            
          CASE laUsrFields[lnUsrFld,3] = "N"
            laUsrFields[lnUsrFld,6] = 0
            
          CASE laUsrFields[lnUsrFld,3] = "L"
            laUsrFields[lnUsrFld,6] = .F.
            
          *B606866,1 Reset the date type. [Begin]
          CASE laUsrFields[lnUsrFld,3] = "D"
            *B607973,1 TMI [START] remove the bug B131469
            **B131469,1 HBG 02/04/2006 Fix bug of not checking if there is value in this user defined fields befor 
            **B131469,1                reseting it to cover the case of calling the screen from another screen [Begin]
            *IF EMPTY(laUsrFields[lnUsrFld,6]) 
            **B131469,1 [End]
            *B607973,1 TMI [END  ]
            
              laUsrFields[lnUsrFld,6] = ''
              
            *B607973,1 TMI [START] remove the bug B131469
            **B131469,1 HBG 02/04/2006 Fix bug of not checking if there is value in this user defined fields befor 
            **B131469,1                reseting it to cover the case of calling the screen from another screen [Begin]
            **ENDIF
            **B131469,1 [End]
            *B607973,1 TMI [END]
          *B606866,1 Reset the date type. [End]  
            
        ENDCASE
        *B603158,1 Assign default values according to data type [End  ]
      ENDFOR
    CASE laScrMode[2] OR laScrMode[3]
      FOR lnUsrFld = 1 TO ALEN(laUsrFields,1)
        laUsrFields[lnUsrFld,6] = EVAL(laUsrFields[lnUsrFld,1])
      ENDFOR
    *B604016,1 MHM 11/14/2000 [START]
    CASE  laScrMode[4]
      FOR lnUsrFld = 1 TO ALEN(laUsrFields,1)
        DO CASE
          CASE laUsrFields[lnUsrFld,3] = "C"
            IF EMPTY(laUsrFields[lnUsrFld,6])
              laUsrFields[lnUsrFld,6] = ''
            ENDIF  
          CASE laUsrFields[lnUsrFld,3] = "N"
            IF EMPTY(laUsrFields[lnUsrFld,6]) 
              laUsrFields[lnUsrFld,6] = 0
            ENDIF           
          CASE laUsrFields[lnUsrFld,3] = "L"
            IF EMPTY(laUsrFields[lnUsrFld,6]) 
              laUsrFields[lnUsrFld,6] = .F.            
            ENDIF
            
          *B606866,1 Reset the date type. [Begin]
          CASE laUsrFields[lnUsrFld,3] = "D"
            *B607973,1 TMI [START] remove the bug B131469
            **B131469,1 HBG 02/04/2006 Fix bug of not checking if there is value in this user defined fields befor 
            **B131469,1                reseting it to cover the case of calling the screen from another screen [Begin]
            **IF EMPTY(laUsrFields[lnUsrFld,6]) 
            **B131469,1 [End]
            *B607973,1 TMI [END  ] 
            
              laUsrFields[lnUsrFld,6] = ''
            
            *B607973,1 TMI [START] remove the bug B131469
            **B131469,1 HBG 02/04/2006 Fix bug of not checking if there is value in this user defined fields befor 
            **B131469,1                reseting it to cover the case of calling the screen from another screen [Begin]
            **ENDIF
            **B131469,1 [End]
            *B607973,1 TMI [END  ] 
            
          *B606866,1 Reset the date type. [End]  
        
        ENDCASE
      ENDFOR
     *B604016,1 MHM 11/14/2000 [END]
  ENDCASE
ENDIF
*C101459,1 Hesham (End)

*E300610,1 Hesham El-Sheltawi (Start)
*E300647,1 disable the print push button in the control panel it
IF TYPE('lcReportID') # 'C' OR EMPTY(lcReportID)
    laCtrStat[6]  =  "DISABLE"     
    SHOW GET pbCpPrint  DISABLE
ENDIF    
*E300610,1 Hesham El-Sheltawi (End)

IF !EMPTY(gcLoclShow)
  DO (gcLoclShow)
ENDIF  
RETURN
*-- end of gpCtrlShow. (CANCEL)

*!*************************************************************
*! Name      : gfCPTop
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the top button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: LPTOPSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push button
*
*:->
FUNCTION  gfCPTop
EXTERNAL ARRAY laData,laDefProc
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  ACTIVATE WINDOW GWCCONTRL1 TOP
  SELECT (lcBaseFile)
  *E500442,5 ABD - It will take a huge time to go to first recored n case that there are a filter
  *E500442,5 ABD - We will use locate in state of GO TOP. [Begin]
  *GO TOP
  LOCATE
  *E500442,5 ABD - [End]

  IF laDefProc[1]
    SCATTER FIELDS &lcScFields MEMO TO laData
  ELSE
    DO lpTopScr
  ENDIF

  SHOW GETS
ENDIF  
*E300704,1 Hesham El-Sheltawi (END)
*!*************************************************************
*! Name      : gfCPBttm
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the bottom button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: LPBTMSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push bottom
*:->
FUNCTION gfCPBttm
EXTERNAL ARRAY laData,laDefProc
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  ACTIVATE WINDOW GWCCONTRL1 TOP
  SELECT (lcBaseFile)

  GO BOTTOM
  IF laDefProc[2]
    SCATTER FIELDS &lcScFields MEMO TO laData
  ELSE
    DO lpBtmScr
  ENDIF
  SHOW GETS
ENDIF
*E300704,1 Hesham El-Sheltawi (END)

*!*************************************************************
*! Name      : gfCPNext
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of next button in the pannel
*!*************************************************************
*! Calls     : 
*!           Calls: LPNXTSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Next
*
*:->
FUNCTION gfCPNext
EXTERNAL ARRAY laData,laDefProc
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  ACTIVATE WINDOW GWCCONTRL1 TOP
  SELECT (lcBaseFile)


  SKIP 
  IF laDefProc[3]
    SCATTER FIELDS &lcScFields MEMO TO laData
  ELSE
    DO lpNxtScr
  ENDIF
  SHOW GETS
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
*!*************************************************************
*! Name      : gfCPPrvis
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the prvios button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: LPPRVSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push previous
*:->
FUNCTION gfCPPrvis
EXTERNAL ARRAY laData,laDefProc
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  ACTIVATE WINDOW GWCCONTRL1 TOP
  SELECT (lcBaseFile)


  SKIP -1
  IF laDefProc[4]
    SCATTER FIELDS &lcScFields MEMO TO laData
  ELSE
    DO lpPrvScr
  ENDIF
  SHOW GETS
ENDIF
*E300704,1 Hesham El-Sheltawi (END)

*!*************************************************************
*! Name      : gfCPSelect
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the select button in the pannel
*!*************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Select
*:->
FUNCTION gfCPSelect
EXTERNAL ARRAY laScrMode
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  ACTIVATE WINDOW GWCCONTRL1 TOP
  SELECT (lcBaseFile)


  laScrMode    = .F.
  laScrMode[1] = .T.

  SCATTER FIELDS &lcScFields MEMO TO laData BLANK
ELSE
  laScrMode    = .F.
  laScrMode[1] = .T.
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
SHOW GETS

*!*************************************************************
*! Name      : gfvCpNew 
*! Developer : Hesham El-Sheltawi
*! Date      : 04/10/97
*! Purpose   : Validation of the New button in the pannel
*!*************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel New push Select
*:->E300647,1 Hesham El-Sheltawi
*E300647,1 New push button in control pannel allowed only if the variable
*E300647,1 llAlowNew is .t.
FUNCTION gfvCpNew 
ACTIVATE WINDOW GWCCONTRL1 TOP
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
  SCATTER FIELDS &lcScFields MEMO TO laData BLANK
ENDIF  
*E300704,1 Hesham El-Sheltawi (END)
laScrMode    = .F.
laScrMode[4] = .T.


IF TYPE('laWndObj') ="C" 
  IF !EMPTY(laWndObj[1,1])
    lnWindNum = ASCAN(laWndObj,WLAST())
    IF lnWindNum >0
      _CUROBJ = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),2])
    ELSE
      _CUROBJ      = 1
    ENDIF
  ELSE  
    _CUROBJ      = 1
  ENDIF
ELSE
  _CUROBJ      = 1
ENDIF
    
SHOW GETS


*!*************************************************************
*! Name      : gfCPBrows
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the browse button in the pannel
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel browse button
*:->
FUNCTION gfCPBrows

SELECT (lcBaseFile)
=gfBrows()

*!*************************************************************
*! Name      : gfCPDelete
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the delete button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!          Calls: LPDELSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Delete
*:->
FUNCTION gfCPDelete
EXTERNAL ARRAY laData,laDefProc,laScrMode

ACTIVATE WINDOW GWCCONTRL1 TOP
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
lcDelMesag = IIF(TYPE('lcDelMesag')='C',lcDelMesag,'delete')
*E300842,1 Hesham (Start)
*E300842,1 check if the current site is the owner of the record before
*E300842,1 deleting it
*IF !llDeleRec
IF !llDeleRec OR IIF(TYPE('COWNER')#'C',.F.,IIF(EMPTY(COWNER),.F.,COWNER<>gcCurSite))
*E300842,1 Hesham (End)
*E300842,1 Hesham (Start)
*E300842,1 give the user the right message if he do not have privl. to delete
*E300842,1 the record or if he is not the owner of the record
*    =gfModalGen("TRM00088B00000","ALERT",'Deleting') 
  IF !llDeleRec
    =gfModalGen("TRM00088B00000","ALERT",'Deleting') 
  ELSE
    =gfModalGen("TRM00299B00000","ALERT",'Deleted')
  ENDIF  
*E300842,1 Hesham (eND)  
ELSE
  IF gfModalGen("QRM00002B00006","ALERT",lcDelMesag) = 1
    IF EMPTY(lcBaseFile) OR gfObj_Lock(.T.)
      IF laDefProc[7]
        *E300704,1 Hesham El-Sheltawi (Start)
        IF !EMPTY(lcBaseFile)
          SCATTER FIELDS &lcScFields MEMO TO laData BLANK
          GATHER FROM laData FIELDS &lcScFields MEMO 
          DELETE
        ENDIF  
        *E300704,1 Hesham El-Sheltawi (END)
        laScrMode    = .F.
        laScrMode[1] = .T.
      ELSE  
        DO lpDelScr
        *B600447,1 Check whether the record was deleted
        *B600447,1 if not then unlock the record
        IF laSCrMode[2]
          *E300704,1 Hesham El-Sheltawi (Start)
          IF !EMPTY(lcBaseFile)
            =gfObj_Lock(.F.)
          ENDIF  
          *E300704,1 Hesham El-Sheltawi (END)          
        ENDIF
      ENDIF
     
      *E301297,1 Change these lines because we are going to use one function
      *          called gfDoTriger() to control any triggers (customized
      *          process and workflow server requests including creating
      *          new project) found in the triggers file [Begin]
      **E300775,1 Hesham (Start)
      **E300775,1 if the workflow module is installed for the company
      **E300775,1 then call the global function to control the workflow
      **E300775,1 data
      *IF 'WF' $ gcCmpModules
      *  =gfCtrlFlow(SUBSTR(gcProg_Nam,4),'DELETE')    
      *ENDIF  
      
      *-- If the Deletion/Cancellation action was complete successfully
      IF ASCAN(laEvntTrig , PADR('DELETE' , 10)) <> 0 .AND.;
         (laScrMode[1] = .T. .OR.;
          (TYPE('lcBaseFile') = 'C' .AND. !EMPTY(lcBaseFile) .AND.;
           TYPE(ALLTRIM(lcBaseFile) + '.Status') = 'C' .AND.;
           EVALUATE(ALLTRIM(lcBaseFile) + '.Status') = 'X'))
        *B603210,1 MAN-WAB -'gcProg_nam' is not a global variable that hold the 
        *B603210,1         active prog. so we use the gcbasewin cause it is hold
        *B603210,1         the active prog name start from pos no 4
        *=gfDoTriger(SUBSTR(gcProg_Nam,4) , 'DELETE') 
        =gfDoTriger(SUBSTR(gcBaseWind,4) , 'DELETE') 
      ENDIF    && End of IF ASCAN(laEvntTrig , PADR('DELETE' , 10)) <> 0
      **E300775,1 Hesham (End)
      *E301297,1 Change these lines because we are going to use one [End]
     
      SHOW GETS
    ENDIF  
  ENDIF
ENDIF

*!*************************************************************
*! Name      : gfCPEdit
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of edit button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Edit
*:->
FUNCTION gfCPEdit
EXTERNAL ARRAY laData,laDefProc,laScrMode

ACTIVATE WINDOW GWCCONTRL1 TOP


IF TYPE('lcBaseFile') = "C" 
  IF !EMPTY(lcBaseFile)
    SELECT (lcBaseFile)
  ENDIF
ENDIF


llUpDate=.F.
*E300842,1 Hesham (Start)
*E300842,1 check if the current site is the owner of the record before
*E300842,1 editing it
*IF !llEditRec
IF !llEditRec OR IIF(TYPE('COWNER')#'C',.F.,IIF(EMPTY(COWNER),.F.,COWNER<>gcCurSite))
*E300842,1 Hesham (End)
*E300842,1 Hesham (Start)
*E300842,1 give the user the right message if he do not have privl. to Edit
*E300842,1 the record or if he is not the owner of the record
*  =gfModalGen("TRM00088B00000","ALERT",'Editing') 
  IF !llEditRec 
    =gfModalGen("TRM00088B00000","ALERT",'Editing') 
  ELSE
    =gfModalGen("TRM00299B00000","ALERT",'Modified')
  ENDIF  
ELSE
  *E300704,1 Hesham El-Sheltawi (Start)
  IF EMPTY(lcBaseFile) OR gfObj_Lock(.T.)
  *E300704,1 Hesham El-Sheltawi (ENDIF)  
    *** Befor edit get fresh copy from the record 
  *E300704,1 Hesham El-Sheltawi (Start)
  IF !EMPTY(lcBaseFile)
    SCATTER FIELDS &lcScFields MEMO TO laData
    lcStamp       =  cAdd_User+IIF(EMPTY(dAdd_Date),'',DTOC(dAdd_Date))+;
                     cAdd_Time
  ENDIF                  
  *E300704,1 Hesham El-Sheltawi (END)
    laScrMode    = .F.                  && Reset screen mode
    laScrMode[3] = .T.                  && Go to edit mode
    IF TYPE('laWndObj') ="C" 
       IF !EMPTY(laWndObj[1,1])
         lnWindNum = ASCAN(laWndObj,WLAST())
         IF lnWindNum >0
           _CUROBJ = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),2])
         ELSE
           _CUROBJ      = 1
         ENDIF
       ELSE  
         _CUROBJ      = 1
       ENDIF
    ELSE
      _CUROBJ      = 1
    ENDIF
    
    SHOW GETS
  ENDIF  
ENDIF


*!*************************************************************
*! Name      : gfCPSave
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of save button in the pannel
*!*************************************************************
*! Calls     : 
*!      Called by: GFSTOPREAD()             (function  in ARIA3.PRG)
*!      Called by: GFESCAP()                (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFADD_INFO()             (function  in ARIA3.PRG)
*!          Calls: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!          Calls: LPSAVSCR.PRG             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Save
*B803748,1 AMH 11/02/2000 Fix data mismatch when saving user defined fields.
*:->
FUNCTION gfCPSave
EXTERNAL ARRAY laData,laDefProc,laScrMode

ACTIVATE WINDOW GWCCONTRL1 TOP
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
llShow     = .T.

IF laDefProc[9]
  *** If the default procedure is wanted
  *** Add new record if add mode 
  *C101459,1 Hesham (Start)
  *B603273,1[START]Also check that lcBaseFile is not empty
  *IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
     TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)
  IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
     TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)    AND ;
     !EMPTY(lcBaseFile)
  *B603273,1[End]
     IF !gfVldUsrFld(@laUsrFields)
       RETURN 
     ENDIF
  ENDIF   
  *C101459,1 Hesham (End)
  IF laScrMode[4]
    APPEND BLANK
    llSaveIt = .T.
  ELSE
    *** Chek if the record has been modified after user start editing
    lnLRecNo = IIF(RECNO()>RECCOUNT(),0,RECNO())
    IF lnLRecNo <> 0
      GO lnLRecNo
    ENDIF  
    *B602152,1 Hesham (Start)
    *B602152,1 check if there is a base file for the screen
    IF !EMPTY(lcBaseFile)
    *B602152,1 Hesham (end)    
      lcNStamp =  cAdd_User+IIF(EMPTY(dAdd_Date),'',DTOC(dAdd_Date))+;
                           cAdd_Time
    
      IF ALLTRIM(lcStamp) = ALLTRIM(lcNStamp)
        llSaveIt = .T.
      ELSE
        IF gfModalGen("QRM00030B00012","DIALOG",cLok_User) = 1
          llSaveIt = .T.
        ELSE
          llSaveIt = .F.
        ENDIF 
      ENDIF
    *B602152,1 Hesham (Start)  
    *B602152,1 End if (check if there is a base file for the screen)
    ELSE
      llSaveIt = .T.       
    ENDIF 
    *B602152,1 Hesham (END)     
  ENDIF

  IF llSaveIt AND !EMPTY(lcBaseFile)
    *** Save from array to the fields in the lcScFields
    *C101459,1 Hesham (Start)
    IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
       TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)
       SELECT (lcBaseFile)
       FOR lnUsrField = 1 TO ALEN(laUsrFields,1)
         *B803748,1 AMH Fix data mismatch when saving user defined fields [Start]
         *REPLACE &laUsrFields[lnUsrField,1] WITH laUsrFields[lnUsrField,6]
         =lfSvUsrFld()
         *B803748,1 [End]
       ENDFOR
    ENDIF   
    *C101459,1 Hesham (End)
    
    GATHER FROM laData FIELDS &lcScFields MEMO 
    =gfAdd_Info()                     && Add the add user,time and date
    =gfObj_Lock(.F.)                  && Unlock the record after saving
    *MAN
    llCUpDate = .F.

  ENDIF  
  
  *E301297,1 Change these lines because we are going to use one function
  *          called gfDoTriger() to control any triggers (customized
  *          process and workflow server requests including creating
  *          new project) found in the triggers file [Begin]
  **E300775,1 Hesham (Start)
  **E300775,1 if the workflow module is installed for the company
  **E300775,1 then call the global function to control the workflow
  **E300775,1 data
  *IF 'WF' $ gcCmpModules
  *  =gfCtrlTrig(SUBSTR(gcProg_Nam,4),IIF(laScrMode[4],'INSERT','UPDATE'))
  *  =gfCtrlFlow(SUBSTR(gcProg_Nam,4),IIF(laScrMode[4],'INSERT','UPDATE'))    
  *ENDIF  
  IF ASCAN(laEvntTrig , PADR(IIF(laScrMode[4],'INSERT','UPDATE') , 10)) <> 0
    *B603210,1 MAN-WAB -gcProg_nam is not a global variable that hold the 
    *B603210,1         active prog. so we use the gcbasewin cause it is hold
    *B603210,1         the active prog name start from pos 4
    *=gfDoTriger(SUBSTR(gcProg_Nam,4) , IIF(laScrMode[4],'INSERT','UPDATE')) 
    =gfDoTriger(SUBSTR(gcBaseWind,4) , IIF(laScrMode[4],'INSERT','UPDATE')) 
  ENDIF    && End of IF ASCAN(laEvntTrig , PADR('DELETE' , 10)) <> 0
  **E300775,1 Hesham (End)  
  *E301297,1 Change these lines because we are going to use one [End]
  
  IF laScrMode[4]                     && If comming from add mode 

    *--HDM B602753,1 04/06/1999[Start] We should call notepad program from global save
    IF llSaveIt AND llShow AND laScrMode[4] AND !EMPTY(lcBaseFile) AND;
       !EMPTY(lcSydKey) .AND. gfModalGen('QRM00349B00006','DIALOG')=1
      llNThing = gfvOrdNote()
    ENDIF
    *--HDM B602753,1 04/06/1999[End]

    laScrMode    = .F.                && Return all screen mode to normal
    laScrMode[1] = .T.                && Back to select mode  
  ELSE
    laScrMode    = .F.                && Return all screen mode to normal
    laScrMode[2] = .T.                && Go to view mode 
  ENDIF

ELSE
  *C101459,1 Hesham (Start)
  *B603273,1[START]Also check that lcBaseFile is not empty
  *IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
     TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)
  IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
     TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)    AND ;
     !EMPTY(lcBaseFile)
  *B603273,1[End]
     IF !gfVldUsrFld(@laUsrFields)
       RETURN 
     ENDIF
  ENDIF   
  *C101459,1 Hesham (End)


  IF laScrMode[4]
    llSaveIt = .T.
  ELSE

    *** Chek if the record has been modified after user start editing
    lnLRecNo = IIF(RECNO()>RECCOUNT(),0,RECNO())
    IF lnLRecNo <> 0
      GO lnLRecNo
    ENDIF  
    *B602152,1 Hesham (Start)
    *B602152,1 check if there is a base file for the screen
    IF !EMPTY(lcBaseFile)
    *B602152,1 Hesham (Start)    
      lcNStamp =  cAdd_User+IIF(EMPTY(dAdd_Date),'',DTOC(dAdd_Date))+;
                           cAdd_Time
      
      IF ALLTRIM(lcStamp) = ALLTRIM(lcNStamp) 
        llSaveIt = .T.
      ELSE
        IF gfModalGen("QRM00030B00012","DIALOG",cLok_User) = 1
          llSaveIt = .T.
        ELSE
          llSaveIt = .F.
        ENDIF 
      ENDIF
    *B602152,1 Hesham (Start)
    *B602152,1 END IF (check if there is a base file for the screen)
    ELSE  
      llSaveIt = .T.    
    ENDIF 
    *B602152,1 Hesham (END)    
  ENDIF
  
  *** If the default procedure is not wanted
  IF llSaveIt 
    DO lpSavScr
    IF llCSave
      *C101459,1 Hesham (Start)
      *B603273,1 [Start] Fixing bug of Alias '' Not found
      *B603273,1 we have to check that lcBaseFile is not empty as well
      *IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
         TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)
      IF TYPE('laCtrStat[14]')#'U' AND TYPE('lcBaseFile')='C' AND ;
         TYPE('laUsrFields') # "U" AND !EMPTY(laUsrFields)    AND ;
         !EMPTY(lcBaseFile)
      *B603273,1 [End]
         SELECT (lcBaseFile)
         FOR lnUsrField = 1 TO ALEN(laUsrFields,1)
           *B803748,1 AMH Fix data mismatch when saving user defined fields [Start]
           *REPLACE &laUsrFields[lnUsrField,1] WITH laUsrFields[lnUsrField,6]
           =lfSvUsrFld()
           *B803748,1 [End]
         ENDFOR
      ENDIF   
      *C101459,1 Hesham (End)
      *MAN
      llCUpDate = .F.
     *E300704,1 Hesham El-Sheltawi (Start)
     IF !EMPTY(lcBaseFile)
        *B123489,1 ASH 07/05/2004 (Begin) Fix bug of sometimes not clearing lock.
        SELECT (lcBaseFile)
        *B123489,1 ASH 07/05/2004 (End)
        =gfAdd_Info()                     && Add the add user,time and date
        =gfObj_Lock(.F.)
     ENDIF   
     *E300704,1 Hesham El-Sheltawi (END)     
    ENDIF  

  ELSE 
    *E300704,1 Hesham El-Sheltawi (Start)
    IF !EMPTY(lcBaseFile)
      SCATTER FIELDS &lcScFields MEMO TO laData
    ENDIF  
    *E300704,1 Hesham El-Sheltawi (END)    
  ENDIF

  IF !llCSave 
    llCSave    = .T.
    llShow     = .F.
  ELSE
    
    *E301297,1 Change these lines because we are going to use one function
    *          called gfDoTriger() to control any triggers (customized
    *          process and workflow server requests including creating
    *          new project) found in the triggers file [Begin]
    **E300775,1 Hesham (Start)
    **E300775,1 if the workflow module is installed for the company
    **E300775,1 then call the global function to control the workflow
    **E300775,1 data
    *IF 'WF' $ gcCmpModules
    *  =gfCtrlTrig(SUBSTR(gcProg_Nam,4),IIF(laScrMode[4],'INSERT','UPDATE'))
    *  =gfCtrlFlow(SUBSTR(gcProg_Nam,4),IIF(laScrMode[4],'INSERT','UPDATE'))    
    *ENDIF  
    IF ASCAN(laEvntTrig ,;
             PADR(IIF(laScrMode[4], 'INSERT' , 'UPDATE') , 10)) <> 0
      *B603210,1 MAN-WAB -gcProg_nam is not a global variable that hold the 
      *B603210,1         active prog. so we use the gcbasewin cause it is hold
      *B603210,1         the active prog name start from pos 4
      *=gfDoTriger(SUBSTR(gcProg_Nam,4) , IIF(laScrMode[4],'INSERT','UPDATE'))
      =gfDoTriger(SUBSTR(gcBaseWind,4) , IIF(laScrMode[4],'INSERT','UPDATE'))
    ENDIF    && End of IF ASCAN(laEvntTrig , PADR(IIF(laScrMode[4],....
    **E300775,1 Hesham (End)    
    *E301297,1 Change these lines because we are going to use one [End]
        
    IF laScrMode[4]
      
      *--HDM B602753,1 04/06/1999[Start] We should call notepad program from global save
      IF llSaveIt AND llShow AND laScrMode[4] AND !EMPTY(lcBaseFile) AND;
      !EMPTY(lcSydKey) .AND. gfModalGen('QRM00349B00006','DIALOG')=1
        llNThing = gfvOrdNote()
      ENDIF
      *--HDM B602753,1 04/06/1999[End]
      
      laScrMode    = .F.
      laScrMode[1] = .T.
    ELSE
      laScrMode    = .F.
      laScrMode[2] = .T.
    ENDIF
  ENDIF  

ENDIF

*MAN
*llCUpDate = .F.

IF llShow
  SHOW  GETS
ELSE
  RETURN .F.
ENDIF  

*!*************************************************************
*! Name      : gfSetFiltr
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to open the filter dialog from menu
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfSetFiltr
*E300704,1 Hesham El-Sheltawi (Start)
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
  lcCurFilter = ''

  lcFltBefor  = SET('FILTER')

  =gfBFiltr('laFixFltr',@laField_H,@laField_N,'F')

  lcFltAftr   = SET('FILTER')

  IF !(lcFltBefor == lcFltAftr)
    laScrMode    = .F.
    laScrMode[1] = .T.
    SHOW GETS
  ENDIF
ENDIF
*E300704,1 Hesham El-Sheltawi (END)
*!*************************************************************
*! Name      : gfCPCopy
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the copy button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: GFWAIT()                 (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfCPCopy

ACTIVATE WINDOW GWCCONTRL1 TOP
SELECT (lcBaseFile)


=ACOPY(laData,laDataCopy)

IF laScrMode[3]
  SHOW GET pbCpPrint ENABLE
ENDIF

=gfWait("00200","NOWAIT")


*!*************************************************************
*! Name      : gfCPPaste
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of the past button in the pannel
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfCPPaste

ACTIVATE WINDOW GWCCONTRL1 TOP
SELECT (lcBaseFile)


FOR lnCount  = 1 TO ALEN(laKeyField,1)
  lcVarName  = "lcKey"+ALLTRIM(STR(lnCount))
  &lcVarName = EVALUATE(laKeyField[lnCount,1])
ENDFOR

=ACOPY(laDataCopy,laData)

FOR lnCount  = 1 TO ALEN(laKeyField,1)
  lcVarName  = "lcKey"+ALLTRIM(STR(lnCount))
  &laKeyField[lnCount,1] = EVALUATE(lcVarName)  
ENDFOR

SHOW GETS

*!*************************************************************
*! Name      : gfCPClose
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Validation of close button in the pannel
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: LPCLSSCR.PRG             
*!          Calls: GFOBJ_LOCK()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* The valid function for the control panel Top push Close
*:->
FUNCTION gfCPClose
EXTERNAL ARRAY laData,laDefProc,laScrMode
EXTERNAL PROCEDURE lpClsScr
IF WEXIST('GWCCONTRL1') AND WREAD('GWCCONTRL1')
  ACTIVATE WINDOW GWCCONTRL1 TOP
ENDIF  

*E300704,1 Hesham El-Sheltawi (Start)
*E300704,1 check if the program have a base file or not 
*E300704,1 before selecting it
*SELECT (lcBaseFile)
IF !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
ENDIF  
*E300704,1 Hesham El-Sheltawi (END)
IF laScrMode[1] .OR. laScrMode[2]         
  *** Select or view mode
  glQuitting = .T.
  CLEAR READ
  RETURN
ELSE

  IF llCUpDate                       && If any object is updated 
    glChildTop = (SUBSTR(WLAST(),1,2)="CW")
    IF gfModalGen('QRM00031B00006','Alert') = 2
      RETURN
    ELSE
      IF laDefProc[10]
       *E300704,1 Hesham El-Sheltawi (Start)
       *E300704,1 check if the program have a base file or not 
       *E300704,1 before SCATTERING THE DATA
*      SCATTER FIELDS &lcScFields MEMO TO laData       
       IF !EMPTY(lcBaseFile)
         SCATTER FIELDS &lcScFields MEMO TO laData
       ENDIF  
       *E300704,1 Hesham El-Sheltawi (END)
      ELSE
        DO lpClsScr
      ENDIF  && DefProc
      llUpDate=.F.          
    ENDIF  &&Message
  ENDIF  &&llUpDate

  *E300704,1 Hesham El-Sheltawi (Start)
  *E300704,1 check if the program have a base file or not 
  *E300704,1 before clearing the logical locking
* =gfObj_Lock(.F.)                       && Unlock the record  
  IF !EMPTY(lcBaseFile)
    =gfObj_Lock(.F.)                       && Unlock the record
  ENDIF  
  *E300704,1 Hesham El-Sheltawi (END)
  IF laScrMode[3]                        && IF Comming From Editting mode
    laScrMode    = .F.                   && Reset screen mode 
    laScrMode[2] = .T.                   && Go To view mode
  ELSE                                   && If Comming From Adding mode
    laScrMode    = .F.                   && Reset screen mode
    laScrMode[1] = .T.                   && Go to select mode
  ENDIF  
  llCUpdate =.F.
  SHOW GETS
ENDIF

*!*************************************************************
*! Name      : gfChngOrdr
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Not used
*!*************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************

FUNCTION gfChngOrdr

*!*************************************************************
*! Name      : gfWinArng
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To rearrange the names of active windows in the windows popup
*!*************************************************************
*! Calls     : 
*!      Called by: GFMENUBLD()              (function  in ARIA3.PRG)
*!      Called by: GFSTOPREAD()             (function  in ARIA3.PRG)
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!      Called by: GFCLEANUP()              (function  in ARIA3.PRG)
*!      Called by: GFACTWIND()              (function  in ARIA3.PRG)
*!      Called by: GFCHCLOSE()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Name of new window
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will arrang the window names in the window popup 
* If called from the setup function when the window is opend for first 
* time the window is not activated yet so it have to be passed as 
* paramiter to this function
*
*:->
FUNCTION gfWinArng
PARAMETERS gcNewWind
PRIVATE gcNewWind,gnWinOrder,gnWinBar,glFrstWind

IF glCh1stAct
  glCh1stAct = .F.
  RETURN
ENDIF

gnWinOrder = 0
gnWinBar   = gnWinSepta+1
glFrstWind = .T.

*** Scan all visible windows and regester their names in the window popup
*** Get window long name from the dinamic window array
lcMainWind = IIF(_WINDOWS,"FNDATION","")
lcWindNam  = UPPER(WCHILD(lcMainWind,0))
DO WHILE !EMPTY(lcWindNam)
  *** Window to register have to be visible , not the command window or
  *** the controll pannel window
  IF SUBSTR(lcWindNam,2,2) <>"WC" .AND. ;
     lcWindNam <> 'COMMAND'       .AND. ;
     WVISIBLE(lcWindNam)

    *** Window names can be found in the array as home window
    *** so we can not use ASCAN() to look for the window name
    lnWind_No = 0
    FOR lnCount = 1 TO ALEN(gaAct_Wind,1) 
      IF lcWindNam = gaAct_wind[lnCount,1]
         lnWind_No = lnCount
         EXIT 
      ENDIF
    ENDFOR
    
    *** If you are regestering the the first window found define a separatore
    *** bar before it's name 
    IF glFrstWind
      glFrstWind = .F. 
      DEFINE BAR gnWinBar;
             OF P08PU08 ;
                 PROMPT "\-"
      gnWinBar   = gnWinBar   + 1    
    ENDIF             

   
    IF lnWind_No >0  .AND. !EMPTY(gaAct_wind[lnWind_No,1])
      lcPrpmpt   = IIF(gnWinOrder>9,"","\<"+STR(gnWinOrder,1)+" ")+;
                    gaAct_wind[lnWind_No,4]

      DEFINE BAR gnWinBar OF P08PU08  PROMPT lcPrpmpt
*B601645,1 Hesham El-Sheltawi (Start)
*B601645,1 Check if the windows version is 95 or later
*B601645,1 then call the function lfzoomwin to restore
*B601645,1 the window in a proper way for the windows 95
*      ON SELECTION BAR gnWinBar OF P08PU08;
         ACTIVATE WINDOW &gaAct_wind[lnWind_No,1] TOP

  IF _WINDOWS AND VAL(SUBSTR(OS(1),ATC(' ',OS(1))))<3.95
      ON SELECTION BAR gnWinBar OF P08PU08;
         ACTIVATE WINDOW &gaAct_wind[lnWind_No,1] TOP
  ELSE
     lcCommand = "ON SELECTION BAR gnWinBar OF P08PU08 do lfZoomWin with '"+;
         gaAct_wind[lnWind_No,1]+"'"
      &lcCommand   
  ENDIF 
*B601645,1 Hesham El-Sheltawi (End)  
      gnWinBar   = gnWinBar   + 1
      gnWinOrder = gnWinOrder + 1
	ENDIF     
  ENDIF
  lcWindNam = UPPER(WCHILD(lcMainWind,1))
ENDDO

*** If activating window and the infornation of this window is added to
*** the windows array but window is not activated yet or not visible yet
*** so the name of this window will be passed as a parameter and the
*** function will append it's name to the bottom of the window popup
IF TYPE('gcNewWind') = 'C'
  IF glFrstWind
    glFrstWind = .F. 
    DEFINE BAR gnWinBar;
           OF P08PU08 ;
               PROMPT "\-"
    gnWinBar   = gnWinBar   + 1    
  ENDIF             

  lnWind_No = 0
  FOR lnCount = 1 TO ALEN(gaAct_Wind,1) 
    IF ALLTRIM(UPPER(gcNewWind)) = UPPER(gaAct_wind[lnCount,1])
      lnWind_No = lnCount
      EXIT 
    ENDIF
  ENDFOR

  lcPrpmpt   = IIF(gnWinOrder>9,"","\<"+STR(gnWinOrder,1)+" ")+;
               gaAct_wind[lnWind_No,4]
  DEFINE BAR gnWinBar OF P08PU08  PROMPT lcPrpmpt
*B601645,1 Hesham El-Sheltawi (Start)
*B601645,1 Check if the windows version is 95 or later
*B601645,1 then call the function lfzoomwin to restore
*B601645,1 the window in a proper way for the windows 95
*    ON SELECTION BAR gnWinBar OF P08PU08;
       ACTIVATE WINDOW &gaAct_wind[lnWind_No,1] TOP

  IF _WINDOWS AND VAL(SUBSTR(OS(1),ATC(' ',OS(1))))<3.95
    ON SELECTION BAR gnWinBar OF P08PU08;
       ACTIVATE WINDOW &gaAct_wind[lnWind_No,1] TOP
  ELSE
     lcCommand = "ON SELECTION BAR gnWinBar OF P08PU08 do lfZoomWin with '"+;
         gaAct_wind[lnWind_No,1]+"'"
      &lcCommand   
  ENDIF     
*B601645,1 Hesham El-Sheltawi (End)  
  gnWinBar   = gnWinBar   + 1
ENDIF
*IF TYPE('gnWinBar')='N' AND gnWinBar>0
  *** If there is more window names in the popup but not active of visible
  *** remove it's names from the window popup
    *B609556,3 TMI 03/31/2011 [Start] disable error handler
    PRIVATE lcSvErr
    lcSvErr = ON('ERROR')
    ON ERROR llDummy = .T.    
    *B609556,3 TMI 03/31/2011 [End  ] 

  FOR lnCount = gnWinBar TO CNTBAR('P08PU08')
    RELEASE BAR lnCount OF P08PU08
  ENDFOR

    *B609556,3 TMI 03/31/2011 [Start] restore error handler
    ON ERROR &lcSvErr
    *B609556,3 TMI 03/31/2011 [End  ] 
*ENDIF  

*!*************************************************************
*! Name      : gfPhoneTem
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : Fix the phone template
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*  FUNCTION RETURN THE PHONE TEMPLATE FORMAT "PICTURE"
*:->
FUNCTION gfPhoneTem
PARAMETER lcPhoneTem

IF PARAMETERS()>0
  RETURN "@R "+STRTRAN(lcPhoneTem,'#','X')
ELSE
  RETURN "@R "+STRTRAN(gcTelTemp,'#','X')
ENDIF  

*!*************************************************************
*! Name      : gffPhoneTem
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gffPhoneTem
PARAMETER lcPhoneTem

IF PARAMETERS()>0
  lcTmpPhone=gcTempPhone
  gcTempPhone=lcPhoneTem
ENDIF

lcTempPhone="@R "

FOR lnCount=1 TO LEN(gcTelTemp)
  lcTempPhone=lcTempPhone+IIF(SUBSTR(gcTelTemp,lnCount,1)="#","X",;
                            SUBSTR(gcTelTemp,lnCount,1))
ENDFOR

IF PARAMETERS()>0
  gcTempPhone=lcTmpPhone
ENDIF
RETURN lcTempPhone

*!*************************************************************
*! Name      : gfValdPath
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To validate any path if right or wrong
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : Path to be validated
*!*************************************************************
*! Returns            : Flag to tell valid or not
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gfValdPath
PARAMETERS lcPath

llRetVal = .T.
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*lcDefault=FULLPATH(SET('DEFAULT'))
lcDefault=SYS(5)+CURDIR()
*E303062,3 TMI 02/14/2012 [End  ] 
lcOnError=ON('ERROR')

ON ERROR llError = .T.
llError          = .F.


SET DEFAULT TO (lcPath)

IF llError
  llRetVal = .F.
ENDIF

ON ERROR &lcOnError

SET DEFAULT TO (lcDefault)

RETURN llRetVal

*!*************************************************************
*! Name      : gfDosShell
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To go to dos shell
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfDosShell

lcWindow = WONTOP()
ACTIVATE SCREEN
SAVE SCREEN TO TEMP
CLEAR 
!COMMAND
RESTORE SCREEN FROM TEMP
IF !EMPTY(lcWindow)
  ACTIVATE WINDOW (lcWindow) SAME
ENDIF  

*!*************************************************************
*! Name      : gfUnLock
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to unlock all records in all files in case of ubnormal termination
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfUnLock

WAIT "Releasing all locks " WINDOW NOWAIT

SCAN FOR cObj_typ ="WIN"      .AND.;
         cUser_ID = gcUser_ID .AND.;
         cStation = gcStation 
         
  RESTORE FROM MEMO mObj_Data ADDITIV

  FOR lnCount = 1 TO ALEN(laFileName,1)
   IF RIGHT(ALLTRIM(laFileName[lnCount]),1)="$"
      lcFileName = SUBSTR(laFileName[lnCount],1,LEN(laFileName[lnCount])-1) 
      EXIT
    ENDIF
  ENDFOR

  IF !USED(lcFileName)
    llOpen = .T.
    SELECT 0
    lcPath = IIF(UPPER(LEFT(lcFileName,2)) = 'SY',;
           gcSysHome,gcDataDir)
    USE &lcPath.&lcFileName
  ELSE 
    llOpen = .F.
    SELECT(lcFileName)
  ENDIF
  GO lnRecNo
  IF cLok_user = gcUser_ID  
    REPLACE llok_stat WITH .F.
  ENDIF  
          
  IF llOpen
    USE IN ALIAS(lcFileName)
  ENDIF  

  SELECT SYUSTATC
ENDSCAN  
WAIT CLEAR 

*!*************************************************************
*! Name      : gfValdTime
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : to validate any time field
*!*************************************************************
*! Calls     : 
*!          Calls: GFVALDRANG()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : time to be validated
*!*************************************************************
*! Returns            : time in new format
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfValdTime
PARAMETERS lcTime

RETURN (gfValdRang(SUBSTR(lcTime,1,2),23,0) .AND.;
         gfValdRang(SUBSTR(lcTime,4,2),59,0) .AND.;
         gfValdRang(SUBSTR(lcTime,7,2),59,0) )
         
*!*************************************************************
*! Name      : gfValdRang
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!      Called by: GFVALDTIME()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : 
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfValdRang
PARAMETERS lcToCheck,lnMax,lnMin

lnToCheck=IIF(TYPE('lcToCheck')='N',lcToCheck,VAL(lcToCheck))
RETURN ( lnToCheck<=lnMax .AND. lnToCheck>=lnMin)         


*!*************************************************************
*! Name      : gfRollBack
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : not used any more
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : ............
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfRollBack
PARAMETERS lcTempFile,laModyRec,laOldData
EXTERNAL ARRAY LAMODYREC
PRIVATE lcTempFile,laModyRec,laOldData

lcSavAlias = SELECT(0)
SELECT (lcTempFile)
FOR lnCount = 1 TO ALEN(laModyRec,1)
  GO laModyRec[lnCount]
  DO CASE 
    CASE DELETED()
      RECALL
      IF !EMPTY (mMisc)
        RESTOR FROM MEMO mMisc ADDITIV
        GATHER FROM laOldData
      ENDIF  
    CASE cStatus = 'A'
      IF !EMPTY (mMisc)
        RESTOR FROM MEMO mMisc ADDITIV
        GATHER FROM laOldData
      ELSE
        REPLACE cStatus WITH 'S'
        DELETE
      ENDIF  
      
    OTHERWIS
      IF !EMPTY (mMisc)
        RESTOR FROM MEMO mMisc ADDITIV
        GATHER FROM laOldData
      ENDIF  
  ENDCASE
ENDFOR 

SELECT (lcSavAlias)

*!*************************************************************
*! Name      : gfvDirPath
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To validate any path field
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Name of path variable
*!*************************************************************
*! Returns            : .t.
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfvDirPath
PARAMETERS 	lcVarNam

lcNewPath = GETDIR() 
&lcVarNam = IIF(!EMPTY(lcNewPath),lcNewPath,&lcVarNam)
SHOW GET &lcVarNam 
RETURN .T.


*!*************************************************************
*! Name      : gfDispRep
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   :  Function to Perform Reports
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Report name
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfDispRep
PARAMETERS  lcRprtNam

IF _DOS

  IF gcDevice="PRINTER" AND SYS(13) = "READY"
    IF _PEJECT $ "BOTH,BEFORE"
       lcAddv=_PADVANCE
       _PADVANCE="FORMFEED"
       EJECT
       _PADVANCE=lcAddv  
     ENDIF
  ENDIF   


  IF glHeader           
    REPORT FORM &gcRepHome.&lcRprtNam TO PRINTER NOCONSOLE NOEJECT  
  ELSE
    REPORT  FORM &gcRepHome.&lcRprtNam  TO PRINTER  PLAIN NOEJECT  
  ENDIF  

  &&lcReport      
  IF gcDevice="PRINTER" AND SYS(13) = "READY"
    IF _PEJECT $ "BOTH,AFTER"
       lcAddv=_PADVANCE
       _PADVANCE="FORMFEED"
       EJECT
       _PADVANCE=lcAddv  
     ENDIF
  ENDIF   

ELSE

  DO CASE
    CASE gcDevice = "SCREEN"
      IF glHeader           
        REPORT FORM &gcRepHome.&lcRprtNam PREVIEW 
      ELSE
        REPORT  FORM &gcRepHome.&lcRprtNam  PREVIEW PLAIN        
      ENDIF  
    CASE gcDevice = "PRINTER"
      IF glHeader           
        REPORT FORM &gcRepHome.&lcRprtNam TO PRINTER NOCONSOLE NOEJECT  
      ELSE
        REPORT  FORM &gcSysHome.&lcRprtNam  TO PRINTER  NOEJECT NOCONSOLE PLAIN      
      ENDIF  
  ENDCASE  
ENDIF



*!*************************************************************
*! Name      : gfTransPhone
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : TO modify the phone template with the right one
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : righ phone template
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfTransPhone
PARAMETER lcPhoneTem

lcTempPhone=STRTRAN(gcTelTemp,'#')

FOR lnCount=1 TO LEN(lcTempPhone)
  lcPhoneTem=STRTRAN(lcPhoneTem,SUBSTR(lcTempPhone,lnCount,1))
ENDFOR
RETURN lcPhoneTem

*!*************************************************************
*! Name      : gfFieldPic
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To build the field picture for any field
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Field name
*!*************************************************************
*! Returns            : Field picture
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfFieldPic
PARAMETERS lcFld_Name
PRIVATE lcFld_Name,lcPicture

lcPicture=''

lcFld_type = TYPE(lcFld_Name)

DO CASE
   CASE lcFld_type = 'C'
     lcPicture = REPLICATE("X",FSIZE(lcFld_Name))
   CASE lcFld_type = 'D'
     lcPicture = "@D"
ENDCASE

RETURN lcPicture

*!*************************************************************
*! Name      : gfUpdate
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To update the update flag after any modification
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfUpdate


*** Check if you confirm action on one of the objects and chang the llUpdate
*** flag, and confirm that llOnChang flag still .T.
IF UPDATE()
  llCUpdate  = .T.
ENDIF  

*!*************************************************************
*! Name      : gfActWind
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To activate any child window
*!*************************************************************
*! Calls     : 
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Name of child window
*!                      Window title
*!                      Name of parent window    
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will be called from a button on home window to activate 
* a child window eather for first time or if the window was activated 
* on desktop from before
* Send 2 parameters : window name and window title
* This function will depend on array called laWndObj to hold the window
* name , first and last objects in this window for all windows involed in the
* current read session
*
*:->
FUNCTION gfActWind
PARAMETERS gcWindNam,lcCWinTtl,lcWparent
PRIVATE gcWindNam,lcCWinTtl
EXTERNAL ARRAY laWndObj


lcWparent = IIF(TYPE('lcWparent')='C',lcWparent,WONTOP()) 
gcWindNam = ALLTRIM(UPPER(gcWindNam))
lnWindNum = ASCAN(laWndObj,gcWindNam)
*** If no title for this window sent as a parameter use the phisical
*** window name
lcCWinTtl = IIF(TYPE('lcCWinTtl')<>'C',PROPER(gcWindNam),PROPER(lcCWinTtl))

*** To activate a child window through this function, the name of this window
*** have to be added to the local array laWndObj
IF lnWindNum > 0
  *** If the window not visible that's mean this is the first time to activate 
  *** this child window so add it's information to the windows array
  IF !WVISIBLE(gcWindNam)
    *** Update Dinamic Windows Array 
    IF !EMPTY(gaAct_Wind[1,1])
      DIMENSION gaAct_Wind [ALEN(gaAct_Wind,1)+1,4]
      =AINS(gaAct_Wind,1)
    ENDIF  
    gaAct_wind [1,1] = gcWindNam        && Child window name
    gaAct_wind [1,2] = gcWinAppl        && Source appl will be as home
    gaAct_wind [1,3] = lcWparent        && Home will be on top at this moment
    gaAct_wind [1,4] = lcCWinTtl        && Window title will be parameter
    =gfWinArng(gcWindNam)
    glCh1stAct = .T.
  ENDIF
  *** Calling the first object in to be activated child window
  *** will activate the window show 
  *** in edit or add call the first object but in view call
  *** the last object whiche most probably will be the close button

  _CUROBJ = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),;
            IIF(laScrMode[2],3,2)])
*  SHOW WINDOW (gcWindNam) TOP
  *#IF _DOS 
  *  IF WVISIBLE('GWCCONTRL1')
  *    IF laScrMode[1] .OR. laScrMode[2]
  *      SHOW GET pbCls,1  PROMPT "\<Close" 
  *    ELSE
  *      SHOW GET pbCls,1  PROMPT "\<Cancel" 
  *      SHOW GET pbSav,1  PROMPT "\<Save"        
  *    ENDIF  
  *  ELSE
  *    SHOW GET pbClose,1 PROMPT "\<Close"
  *  ENDIF 
  *#ENDIF 
ENDIF

*!*************************************************************
*! Name      : gfChClose
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To close any child window
*!*************************************************************
*! Calls     : 
*!      Called by: GFSTOPREAD()             (function  in ARIA3.PRG)
*!      Called by: GFESCAP()                (function  in ARIA3.PRG)
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Name of the child window
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfChClose
PARAMETERS lcWindow
PRIVATE lcWindow,lnWin_No

lcWindow = IIF(TYPE('lcWindow')='C',ALLTRIM(UPPER(lcWindow)),WONTOP())
lcWindow = IIF(lcWindow='GWCCONTRL1',WLAST(),lcWindow)
llChild  = .T.

HIDE WINDOW (lcWindow)

*** Remove the window name from the activ windows array
lnWin_No  = ASCAN(gaAct_Wind,lcWindow)

IF lnWin_No > 0        && Found this window name in array

  lnWin_No  = ASUBSCRIPT(gaAct_Wind,lnWin_No,1)

  =ADEL(gaAct_Wind,lnWin_No)
   
  IF ALEN(gaAct_Wind,1)  > 1             && Shrink the array till 1 colum
    DIMENSION gaAct_Wind[ALEN(gaAct_Wind,1) - 1,4]
  ELSE
    gaAct_Wind = ' '
  ENDIF 
  =gfWinArng()



ENDIF

IF glGo2Objct
   glGo2Objct = .F.
  _CUROBJ  = lnCurObj
ELSE
  IF SUBSTR(WONTOP(),1,2) = "CW"  
    lnWin_No1 = ASCAN(laWndObj,WONTOP()) 
    IF lnWin_No1 > 0 
      lnWin_No1 = ASUBSCRIPT(laWndObj,lnWin_No1,1)
      _CUROBJ   = OBJNUM(&laWndObj[lnWin_No1,2])

      *#IF _DOS 
      *  lcToWObj = laWndObj[lnWin_No1,3]
      *  SHOW GET &lcToWObj,1 PROMPT "\!\?Close"
      *#ENDIF
    ENDIF   
  ELSE
   _CUROBJ  = 1
   *#IF _DOS
   *  IF WVISIBLE('GWCCONTRL1')
   *     IF laScrMode[1] .OR. laScrMode[2]
   *       SHOW GET pbCls,1  PROMPT "\?\!\<Close" 
   *     ELSE
   *       SHOW GET pbCls,1  PROMPT "\?\<Cancel" 
   *      SHOW GET pbSav,1  PROMPT "\!\<Save"
   *     ENDIF  
   *   ELSE
   *     SHOW GET pbClose,1 PROMPT "\?\!\<Close"
   *   ENDIF 
   *#ENDIF  
  ENDIF 
ENDIF  


*!*************************************************************
*! Name      : gfCtrDirct
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To handle the cursor direction when coming from the pannel
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : First object or last one
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will be called when entering the  first object  and also the last
* one in the control screen to redirest the tab action to the propriat 
* object according to the screen  on top at this moment.
*
*:->
FUNCTION gfCtrDirct
PARAMETERS lcBgnLast


IF TYPE('laWndObj') <> 'C' .OR. EMPTY(laWndObj[1,1])
  RETURN .F.
ENDIF
  
*** If comming from the first object 

IF UPPER(lcBgnLast) = 'BEGIN'
  DO CASE
    CASE INLIST(LASTKEY(),9,4,18,24)   && Tab or right arrow
      _CUROBJ   = _CUROBJ + 1
    CASE INLIST(LASTKEY(),5,15,19)    && Shift+Tab or left arrow
      lnWindNum = ASCAN(laWndObj,WLAST())
      IF lnWindNum > 0
        _CUROBJ = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),3])
      ELSE
        _CUROBJ   = 2
      ENDIF  
  ENDCASE     

*** If comming from the last object
ELSE
  DO CASE
    CASE INLIST(LASTKEY(),24,9,4,18)  && Tab or right arrow
      
      lnWindNum = ASCAN(laWndObj,WLAST())
      IF  lnWindNum > 0
        _CUROBJ   = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),2])
        
      ELSE
        _CUROBJ   = 2
      ENDIF  
    CASE INLIST(LASTKEY(),5,3,15,19)  && Shift+Tab or left arrow
      _CUROBJ   = _CUROBJ - 1
  ENDCASE
ENDIF

*!*************************************************************
*! Name      : gfSUsrPrg
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO check if one copy is opend from a single user program
*!*************************************************************
*! Calls     : 
*!      Called by: GFSETUP()                (function  in ARIA3.PRG)
*!          Calls: GFADD_INFO()             (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Program name
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfSUsrPrg
PARAMETERS lcPrgName
lcPrgName = UPPER(lcPrgName)

SET EXACT ON
*** Check if the program restricted for one user run
IF !SEEK(lcPrgName+UPPER(gcAct_Comp),'SYDSUPRG')
  INSERT INTO &gcSysHome.SYDSUPRG ;
    (cProgNam,cComp_ID)  VALUES (lcPrgName,gcAct_Comp)
ENDIF

SET EXACT OFF 

lcOldRep = SET('REPROCESS')
SET REPROCESS TO 1

IF RLOCK('SYDSUPRG')
  =gfAdd_Info('SYDSUPRG')
  SET REPROCESS TO lcOldRep
ELSE
  lcUserName = ALLTRIM(LOOKUP(syuUser.cUsr_Name,;
               sydSuPrg.cAdd_User,syuUser.cUser_ID,'CUSER_ID'))
               
  =gfModalgen('INM00089B00000','ALERT',lcUserName)
  SET REPROCESS TO lcOldRep

  RETURN .F.      

ENDIF

*!*************************************************************
*! Name      : gpRpPrint
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To call the report engen from the menu
*!*************************************************************
*! Calls     : 
*!      Called by: GFMAINCONT()             (function  in ARIA3.PRG)
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!          Calls: &LCMDRPORTS              
*!*************************************************************
*! Passed Parameters  : Report ID
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE  gpRpPrint
PARAMETERS lcReport

*E038621,1 WAM 04/05/2005 Prevent Aria4XP programs & reports from running under Aria27
USE gcSysHome+'SYDREPRT' ORDER TAG cRep_Id AGAIN IN 0 ALIAS 'A4xpObj' 
llA4xpPrg = glRunFrmA4 AND SEEK(PADR(lcReport,8),'A4xpObj') AND A4xpObj.lRunFromA4
USE IN 'A4xpObj'
IF llA4xpPrg
  =gfModalgen("TRM00419B00000","ALERT")
  RETURN
ENDIF
*E038621,1 WAM 04/05/2005 (End)

lcMdRports = gcRepHome+gcAct_Appl+"REPORT"

DO &lcMdRports WITH lcReport

*!*************************************************************
*! Name      : gpRechist
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display the record history dialog
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: RECHIST.SPR              
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->>
PROCEDURE gpRechist

IF EMPTY(lc_TablNam)
  lc_TablNam = ALIAS()
ENDIF

*** Go to the same record to get a fresh copy in the buffer
lnHRecNo = IIF(RECNO()>RECCOUNT(),0,RECNO())

IF lnHRecNo <> 0
  GO lnHRecNo
ENDIF  

IF TYPE('&lc_TablNam..cAdd_User') = 'U' .AND. ;
   TYPE('&lc_TablNam..dAdd_Date') = 'U' .AND. ;
   TYPE('&lc_TablNam..cAdd_Time') = 'U'
  
  =gfModalGen("INM00050B00000","DIALOG")
  RETURN

ELSE
  IF EMPTY(&lc_TablNam..cAdd_User) .OR. ;
     EMPTY(&lc_TablNam..dAdd_Date) .OR. ;
     EMPTY(&lc_TablNam..cAdd_Time)
    
    =gfModalGen("INM00051B00000","DIALOG")
    RETURN

  ENDIF
ENDIF

lnSavRec     = IIF(RECNO('SYUUSER')>RECCOUNT('SYUUSER'),0,RECNO('SYUUSER'))

lcUserName = LOOKUP(syuUser.cUsr_name,&lc_TablNam..cAdd_User,;
                    syuUser.cUser_id,'cUser_id')


IF lnSavRec <>0
  GO lnSavRec IN SYUUSER
ENDIF  

DO RECHIST.SPR

*!*************************************************************
*! Name      : gfStopBrow
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To terminat the program if comming from browse
*!*************************************************************
*! Calls     : 
*!          Calls: GFSTATIC()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfStopBrow

IF (WPARENT(WONTOP())='FNDATION' .AND. !WVISIBLE(WLAST())) .OR. (!WVISIBLE(WPARENT(WONTOP())) .AND. UPPER(LEFT(WPARENT(WONTOP()),1)) <> 'C')

    IF (WOUTPUT() = gcBaseWind .OR. WPARENT(WOUTPUT()) = gcBaseWind) .OR. (WPARENT(WONTOP())='FNDATION' .AND. !WVISIBLE(WLAST()))
      *** If edit or add mode, dont leave the program
      
      IF laScrMode[3] .OR. laScrMode[4] 
        *** Reactivate the window becouse it's olredy hided
        ACTIVATE WINDOW (gcBaseWind)
        IF (WPARENT(WONTOP())='FNDATION' .AND. !WVISIBLE(WLAST()))
           lcWLst = WLAST()
           ACTIVATE WINDOW (lcWlst)
        ELSE
           ACTIVATE WINDOW (WOUTPUT())
        ENDIF  
        *** Do you want to save chanes befor closing this progrm
        *** Yes, No , Cancel
        lnOption = gfModalGen("QRM00140B00025","ALERT")
        DO CASE
          CASE lnOption = 1
           IF !gfCpSave()
             RETURN .F.
           ENDIF  
          CASE lnOption = 2
            IF !laDefProc[10]
              DO lpClsScr
            ELSE
              IF TYPE("lcBaseFile")='C' AND !EMPTY(lcBaseFile)
                  lnActAls = SELECT(0)
                  SELECT (lcBaseFile)
                  =gfObj_Lock(.F.)   && Unlock the record
                  SELECT (lnActAls )
              ENDIF  
            ENDIF  
          CASE lnOption = 3
            RETURN .F.                             
        ENDCASE
      ENDIF
   ENDIF
  glFromBrow = .F.
  glquitting = .T.
  CLEAR READ
  KEYBOARD "{ENTER}" PLAIN CLEAR
*B601974,1 Hesham (Start)  
*B601974,1 get the name of the running spr and do not depend on
*B601974,1 the variable lcprogname because this variable hold the 
*B601974,1 program Name that is called from the menu and it does
*B601974,1 not reflect the right spr name
*  gcRunning = lcprogname+".SPX"
*  RETURN TO &gcRunning
  lcScrName = lfGetSpr()
  IF !EMPTY(lcScrName)
    RETURN TO &lcScrName
  ENDIF
*B601974,1 Hesham (End)    
ENDIF
IF !WREAD(WONTOP()) .AND. (EMPTY(gcBaseWind) .OR. ALLTRIM(UPPER(gcBaseWind)) <> gfGetWPrnt(WONTOP()))
  lnCurObj    = _CUROBJ            && Save current object to variable 
  *MAN Start commented the following line and added IF Structure
  *=gfStatic() 
  IF !WVISIBLE(WOUTPUT()) 
    glquitting = .T.
  ELSE
     =gfStatic() 
  ENDIF
  *MAN End
  glFromBrow = .F.
  CLEAR READ
  KEYBOARD "{ENTER}" PLAIN CLEAR
*B601974,1 Hesham (Start)  
*B601974,1 get the name of the running spr and do not depend on
*B601974,1 the variable lcprogname because this variable hold the 
*B601974,1 program Name that is called from the menu and it does
*B601974,1 not reflect the right spr name
*  gcRunning = lcprogname+".SPX"
*  RETURN TO &gcRunning
  lcScrName = lfGetSpr()
  IF !EMPTY(lcScrName)
    RETURN TO &lcScrName
  ENDIF
*B601974,1 Hesham (End)    
ENDIF

glFromBrow = .F.

*!*************************************************************
*! Name      : gfvMovRight
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To move the toolbar icons to right
*!*************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfvMovRight     

IF gnButtPos = 1
  RETURN
ELSE
  SHOW OBJECT (_CUROBJ+ gnButtPos ) ENABLE
  MOVE WINDOW toolbar2 BY 0,gnButtW
  SHOW OBJECT (_CUROBJ+8 + gnButtPos) DISABLE
  gnButtPos = gnButtPos - 1
ENDIF  

*!*************************************************************
*! Name      : gfvMovLeft
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To move the toolbar icons to left
*!*************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfvMovLeft    


IF  gnButtPos = gnMaxButt - 7 .OR. (gnMaxButt - 7)<0
  RETURN
ELSE 
  SHOW OBJECT (_CUROBJ+8 + gnButtPos) ENABLE 
  MOVE WINDOW toolbar2 BY 0,-gnButtW-0.1
  SHOW OBJECT (_CUROBJ+ gnButtPos ) DISABLE
  gnButtPos  = gnButtPos + 1
ENDIF  

*!*************************************************************
*! Name      : gfvToolVld
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO call any program from the toolbar
*!*************************************************************
*! Calls     : 
*!          Calls: GPDOPROG                 (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Program name
*!                      Module name
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* left VALID
*
*:->
FUNCTION gfvToolVld
PARAMETERS lcPrgToRun,lcPrgAppl


IF !EMPTY(lcPrgToRun)
  DO gpDoProg WITH lcPrgToRun,'',lcPrgAppl
ENDIF  

*!*************************************************************
*! Name      : gfActPop
*! Developer : Reham Aly Al Allaym
*! Date      : 1993-1995 
*! Purpose   : To open popup from array or from file
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFFILLPOP()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : upper row position
*!                      left colum position
*!                      bottom row posiotion
*!                      rigth colum position
*!                      name of file or array
*!                      mane of field or colum to be returnd  
*!                      name of field or colum to be dispalied
*!                      pointer to the display variable
*!*************************************************************
*! Returns            : content of the selected bar
*!*************************************************************
*! Example   : laData[5]  = gfActPop(8,2,10,16,'laTTerm',1,2,@lcTerm)  from array
*!             laData[10] = gfActPop(11,22,15,70,'GLCFITEM','CSEGCAFLO','CCFIDESC',@lcCashFDes)  from file
*!*************************************************************
*:->
FUNCTION gfActPop

PARAMETERS lnRow1,lnCol1,lnRow2,lnCol2,lcContNam,lcReturn,lcDisplay,lcSayVar,lcPopWindo

lnDefBar   = 1
lcCode     = ''  
lnFound    = 0
*B600915,1 Hesham (Start)
*B600915,1 Store the interrupt of the escape key and clear it to return back
*B600915,1 normaly to screen first
PRIVATE lcOnEsc
lcOnEsc=ON("KEY",'ESCAPE')
ON KEY LABEL ESCAPE
*B600915,1 Hesham (End)
IF TYPE("lcReturn") = 'C'

  *** If the popup from field in a file ***
  
  *** Save old alias ***
  lcOldFile = ALIAS()
 
  *** Select the file that has the popup contains ***
  SELECT (lcContNam)  
  
  LOCATE
 
  IF !FOUND()
    *** File is empty.  No bars has been defined for this popup. ***
    *** <  Ok  > ***
    =gfModalGen("TRM00210B00000","DIALOG")
    SELECT (lcOldFile)
    *B600915,1 Hesham (Start)
    ON KEY LABEL ESCAPE &lcOnEsc
    *B600915,1 Hesham (END)
    RETURN " "
  ENDIF

  *** define popup from field
  IF TYPE('lcPopWindo') ='C'
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           PROMPT FIELD &lcDisplay;
           MARGIN ;
           MARK "" ;
           SCROLL;
           SHADOW ;
           IN WINDOW(lcPopWindo)
  ELSE
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           PROMPT FIELD &lcDisplay;
           MARGIN ;
           MARK "" ;
           SHADOW;
           SCROLL           
  ENDIF
  *** If select any bar of the popup deactivate this popup ***
  ON SELECTION POPUP lcList DEACTIVATE POPUP lcList

  lnFound = 0
  GO TOP
  COUNT WHILE UPPER(ALLTRIM(EVALUATE(lcDisplay)))<> ;
              UPPER(ALLTRIM(lcSayVar)) TO lnFound
  
  IF lnFound > 0
    lcCode   = &lcReturn
    lnDefBar = _TALLY + 1
  ENDIF
  
  *** Activate the popup, & it will stop at this line till ***
  *** any action happen ....
  ACTIVATE POPUP lcList BAR lnDefBar
  
  *** If select any bar, put the fields values in the ***
  *** variables that defined in the calling screen .. ***
  IF LASTKEY() = 13
    lcSayVar = &lcDisplay
    lcCode   = &lcReturn
  ENDIF
  *** Release the popup & select the old alias ***
  RELEASE POPUP lcList  
  SELECT (lcOldFile)
  *B600915,1 Hesham (Start)
  ON KEY LABEL ESCAPE &lcOnEsc
  *B600915,1 Hesham (END)
  RETURN (lcCode)
  
ELSE

  *** If the popup from array declared before calling the function ***

  *** Define the popup name ***
  *lcPopupNam = 'lcList'

  *** Define popup from array ***
  IF TYPE('lcPopWindo') ='C'
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           MARGIN ;
           MARK "" ;
           SCROLL;
           SHADOW ;
           IN WINDOW (lcPopWindo)

  ELSE
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           MARGIN ;
           SCROLL;
           MARK "" ;
           SHADOW
  ENDIF
  *** Fill the popup with the element of the array ***
  =gfFillPop('lcList',lcContNam,lcDisplay)

  *** If select any bar of the popup deactivate this popup ***
  ON SELECTION POPUP lcList DEACTIVATE POPUP lcList
  

  lnFound = ASCAN(&lcContNam,ALLTRIM(lcSayVar))

  IF lnFound > 0
    lnDefBar = ASUBSCRIPT(&lcContNam,lnFound,1)
    lcCode   = &lcContNam[lnDefBar,lcReturn] 
  ENDIF 


  *** Activate the popup, & it will stop at this line till ***
  *** any action happen ....
  ACTIVATE POPUP lcList BAR lnDefBar
  
  *** Release the popup ***
  RELEASE POPUP lcList


  *** If select any bar, but the array elements in the ***
  *** variables that defined in the calling screen ..  ***

  IF LASTKEY() = 13
    lcSayVar = &lcContNam[IIF(BAR()=0 .OR. BAR()>ALEN(&lcContNam,1),1,BAR()),lcDisplay]
    lcCode   = (&lcContNam[IIF(BAR()=0 .OR. BAR()>ALEN(&lcContNam,1),1,BAR()),lcReturn])
  ENDIF  


  *** Return with 2nd column in the array that hold the ***
  *** value that has to be put in the ladata in the     ***
  *** calling screen ...
  *B600915,1 Hesham (Start)
  ON KEY LABEL ESCAPE &lcOnEsc
  *B600915,1 Hesham (END)
  RETURN lcCode

ENDIF

*!*************************************************************
*! Name      : gfFlock
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To lock entir file or files
*!*************************************************************
*! Calls     : 
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Name of files
*!                      lock or unlock
*!                      Numvber of attemps 
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will atempt to lock multiple files and let the user to retry
* agian till he select to cancel the operation
* parameters : Files list to lock
*              Flag to lock or unlock the files
*
*:->
FUNCTION gfFlock
PARAMETERS lcFls2lock,llLokUnlok,lnTry

lcFls2lock = IIF(TYPE('lcFls2lock')<>'C',ALIAS(),lcFls2lock)
llLokUnlok = IIF(TYPE('llLokUnlok')='U',.F.,llLokUnlok)
lnTry      = IIF(TYPE('lnTry')     ='N',lnTry,gnLockTry) 
llRetFlag  = .F.
llRetry    = .F.

*** If no files was sent return with .F.
IF EMPTY(lcFls2lock)
  RETURN llRetFlag
ENDIF

*** Put files to be locked in array
DECLARE laFls2lock[1]

IF ',' $ lcFls2lock
  =gfSubStr(lcFls2lock,@laFls2lock,',')
ELSE
  laFls2lock[1] = lcFls2lock
ENDIF   



SET REPROCESS TO lnTry

*** Lock one or multiple files
IF llLokUnlok
  *** Keep tring till the user decide to cancle
  DO WHILE .T.
    *** Loop to lock all files to be locked
    FOR lnFCount =  1 TO ALEN(laFls2lock,1)
      *** If files was locked all return with .T.
      IF FLOCK(laFls2lock[lnFCount])
        llRetFlag = .T.
      ELSE
        *** Give the user message to retry or cancel
        *** Files is in use by another user
        IF gfModalgen("QRM00108B00015","ALERT",UPPER(ALLTRIM(laFls2lock[lnFCount]))) = 1
          llRetFlag = .F.
          llRetry   = .T.
          *** Exit from the for loop and retry again
          EXIT
        ELSE
          llRetFlag = .F.
          llRetry   = .F.
          *** Exit from the for loop and quit function
          EXIT
        ENDIF
      ENDIF
    ENDFOR
    *** If at least one files was not locked
    IF !llRetFlag 
      *** If the user select to retry loop again
      IF llRetry 
        LOOP
      *** If not quit the function with .F.
      ELSE
        *** If cancel unlock in all alias 
        FOR lnFCount =  1 TO ALEN(laFls2lock,1)
          UNLOCK IN (laFls2lock[lnFCount])
        ENDFOR
        llRetFlag = .F.    
        EXIT
      ENDIF
    ELSE
      *** If all lockes went ok terminat the loop
      EXIT
    ENDIF  
  ENDDO

*** Unlock multiple files 
ELSE
  FOR lnFCount =  1 TO ALEN(laFls2lock,1)
    UNLOCK IN (laFls2lock[lnFCount])
  ENDFOR
  llRetFlag = .T.
ENDIF

SET REPROCESS TO gnLockTry

RETURN llRetFlag

*!*************************************************************
*! Name      : gfRlock
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Phisycal lock to record in one or more files
*!*************************************************************
*! Calls     : 
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Name of files
*!                      Lock or unlock 
*!                      Number of attempts    
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function will atempt to lock multiple files and let the user to retry
* agian till he select to cancel the operation
* parameters : Files list to lock
*              Flag to lock or unlock the files
*
*:->
FUNCTION gfRlock
PARAMETERS lcFls2lock,llLokUnlok,lnTry

lcFls2lock = IIF(TYPE('lcFls2lock')<>'C',ALIAS(),lcFls2lock)
llLokUnlok = IIF(TYPE('llLokUnlok')='U',.F.,llLokUnlok)
lnTry      = IIF(TYPE('lnTry')     ='N',lnTry,gnLockTry) 
llRetFlag  = .F.
llRetry    = .F.

*** If no files was sent return with .F.
IF EMPTY(lcFls2lock)
  RETURN llRetFlag
ENDIF

*** Put files to be record locked in array
DECLARE laFls2lock[1]
IF ',' $ lcFls2lock 
  =gfSubStr(lcFls2lock,@laFls2lock,',')
ELSE
  laFls2lock[1] = lcFls2lock
ENDIF  


SET REPROCESS TO lnTry

*** Lock one or multiple files
IF llLokUnlok
  *** Keep tring till the user decide to cancle
  DO WHILE .T.
    *** Loop to lock all files to be locked
    FOR lnFCount =  1 TO ALEN(laFls2lock,1)
      *** If files was locked all return with .T.
      IF RLOCK(laFls2lock[lnFCount])
        llRetFlag = .T.
      ELSE
        *** Give the user message to retry or cancel
        *** Files is in use by another user
        IF gfModalgen("QRM00109B00015","ALERT",UPPER(ALLTRIM(laFls2lock[lnFCount]))) = 1
          llRetFlag = .F.
          llRetry   = .T.
          *** Exit from the for loop and retry again
          EXIT
        ELSE
          llRetFlag = .F.
          llRetry   = .F.
          *** Exit from the for loop and quit function
          EXIT
        ENDIF
      ENDIF
    ENDFOR
    *** If at least one files was not locked
    IF !llRetFlag 
      *** If the user select to retry loop again
      IF llRetry 
        LOOP
      *** If not quit the function with .F.
      ELSE
        *** If cancel unlock in all alias 
        FOR lnFCount =  1 TO ALEN(laFls2lock,1)
          UNLOCK IN (laFls2lock[lnFCount])
        ENDFOR
        llRetFlag = .F.    
        EXIT
      ENDIF
    ELSE
      *** If all lockes went ok terminat the loop
      EXIT
    ENDIF  
  ENDDO

*** Unlock multiple files 
ELSE
  FOR lnFCount =  1 TO ALEN(laFls2lock,1)
    UNLOCK IN (laFls2lock[lnFCount])
  ENDFOR
  llRetFlag = .T.
ENDIF

SET REPROCESS TO gnLockTry

RETURN llRetFlag

*!*************************************************************
*! Name      : gfwDirect
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To redirect the cursor to the right object in case of child windows
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : First or last object in screen
*!                      Offset to shift to 
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfwDirect
PARAMETERS lcBgnLast,lnShift

lnShift = IIF(TYPE('lnShift')<> 'N',1,lnShift)

*** Comming from first object 
IF UPPER(lcBgnLast) = 'BEGIN'
  DO CASE
    *** Moving forword
    *B600478,1 add the END key (6) to condition            
    CASE INLIST(LASTKEY(),9,4,24,18,6)
      _CUROBJ = _CUROBJ + 1
    *** Moving bakword 
    *B600478,1 add the backspac key (127) to condition
    *B600478,1 add the home key (1) to condition                
    *B600478,1 add the ^K key (11) to condition    
    CASE INLIST(LASTKEY(),15,19,5,3,127,1,11)
      IF WREAD("gwcContrl1")
        lnWindNum = ASCAN(laWndObj,'GWCCONTRL1')
      ELSE
        lnWindNum = ASCAN(laWndObj,WOUTPUT())
      ENDIF
       _CUROBJ    = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),3])
    OTHERWISE
    IF  WREAD("GWCCONTRL1")
       _CUROBJ = OBJNUM(pbCls)
    ELSE   
      lnWindNum  = ASCAN(laWndObj,WOUTPUT())
      _CUROBJ    = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),2])       
*ymo       RETURN .F.
     ENDIF  
  ENDCASE     
*** Comming from last object
ELSE
  DO CASE
    *** Moving Forword
    *B600478,1 add the END key (6) to condition                
    CASE INLIST(LASTKEY(),9,4,24,18,6)
      IF WREAD("GWCCONTRL1")
        lnWindNum = ASCAN(laWndObj,'GWCCONTRL1')
      ELSE
        lnWindNum = ASCAN(laWndObj,WOUTPUT())
      ENDIF
      _CUROBJ     = OBJNUM(&laWndObj[ASUBSCRIPT(laWndObj,lnWindNum,1),2])
    *** Moving bakword
    *B600478,1 add the backspac key (127) to condition
    *B600478,1 add the home key (1) to condition            
    *B600478,1 add the ^K key (11) to condition        
    CASE INLIST(LASTKEY(),15,19,3,127,1,11)    &&,5
       IF laScrMode[1]
         _CUROBJ = 2
       ELSE
         _CUROBJ = _CUROBJ - lnShift
       ENDIF  
  ENDCASE
ENDIF


*!*************************************************************
*! Name      : gfTmp2Mast
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To update master file from a temp one
*!*************************************************************
*! Calls     : 
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Master file name
*!                      Temp file name 
*!                      Fixed message in thermo
*!                      variable message in thermo   
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Program to update records of master file from temp file 
* Temp file has to have 2 additional fields nRecNo and cStatus to hold
* the phisical records no and the action status done to this record
*
*:->
FUNCTION gfTmp2Mast
PARAMETERS lcMastFile,lcTempFile,lcFxdMsg,lcVarMsg

PRIVATE    lcMastFile,lcTempFile,lcSavAlias,lcFxdMsg,lcVarMsg

lcSavAlias = SELECT(0)
*E300591,1 Hesham El-Sheltawi (Start)
*E300591,1 No need for variable lcSourceDir
*lcSourcDir = IIF (UPPER(LEFT(lcMastFile,2))="SY",gcSyshome,gcDatadir)
*E300591,1 Hesham El-Sheltawi (End)
lcFxdMsg   = IIF(TYPE('lcFxdMsg')<>'C','Saving to master file...',lcFxdMsg ) 
lcVarMsg   = IIF(TYPE('lcVarMsg')<>'C',' ',lcVarMsg) 

lcSaveDel = SET ('DELETE')
SET DELETE OFF

SELECT (lcTempFile)
lnTotalRec = RECCOUNT(lcTempFile)
lnCurrRec  = 0
GO TOP

*** Scan through all the Added,Modified or Deleted records

SCAN FOR cStatus <> 'S' 
*  lnCurrRec = RECNO(lcTempFile)
   lnCurrRec = lnCurrRec+1
  = gfThermo(lnTotalRec,lnCurrRec,lcFxdMsg,lcVarMsg)
  DO CASE 
    *** New added record   
    CASE cStatus = 'A'                    
      SCATTER MEMVAR MEMO
      SELECT  (lcMastFile)  
      IF SEEK(' ')                        && Chek if there is empty 
        RECALL                            && Deleted records to recall
        GATHER MEMVAR MEMO
      ELSE  
       *E300591,1 Hesham El-Sheltawi (Start)
       *E300591,1 No need for variable lcSourceDir
*        INSERT INTO &lcSourcDir.&lcMastFile FROM MEMVAR
        INSERT INTO &lcMastFile FROM MEMVAR 
       *E300591,1 Hesham El-Sheltawi (End)               
      ENDIF  

    *** Record was modified
    CASE cStatus = 'M'                    
      SCATTER MEMVAR MEMO                 && Collect data from temp
      SELECT  (lcMastFile)  
      GO &lcTempFile..nRecNo
      GATHER  MEMVAR MEMO                 && Replace master data 

    *** Record was deleted
    CASE cStatus = 'D' .AND.  DELETED() 
      SELECT  (lcMastFile)  
      GO &lcTempFile..nRecNo
      SCATTER MEMVAR MEMO BLANK           && Empty the record befor
      GATHER  MEMVAR MEMO                 && delete it
      DELETE                              && Delete recored not in temp
  ENDCASE

  SELECT  (lcTempFile)
  REPLACE cStatus WITH "S"
ENDSCAN  

IF lnTotalRec > lnCurrRec
  FOR lnCurrRec=lnCurrRec TO lnTotalRec
    = gfThermo(lnTotalRec,lnCurrRec,lcFxdMsg,lcVarMsg)
  ENDFOR
ENDIF  

SET DELETE &lcSaveDel
SELECT (lcSavAlias)

*!*************************************************************
*! Name      : gfBldStatc
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To build the static file for all programs in the system
*!*************************************************************
*! Calls     : 
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!          Calls: GFSCRINI()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfBldStatc
*E301316,1 Define the variable lcProgName before calling gfScrIni() [Start]
PRIVATE lcProgName
*E301316,1 Define the variable lcProgName before calling gfScrIni() [End..]

lcCurFile = ALIAS()
*E301077,78 Hesham (Start)
llObjctUse = gfSysOpen(gcSysHome+'SYDOBJCT','CAPP_ID')
*SELECT SYDOBJCT
*SET ORDER TO TAG CAPP_ID
*E301077,78 Hesham (End)
GO TOP


lcOldBase = gcBaseWind
lcOldAppl = gcWinAppl 
lcOldModl = gcAct_Appl
lnCurRec  = RECNO()
lnCurrent = 0
COUNT TO lnTotRec  FOR capobjtyp = 'P'

**** Scan for

SCAN FOR capobjtyp = 'P'
  lnCurrent = lnCurrent + 1
  =gfThermo(lnTotRec,lnCurrent,"Generating static record for :",cPrglname)
  gcBaseWind = ALLTRIM(cBaseWind)
  gcIniName  = ALLTRIM(cBaseWind) 
  *E301316,1 Define the variable lcProgName before calling gfScrIni() [Start]
  lcProgName = cApobjnam
  *E301316,1 Define the variable lcProgName before calling gfScrIni() [End..]    
  gcAct_Appl = cApp_id
  gcWinAppl  = cApp_id
  lnCurRec   = RECNO()
  =gfScrIni()
  SELECT SYDOBJCT
  SET ORDER TO TAG CAPP_ID
  GO lnCurRec

ENDSCAN

gcBaseWind = lcOldBase 
gcWinAppl  = lcOldAppl
gcAct_Appl = lcOldModl
*E301077,78 Hesham (Start)
USE IN IIF(llObjctUse,'SYDOBJCT',0)
*E301077,78 Hesham (End)

IF !EMPTY(lcCurFile)
  SELECT (lcCurFile)
ENDIF  


*!*************************************************************
*! Name      : gfUserList
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Collect the names of users loged to the system
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!          Calls: SYUSRLST.SPR             
*!*************************************************************
*! Passed Parameters  : Flag to get the count only
*!*************************************************************
*! Returns            : Number of users loged to the system
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfUserList
PARAMETERS llGetCount

*SAMEH    SSE Fix Global Bug LASCRMODE not found (START)
*PRIVATE ALL LIKE  L*
PRIVATE lcOldRep,laUserList,lcCurrFile,lnUsrRec
*SAMEH    SSE     (END)              

*B600846,1 Get the old prepocess number
lcOldRep = SET('REPROCESS')
*B600846,1 Set the system to try to lock only one  time
SET REPROCESS TO 1

llGetCount = IIF(TYPE('llGetCount')="U",.F.,llGetCount)

DECLARE laUserList[1]

lcCurrFile = ALIAS()
laUserList = " "
lnUsrRec   = 0

IF USED("SYUUSER")
  lnUsrRec = RECNO("SYUUSER")
ENDIF

*B600498,1 Modidy the SQL SELECT to search for users records by User ID and Station no.
* SELECT IIF(SYUSTATC.CUSER_ID=gcUser_ID .AND. SYUSTATC.cstation=gcStation,"*"," ")+SYUUSER.CUSR_NAME ;
       FROM (gcSysHome+"SYUSTATC"),(gcSysHome+"SYUUSER");
       WHERE SYUSTATC.CUSER_ID = SYUUSER.CUSER_ID .AND.;
             COBJ_TYP+ALLTRIM(COBJ_NAME)+SYUSTATC.CUSER_ID+CSTATION =;
              'INI'+'OLDVARS' .AND.;
             gfCheckUser(SYUSTATC.CUSER_ID) ;
      ORDER BY SYUUSER.CUSR_NAME ;       
       INTO ARRAY  laUserList     

* SELECT IIF(SYUSTATC.CUSER_ID=gcUser_ID .AND. SYUSTATC.cstation=gcStation,"*"," ")+SYUUSER.CUSR_NAME ;
       FROM (gcSysHome+"SYUSTATC"),(gcSysHome+"SYUUSER");
       WHERE SYUSTATC.CUSER_ID = SYUUSER.CUSER_ID ;
       .AND.;
             COBJ_TYP+ALLTRIM(COBJ_NAME)+SYUSTATC.CUSER_ID+CSTATION=;
              'INI'+'OLDVARS' ;
       .AND.;
             gfCheckUser(SYUSTATC.CUSER_ID,CSTATION) ;
        ORDER BY SYUUSER.CUSR_NAME ;       
       INTO ARRAY  laUserList     

*B609495,1 HES 11/01/2011 Filter just the A27 users [Begin]
*!*	 SELECT IIF(SYUSTATC.CUSER_ID=gcUser_ID .AND. SYUSTATC.cstation=gcStation,"*"," ")+PADR(LFGETUSRNM(SYUSTATC.CUSER_ID),35) ;
*!*	       FROM (gcSysHome+"SYUSTATC");
*!*	       WHERE COBJ_TYP+ALLTRIM(COBJ_NAME)+SYUSTATC.CUSER_ID+CSTATION=;
*!*	              'INI'+'OLDVARS' ;
*!*	       .AND.;
*!*	             gfCheckUser(SYUSTATC.CUSER_ID,CSTATION) ;
*!*	       INTO ARRAY  laUserList     

 SELECT IIF(SYUSTATC.CUSER_ID=gcUser_ID .AND. SYUSTATC.cstation=gcStation,"*"," ")+PADR(LFGETUSRNM(SYUSTATC.CUSER_ID),35) ;
       FROM (gcSysHome+"SYUSTATC");
       WHERE COBJ_TYP+ALLTRIM(COBJ_NAME)+SYUSTATC.CUSER_ID+CSTATION=;
              'INI'+'OLDVARS' ;
       .AND.;
             SYUSTATC.Cadd_Ver = 'A27' ;
       .AND.;
             gfCheckUser(SYUSTATC.CUSER_ID,SYUSTATC.cstation) ;
       INTO ARRAY  laUserList     
       
*B609495,1 HES 11/01/2011 Filter just the A27 users [End  ]

*B600846,1 Return the SET REPROCESS to its initial value
SET REPROCESS TO lcOldRep
IF gnMyStRec<RECCOUNT('syuStatc')
  GO gnMyStRec IN syuStatc 
  =RLOCK('syuStatc')
ENDIF  

IF !llGetCount
  DO SYUSRLST.SPR
ENDIF  


IF !EMPTY(lcCurrFile)
  SELECT (lcCurrFile)
ENDIF  

IF lnUsrRec > 0 .AND. USED("SYUUSER")
  IF lnUsrRec <= RECCOUNT("SYUUSER")
    GO lnUsrRec IN SYUUSER
  ENDIF
ENDIF

IF llGetCount
  RETURN _TALLY 
ENDIF

*!*************************************************************
*! Name      : gfCheckUser
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To check if user is loged in or not 
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : User ID
*!*************************************************************
*! Returns            : .t. if user is loged
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfCheckUser
*B600498,1 Add new parameter lCSTATION
PARAMETERS lcUserID, lcStation

lcStation=IIF(TYPE('lcStation')<>"C","",lcStation)
llRetFlag = .T.
*B600498,1 Seek by lcUserID+lcStation
*IF SEEK('INI'+'OLDVARS'+lcUserID,'SYUSTATC')

*B609495,1 HES 11/01/2011 Filter just the A27 users [Begin]
*!*	IF SEEK('INI'+'OLDVARS'+lcUserID+lcStation,'SYUSTATC')
lnAlais= SELECT()
=SEEK('INI'+'OLDVARS'+lcUserID+lcStation,'SYUSTATC')
SELECT SYUSTATC
LOCATE REST WHILE cobj_typ+ALLTRIM(cobj_name)+cuser_id+cstation =  'INI'+'OLDVARS'+lcUserID+lcStation FOR SYUSTATC.cAdd_Ver = 'A27'
IF FOUND()
*B609495,1 HES 11/01/2011 Filter just the A27 users [End  ]

  IF RLOCK('SYUSTATC') 
    *B609495,1 HES 11/01/2011 Filter just the EDI users [Begin]
    IF !(lcUserID+lcStation = gcUser_ID+gcStation)
    *B609495,1 HES 11/01/2011 (End)  
    UNLOCK IN SYUSTATC
    *B609495,1 HES 11/01/2011 Filter just the EDI users [Begin]
    ENDIF
    *B609495,1 HES 11/01/2011 (End)    
    llRetFlag = .F.
  ENDIF
ELSE
  llRetFlag = .F.
ENDIF  
*B600498,1 Check by both lcUserID+lcStation for this session user data
*RETURN llRetFlag .OR. (lcUserID = gcUser_Id)
RETURN llRetFlag .OR. (lcUserID+lcStation = gcUser_Id+gcStation)

*!*************************************************************
*! Name      : lfGetUsrNm
*! Developer : Yasser EL Oraby
*! Date      : 07/05/1995
*! Purpose   : Get the user name
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : User ID
*!*************************************************************
*! Returns            : If use_id exist in the user file returns user name, 
*!                      else returns CUSER_ID
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
*YMO
FUNCTION lfGetUsrNm

PARAMETER lcUser_ID
SELECT SYUUSER
IF SEEK(lcUser_ID)
   RETURN cUsr_Name
ELSE
    RETURN lcUser_ID
ENDIF

*!*************************************************************
*! Name      : gfStripExt
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To extract the extention from file name
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : file name with extention
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*:->
FUNCTION gfStripExt
PARAMETERS lcFileName
PRIVATE lnDotPos,lnTermintr

lnDotPos   = RAT(".",lcFileName)
lnTermintr = MAX(RAT("\",lcFileName),RAT(":",lcFileName))
IF lnDotPos > lnTermintr
  lcFileName = LEFT( lcFileName ,lnDotPos-1)
ENDIF
RETURN lcFileName

*!*************************************************************
*! Name      : gpSQLBrak
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : Do handle Esc during any SQL select
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
PROCEDURE gpSQLBrak


SET TALK OFF
IF gfModalGen("INM00114B00015","ALERT") = 1
  glEscPrs = .F.
  SET TALK ON
  RETRY
ELSE
  glEscPrs = .T.
ENDIF

*!*************************************************************
*! Name      : gpChngModl
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To change the module to selected one
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GFREADWHEN()             (function  in ARIA3.PRG)
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!      Called by: GPRELOGIN                (procedure in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFMENUBLD()              (function  in ARIA3.PRG)
*!          Calls: GPCHNGDATA               (procedure in ARIA3.PRG)
*!          Calls: GPDISPSTAT               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Module ID
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*Builds applications menu
*
*:->>
PROCEDURE gpChngModl
PARAMETER lcAppID                      && Accept parameters.

llInitMenu = .F.

*** Return if no company created or selected
*B609580,1 TMI 05/07/2011 [Start] a Co. should be selected in all cases, 
*IF EMPTY(gcAct_Comp) .AND. lcAppID <> 'SM' 
IF EMPTY(gcAct_Comp)
  *B609580,1 TMI 05/07/2011 [End  ] 
  =gfModalgen("INM00058B00000","DIALOG")
  *B600474,1 Hesham (Start)
  *B600474,1 Show the menu
  SHOW MENU _MSYSMENU
  *B600474,1 Hesham (End)
  RETURN
ENDIF

*** Return if calling the active application
IF UPPER(lcAppID) = UPPER(gcAct_Appl)  .AND. !glReLogIn                      
  =gfModalgen("INM00046B00000","DIALOG",gcApp_Name)
  *B600474,1 Hesham (Start)
  *B600474,1 Show the menu
  SHOW MENU _MSYSMENU  
  *B600474,1 Hesham (End)
  RETURN                              
ENDIF

IF !(lcAppID $ gcPrmtMdls) .AND. lcAppID <> "SM" 
  =gfModalgen("INM00239B00000","ALERT")
  *B600474,1 Hesham (Start)
  *B600474,1 Show the menu  
  SHOW MENU _MSYSMENU  
  *B600474,1 Hesham (End)
  RETURN                              
ENDIF

lcCerFile  = ALIAS()

*E301077,78 Hesham (Start)
llAppUsd = gfSysOpen(gcSysHome+'SYDAPPL','CAPP_ID')

*IF !USED("SYDAPPL")
*  SELECT 0
*  USE (gcSyshome+"SYDAPPL")
*ELSE
*  SELECT SYDAPPL
*ENDIF
*E301077,78 Hesham (End) 
SET ORDER TO TAG CAPP_ID

*** Check if the selected module linked to the system
IF SEEK(lcAppID)
    IF CMODULEVER = 'V'
   *   = gfMsgBox('TR','Module '+ALLT(CAPP_NAME)+' can,'\?\!\<Ok','ALERT')  
   SHOW MENU _MSYSMENU
   RETURN 
  ENDIF

  IF gcComp_Lvl='C' .AND. lparntmdl
    =gfModalgen("INM00157B00000","ALERT",ALLTRIM(PROMPT()))
    *B500645,1 Check if the file [lcCerFile] is still used
    IF !EMPTY(lcCerFile) AND USED(lcCerFile)
      SELECT(lcCerFile)
    ENDIF
    *B600474,1 Hesham (Start)
    *B600474,1 Show the menu    
    SHOW MENU _MSYSMENU
    *B600474,1 Hesham (End)
    USE IN IIF(llAppUsd,'SYDAPPL',0)
    RETURN 
  ENDIF

  *** Check if the selected module is installed to the current company 
  IF AT(lcAppID,gcComp_Mdl) = 0 .AND. lcAppID <>'SM' 
    =gfModalgen("INM00151B00000","ALERT",ALLTRIM(PROMPT())+"|"+gcCom_Name)
    *B500645,1 Check if the file [lcCerFile] is still used
    IF !EMPTY(lcCerFile) AND USED(lcCerFile)
      SELECT(lcCerFile)
    ENDIF
    *B600474,1 Hesham (Start)
    *B600474,1 Show the menu    
    SHOW MENU _MSYSMENU
    *B600474,1 Hesham (End)
    USE IN IIF(llAppUsd,'SYDAPPL',0)
    RETURN 
  ENDIF 


  *** Check if setup requred for the selected module
  IF SYDAPPL.lsetreq
*E300633,1 Hesham El-Sheltawi (Start)
*E300633,1 Check if the selected module was setuped for the active company 
*E300633,1 through the new comp. variable gcCmpModules "Comp. Set Modules"
     llSetDon = ATC(lcAppID,gcCmpModules)>0 OR lcAppID='SM'  
*    lcSetupFl = lcAppID+"SETUP"
*    llSetDon  = .F.
*    SELECT 0
*    *** Check if the setup file for the selected module is exist or not 
*    IF FILE(gcDataDir+lcSetupFl+".DBF")
*       USE (gcDataDir+lcSetupFl) ALIAS MODSETUP AGAIN
*       llSetDon  = lsetdon 
*       USE
*    ELSE
*     IF !llSetDon
*       *** The  setup file is not exist, 
*       *** you have to creat this file first befor attempt to 
*       *** select this module...!
*       =gfModalgen("INM00144B00000","ALERT",ALLTRIM(PROMPT()))        
*       *B500645,1 Check if the file [lcCerFile] is still used
*       IF !EMPTY(lcCerFile) AND USED(lcCerFile)
*         SELECT(lcCerFile)
*       ENDIF
*      *B600474,1 Hesham (Start)
*      *B600474,1 Show the menu       
*       SHOW MENU _MSYSMENU       
*      *B600474,1 Hesham (End)
*       RETURN
*     ENDIF  
*    ENDIF  
*E300633,1 Hesham El-Sheltawi (End)
    *** Check if the setup was done for the selected module 
    IF !llSetDon 
      *** Setup was not done to this module yet,"+CHR(13)
      *** you have to setup the module through the company information 
      *** program...!
      =gfModalgen("INM00145B00000","ALERT")
      *B500645,1 Check if the file [lcCerFile] is still used
      IF !EMPTY(lcCerFile) AND USED(lcCerFile)
        SELECT(lcCerFile)
      ENDIF
      *B600474,1 Hesham (Start)
      *B600474,1 Show the menu      
      SHOW MENU _MSYSMENU
      *B600474,1 Hesham (End)
      USE IN IIF(llAppUsd,'SYDAPPL',0)
      RETURN
    ENDIF     
    
    *E300441,4 Hesham (Start)
    *E300441,4 check if system build number is greater than or equal to
    *E300441,4 the needed one for the selected module
    lcActivePlat = IIF(_DOS,'Dos',IIF(_WINDOWS,'Windows',IIF(_MAC,'MAC','UNIX')))
    lcErrCond    = 'SYDAPPL.C'+IIF(_DOS,'Dos',IIF(_WINDOWS,'Win',IIF(_MAC,'MAC','UNIX')))+'BUILD==SYDAPPL.CMDLBUILD'    
    IF ! &lcErrCond
      lcMessage=[module ]+lcAppID+[ have not ]+;
                [been upgraded to the latest build number on the current ]+;
                [platform ( ]+lcActivePlat+[ )!]+CHR(13)+CHR(10)+[ If you proceed and use this ]+;
                [module, errors may occur and data may be lost. therefore ]+;
                [you have to install files for thid module ]+;
                [from the latest builds to be able to proceed with this module!]
      = gfMsgBox('TR',lcMessage,'\?\!\<Ok','ALERT')
      USE IN IIF(llAppUsd,'SYDAPPL',0)
      RETURN
    ENDIF
    lcMdlBldNum = ALLT(SUBSTR(sydappl.CMDLBUILD,1,ATC('-',sydappl.CMDLBUILD)-1))
    lcSysBldNum = ALLT(LOOKUP(SYDAPPL.CMDLBUILD,'SY',SYDAPPL.CAPP_ID,'CAPP_ID'))
    =SEEK(lcAppID,'SYDAPPL')    
    IF lcSysBldNum < lcMdlBldNum
      =gfMsgBox("IN","The current build number of the System Manager ("+lcSysBldNum ;
      +") is too old to run ("+lcAppID+"), you need at least SM build # "+lcMdlBldNum+;
      " to run this build of ("+lcAppID+"). Please update SM and try again!",.f.,'ALERT')
      SHOW MENU _MSYSMENU
      USE IN IIF(llAppUsd,'SYDAPPL',0)
      RETURN
    ENDIF
    *E300441,4 Hesham (End)
    
  ENDIF


*** Case the selected module was not installed to the system
ELSE
  *** Module  is not installed to your system...!
  =gfModalgen("INM00146B00000","ALERT",ALLTRIM(PROMPT()))
  *B500645,1 Check if the file [lcCerFile] is still used
  IF !EMPTY(lcCerFile) AND USED(lcCerFile)
    SELECT(lcCerFile)
  ENDIF
  *B600474,1 Hesham (Start)
  *B600474,1 Show the menu  
  SHOW MENU _MSYSMENU
  *B600474,1 Hesham (End)
  USE IN IIF(llAppUsd,'SYDAPPL',0)
  RETURN
ENDIF



*** If changing module while active program save it's enviroment
*IF RDLEVEL() >1                        
  *** If any program exept the tool bar the lcBaseWind variable will
  *** be defined
*  IF TYPE('lcBaseWind') = 'C'
*    =gfStatic()                     
*  ENDIF  
*ENDIF

*** If this is first module to run intializ the rest of the system
*** menu but dont do it again
IF glInitMenu  
  glInitMenu = .F.
  llInitMenu = .T.
  =gfMenuBld('SY','S')
ENDIF

*** Creat the module menu
IF !gfMenuBld(lcAppID,'A')
  *B500645,1 Check if the file [lcCerFile] is still used
  IF !EMPTY(lcCerFile) AND USED(lcCerFile)
    SELECT(lcCerFile)
  ENDIF
  USE IN IIF(llAppUsd,'SYDAPPL',0)
  RETURN 
ENDIF

glReLogIn  = .F.
  
*** Collect the files names to be opend and open them
llFil_Used = USED('sydfiles')
SELECT RTRIM(cFile_nam),RTRIM(cFile_Tag),000,000,"M",RTRIM(cFile_ttl);
     FROM  (gcSysHome+"sydfiles");
     INTO  ARRAY laMnu_Fl ;
     WHERE cFile_nam='' .AND.;
           lcAppID+'$' $ mFile_App

IF !llFil_Used
  USE IN ALIAS('sydfiles')
ENDIF  

*** In case activatin the first module reset the number of opened
*** files to 1 else ?
IF !EMPTY(gaMnu_Fl[1,1])
  gnOldFiles = ALEN(gaMnu_FL,1)
ELSE
  gnOldFiles = 1
ENDIF  

*** If the new module have files to be opend add them to the global
*** array
IF TYPE ('laMnu_Fl') <> 'U' 
  FOR lnARyFile = 1 TO ALEN(laMnu_Fl,1)
    *B601781,1 Compare ALLTRIM() of file names instead of file names
    *lnFilePos = ASCAN(gaMnu_Fl,laMnu_Fl[lnARyFile,1])
    lnFilePos = ASCAN(gaMnu_Fl,ALLTRIM(laMnu_Fl[lnARyFile,1]))
    *B601781,1 end
    IF lnFilePos > 0
      gaMnu_Fl[ASUBSCRIPT(gaMnu_Fl,lnFilePos,1),5] = "K"    
    ELSE
      IF !EMPTY(gaMnu_Fl[1,1])
        DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
      ENDIF  
      =AINS(gaMnu_Fl,1)
      gaMnu_Fl[1,1] = ALLTRIM(laMnu_Fl[lnARyFile,1])
      gaMnu_Fl[1,2] = ALLTRIM(laMnu_Fl[lnARyFile,2])
      gaMnu_Fl[1,3] = laMnu_Fl[lnARyFile,3]
      gaMnu_Fl[1,4] = laMnu_Fl[lnARyFile,4]
      gaMnu_Fl[1,5] = laMnu_Fl[lnARyFile,5]
      gaMnu_Fl[1,6] = laMnu_Fl[lnARyFile,6]
    ENDIF
  ENDFOR
  
  *** Close old files and open the new ones
  IF ALEN(laMnu_Fl,1) > 1 .AND. gcAct_Appl <> lcAppID
    =gpChngData(!llInitMenu)
  ENDIF

ENDIF


*** Update the global module variable
gcAct_Appl = lcAppID
gcApp_Name = ALLTRIM(SYDAPPL.cApp_name)
glParntMdl = SYDAPPL.lParntMdl
USE IN IIF(llAppUsd,'SYDAPPL',0)
*** Display the ID or name of the new module according to platform
*#IF _DOS
*    *** Case dos display the module ID at the status bar
*    lcSaveWIN  = WONTOP()
*    ACTIVATE SCREEN 
*    
*    DO gpDispStat
*    
*    IF !EMPTY(lcSaveWIN)
*      ACTIVATE WINDOW (lcSaveWIN) SAME
*    ENDIF
*
*  *** Case windows display the name of current module on the
*  *** fox window title
*#ELSE
    *B600439 ADD THE ACTIVE COMPANY TO THE DISPLAY IN THE MAIN WINDOW TITLE
    MODIFY WINDOW SCREEN FONT"FOXFONT",9 STYLE 'N';
            TITLE ALLTRIM(gcSysName)+" - "+ALLTRIM(gcApp_Name)+;
            IIF(!EMPTY(gcAct_Comp),' ('+ALLTRIM(gcAct_Comp)+')','');
            FLOAT;
            ZOOM;
            GROW 
*#ENDIF

*E300279,1 Change the help file to the one of the new application
=gfSetHlpFl(lcAppID)

*B132130,1  TMI [Start] call the lfReadAct function when module is changed and there is an open screen found
IF !EMPTY(WONTOP())
 PRIVATE lcErr
 lcErr = ON('ERROR')
 ON ERROR llDumy = .T.
 =lfReadAct()
 ON ERROR &lcErr
ENDIF
*B132130,1  TMI [End  ] 

*B500645,1 Check if the file [lcCerFile] is still used
IF !EMPTY(lcCerFile) AND USED(lcCerFile)
  SELECT(lcCerFile)
ENDIF



*!*************************************************************
*! Name      : gfAbotAria
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To dispaly the about aria dialog
*!*************************************************************
*! Calls     : 
*!       Calls: SYABOUT.SPR              
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
FUNCTION gfAbotAria
*E300355,1 In the screen : Change the Copyright 
*E300355,1 year to be 1996 instead of 1995
DO SYABOUT.SPR

*!*************************************************************
*! Name      : gfTechInfo
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   :  To diplay the tec. info dialog
*!*************************************************************
*! Calls     : 
*!           Calls: SYTECINF.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
FUNCTION gfTechInfo

DO SYTECINF.SPR

*!*************************************************************
*! Name      : gfAddOnOff
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To mark the auto add bar on/off
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfAddOnOff

lnBar = BAR()
lcPop = POPUP()

glAutoAdd=!glAutoAdd
SET MARK OF BAR lnBar OF (lcPop) glAutoAdd

*!*************************************************************
*! Name      : gfMsgOnOff
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to mark the message bar on/off
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfMsgOnOff

lnBar = BAR()
lcPop = POPUP()

glMsgRem=!glMsgRem
SET MARK OF BAR lnBar OF (lcPop) glMsgRem

*!*************************************************************
*! Name      : gfTskOnOff
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To mark the user task bar on/off
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfTskOnOff

lnBar     = BAR()
lcPop     = POPUP()
llUserOpn = .F.

glUser_Tsk=!glUser_Tsk
SET MARK OF BAR lnBar OF (lcPop) glUser_Tsk


IF !USED('syuUser')
  llUserOpn = .T.
  SELECT 0
  USE (gcSysHome+"syuUser") 
ELSE
  SELECT syuUser
ENDIF

SET ORDER TO TAG Cuser_id

IF SEEK(gcUser_ID)
  REPLACE syuuser.lusr_dtask WITH glUser_Tsk
ENDIF 
   
IF llUserOpn
  USE IN syuUser
ENDIF

IF glUser_Tsk
  IF glTooAlon 
    CLEAR READ
  ELSE  
    IF RDLEVEL() = 1 
      KEYBOARD "{ENTER}" PLAIN CLEAR
    ENDIF
  ENDIF  
ENDIF

*!*************************************************************
*! Name      : gfTbarOnOff
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to mark the toolbar bar on/off
*!*************************************************************
*! Calls     : 
*!          Calls: GFTOOLBAR()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfTbarOnOff

lnBar     = BAR()
lcPop     = POPUP()
llUserOpn = .F.

glToolActv =!glToolActv
gltooAlon  =!glTooAlon 

SET MARK OF BAR lnBar OF (lcPop) glToolActv

IF !USED('syuUser')
  llUserOpn = .T.
  SELECT 0
  USE (gcSysHome+"syuUser") 
ELSE
  SELECT syuUser
ENDIF

SET ORDER TO TAG Cuser_id

IF SEEK(gcUser_ID)
  REPLACE Syuuser.lusr_ustb WITH glToolActv 
ENDIF 
   
IF llUserOpn
  USE IN syuUser
ENDIF


IF glToolActv
  =gfToolbar()
ELSE
  CLEAR READ
  glquitting = .T.
ENDIF  


*!*************************************************************
*! Name      : gfUnderDev
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to dispaly the message of program under development
*!*************************************************************
*! Calls     : 
*!            Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfUnderDev

=gfModalgen("TRM00092B00000","DIALOG")

*!*************************************************************
*! Name      : gpAppLink
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to call any external application
*!*************************************************************
*! Calls     : 
*!      Called by: GPMENUBAR                (procedure in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GPEXIT                   (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : application name, application path
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
PROCEDURE gpAppLink

PARAMETERS lcAppName,lcAPPPath

*B804099,1 AME [Start] In case of running dot prompt in presince of toolbar
*B804099,1 AME         releas tool bar first
IF WONTOP() = 'GWCCONTRL1' .AND. 'SMDOT' $ lcAppName
  RELEAS WINDOW GWCCONTRL1
ENDIF
*B804099,1 AME [End]

IF !glExtPrg
  glExtPrg  = .T.
  glEndProg = .T.
  gcApName    = lcAppName
  gcExtPrg    = lcAPPPath

  RETURN
ENDIF    

lcAppName = IIF(TYPE('lcAppName')='C',ALLTRIM(lcAppName),'ARIA')
lcAPPPath = IIF(TYPE('lcAPPPath')='C',lcAPPPath,gcDosApps)
lcAPPPath = SUBSTR(lcAPPPath,1,RAT("\",lcAPPPath))

IF RDLEVEL() > 1
  *** Please close all the open programs first...!
  =gfModalgen("TRM00160B00000","ALERT")
  RETURN
ENDIF
*MAN Added !FILE((lcAPPPath+lcAppName+'.EXE'))
IF !FILE((lcAPPPath+lcAppName+'.FXP')) .AND. ;
   !FILE((lcAPPPath+lcAppName+'.PRG')) .AND. ;
   !FILE((lcAPPPath+lcAppName+'.EXE'))
  *** Program +lcAPPPath+lcAppName+ dose not exist...!
  =gfModalgen("TRM00161B00000","ALERT",lcAPPPath+lcAppName)
  RETURN
ENDIF

*B600991 MAN 06/05/96 Start
IF FILE((lcAPPPath+'CONTROL.DBF')) AND 'ARIA' $ lcAppName 
  IF EMPTY(gcAct_comp)
    *You have to create or select a company before selecting this module.    =gfModalgen("INM00058B00000","DIALOG")
    =gfModalgen("INM00058B00000","DIALOG")
    RETURN
  ENDIF

  lcCurAl = ALIAS()
  SELECT 0
  USE (lcAPPPath+'CONTROL.DBF')
  LOCATE FOR SYSCODE = gcAct_comp 
  IF !FOUND()
    =gfModalgen("INM00252B00000","DIALOG",gcAct_Comp)
    USE
    RETURN
  ENDIF
  USE
  SELECT IIF(EMPTY(lcCurAl),SELECT(0), lcCurAl)
ENDIF
*B600991 END

*E300279,1  SET Help Topic to the related one in the menu file.
*DECLARE laOldSets(64)                   && Array to save old values
*E300492,1 Hesham El-Sheltawi (Start)
*DECLARE laOldSets(65)                   && Array to save old values
DECLARE laOldSets(66)                   && Array to save old values
*E300492,1 Hesham El-Sheltawi (End)
*E300279,1 End

*B600305,1 Define the temp name of the view, macro, and memory file to save the current environment
lcTmp_Nm = gfTempName()

*B600342,1 Stop screen saving
*SAVE SCREEN TO gcOldScreen

*B600305 use the temp file name instead of the fix one for the view file 
CREATE VIEW (gcWorkDir+lcTmp_Nm)
*CREATE VIEW (gcWorkDir+"AAS")

*B600421,1 Only save resource files under Dos and when the resources is ON
IF _DOS AND SET("RESOURCE") = "ON"
  CREATE COLOR SET OLDSET
ENDIF

*B600305 use the temp file name instead of the fix one for the macro file 
SAVE MACROS TO (gcWorkDir+lcTmp_Nm)
*SAVE MACROS TO (gcWorkDir+"AAS")

lcErorHand    = ON ('ERROR')
laOldSets(1)  = SET("AUTOSAVE")
laOldSets(2)  = SET("BELL")
laOldSets(3)  = SET("BLINK")
laOldSets(4)  = STR(SET("BLOCKSIZE"))
laOldSets(5)  = SET("CARRY")
laOldSets(6)  = SET("CENTURY")
laOldSets(7)  = SET("CLEAR")
laOldSets(8)  = SET("CLOCK")
laOldSets(9)  = SET("COLOR")
laOldSets(10) = SET("COMPATIBLE")
laOldSets(11) = SET("CONFIRM")
laOldSets(12) = SET("CONSOLE")
laOldSets(13) = SET("CURRENCY")
laOldSets(14) = SET("DATE")
laOldSets(15) = SET("DEBUG")
laOldSets(16) = STR(SET("DECIMALS"))
laOldSets(17) = FULLPATH(SET("DEFAULT"))
laOldSets(18) = SET("DELETED")
laOldSets(19) = SET("DELIMITERS")
laOldSets(20) = SET("DEVELOPMENT")
laOldSets(21) = SET("DEVICE")
laOldSets(22) = SET("DOHISTORY")
laOldSets(23) = SET("ECHO")
laOldSets(24) = SET("ESCAPE")
laOldSets(25) = SET("EXACT")
laOldSets(26) = SET("EXCLUSIVE")
laOldSets(27) = SET("FIELDS")
laOldSets(28) = SET("FILTER")
laOldSets(29) = SET("FIXED")
laOldSets(30) = SET("FULLPATH")
laOldSets(31) = SET("HEADING")
laOldSets(32) = SET("HELP")
laOldSets(33) = SET("HISTORY")
laOldSets(34) = STR(SET("HOURS"))
laOldSets(35) = SET("INTENSITY")
laOldSets(36) = STR(SET("MARGIN"))
laOldSets(37) = SET("MARK")
laOldSets(38) = STR(SET("MEMOWIDTH"))
laOldSets(39) = SET("MENU")
laOldSets(40) = SET("MESSAGE")
laOldSets(41) = STR(SET("MOUSE",1))
laOldSets(42) = SET("NEAR")
laOldSets(43) = STR(SET("ODOMETER"))
laOldSets(44) = SET("PATH")
laOldSets(45) = SET("POINT")
laOldSets(46) = SET("PRINT")
laOldSets(47) = SET("RESOURCE")
laOldSets(48) = SET("SAFETY")
laOldSets(49) = SET("SCOREBOARD")
laOldSets(50) = SET("SEPARATOR")
laOldSets(51) = SET("SHADOW")
laOldSets(52) = SET("SPACE")
laOldSets(53) = SET("STATUS")
laOldSets(54) = SET("STEP")
laOldSets(55) = SET("STICKY")
laOldSets(56) = SET("SYSMENUS")
laOldSets(57) = SET("TALK")
laOldSets(58) = SET("TITLE")
laOldSets(59) = STR(SET("TYPEAHEAD"))
laOldSets(60) = SET("UNIQUE")
laOldSets(61) = INSMODE()
laOldSets(62) = CAPSLOCK()
laOldSets(63) = NUMLOCK()
*E300279,1  SET Help Topic to the related one in the menu file.
laOldSets(65) = SET('TOPIC')
*E300279,1 End
*E300492,1 Hesham El-Sheltawi (Start)
laOldSets(66) = ON('SHUTDOWN')
*E300492,1 Hesham El-Sheltawi (End)

lcOldAlias    = ALIAS()

SET CLOCK OFF

*B600305 use the temp file name instead of the fix one for the memory file 
SAVE ALL LIKE * TO &gcWorkDir.&lcTmp_Nm
*SAVE ALL LIKE * TO &gcWorkDir.AAS
*E300251,1 Release Public Variables before leaving the system

*E301314,1 Save gcDataDir value to use it when call dotwin from aria [Start]
waDataDir=gcDataDir
*E301314,1 Save gcDataDir value to use it when call dotwin from aria [End..]

DO gpRlsPbl

*B600420,1 The menu pushing will be only under dos as we only pop it under dos
IF _DOS
  PUSH MENU _MSYSMENU
ENDIF
PUSH KEY

****************************************************************************
SET DEFAULT TO &lcAPPPath
llExitVal = .F.
DO (lcAppName) WITH "llExitVal"
SET RESO ON
WAIT "Restoring old environment.  Please standby...!" WINDOW NOWAIT
CLOSE DATABASES
*E301314,1 [Start]
RELEASE waDataDir 
*E301314,1 [End..]
****************************************************************************

POP KEY ALL
*B600303 IF WINDOWS DO NOT POP THE MENU
IF _WINDOWS
  POP MENU _MSYSMENU TO MASTER
  SET SYSMENU TO
ELSE
  POP MENU _MSYSMENU
ENDIF

*E300251,1 Define the Public variables 
DO gpDfnPbl

*B600305,1 use the temp file name instead of the fix one for the memory file 
RESTORE FROM &gcWorkDir.&lcTmp_Nm ADDITIVE
*RESTORE FROM &gcWorkDir.AAS ADDITIVE

*B600304 SET the default path before reOpening the files
SET DEFAULT TO  &laOldSets(17)
*B600305 use the temp file name instead of the fix one for the VIEW file 
*B600303 The set view command was used before defining the foundation window as while defining the window we use the system file
SET VIEW TO  (gcWorkDir+lcTmp_Nm)


*B600303 If the foundation window not defined and running under windows
IF _WINDOWS .AND. !WEXIST('fndation')
  *B600303,1 Change the "Microsoft Fox" screen title to "Aria Advantage Series"
  *B600439,1 ADD THE ACTIVE COMPANY TO THE DISPLAY IN THE MAIN WINDOW TITLE
  MODIFY WINDOW SCREEN FONT"FOXFONT",9 STYLE 'N';
	 TITLE ALLTRIM(gcSysName)+IIF(EMPTY(gcApp_Name),""," - ")+ALLTRIM(gcApp_Name)+ ;
	 IIF(!EMPTY(gcAct_Comp),' ('+ALLTRIM(gcAct_Comp)+')','');
	 FLOAT;
	 ZOOM;
	 GROW      

  *E301077,78 Hesham (Start)
  llInstUse=gfSysOpen(gcSysHome+'SYCINST')
  *E301077,78 Hesham (End)

  *B600303 if there is default bmp file display it
  IF !EMPTY(sycinst.cDef_BMP) AND FILE(sycinst.cDef_BMP)
    DEFINE WINDOW fndation   ;
	   FONT "FoxFont", 9 ;
       AT 0,0 SIZE SROWS(),SCOLS() ;
	   NONE &&FILL FILE (gcBmpHome+ALLTRIM(sycinst.cDef_BMP)) 
	   ACTIVATE WINDOW FNDATION
     @0,0 say (gcBmpHome+ALLTRIM(sycinst.cDef_BMP)) bitmap size SROW(),SCOL() CENTER STYLE "Q"	   
  ELSE
    DEFINE WINDOW fndation   ;
	   FONT "FoxFont", 9 ;
       AT 0,0 SIZE SROWS(),SCOLS() ;
	   NONE 
  ENDIF         
  ACTIVATE WINDOW fndation
  
  *B600342,1 Redraw the Aria Advantage Screen instead of saving and restoring it.
  *B600342,1 If there is default bmp file in the user file display it
  IF !EMPTY (gcUser_bmp) .and. ;
       ALLTRIM(sycinst.cDef_BMP) <> gcUser_bmp and file(gcBmpHome+gcUser_bmp)

  *E300791,1 Hesham (Start)           
*      MODIFY WINDOW fndation FILL FILE (gcBmpHome+gcUser_bmp )
    ACTIVATE WINDOW fndation 
    @0,0 CLEAR TO SROW(),SCOL()
     @0,0 say (gcBmpHome+gcUser_bmp ) bitmap size SROW(),SCOL() CENTER STYLE "Q"
  *E300791,1 Hesham (End)   
  ENDIF  
  *E301077,78 Hesham (Start)
  USE IN IIF(llInstUse,'SYCINST',0)
  *E301077,78 Hesham (End)
  
*E300791,1 Hesham (Start)  
*  @ 8.2,8.2 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W    
*  @ 8.1,8.1 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W  
*  @ 8,8     SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR R*	
*E300791,1 Hesham (End)
ENDIF
*B600303,1 Redefine the Aria Advantage Sysmenu as it is released under Aria Apparel (under WIN) due to the MDI settings
IF _WINDOWS 
  SET SYSMENU TO
  glInitMenu = .T.
  IF !EMPTY(gcAct_Appl)
   *B600420,1 Pop the menu before building the sysmenu
    POP MENU _MSYSMENU
    =gfMenuBld('SY','I','NOSHOW')
    =gfMenuBld('SY','S')
    =gfMenuBld(gcAct_Appl,'A')
    glInitMenu = .F.
  ELSE
    =gfMenuBld('SY','I')       
  ENDIF
ENDIF



SET AUTOSAVE     &laOldSets(1)
SET BELL         &laOldSets(2)
SET blink        &laOldSets(3)
SET BLOCKSIZE TO &laOldSets(4)
SET CARRY        &laOldSets(5)
SET CENTURY      &laOldSets(6)
SET CLEAR        &laOldSets(7)
SET CLOCK        &laOldSets(8)
SET COLOR TO     &laOldSets(9)
SET compatible   &laOldSets(10)
SET CONFIRM      &laOldSets(11)
SET CONSOLE      &laOldSets(12)
SET CURRENCY     &laOldSets(13)
SET DATE         &laOldSets(14)
SET DEBUG        &laOldSets(15)
SET DECIMALS TO  &laOldSets(16)
*B600304 This line is moved before set view as the set view was moved before the defination of the foundation window
*SET DEFAULT TO   &laOldSets(17)
SET DELETED      &laOldSets(18)
SET DELIMITERS   &laOldSets(19)
SET DEVELOPMENT  &laOldSets(20)
SET DEVICE TO    &laOldSets(21)
SET DOHISTORY    &laOldSets(22)
SET ECHO         &laOldSets(23)
SET ESCAPE       &laOldSets(24)
SET EXACT        &laOldSets(25)
SET EXCLUSIVE    &laOldSets(26)


SET FIXED        &laOldSets(29)
SET FULLPATH     &laOldSets(30)
SET HEADING      &laOldSets(31)
SET HELP         &laOldSets(32)
SET HISTORY      &laOldSets(33)
SET HOURS TO     &laOldSets(34)
SET INTENSITY    &laOldSets(35)
SET MARGIN TO    &laOldSets(36)
SET MARK TO      &laOldSets(37)
SET MEMOWIDTH TO &laOldSets(38)
SET MENU         &laOldSets(39)
SET MESSAGE TO   &laOldSets(40)
SET mouse TO     &laOldSets(41)
SET NEAR         &laOldSets(42)
SET ODOMETER TO  &laOldSets(43)
SET PATH TO      &laOldSets(44)
SET POINT TO     &laOldSets(45)
SET PRINT        &laOldSets(46)
SET RESOURCE     &laOldSets(47)
SET SAFETY       &laOldSets(48)
SET SCOREBOARD   &laOldSets(49)
SET SEPARATOR TO &laOldSets(50)
SET SHADOW       &laOldSets(51)
SET SPACE        &laOldSets(52)
SET STATUS       &laOldSets(53)
SET STEP         &laOldSets(54)
SET sticky       &laOldSets(55)
SET sysmenus     &laOldSets(56)
SET TALK         &laOldSets(57)
SET TITLE        &laOldSets(58)
SET TYPEAHEAD TO &laOldSets(59)
SET UNIQUE       &laOldSets(60)
*E300279,1  SET Help Topic to the related one in the menu file.
*SET TOPIC TO &gcHelpTopc
SET TOPIC TO &laOldSets(65)
*E300279,1  END
*E300492,1 Hesham El-Sheltawi (Start)
ON SHUTDOWN &laOldSets(66)
*E300492,1 Hesham El-Sheltawi (End)

ON ERROR &lcErorHand

= INSMODE(laOldSets(61))                        && Note usefulness of
*MAN
*= CAPSLOCK(laOldSets(62))                       && '=' evaluate command.
*= NUMLOCK(laOldSets(63))
*B600303 Moved the files Opening before the defining of the foundtion window
*SET VIEW TO  (gcWorkDir+"AAS")



IF !EMPTY(lcOldAlias)
  SELECT (lcOldAlias)
  SET FIELDS       &laOldSets(27)
  SET FILTER TO    &laOldSets(28)
ENDIF  

*B600305 use the temp file name instead of the fix one for the macro file 
RESTORE MACROS FROM &gcWorkDir.&lcTmp_Nm
*RESTORE MACROS FROM &gcWorkDir.AAS

IF _DOS AND SET('RESOURCE') = "ON"
  SET COLOR SET TO OLDSET
ENDIF

*B600456,1 Restoring the old background and the status bar when coming back from Apparel
*B600456,1 system
*#IF _DOS
*  @ 0,0,SROWS(),79 BOX REPLICATE("",9)
*  DO gpDispStat  
*#ENDIF
  
*B600342,1 Stop the screen restoring and releasing
*RESTORE SCREEN FROM gcOldScreen
*RELEASE gcOldScreen


RELEASE laOldSets

*B600305 use the temp file name instead of the fix one 
ERASE (gcWorkDir +lcTmp_Nm +".MEM")
ERASE (gcWorkDir +lcTmp_Nm +".VUE")
ERASE (gcWorkDir +lcTmp_Nm +".FKY")
*ERASE &gcWorkDir.AAS.MEM
*ERASE &gcWorkDir.AAS.VUE
*ERASE &gcWorkDir.AAS.FKY



WAIT CLEAR

IF llExitVal
  KEYBOARD "{ENTER}"
  =gpExit()
ELSE
  *E301314,1 comment the next line and add IF....ELSE....ENDIF structure [Start]
  *KEYBOARD "{ALT+M}" PLAIN CLEAR
  IF glSys_Log
    llOld=glLog_Requ
    glLog_Requ = .T.
    IF !gfLog_In()
      KEYBOARD "{ENTER}"
      =gpExit()
    ENDIF  
    glLog_Requ=llOld
  ELSE  
    KEYBOARD "{ALT+M}" PLAIN CLEAR
  ENDIF
  *E301314,1 comment the next line and add IF....ELSE....ENDIF structure [End..]  
ENDIF

*!*************************************************************
*! Name      : gfChngWall
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the change wallpaper dialog
*!*************************************************************
*! Calls     : 
*!          Calls: SYNEWALL.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfChngWall
PARAMETERS llFromInst

llFromInst = IIF(PARAMETERS()=1,llFromInst,.F.)

IF _WINDOWS
  lcOldFile = ALIAS()
  lnOldRec  = RECNO()
  llUsrOpen = .F.
  llInsOpen = .f.
  llInsOpen = !USED('SYCINST')
  IF llInsOpen
    USE (gcSysHome+'SYCINST') IN 0
  ENDIF
  lcDefBmp = ALLTRIM(SYCINST.CDEF_BMP)
  IF llInsOpen
    USE IN SYCINST
  ENDIF
  DECLARE laAllBmps[1]
  *B601811,1 Initialize array with ' ' 
  laAllBmps = ' '
  *B601811,1 end
  =ADIR('laAllBmps',(gcBmpHome+"*.BMP"))
  DECLARE laAllBmps[ALEN(laAllBmps,1)+IIF(!EMPTY(lcDefBmp),2,1),ALEN(laAllBmps,2)]
  IF !EMPTY(lcDefBmp)
    =AINS(laAllBmps,1)  
    laAllBmps[1,1] = '(Default)'
  ENDIF  
  =AINS(laAllBmps,1)  
  laAllBmps[1,1] = '(None)'
  lcNew_Wall =' '
  IF !USED("SYUUSER")
    SELECT 0
    USE (gcSysHome+"SYUUSER")
    llUsrOpen = .T.
  ELSE 
    SELECT SYUUSER
  ENDIF  
  SET ORDER TO TAG cUser_ID 
  lsAllBmps = ALLT(cDef_bmp)
  lsAllBmps = IIF(EMPTY(lsAllBmps) AND !EMPTY(lcDefBmp),'(Default)',lsAllBmps)
    
  DO SYNEWALL.SPR 

  IF !EMPTY(lcNew_Wall) .AND. !llFromInst  
    lcOpWindow = WONTOP()
    ACTIVATE WINDOW fndation TOP &&SAME
    *E300791,1 Hesham (Start)    
*    MODIFY WINDOW fndation FILL FILE (gcBmpHome+lcNew_Wall)    
     @0,0 CLEAR 
     IF !EMPTY(lcNew_Wall) AND lcNew_Wall <> '(None)'
       IF lcNew_Wall = '(Default)' 
         @0,0 say (gcBmpHome+lcDefBmp) bitmap SIZE SROW(),SCOL() CENTER STYLE "Q"
       ELSE
         @0,0 say (gcBmpHome+lcNew_Wall  ) bitmap SIZE SROW(),SCOL() CENTER STYLE "Q"       
       ENDIF  
     ENDIF  
    *E300791,1 Hesham (End)     
    *E300791,1 Hesham (Start)
*    @ 8.2,8.2 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W    
*    @ 8.1,8.1 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W  
*    @ 8,8     SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR R*	
    *E300791,1 Hesham (End)    
    IF !EMPTY(lcOpWindow)  
      ACTIVATE WINDOW (lcOpWindow) SAME
    ENDIF
    
    SELECT SYUUSER
    IF SEEK(gcUser_ID)
      REPLACE cDef_bmp WITH IIF(lcNew_Wall = '(Default)','',lcNew_Wall)
    ENDIF  
  ENDIF
  *ymo
  IF !EMPTY(lcOldFile) 
    SELECT (lcOldFile) 
    IF lcOldFile = "SYUUSER" .AND. BETWEEN(lnOldRec,1,RECCOUNT(lcOldFile))
      GO lnOldRec
    *YMO
    ENDIF 
  ENDIF
  IF llUsrOpen 
    USE IN SYUUSER
  ENDIF
  lcNew_Wall = IIF(lcNew_Wall='(Default)','',lcNew_Wall)
  IF llFromInst 
    RETURN lcNew_Wall
  ENDIF
ENDIF


*!*************************************************************
*! Name      : gfDispMem
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the dispaly memory dialog
*!*************************************************************
*! Calls     : 
*!          Calls: DISPMEM.SPR              
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDispMem

DO DISPMEM.SPR

*!*************************************************************
*! Name      : gfDispCalp
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the diaplay call procedure dialog
*!*************************************************************
*! Calls     : 
*!          Calls: DISPCALP.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDispCalp

DO DISPCALP.SPR

*!*************************************************************
*! Name      : gfDefModul
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the default module dialog
*!*************************************************************
*! Calls     : 
*!           Calls: SYDEFMDL.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDefModul

DO SYDEFMDL.SPR

*!*************************************************************
*! Name      : gfDefComp
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the default company dialog
*!*************************************************************
*! Calls     : 
*!           Calls: SYDEFCMP.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDefComp
llUsed = gfOpenFile(gcSysHome+'SYCCOMP','CCOMP_ID')
DO SYDEFCMP.SPR
USE IN (IIF(llUsed ,'SYCCOMP',0))

*!*************************************************************
*! Name      : gfDispStat
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : open the dispaly status dialog
*!*************************************************************
*! Calls     : 
*!            Calls: DISPSTAT.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDispStat

DO DISPSTAT.SPR

*!*************************************************************
*! Name      : gfBarSkip
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to skip any menu bar
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : name of popup and bar number
*!*************************************************************
*! Returns            : .f.
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfBarSkip
PARAMETERS lcPop_Bar

IF _WINDOWS
  RETURN .F.
ENDIF

lcPopup  = SUBSTR(lcPop_Bar,1,AT("-",lcPop_Bar)-1)

IF gcAct_Pad <> lcPopup 
  gcAct_Pad = lcPopup
  glPopAct = .F.  
ENDIF

IF !glPopAct
  lnBar    = INT(VAL(RIGHT(lcPop_Bar,2)))
  glPopAct = !(lnBar < CNTBAR(lcPopup))
  RETURN .F.
ENDIF  


lcWonTop   = WONTOP()
lcMesg_Str = SPACE(51)

lnAryPos = ASCAN('gaProcess',lcPop_Bar)
IF lnAryPos > 0
  lnAryPos  = ASUBSCRIPT('gaProcess',lnAryPos,1)
  lcMesg_Str =" "+gaProcess[lnAryPos,6]+gcMesg_Str
ENDIF

*#IF _DOS
*    ACTIVATE SCREEN
*
*    @ SROWS()-1,0 SAY  lcMesg_Str COLOR (SCHEME(1,5))
*
*    IF !EMPTY(lcWonTop)
*      ACTIVATE WINDOW(lcWonTop) SAME
*    ENDIF
*#ELSE
    IF lnAryPos > 0
      SET MESSAGE TO  ALLTRIM(gaProcess[lnAryPos,6])     
    ELSE
      SET MESSAGE TO  ALLTRIM(gcSysName)     
    ENDIF  
*#ENDIF

RETURN .F.


*!*************************************************************
*! Name      : gfToolbar
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to activate the toolbar under windows
*!*************************************************************
*! Calls     : 
*!      Called by: GFMAINCONT()             (function  in ARIA3.PRG)
*!      Called by: GFTBARONOFF()            (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : wait or nowait (with read or not)
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfToolbar
PARAMETERS lcNowait
glToolActv = .t.	        
DO gpDoProg WITH 'AWRSMTOOLBA',.F.,'SM'
RETURN
*E300492,1 Hesham El-Sheltawi (Start)
*IF _WINDOWS 

*  lcNowait = IIF(TYPE('lcNowait')='C',lcNowait,'')

*  IF EMPTY(gaBmpNams[1,1])
    *** Tool bar for windows
*    lcAlias = ALIAS()

*    IF !USED('syuToolB')
*      SELECT 0
*      USE (gcSysHome+"syuToolB") ORDER 1
*    ELSE
*      SELECT syuToolB 
*      SET ORDER TO 1 
*    ENDIF


*    IF SEEK(gcUser_Id)
  	  ** Collect the names of the BMPs from the toolbar file for the
 	  *** Current user
*	   SELECT cBmp_Nam,cProgNam,capp_id,cfld_msg FROM (gcSysHome+"syuToolB") ;
	           WHERE cUser_id = gcUser_ID;
	           INTO ARRAY gaBmpNams 

*	    USE IN syuToolB 

*	    SELECT (lcAlias)
*	    IF _TALLY > 0
*          glToolActv = .T.
*	      gnButtPos = 1
*	      gnMaxButt = _TALLY
*          gnButtX   = 0.000
*	      gnButtY   = 0.009
*	      gnButtH   = 3.000
*          gnButtW   = 10.857
*	      gnButtB   = 0.000
*         
*          *** Display the toolbar on top of the screen
*          =toolbar(lcNowait)
*	    ELSE
*          glToolActv = .F.	    
*	    ENDIF  

*    ELSE
*      glToolActv = .F.	        
*    ENDIF
*  ELSE
*    =toolbar(lcNowait)
*  ENDIF
*ENDIF
*E300492,1 Hesham El-Sheltawi (End)

*!*************************************************************
*! Name      : gfMarkBars
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : marke some menu bars on/off
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfMarkBars

FOR lnMBar = 1 TO ALEN(gaMarkBars,1)
  lnMarkBar = VAL(gaMarkBars[lnMBar,1])
  lcMPop    = ALLTRIM(gaMarkBars[lnMBar,2])
  llExpr    = EVAL(gaMarkBars[lnMBar,3])
  SET MARK OF BAR lnMarkBar OF &lcMPop TO llExpr 
ENDFOR

*!*************************************************************
*! Name      : gfMkDir
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : Make directory
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfMkDir
PARAMETERS lcDirectory
*E301336,1 Set library if it was not set before. [Begin]
*SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
PRIVATE lcSetLibr
lcSetLibr = SET("LIBRARY")
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
*ENDIF
*E301336,1 Set library if it was not set before. [End  ]
  
=MKDIR(lcDirectory)
*E301336,1 Release library only if set it here . [Begin]
*RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*ENDIF  
*E301336,1 Release library only if set it here . [End  ]

*-- end of gfMkDir.

*!*************************************************************
*! Name      : gfRMDir
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : remove directorey
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfRMDir
PARAMETERS lcDirectory
*E301336,1 Set library if it was not set before. [Begin]
*SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
*PRIVATE lcSetLibr
*lcSetLibr = SET("LIBRARY")
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
*ENDIF
*E301336,1 Set library if it was not set before. [End  ]

=RMDIR(lcDirectory)
*E301336,1 Release library only if set it here . [Begin]
*RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*ENDIF  
*E301336,1 Release library only if set it here . [End  ]
*-- end of gfRMDir.

*!*************************************************************
*! Name      : gfSetPath
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to update the install file with right paths
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfSetPath

CREATE CURSOR SYSPATH (mAllPath M)
APPEND BLANK
*B609580,2 TMI 05/10/2011 [Start] create the file PATH.DAT on the client path with the same name
*APPEND MEMO SYSPATH.mAllPath FROM (FULLPATH(SET('DEFAULT'))+"PATH.DAT")
APPEND MEMO SYSPATH.mAllPath FROM (lcInitHome+"PATH.DAT")
*B609580,2 TMI 05/10/2011 [End  ] 

*B609556,3 TMI 03/31/2011 [Start] 
*lcSysHome = MLINE(SYSPATH.mAllPath,1)
lcSysHome = IIF( FILE('CLIENTS.DBF') , lcInitHome , MLINE(SYSPATH.mAllPath,1) )
*B609556,3 TMI 03/31/2011 [End  ] 

SELECT 0
USE (lcSysHome+"SYCINST")
*E303076,1 TMI 02/22/2012 [Start] define the variable llLineAdded
llLineAdded = .F.
*E303076,1 TMI 02/22/2012 [End  ] 
GO TOP
IF EOF()
  APPEND BLANK
  *E303076,1 TMI 02/22/2012 [Start] update the sycinst
  llLineAdded = .T.
  *E303076,1 TMI 02/22/2012 [End  ] 
ENDIF  

*E300613,1 YMA 06/22/97 Added to update the screens and 
*E300613,1 YMA 06/22/97 images directories.

*E301060,1 YMA 11/10/98 Added to save the full path of the new
*E301060,1 YMA 11/10/98 added directories (CLASSES and EDI)

*E301603,5 Hesham (Start)
*E301603,5 add new path for the service packs directory
*REPLACE cinsdfclc   WITH "COLOR_SET1" ;
        cinsysfdr   WITH MLINE(SYSPATH.mAllPath,1) ;
        cinsallcmp  WITH MLINE(SYSPATH.mAllPath,2) ;
        cinsdospd   WITH MLINE(SYSPATH.mAllPath,3) ;
        cinsdosrd   WITH MLINE(SYSPATH.mAllPath,4) ;
        cinsdoswd   WITH MLINE(SYSPATH.mAllPath,5) ;
        cinswinpd   WITH MLINE(SYSPATH.mAllPath,6) ;
        cinswinrd   WITH MLINE(SYSPATH.mAllPath,7) ;
        cinswinwd   WITH MLINE(SYSPATH.mAllPath,8) ;
        cinswinbm   WITH MLINE(SYSPATH.mAllPath,9) ;
        cinsrsrdr   WITH MLINE(SYSPATH.mAllPath,10);
        cImagDir    WITH MLINE(SYSPATH.mAllPath,11);
        cScrDir     WITH MLINE(SYSPATH.mAllPath,12);
        cClassDir   WITH MLINE(SYSPATH.mAllPath,13);
        cEDIPath    WITH MLINE(SYSPATH.mAllPath,14)

*B609590,1 TMI 05/19/2011 [Start] Assure that all fields in the SYCINST updated at the first run be uppercase[Media] 
*REPLACE cinsdfclc   WITH "COLOR_SET1" ;
        cinsysfdr   WITH MLINE(SYSPATH.mAllPath,1) ;
        cinsallcmp  WITH MLINE(SYSPATH.mAllPath,2) ;
        cinsdospd   WITH MLINE(SYSPATH.mAllPath,3) ;
        cinsdosrd   WITH MLINE(SYSPATH.mAllPath,4) ;
        cinsdoswd   WITH MLINE(SYSPATH.mAllPath,5) ;
        cinswinpd   WITH MLINE(SYSPATH.mAllPath,6) ;
        cinswinrd   WITH MLINE(SYSPATH.mAllPath,7) ;
        cinswinwd   WITH MLINE(SYSPATH.mAllPath,8) ;
        cinswinbm   WITH MLINE(SYSPATH.mAllPath,9) ;
        cinsrsrdr   WITH MLINE(SYSPATH.mAllPath,10);
        cImagDir    WITH MLINE(SYSPATH.mAllPath,11);
        cScrDir     WITH MLINE(SYSPATH.mAllPath,12);
        cClassDir   WITH MLINE(SYSPATH.mAllPath,13);
        cEDIPath    WITH MLINE(SYSPATH.mAllPath,14);
        cservPath   WITH MLINE(SYSPATH.mAllPath,15)              
*E303076,1 TMI 02/22/2012 [Start] if first installation , update sycinst
IF llLineAdded
  *E303076,1 TMI 02/22/2012 [End  ]          
  REPLACE cinsdfclc   WITH "COLOR_SET1" ;
          cinsysfdr   WITH UPPER(MLINE(SYSPATH.mAllPath,1)) ;
          cinsallcmp  WITH UPPER(MLINE(SYSPATH.mAllPath,2)) ;
          cinsdospd   WITH UPPER(MLINE(SYSPATH.mAllPath,3)) ;
          cinsdosrd   WITH UPPER(MLINE(SYSPATH.mAllPath,4)) ;
          cinsdoswd   WITH UPPER(MLINE(SYSPATH.mAllPath,5)) ;
          cinswinpd   WITH UPPER(MLINE(SYSPATH.mAllPath,6)) ;
          cinswinrd   WITH UPPER(MLINE(SYSPATH.mAllPath,7)) ;
          cinswinwd   WITH UPPER(MLINE(SYSPATH.mAllPath,8)) ;
          cinswinbm   WITH UPPER(MLINE(SYSPATH.mAllPath,9)) ;
          cinsrsrdr   WITH UPPER(MLINE(SYSPATH.mAllPath,10)) ;
          cImagDir    WITH UPPER(MLINE(SYSPATH.mAllPath,11)) ;
          cScrDir     WITH UPPER(MLINE(SYSPATH.mAllPath,12)) ;
          cClassDir   WITH UPPER(MLINE(SYSPATH.mAllPath,13)) ;
          cEDIPath    WITH UPPER(MLINE(SYSPATH.mAllPath,14)) ;
          cservPath   WITH UPPER(MLINE(SYSPATH.mAllPath,15))
  *E303076,1 TMI 02/22/2012 [Start] close the added if statement
ENDIF   
*E303076,1 TMI 02/22/2012 [End  ] 
          
*B609590,1 TMI 05/19/2011 [End  ] 
*E301603,5 Hesham (End)
*E301060,1 YMA 11/10/98 End.
*E300613,1 YMA 06/22/97 End.
*        linsusdos   WITH !EMPTY(MLINE(SYSPATH.mAllPath,3))  
*        linsuswin   WITH !EMPTY(MLINE(SYSPATH.mAllPath,6))  

USE
USE IN SYSPATH
*B609580,2 TMI 05/10/2011 [Start] create the file PATH.DAT on the client path with the same name
*ERASE PATH.DAT        
ERASE (lcInitHome+"PATH.DAT")
*B609580,2 TMI 05/10/2011 [End  ] 


*!*************************************************************
*! Name      : gfUpdModul
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Update system files with module data
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!          Calls: GFUPDATSYS()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : lcNewMod    any installed modules for app. system
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*B600989,1 Oraby 03/03/1996 The GFUPDMODUL is duplicating the records is SYDFILES
*
FUNCTION gfUpdModul
PARAMETERS lcNewMod
*B600975,1 Hesham El-Sheltawi (START)
*B600975,1 get if it is a fresh installation or upgrading
lcNewMod = IIF(TYPE('lcNewMod')<>'C','',lcNewMod)
lcSetComp = SET('COMP')
SET COMP ON
llFreshInst = !FILE(gcSysHome+"SYCMENU.DBF")

*E301416,1 Hesham (Start)
*E301416,1 Check if there is any transm. send through CM module
*E301416,1 in the inbox before upgrading
IF !llFreshInst AND FILE(gcSysHome+"SYCSELOG.DBF")
  USE (gcSysHome+"SYCSELOG") IN 0 ORDER TAG CCOMTRNST DESC
  USE (gcSysHome+"SYCSELOG") AGAIN ALIAS SYLOGSE IN 0 ORDER TAG CCOMTRNST 
  SELECT SYCSELOG
  SET RELATION TO 'U'+ctrnsses+CCENTRY INTO SYLOGSE ADDI
  GO TOP	
  IF SEEK('R')
    llCantUp = .F.
    SCAN REST WHILE CCOMTRNST+ctrnsses+CCENTRY+CFILE_NAM = 'R'
      llCantUp = EOF('SYLOGSE')
      IF llCantUp
        EXIT
      ENDIF
    ENDSCAN
    SET ORDER TO TAG CCOMTRNST IN SYCSELOG ASCE
    IF llCantUp
      USE IN SYCSELOG
      USE IN SYLOGSE
      = gfMsgBox("TR","There is a transmission in the inbox directory."+CHR(13)+CHR(10)+;
                      "you have to run the update program before upgrading the system","\!\?\<Ok","ALERT")
    
      RETURN
    ENDIF
  ENDIF  
  USE IN SYCSELOG
  USE IN SYLOGSE
ENDIF
*E301416,1 Hesham (End)
SET COMP &lcSetComp
*B600975,1 Hesham El-Sheltawi (End)
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*IF !FILE(FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
IF !FILE(SYS(5)+CURDIR()+"UPDMODUL.DAT")
  *E303062,3 TMI 02/14/2012 [End  ] 
  RETURN
ENDIF

*B602265,1 (Start)
*B602265,1 Checking if there is any one else updating the system
*llUPDError = .F.
*lcUpDError = ON('ERROR')
*ON ERROR llUPDError = .T.
*SELECT 0 
*llStaticUs = .F.
*IF FILE(gcSysHome+"syustatc.dbf")
*  llStaticUs = .T.
*  USE (gcSysHome+"syustatc")  EXCL      
*ENDIF  
*USE (gcSysHome+"sycresrc")  IN 0 EXCL      
*ON ERROR &lcUpDError
*IF llUPDError
*Cannot access the system now. The system is under upgrade from another session. Try later.
*  WAIT WINDOW 'Cannot upgrade. The system is running or already under upgrade '+;
              'in another session.'
*  =gfModalGen(.F.,.F.,.F.,.F.,'Someone else is upgrading or running the system at the moment.'+;
              'The system will be terminated!')
*  CLEAR ALL
*  CANCEL    
*ENDIF
*B602265,1 (End)

*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 define array to hold the module information for all the paltforms
*E300441,4 array element 1,1 in DOS , 1,2 the build # ,1,3 .t. if it is the
*E300441,4 recent platform upgrade
DIMENSION laModBuild[4,3]
STORE .F. TO laModBuild
laModBuild[1,1] = 'DOS'
laModBuild[2,1] = 'WIN'
laModBuild[3,1] = 'MAC'
laModBuild[4,1] = 'UNIX'
*E300441,4 Hesham El-Sheltawi (End)
lcSetSafe = SET('SAFETY')
SET SAFETY OFF
CREATE CURSOR UPDMODUL (mModules M)
APPEND BLANK
*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*APPEND MEMO UPDMODUL.mModules FROM (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
APPEND MEMO UPDMODUL.mModules FROM (SYS(5)+CURDIR()+"UPDMODUL.DAT")
*E303062,3 TMI 02/14/2012 [End  ] 

*E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*ERASE (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
ERASE (SYS(5)+CURDIR()+"UPDMODUL.DAT")
*E303062,3 TMI 02/14/2012 [End  ] 

*E300441,4 Hesham El-Sheltawi (Start) 
=lfUpdAppl()
*E300441,4 Hesham El-Sheltawi (End) 
*** In case of updating SM module we have to make sure that the
*** structure of all system files are updated before updatind the data
FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
  IF UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2)) = "SM"
    *E300441,4 Hesham El-Sheltawi (Start) 
     llContinue = .T.
    IF !llFreshInst
      SELECT 0 
      USE (gcSysHome+"SYDAPPL") ORDER TAG  CAPP_ID  EXCL
      lcMdToUP='SM'
      lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
      SELECT SYDAPPL
      =SEEK(lcMdToUP)
      IF lcBuildIns < ALLT(CMDLBUILD)
        lnOption = gfMsgBox("TR","You have installed module("+lcMdToUp+") with a build number ("+lcBuildIns+;
                            "), which is older than the one currently installed ("+ALLT(CMDLBUILD)+;
                            ")!"+CHR(10)+CHR(13)+"If you proceed with the installation, some data may be lost."+;
                            " It is highly recommended to abort now and reinstall files from the latest build available." ,;
                            "\!\?\<Abort;\<Proceed","ALERT")
        IF lnOption = 2
          SELECT SYDAPPL
          REPLACE CMDLBUILD WITH lcBuildIns
        ELSE
          llContinue = .F.
        ENDIF  
        FOR lnPlat= 1 TO ALEN(laModBuild,1)
          lcField='C'+laModBuild[lnPlat,1]+'BUILD'
          IF !EMPTY(laModBuild[lnPlat,2])
            REPLACE &lcField WITH laModBuild[lnPlat,2]
          ENDIF
        ENDFOR
        IF !llContinue
          FOR lnCount = 1 TO MEMLINES(UPDMODUL.mModules)
            lcMdToUP = UPPER(LEFT(MLINE(UPDMODUL.mModules,lnCount),2))
            IF !EMPTY(lcMdToUP)
              IF SEEK(lcMdToUP)
                lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
                FOR lnPlat= 1 TO ALEN(laModBuild,1)
                  lcField='C'+laModBuild[lnPlat,1]+'BUILD'
                  IF !EMPTY(laModBuild[lnPlat,2])
                    REPLACE &lcField WITH laModBuild[lnPlat,2]
                  ENDIF
                ENDFOR
              ENDIF
              =lfDelSplit(lcMdToUp)
            ENDIF
          ENDFOR
          IF USED('SYDAPPL')
            USE IN SYDAPPL  
          ENDIF  
          CLEAR ALL
          CANCEL    
        ELSE   
          IF USED('SYDAPPL')
            USE IN SYDAPPL  
          ENDIF  
          =gfUpdatSYS()
          EXIT        
        ENDIF
        IF USED('SYDAPPL')
          USE IN SYDAPPL  
        ENDIF  
      ELSE  
        USE IN SYDAPPL
        =gfUpdatSYS()
        EXIT        
      ENDIF
    ELSE
      =gfUpdatSYS()
      EXIT
    ENDIF  
*E300441,4 Hesham El-Sheltawi (End) 
  ENDIF
ENDFOR  

*E301199,1 Hesham (Start)
IF !EMPTY(UPDMODUL.mModules)
  DECLARE laCompany [1,3] 
  STORE '' TO laCompany
  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1

  FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
    IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
      lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
      IF lcMd_id <> 'SM' AND lcMd_id <> 'SY'
        lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
        lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
        WAIT 'Running fix programs for module '+lcMd_name WINDOW NOWAIT
       *++NAD40
        *= gfRunFxPrg(lcMd_id)
        = gfRunFxPrg(lcMd_id,.F.)
       *++NAD40 
      ENDIF
    ENDIF
  ENDFOR    
ENDIF
*E301199,1 Hesham (End)

IF !EMPTY(UPDMODUL.mModules)
  *B600975,10  Hesham El-Sheltawi (Start)
  DECLARE laCompany [1,3] 
  STORE '' TO laCompany
  *E301098,1 Hesham (Start)
  *SELECT ccomp_id+" - "+cCom_Name,cCom_dDir,syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1
  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
    FROM (gcSyshome+"syccomp") ;
    INTO ARRAY laCompany ;
    ORDER BY 1
  *E301098,1 Hesham (End)  
  IF _TALLY=0
    STORE '' TO laCompany
  ENDIF  
  USE IN SYCCOMP  
  *B600975,10 Hesham El-Sheltawi (End)

  SELECT 0 
  USE (gcSysHome+"SYDFILES")  EXCL      && Check Append / Modify
  SELECT 0
  USE (gcSysHome+"SYDFIELD")  EXCL     && Check Append
  SELECT 0 
  USE (gcSysHome+"SYDFLFLD")  EXCL     && Check Append 
  SELECT 0 
  USE (gcSysHome+"SYDINDEX")  EXCL     && Check Append

  *E301065,1 AMM start, Open system form codes files to update
  SELECT 0
  USE (gcSysHome+"SYFRMCDH") ORDER TAG FORMCDHD EXCL
  SELECT 0
  USE (gcSysHome+"SYFRMCDD") ORDER TAG FORMCDDT EXCL
  *E301065,1 AMM end

  *E301252,1 AMM Open file
  SELECT 0
  USE (gcSysHome+"SYCCONFG") ORDER TAG Modvar EXCL
  *E301252,1 AMM end  

  SELECT 0
  USE (gcSysHome+"SYCMENU")   EXCL     && Append
  lcAppPath = ''
  *B600975,1 Hesham El-Sheltawi (START)
  *B600975,1 Change the apparel bar to default
  LOCATE FOR CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
  IF FOUND()
    lcAppPath = CPROCPATH
  ENDIF
  *B600975,1 Hesham El-Sheltawi (END)         
  SELECT 0 
  USE (gcSysHome+"SYDAPPL")   EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDDLOBJ")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDOBJCT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDREPRT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYDSCOBJ")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYREPSRT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYREPUVR")  EXCL     && Append
*--hesham
  SELECT 0 
  USE (gcSysHome+"SYCPRINT")  EXCL     && Append
  SELECT 0 
  USE (gcSysHome+"SYCP_ESC")  EXCL     && Append
*B802980,1 Hesham Start
  SELECT 0 
  USE (gcSysHome+"SYSZONES")  EXCL     && Append
*B802980,1 Hesham END

  SET MOUSE OFF

  *C200443,1 Define variables used in copying custom related fields to stanard code. [Begin]
  PRIVATE lcSyFldTag , lnPipeN1 , lnPipeN2 , lcSyFldKey , laRltField , laNewRFld
  DECLARE laRltField[1] , laNewRFld[1]
  STORE 1 TO lnPipeN1 , lnPipeN2
  STORE '' TO lcSyFldKey , laRltField
  SELECT *;
  FROM SydField ;
  WHERE lVldEntry AND !EMPTY(mRltFields) ;
  INTO CURSOR TmpFields
  *C200443,1 Define variables used in copying custom related fields to stanard code. [End]
  
  *B606832,1 Building Temp. Index on SyRepuvr file. [Begin]
  PRIVATE lcTmpIndx , lcCurAlias , lnRpVarPos , lcRpUvrTag
  lnRpVarPos = 0
  lcCurAlias = ALIAS()
  lcTmpIndx = gfTempName()
  SELECT SyRepUvr

  *BSAMEH Define Array to hold SyRepuvr structure. [Begin]
  PRIVATE laRepVrArr
  =AFIELDS(laRepVrArr)
  *BSAMEH Define Array to hold SyRepuvr structure. [End]
  
  lcRpUvrTag = ORDER()
  INDEX ON cRep_ID + cUpGrdLvl + STR(nVarPos) TAG (lcTmpIndx) OF (gcWorkDir + lcTmpIndx + '.CDX')
  
  *BSAMEH Create Temp cursors for Syrepuvr & SycConfg. [Begin]
  CREATE CURSOR RepVrCur FROM ARRAY laRepVrArr
  PRIVATE laConfgArr
  SELECT SycConfg
  =AFIELDS(laConfgArr)
  CREATE CURSOR ConfgCur FROM ARRAY laConfgArr
  *BSAMEH Create Temp cursors for Syrepuvr & SycConfg. [End]

  IF !EMPTY(lcCurAlias)
    SELECT (lcCurAlias)
  ENDIF
  *B606832,1 Building Temp. Index on SyRepuvr file. [End]
  
  FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)

    IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
      lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
      lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
      lcMdToUP = lcMd_id
      *--hesham start
      lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
      lcMd_ID = IIF(lcMd_id='SY','XX',lcMd_id)     
      *--hesham end
      *E300441,4 HESHAM EL-SHELTAWI (START)
      SELECT UPDMODUL

      llContinue = .T.
      IF FILE (gcSysHome+lcMd_id+"DAPPL.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DAPPL") ORDER TAG  CAPP_ID
        SELECT (lcMd_id+"DAPPL")
        lcBuildIns = lfGetPlatBuild(lcMdToUP,@laModBuild)
        SELECT SYDAPPL
        SET ORDER TO TAG  CAPP_ID
        IF lcMdToUP <> 'SY' AND lcMdToUP <> 'SM'
          IF SEEK(lcMdToUP)
            SELECT SYDAPPL
            IF lcBuildIns < ALLT(CMDLBUILD)
              lnOption = gfMsgBox("TR","You have installed module("+lcMdToUp+") with a build number ("+lcBuildIns+;
                                   "), which is older than the one currently installed ("+ALLT(CMDLBUILD)+;
                                   ")!"+CHR(10)+CHR(13)+"If you proceed with the installation, some data may be lost."+;
                                   " It is highly recommended to abort now and reinstall files from the latest build available." ,;
                                   "\!\?\<Abort;\<Proceed","ALERT")
              IF lnOption = 2
                SELECT SYDAPPL
                *B803757,1 NAD 11/02/2000 (Start) Update the nServcPak Field.
                *REPLACE CMDLBUILD WITH lcBuildIns
                REPLACE CMDLBUILD WITH lcBuildIns,;
                        NSRVCPAK  WITH lnNSrvPak
                *B803757,1 NAD 11/02/2000 (End) 

              ELSE
                llContinue = .F.
              ENDIF  
            ELSE
                *B604944,1 NAD 09/20/2001  (START)Fix Sydtrans is Zapped after runinig any 
                *B604944,1           standered fix program
                *IF lcBuildIns > ALLT(SYDAPPL.CMDLBUILD)    
                 * DO lpDelTrans 
                *ENDIF
                *B604944,1 NAD (END)                     
                SELECT SYDAPPL
                *B803757,1 NAD 11/02/2000 (Start) Update the nServcPak Field.
                *REPLACE CMDLBUILD WITH lcBuildIns
                REPLACE CMDLBUILD WITH lcBuildIns,;
                        NSRVCPAK  WITH lnNSrvPak
                *B803757,1 NAD 11/02/2000 (End) 

            ENDIF
          ELSE
            USE IN (lcMd_id+"DAPPL")
            APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
            FOR lnPlat= 1 TO ALEN(laModBuild,1)
              lcField='C'+laModBuild[lnPlat,1]+'BUILD'
              REPLACE &lcField WITH laModBuild[lnPlat,2]
            ENDFOR
          ENDIF
        ELSE
          DELETE ALL FOR SEEK(CAPP_ID,lcMd_id+"DAPPL")
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
          *PACK
          *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
          USE IN (lcMd_id+"DAPPL")
          APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
        ENDIF          
        SELECT SYDAPPL
        FOR lnPlat= 1 TO ALEN(laModBuild,1)
          lcField='C'+laModBuild[lnPlat,1]+'BUILD'
          IF !EMPTY(laModBuild[lnPlat,2])
            REPLACE &lcField WITH laModBuild[lnPlat,2]
          ENDIF
        ENDFOR
        IF USED(lcMd_id+"DAPPL")
          USE IN (lcMd_id+"DAPPL")        
        ENDIF  
      ENDIF  
      IF !llContinue
        =lfDelSplit(lcMdToUp)
        LOOP
      ENDIF
      *E300441,4 HESHAM EL-SHELTAWI (END)            
      
      WAIT "Updating system files for "+lcMd_name+" , Please wait...!" WINDOW NOWAIT

      *E300717,1 Hesham (Start)
      *E300717,1 Update the user file with the system default user
      *E300717,1 the system default user is the user have id = 'ADMIN'
      IF FILE (gcSysHome+lcMd_id+"UUSER.DBF")
        SELECT 0 
        USE (gcSysHome+lcMd_id+"UUSER") ORDER TAG CUSER_ID
        SELECT 0 
        USE (gcSysHome+"SYUUSER")  EXCL 
        DELETE FOR CUSER_ID = PADR('ADMIN',LEN(CUSER_ID))
        USE IN (lcMd_id+"UUSER")
        APPEND FROM (gcSysHome+lcMd_id+"UUSER")
        USE IN SYUUSER
      ENDIF
      *E300717,1 Hesham (End)
      
      IF FILE (gcSysHome+lcMd_id+"CMENU.DBF")
        SELECT 0 
        USE (gcSysHome+lcMd_id+"CMENU") ORDER TAG APPPOPBAR
        SELECT SYCMENU
        SET ORDER TO TAG APPPOPBAR
        IF lcMd_id = "SM"
          DECLARE laExtProg [1]
          laExtProg = ""
          SELECT *;
            FROM SYCMENU;
            WHERE SYCMENU.CAPP_ID = 'SY';
            AND SYCMENU.CPROCTYPE = 'E' INTO ARRAY laExtProg
         ENDIF
         *E301141,1 Hesham (Start)
         *E301141,1 check if the module we are updating
         *E301141,1 belog to another module menu bars
         lcMenuToUp = lcMdToUp
         IF SEEK(lcMdToUp,'SYDAPPL')
           lcMenuToUp = IIF(TYPE('SYDAPPL.CMODPARENT')='C' AND !EMPTY(SYDAPPL.CMODPARENT),SYDAPPL.CMODPARENT,lcMenuToUp)
         ENDIF
         *E301141,1 Hesham (End)
        *B601052,1Hesham El_Sheltawi (START)
        *B601052,1select all the custom bars for the current install app.
        *B601052,1to add these bars at the end of the menu popups
        *E301141,1 Hesham (Start)
        *E301141,1 update the menu file for the main module that 
        *E301141,1 the module we are updating belog to
*        SELECT *;
        FROM SYCMENU ;
        WHERE CAPP_ID=lcMdToUp ;
              AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
              AND !EMPTY(CPROCTYPE);
        INTO CURSOR TMPMENU ORDER BY CMSTR_NAM
        *B038431,1 MHM 09/04/2004 use table insted of cursor to update in [Start]
        *SELECT *;
        *FROM SYCMENU ;
        *WHERE CAPP_ID=lcMenuToUp ;
        *      AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
        *      AND !EMPTY(CPROCTYPE);
        *INTO CURSOR TMPMENU ORDER BY CMSTR_NAM
        
        TMPMENU = gfTempName()
        SELECT *;
        FROM SYCMENU ;
        WHERE CAPP_ID=lcMenuToUp ;
              AND ( CPROCTYPE='C' OR CUPGRDLVL='U' OR CUPGRDLVL='C');
              AND !EMPTY(CPROCTYPE);
        INTO DBF (gcWorkDir+TMPMENU) ORDER BY CMSTR_NAM
        *B038431,1 MHM [End]
        
       *B605903,1 Create Temp file for all Sub Menus. [Begin]
       *B038431,1 MHM 09/04/2004 use table insted of cursor to update in [Start]
       *SELECT *;
       *FROM SycMenu ;
       *WHERE CAPP_ID=lcMenuToUp AND cSub_Typ = "S";
       *INTO CURSOR TmpSbMnu ORDER BY cMstr_Nam , cPross_ID

       TmpSbMnu = gfTempName()
       SELECT *;
       FROM SycMenu ;
       WHERE CAPP_ID=lcMenuToUp AND cSub_Typ = "S";
       INTO DBF (gcWorkDir+TmpSbMnu) ORDER BY cMstr_Nam , cPross_ID
       *B038431,1 MHM  [End]
       *B605903,1 Create Temp file for all Sub Menus. [Begin]
        
       *E301141,1 Hesham (End)
        SELECT SYCMENU
        ** delete all the install Module bars         
*        DELETE ALL FOR SEEK(CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS,lcMd_id+"CMENU") ;
                       .OR. (CAPP_ID = lcMdToUP AND CPROCTYPE<>'C')
        *B602329,1 Remove extra separator in the modules menu
        IF lcMdToUP='SY'
          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMdToUP AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND cProcType <> 'M') 
        ELSE
        *B602329,1 end
        *E301141,1 Hesham (Start)
        *E301141,1 update the menu file for the main module that 
        *E301141,1 the module we are updating belog to
*          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMdToUP AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND CPROSS_ID=lcMdToUP)
          DELETE ALL FOR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS=lcMenuToUp AND CPAD_POS <>'07');
                      OR (CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS='SY07' AND CPROSS_ID=lcMenuToUp)
        *E301141,1 Hesham (End)                      
        *B602329,1 Add an ENDIF
        ENDIF   
        *B602329,1 end
        
        *B601052,1Hesham El-Sheltawi (END)                       
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"CMENU")
       
        *B605903,1 Shift all menus records after inserting lines. [Begin]
        *APPEND FROM (gcSysHome+lcMd_id+"CMENU")
        IF lcMenuToUp = "SY"
          APPEND FROM (gcSysHome+lcMd_id+"CMENU")
        ELSE
          DO lpMenuPad WITH "01"
          DO lpMenuPad WITH "04"
          DO lpMenuPad WITH "05"
          APPEND FROM (gcSysHome+lcMd_id+"CMENU") FOR cApp_ID + cPad_Pos + cPop_Pos + cPop_Levl + cBar_Pos = 'SY07' AND cPross_ID = lcMenuToUp
        ENDIF  
        *B605903,1 Shift all menus records after inserting lines. [Begin]
       
        *B601052,1Hesham El-Sheltawi (START)
        *B601052,1scan through the module custom bars and check the popup it belong
        *B601052,1to and add this bar at the end of the popup it belongs to
        
        *B605903,1 SSE Commented out. [Begin]
        *-- No need for these lines of codes 
        *SELECT TMPMENU
        *lcMstname=''               
        *SCAN
        *  IF lcMstName <> cMstr_Nam
        *    lnBarno=0
        *    lnPopPos=0
        *    lcMstName = cMstr_Nam
        *    SELECT SYCMENU
        *    *E301141,1 Hesham (Start)
        *    *E301141,1 we have to defferentiate between updating the main system
        *    *E301141,1 and any other module 
        *    ** get the last bar # defined in the popup that the bar we want to add belongs            
        *    *CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos            
        *    IF lcMdToUP = 'SY'
        *      CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos
        *    ELSE
        *      CALCU MAX(VAL(CBAR_POS)),MAX(VAL(CPOP_POS)) FOR capp_id = lcMenuToUp AND CMSTR_NAM=lcMstName TO lnBarno,lnPopPos            
        *    ENDIF  
        *    *E301141,1 Hesham (End)            
        *    ** check if this bar is a seperator bar or not            
        *    llIsBar=.F.       
        *    *E301141,1 Hesham (Start)
        *    *E301141,1 we have to defferentiate between updating the main system
        *    *E301141,1 and any other module 
        *    *LOCATE FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')            
        *    IF lcMdToUP = 'SY'     
        *      LOCATE FOR capp_id = lcMd_ID AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')
        *    ELSE
        *      LOCATE FOR capp_id = lcMenuToUp AND CMSTR_NAM=lcMstName AND CPOP_POS=STRTRAN(STR(lnPopPos,2),' ','0') AND CBAR_POS=STRTRAN(STR(lnBarNo,2),' ','0')
        *    ENDIF
        *    *E301141,1 Hesham (End)            
        *    llIsBar=FOUND() AND CSUB_PRPT='\-' AND EMPTY(CPROSS_ID)
        *    lnBarPos=IIF(llIsBar,RECNO(),0)
        *    lnBarNo  = lnBarNo+IIF(llIsBar,0,1)
        *    lnPopPos = lnPopPos+IIF(llIsBar,0,1)
        *    SELECT TMPMENU
        *  ENDIF            
        *  **get the custom bar we want to add inf.          
        *  SCATTER MEMVAR MEMO
        *  SELECT SYCMENU
        *  **append the custom bar to the menu and change the position
        *  ** of it at the end of the popup          
        *  APPEND BLANK
        *  GATHER MEMVAR MEMO
        *  REPLACE CBAR_POS WITH STRTRAN(STR(lnBarNo,2),' ','0');
        *          CPop_Pos WITH STRTRAN(STR(lnPopPos,2),' ','0')
        *  ** if the last bar in the popup was a seperator then increment
        *  ** the position of this bar by one to keep it at the end of the popup                  
        *  IF llIsBar AND lnBarPos>0
        *    GO lnBarPos
        *    REPLACE CBAR_POS WITH STRTRAN(STR(lnBarNo+1,2),' ','0');
        *            CPop_Pos WITH STRTRAN(STR(lnPopPos+1,2),' ','0')
        *  ENDIF        
        *  lnBarNo=lnBarNo+1
        *  lnPopPos = lnPopPos+1          
        *ENDSCAN
        *B601052,1Hesham El_Sheltawi (END)                                       
        *B605903,1 SSE Commented out. [End]
                                             
        
        IF lcMd_id = "SM"
          IF !EMPTY(laExtProg[1])
            FOR lnExt = 1 TO ALEN(laExtProg,1)
              IF SEEK(laExtProg[lnExt,1]+laExtProg[lnExt,2]+laExtProg[lnExt,3]+;
              laExtProg[lnExt,5]+laExtProg[lnExt,4],"SYCMENU")
                REPLACE sycmenu.cprocpath WITH laExtProg[lnExt,15]
              ENDIF
            ENDFOR
          ENDIF
        ENDIF

        *B600975,1 Hesham El-Sheltawi (Start)
        *B600975,1 check for the bar of the apparel system to change
        *B600975,1 the path
        ** If updating the main system 
        IF lcMdToUP = 'SY'
          ** IF the aria apparel branching bar exist        
          LOCATE FOR CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
          IF FOUND()
            DO CASE
              ** if fresh installation and installing app. system too
              CASE llFreshInst AND !EMPTY(lcNewMod)
                REPLACE CPROCPATH WITH LCARIAPATH+'ARIA.FXP'
              ** if fresh installation and not installing app. system
              CASE llFreshInst AND EMPTY(lcNewMod)
                 ** ask the user for the installation directory of app. system 
                 lcAriaFxp = ''
                 DO WHILE EMPTY(lcAriaFxp)
                   lcAriaFxp = GETDIR('','Select directory for Apparel System')
                   ** if the user select a directory
                   IF !EMPTY(lcAriaFxp)
                     ** check for existing of any of the files aria.exe or aria.fxp
                     lcLastComp = SET('COMP')
                     SET COMP ON
                     llFxpFound = FILE(lcAriaFxp+'ARIA.FXP') 
                     llExeFound = FILE(lcAriaFxp+'ARIA.EXE') 
                     SET COMP &lcLastComp
                     ** if found that the apparel system is installed in the
                     ** selected directory
                     IF llFxpFound OR llExeFound
                       REPLACE CPROCPATH WITH lcAriaFxp+IIF(llExeFound,'ARIA.EXE','ARIA.FXP')
                     ELSE
                       *REPLACE CPROCPATH WITH ''
                       lcAriaFxp = ''
                       lcSysName = gcSysName
                       lnMsgRec = gnMsgRec
                       gcSysName ='Aria Systems Installation'
                       gnMsgRec = 0
                       =gfModalGen(.F.,.F.,.F.,.F.,'Apparel System not installed in directory '+;
                                    ALLTRIM(lcAriaFxp)+;
                                    '? You have to select the right path or select Cancel. ')
                       gcSysName = lcSysName
                       gnMsgRec  = lnMsgRec                                      
                     ENDIF
                   ELSE
                     REPLACE CPROCPATH WITH ''  
                     DELETE
                     EXIT
                   ENDIF
                 ENDDO
              ** if Upgrade installation and installing app. system too               
              CASE !llFreshInst AND !EMPTY(lcNewMod)   
                REPLACE CPROCPATH WITH LCARIAPATH+'ARIA.FXP'
              ** if Upgrade installation and not installing app. system
              CASE !llFreshInst AND EMPTY(lcNewMod)
                REPLACE ALL CPROCPATH WITH lcAppPath FOR ;
                CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
            ENDCASE
          ENDIF
        ENDIF  
        *B600975,1 Hesham El-Sheltawi (END)
 
        
*E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"CMENU.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CMENU.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CMENU.FPT")
*E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  
      
      *E300441,4 HESHAM EL-SHELTAWI (START)
 *     IF FILE (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       SELECT 0
 *       USE (gcSysHome+lcMd_id+"DAPPL") ORDER TAG  CAPP_ID
 *       SELECT SYDAPPL
 *       DELETE ALL FOR SEEK(CAPP_ID,lcMd_id+"DAPPL")
 *       PACK
 *       USE IN (lcMd_id+"DAPPL")
 *       APPEND FROM (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.DBF")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.CDX")
 *       ERASE  (gcSysHome+lcMd_id+"DAPPL.FPT")
 *     ENDIF  
      *E300441,4 HESHAM EL-SHELTAWI (END)

*--HESHAM
      *B601021,1 Hesham (Start)
      *B601021,1 remarkingi the next file updating
      *B601021,1 Because it is not with a default data
*      IF FILE (gcSysHome+lcMd_id+"CPRINT.DBF") 
*        SELECT 0
*        USE (gcSysHome+lcMd_id+"CPRINT") ORDER TAG CPRINT_ID
        *SELECT SYDDLOBJ
*        DELETE ALL FOR SEEK(CPRINT_ID,lcMd_id+"CPRINT")
*        PACK
*        USE IN (lcMd_id+"CPRINT")
*        APPEND FROM (gcSysHome+lcMd_id+"CPRINT")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CPRINT.FPT")
*      ENDIF 
      *B601021,1 Hesham (End)       
       
      IF FILE (gcSysHome+lcMd_id+"CP_ESC.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"CP_ESC") ORDER TAG P_NAME
        SELECT SYCP_ESC
        DELETE ALL FOR SEEK(P_NAME,lcMd_id+"CP_ESC")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"CP_ESC")
        APPEND FROM (gcSysHome+lcMd_id+"CP_ESC")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.DBF")
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.CDX")
*        ERASE  (gcSysHome+lcMd_id+"CP_ESC.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF        

*--HESHAM END

       *** CHANGE TO THE OTHER TAG
      IF FILE (gcSysHome+lcMd_id+"DDLOBJ.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DDLOBJ") ORDER TAG CDLOBJID
        SELECT SYDDLOBJ
        DELETE ALL FOR SEEK(CDLOBJTYP+CDLOBJID,lcMd_id+"DDLOBJ")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DDLOBJ")
        APPEND FROM (gcSysHome+lcMd_id+"DDLOBJ")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DDLOBJ.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  
 
      IF FILE (gcSysHome+lcMd_id+"DOBJCT.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DOBJCT") ORDER TAG CAPP_ID
        SELECT SYDOBJCT
        DELETE ALL FOR SEEK(CAPP_ID+CAPOBJNAM,lcMd_id+"DOBJCT")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DOBJCT")
        APPEND FROM (gcSysHome+lcMd_id+"DOBJCT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DOBJCT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DREPRT.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DREPRT") ORDER TAG CREP_ID
        SELECT SYDREPRT
        *E038033,1 HMA 04/03/2004 Select only Records belong to ARIA27 [BEGIN]
        *DELETE ALL FOR SEEK(CREP_ID,lcMd_id+"DREPRT")
        DELETE ALL FOR SEEK(CREP_ID,lcMd_id+"DREPRT") .AND. cVer <>"A40"
        *E038033,1 HMA [END]
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DREPRT")
        APPEND FROM (gcSysHome+lcMd_id+"DREPRT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DREPRT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DSCOBJ.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DSCOBJ") ORDER TAG CSCRNAM
        SELECT SYDSCOBJ
        DELETE ALL FOR SEEK(ALLTRIM(CSCRNAM)+CSCOBJTYP,lcMd_id+"DSCOBJ")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        
        *B602329,1 Update SYDSCOBJ file so as not to duplicate records 
        *B602329,1 shared between modules (e.g. APVENDR records)
        *USE IN (lcMd_id+"DSCOBJ")
        *APPEND FROM (gcSysHome+lcMd_id+"DSCOBJ")
        
        PRIVATE lnCurAlias, laUpdArr, lcTmpExp, lnCurTag
        lnCurAlias = SELECT(0)
        
        SELECT SYDSCOBJ
        lnCurTag = VAL(SYS(21))
        
        SET ORDER TO TAG VAR_NAME
        SELECT (lcMd_id+"DSCOBJ")
        SCAN
          *-- Append the record in the AYDSCOBJ only if it does not exist.
          lcTmpExp = ALLTRIM(cScrNam) + cscobjnam
          IF !SEEK(lcTmpExp, 'SYDSCOBJ')	
         	SCATTER TO laUpdArr MEMO
          	INSERT INTO SYDSCOBJ FROM ARRAY laUpdArr
		  ENDIF
        ENDSCAN
        RELEASE laUpdArr
        USE IN (lcMd_id+"DSCOBJ")
	    SET ORDER TO (lnCurTag) IN SYDSCOBJ
        SELECT (lnCurAlias)
        *B602329,1 end

        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DSCOBJ.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"REPSRT.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPSRT") ORDER TAG CSORT_ID
        SELECT SYREPSRT
        DELETE ALL FOR SEEK(CSORT_ID+CREP_ID,lcMd_id+"REPSRT")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"REPSRT")
        APPEND FROM (gcSysHome+lcMd_id+"REPSRT")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.DBF")
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.CDX")
*        ERASE  (gcSysHome+lcMd_id+"REPSRT.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"REPUVR.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPUVR") ORDER TAG FLD_NAME
        SELECT SYREPUVR
        *B602871,1 AMM Update the required record types (standard or USER)
        *DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *B603837,1 Hesham (Start)
        *B603837,1 delete all records with the same upgrade level that is installed
        lcRpVUpgrd = EVAL(lcMd_id+"REPUVR.cupgrdlvl")
        IF lcRpVUpgrd $ "AS" 
          DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR") AND CUPGRDLVL $ "AS"
        ELSE
          DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR") AND CUPGRDLVL $ "UC"
        ENDIF
        *IF EVAL(lcMd_id+"REPUVR.cupgrdlvl") = 'A'
        *  SELECT (lcMd_id+"REPUVR")
        *  LOCATE FOR cupgrdlvl='U' 
        *  IF FOUND()
        *    SELECT SYREPUVR
        *    DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ELSE
        *    SELECT SYREPUVR
        *    DELETE ALL FOR cupgrdlvl#'U' .AND. SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ENDIF
        *ELSE   && EVAL(lcMd_id+"REPUVR.cupgrdlvl") = 'U'
        *  SELECT (lcMd_id+"REPUVR")
        *  LOCATE FOR cupgrdlvl='A' 
        *  IF FOUND()
        *    SELECT SYREPUVR
        *    DELETE ALL FOR SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ELSE
        *    SELECT SYREPUVR
        *    DELETE ALL FOR cupgrdlvl#'A' .AND. SEEK(ALLTRIM(CREP_ID),lcMd_id+"REPUVR")
        *  ENDIF
        *ENDIF
        *B602871,1 AMM end
        *B603837,1 Hesham (End)
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"REPUVR")
        APPEND FROM (gcSysHome+lcMd_id+"REPUVR")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.DBF")
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.CDX")
*        ERASE  (gcSysHome+lcMd_id+"REPUVR.FPT")
        *E300441,4 Hesham El-Sheltawi (End) 
        
        *B606832,1 Update the custom records after installing standard ones. [Begin]
        lcCurAlias = ALIAS()
        SET ORDER TO TAG (lcTmpIndx) IN SyRepuvr 
        SELECT 0
        USE (gcSysHome+lcMd_id+"REPUVR") ORDER TAG cRepVar DESCENDING
        SELECT 0
        USE (gcSysHome+lcMd_id+"DREPRT")
        SCAN
          IF SEEK(cRep_ID,lcMd_id+"REPUVR") AND SEEK(cRep_ID+'U','SyRepuvr')
            lnRpVarPos = EVALUATE(lcMd_id+"REPUVR.nVarPos")

            *BSAMEH ZAP the temp cursor. [Begin]
            SELECT RepVrCur 
            ZAP
            *BSAMEH ZAP the temp cursor. [End]
            
            SELECT SyRepuvr
            SCAN REST WHILE cRep_ID + cUpGrdLvl + STR(nVarPos) = EVALUATE(lcMd_id+"DREPRT.cRep_ID")+"U"
              
              *BSAMEH Move all "U" records to temp cursor. [Begin]            
              *IF nVarPos > 0
              *  lnRpVarPos = lnRpVarPos + 1
              *  REPLACE nVarPos WITH lnRpVarPos
              *ENDIF
              IF nVarPos > 0
                SCATTER MEMVAR MEMO
                INSERT INTO RepVrCur FROM MEMVAR
                DELETE
              ENDIF
              *BSAMEH Move all "U" records to temp cursor. [End]

            ENDSCAN
            
            *BSAMEH Update all "U" records position. [Begin]            
            *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
            *B609764,2 TMI 12/08/2011 [Start] restore the pack command
            PACK
            *B609764,2 TMI 12/08/2011 [End  ]           
            SELECT RepVrCur
            SCAN
              lnRpVarPos = lnRpVarPos + 1
              REPLACE nVarPos WITH lnRpVarPos            
            ENDSCAN
            SELECT RepVrCur
            SCAN
              SCATTER MEMVAR MEMO
              SELECT SyRepUvr
              APPEND BLANK
              GATHER MEMVAR MEMO  
            ENDSCAN
            *BSAMEH Update all "U" records position. [End]

          ENDIF
        ENDSCAN
        USE IN (lcMd_id+"DREPRT")
        USE IN (lcMd_id+"REPUVR")
        SET ORDER TO TAG (lcRpUvrTag) IN SyRepuvr 
        IF !EMPTY(lcCurAlias)
          SELECT (lcCurAlias)
        ENDIF
        *B606832,1 Update the custom records after installing standard ones. [End]

      ENDIF  


      IF FILE (gcSysHome+lcMd_id+"DFIELD.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFIELD")  ORDER TAG CFLD_NAME
        SELECT SYDFIELD
        DELETE ALL FOR SEEK(CFLD_NAME,lcMd_id+"DFIELD")
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DFIELD")
        APPEND FROM (gcSysHome+lcMd_id+"DFIELD")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFIELD.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DFLFLD.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFLFLD") ORDER TAG CFILE_NAM
        IF lcMdToUP <> 'SM'
          SELECT SYDFIELD
          SET ORDER TO TAG CFLD_NAME
          SELECT SYDFLFLD        
          SET RELATION TO CFLD_NAME INTO SYDFIELD
          *B038431,1 ASH 10/04/2004 (Begin) Fix bug of deleting custom records from SYDFLFLD file if the field in SYDFIELD is upgrdlvl 'A'.
          *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND SYDFIELD.CUPGRDLVL<>'U'
          DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND SYDFIELD.CUPGRDLVL<>'U' AND CUPGRDLVL<>'U'
          *B038431,1 ASH 10/04/2004 (End)
          SET RELATION OFF INTO SYDFIELD          
        ELSE
          *B038431,1 ASH 10/04/2004 (Begin) Fix bug of deleting custom records from SYDFLFLD file if the field in SYDFIELD is upgrdlvl 'A'.          
          SELECT SYDFLFLD        
          *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") 
          DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DFLFLD") AND CUPGRDLVL<>'U'
          *B038431,1 ASH 10/04/2004 (End)
        ENDIF
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DFLFLD")
        APPEND FROM (gcSysHome+lcMd_id+"DFLFLD")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFLFLD.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF FILE (gcSysHome+lcMd_id+"DINDEX.DBF")
        SELECT 0
        *B802818,1 Use Cfile_nam tag to delete specific records in SYDINDEX
        *B802818,1 so as to be able to upgrade custom indeces, and, so as 
        *B802818,1 not to overwrite them when updating a new release
        *USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG CFILE

        *B603497,1 KHM 03/03/2000 (Begin) Opening the file with cFile tag
        *B603497,1                instead of cfile_nam.
        *USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG Cfile_nam
        USE (gcSysHome+lcMd_id+"DINDEX") ORDER TAG CFILE
        *B603497,1 KHM 03/03/2000 (End)
        
        *B802818,1 end
        SELECT SYDINDEX
        *B802818,1 Delete all index tags in the module index system files
        *DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DINDEX")

        *B603497,1 KHM 03/03/2000 (Begin) Changing the clause of the delete
        *B603497,1                command by adding the checking of the 
        *B603497,1                upgrade level.
        *DELETE ALL FOR SEEK(CFILE_NAM+cFILE_TAG,lcMd_id+"DINDEX")
        DELETE ALL FOR SEEK(CFILE_NAM,lcMd_id+"DINDEX") AND CUPGRDLVL $ "AS"
        *B603497,1 KHM 03/03/2000 (End)
        *B802818,1 end
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [Start] 
        *PACK
        *B609590,4 Comment the PACK command in the function  gfUpdModul TMI 05/30/2011 [End  ] 
        *B609764,2 TMI 12/08/2011 [Start] restore the pack command
        PACK
        *B609764,2 TMI 12/08/2011 [End  ]           
        USE IN (lcMd_id+"DINDEX")
        APPEND FROM (gcSysHome+lcMd_id+"DINDEX")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DINDEX.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF   

      IF FILE (gcSysHome+lcMd_id+"DFILES.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"DFILES") ORDER TAG CFILE_NAM
        lcAlias = lcMd_id+"DFILES"  

        SELECT SYDFILES
        SET ORDER TO TAG  CFILE_NAM
        *B602640,1 Hesham (Start)
        *B602798,1 Hesham (Start)
        *B602798,1 don't remove the user defined files for the module when upgrading
        *REPLACE ALL MFILE_APP WITH STRTRAN(STRTRAN(ALLT(MFILE_APP),lcMdToUP+'$'),lcMdToUP) 
        REPLACE ALL MFILE_APP WITH STRTRAN(STRTRAN(ALLT(MFILE_APP),lcMdToUP+'$'),lcMdToUP) FOR !(CUPGRDLVL$'UC')
        *B602798,1 Hesham (End)
        *B602640,1 Hesham (End)        
        *B600989,1 Stop the replacing of the module in the SYDFILES
        *REPLACE ALL sydfiles.mfile_app ;
           WITH ALLTRIM(mfile_app)+","+ALLTRIM(&lcAlias..mfile_app);
            FOR SEEK(cfile_nam,lcMd_ID+"DFILES") .AND. ;
                AT(lcMd_ID,mfile_app)=0
        
        SELECT (lcAlias)
        *B600989,1 Replace in the Application ??DFILES by the file modules from the SYDFILES
        *B602640,1 Hesham (Start)        
        *REPLACE ALL mfile_app ;
           WITH ALLTRIM(SYDFILES.mfile_app)+IIF(AT(lcMd_ID,SYDFILES.mfile_app)=0,","+ALLTRIM(&lcAlias..mfile_app),"");
            FOR SEEK(cfile_nam,"SYDFILES") 

        REPLACE ALL mfile_app ;
           WITH ALLTRIM(SYDFILES.mfile_app)+IIF(AT(lcMdToUP+'$',&lcAlias..mfile_app)=0,","+IIF(lcMdToUP='SM' AND LEFT(CFILE_NAM,2)<>'SY','SY',lcMdToUP),","+lcMdToUP+'$');
            FOR SEEK(cfile_nam,"SYDFILES") 
        *B602640,1 Hesham (End)            
        *B600989  Go to the SYDFILES work area to delete the unneeded records
        SELECT SYDFILES        
        *B600989,1 Changed the next line. Delete all the records that exist in the ??DFILES of
        *B600989,1 the installed module in SYDFILES  (No need to check the cUpgrdLvl <> "C" 
        *B600989,1 because it the file exist in the ??DFILES, it is a system of application file
        *DELETE ALL FOR SEEK(CFILE_NAM,"SYDFILES")
        DELETE ALL FOR SEEK(CFILE_NAM,lcMd_ID+"DFILES")


        USE IN (lcMd_id+"DFILES") 
        SELECT SYDFILES
        APPEND FROM (gcSysHome+lcMd_id+"DFILES")
        *E300441,4 Hesham El-Sheltawi (Start)        
*        ERASE  (gcSysHome+lcMd_id+"DFILES.DBF")
*        ERASE  (gcSysHome+lcMd_id+"DFILES.CDX")
*        ERASE  (gcSysHome+lcMd_id+"DFILES.FPT")
        *E300441,4 Hesham El-Sheltawi (End)        
      ENDIF  

      IF llFreshInst AND lcMdToUP='SY'
          SELECT 0
          USE (gcSysHome+'SYCINT')
          APPEND FROM (gcSysHome+lcMd_id+"CINT")
      ENDIF
      *E300441,4 Hesham El-Sheltawi (Start)
*      ERASE (gcSysHome+lcMd_id+"CINT.DBF") 
*      ERASE (gcSysHome+lcMd_id+"CINT.CDX")
      *E300441,4 Hesham El-Sheltawi (End)

      *E301252,1 AMM comment out, use another function to update (LFUSETUP)
      *E300454,1 Hesham El-Sheltawi (Start)
      *IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP = 'SY'
      *  =gfUpdSetup(@laCompany)
      *ENDIF
      *E300454,1 Hesham El-Sheltawi (End)
      *E301252,1 AMM end
          
      *E301065,1 AMM Update SYFRMCDH, SYFRMCDD with the new records.
      IF FILE (gcSysHome+lcMd_id+"FRMCDH.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"FRMCDH") ORDER TAG FORMCDHD
        SELECT SYFRMCDH
        DELETE ALL FOR SEEK(cFormMaj,lcMd_ID+"FRMCDH")
        USE IN (lcMd_id+"FRMCDH")
        APPEND FROM (gcSysHome+lcMd_id+"FRMCDH")
      ENDIF  
      IF FILE (gcSysHome+lcMd_id+"FRMCDD.DBF") 
        SELECT 0
        USE (gcSysHome+lcMd_id+"FRMCDD") ORDER TAG FORMCDDT
        SELECT SYFRMCDD
        DELETE ALL FOR SEEK(cFormMaj+cFormCode,lcMd_ID+"FRMCDD")
        USE IN (lcMd_id+"FRMCDD")
        APPEND FROM (gcSysHome+lcMd_id+"FRMCDD")
      ENDIF  
      *E301065,1 AMM end 
      
      *E301252,1 AMM Update SYCCONFG with the splitted files
      =lfUSetup('S',lcMd_id)
      *E301252,1 AMM end
      
      *B600975,10 Hesham El-Sheltawi (START)
      *E300645,1 Hesham El-Sheltawi (Start)
      *E300645,1 force the system to update all the system data files in all
      *E300645,1 companies "EX. codes,sequence files"
*      IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP <> 'SY' AND lcMdToUP <> 'SM'
*        =gfUpdModFl('UPDATE',lcMdToUP)      
*      ENDIF  
      *Ren
      *IF !llFreshInst AND !EMPTY(laCompany[1,1])  AND lcMdToUP <> 'SM'
      IF !llFreshInst AND !EMPTY(laCompany[1,1]) AND lcMdToUP <> 'SY'  
      *Ren end
        =gfUpdModFl('UPDATE',lcMdToUP)      
      ENDIF  
      *E300645,1 Hesham El-Sheltawi (End)
      *B802980,1 Hesham Start
      IF FILE(gcSysHome+lcMd_id+"SZONES.DBF")
        SELECT 0
        USE (gcSysHome+lcMd_id+"SZONES") ORDER TAG Frtzones
        SELECT SYSZONES
        SET ORDER TO TAG Frtzones
        lcZonKey = KEY()
        SELECT (lcMd_id+"SZONES")
        GO TOP
        SCAN
          IF !SEEK(EVAL(lcZonKey),'SYSZONES')
            SCATT MEMVAR MEMO
            INSERT INTO SYSZONES FROM MEMVAR
          ENDIF
        ENDSCAN
      ENDIF
      *B802980,1 Hesham END
      
      *B600975,10 Hesham El-Sheltawi (START)      
      *E300441,4 Hesham El-Sheltawi (Start)        
      =lfDelSplit(lcMdToUp)        
      *E300441,4 Hesham El-Sheltawi (End)        
    ENDIF
  ENDFOR
  
  
  
  *++nad40
  
  PRIVATE lcOrdAPPL ,lnRecnAPPL ,llclsAPPl
  lcOrdAPPL=""
  lnRecnAPPL=1
  llclsApl =.F.
  
  IF USED ("SYDAPPL")
    
    lcOrdAPPL =ORDER('SYDAPPL')
    lnRecnAPPL =RECNO('SYDAPPL') 
    USE IN SYDAPPL
    llclsApl =.T.
  ENDIF
  
  IF !EMPTY(UPDMODUL.mModules)
    DECLARE laCompany [1,3] 
    STORE '' TO laCompany
    SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
      FROM (gcSyshome+"syccomp") ;
      INTO ARRAY laCompany ;
      ORDER BY 1

    FOR lcModCount = 1 TO MEMLINES(UPDMODUL.mModules)
      IF !EMPTY(MLINE(UPDMODUL.mModules,lcModCount))
        lcMd_id   = UPPER(LEFT(MLINE(UPDMODUL.mModules,lcModCount),2))
        IF lcMd_id <> 'SM' AND lcMd_id <> 'SY'
          lcMd_name = ALLTRIM(SUBSTR(MLINE(UPDMODUL.mModules,lcModCount),3))
          lcMd_name = IIF(EMPTY(lcMd_name),lcMd_id ,lcMd_name)      
          WAIT 'Running fix programs for module '+lcMd_name WINDOW NOWAIT
          
          = gfRunFxPrg(lcMd_id,.T.)
         
        ENDIF
        lcMd_ID =IIF(lcMd_id='SY','XX',lcMd_id)
        IF USED(lcMd_id+'DFXPRG') 
          USE IN (lcMd_id+'DFXPRG')
        ENDIF
        ERASE gcSysHome+lcMd_id+'DFXPRG.DBF'
        ERASE gcSysHome+lcMd_id+'DFXPRG.FPT'
        ERASE gcSysHome+lcMd_id+'DFXPRG.CDX'
      ENDIF
    ENDFOR    
 ENDIF
  
  IF llclsApl 
     
     USE (gcSysHome+"SYDAPPL.DBF") in 0  ORDER TAG lcOrdAPPL EXCL
     
     IF BETWEEN(lnRecnAPPL,1,RECCOUNT("SYDAPPL"))
       GOTO lnRecnAPPL IN SYDAPPL
     ENDIF
  ENDIF
 *++NAD40

  *C200443,1 Copy custom related fields to standard code. [Begin]
  lcSyFldTag = ORDER('SydField')
  SET ORDER TO TAG cFld_Name IN SydField
  SELECT TmpFields
  SCAN
    IF SEEK(cFld_Name,'SydField') AND !(ALLTRIM(STRTRAN(mRltFields,' ','')) == ALLTRIM(STRTRAN(SydField.mRltFields,' ','')))
      =gfSubStr(mRltFields,@laRltField,'|')
      =gfSubStr(SydField.mRltFields,@laNewRFld,'|')
      FOR lnPipeN2 = 1 TO ALEN(laNewRFld,1)
        laNewRFld[lnPipeN2] = PADR(ALLTRIM(laNewRFld[lnPipeN2]),10)
      ENDFOR
      FOR lnPipeN1 = 1 TO ALEN(laRltField,1)
        IF !ASCAN(laNewRFld,PADR(ALLTRIM(laRltField[lnPipeN1]),10)) > 0
          SELECT SydField
          lcSyFldKey = EVALUATE(KEY())
          IF SEEK(ALLTRIM(laRltField[lnPipeN1])) AND SydField.cUpgrdLvl = 'U' AND SEEK(lcSyFldKey)
            REPLACE mRltFields WITH mRltFields + IIF(RIGHT(mRltFields,1)='|','','|') + ALLTRIM(laRltField[lnPipeN1])
          ENDIF
        ENDIF
      ENDFOR
    ENDIF
  ENDSCAN
  SET ORDER TO TAG (lcSyFldTag) IN SydField
  *C200443,1 Copy custom related fields to standard code. [End]
  
  *B606832,1 Close the temp index. [Begin]
  SELECT SyRepuvr
  CLOSE INDEX
  ERASE (gcWorkDir + lcTmpIndx + '.CDX')
  *B606832,1 Close the temp index. [End]
  
  SELECT SYDAPPL
  SET ORDER TO TAG CAPP_ID
  SELECT SYCMENU
  SET ORDER TO TAG APPPOPBAR

  *B604063,1 HS 12/12/2000 Change these lines to fix the EDI modules menu update error [Begin]
  *SET RELATION TO ALLTRIM(sycmenu.cpross_id) INTO SYDAPPL ADDITIVE  
  *
  *IF SEEK("SY"+"07")
  *  SCAN WHILE capp_id = "SY" .AND. cpad_pos ="07" FOR cproctype ="M"
  *     IF EOF("SYDAPPL") 
  *       DELETE
  *     ENDIF
  *  ENDSCAN
  *ENDIF

  *SAMEH     SSE            Fix problem with custom Modules in SycMenu Build 40. [Begin]
  IF SEEK("SY07")
    SKIP
    PRIVATE lnCurPos
    lnCurPos = VAL(cPop_Pos)
    IF lnCurPos > 0
      SCAN REST WHILE cApp_ID = "SY" AND cPad_Pos = "07" FOR !EMPTY(cPop_Pos)
        REPLACE cPop_Pos WITH PADL(ALLTRIM(STR(lnCurPos)),2,"0") , cBar_Pos WITH PADL(ALLTRIM(STR(lnCurPos)),2,"0")
        lnCurPos = lnCurPos + 1
      ENDSCAN
    ENDIF  
  ENDIF
  *SAMEH     SSE            Fix problem with custom Modules in SycMenu Build 40. [End]
  
  *-- Seek for the first module bar record
  IF SEEK("SY" + "07")
    *-- Scan the module bar records
    SCAN WHILE cApp_ID = "SY" .AND. cPad_Pos = "07";
           FOR cProcType = "M"
      
      *-- If the menu bar is assigned to only one module
      IF EMPTY(cBarModule)
        *-- Check if the module doesn't exist (not installed)
        IF !SEEK(ALLTRIM(cPross_ID) , "SYDAPPL")
          *-- Delete the module bar record
          DELETE
        ENDIF
      ELSE    && Else, if the menu bar is assigned to more than one module
        PRIVATE lcBarModul
        
        *-- Variable to hold the bar modules
        lcBarModul = ALLTRIM(cBarModule)
        *-- Do while, there are still modules that has not been checked yet
        DO WHILE !EMPTY(lcBarModul)
          *-- If the first character is the ","character remove it from the string
          lcBarModul = IIF(LEFT(lcBarModul , 1) = "," , SUBSTR(lcBarModul , 2) , lcBarModul)
          
          *-- Check if the first module in the bar modules string exist (installed)
          IF SEEK(LEFT(lcBarModul , 2) , "SYDAPPL")
            *-- If the module is installed exit the DO WHILE loop
            EXIT
          ELSE    && Else, if the module doesn't exist (not installed)
            *-- Remove the module name from the bar modules string
            lcBarModul = SUBSTR(lcBarModul , 3)
          ENDIF
        ENDDO
        
        *-- If none of the bar modules is installed
        IF EMPTY(lcBarModul)
          *-- Delete the module bar record
          DELETE
        ENDIF
      ENDIF
    ENDSCAN
  ENDIF
  *B604063,1 HS 12/12/2000 Change these lines to fix the EDI modules menu update error [End]

  SET MOUSE ON
  
  USE IN UPDMODUL
  USE IN SYCMENU
  USE IN SYDAPPL
  USE IN SYDDLOBJ
  USE IN SYDFIELD
  USE IN SYDFILES
  USE IN SYDFLFLD
  USE IN SYDINDEX
  USE IN SYDOBJCT
  USE IN SYDREPRT
  USE IN SYDSCOBJ
  USE IN SYREPSRT
  USE IN SYREPUVR
  *E301077,78 Hesham (Start)
  IF USED('SYCINT')
    USE IN SYCINT
  ENDIF
  *E301077,78 Hesham (End)
  *hesham start
  USE IN SYCPRINT
  USE IN SYCP_ESC
  *hesham end
  *E301065,1 AMM start, Close files
  USE IN SYFRMCDH
  USE IN SYFRMCDD
  *E301065,1 AMM end  

  *E301252,1 AMM Close file 
  IF USED('SYCCONFG')
    USE IN SYCCONFG
  ENDIF
  *E301252,1 AMM end

  *B802980,1  Hesham (Start)
  IF USED('SYSZONES')
    USE IN SYSZONES
  ENDIF
  *B802980,1  Hesham (End)
  
  USE (gcSysHome+"SYUSTATC") EXCL
  lcSafty = SET('SAFETY')
  SET SAFETY OFF 
  ZAP
  USE

  *B803990,1 MAB 02/04/2001 Zap the SYDTRANS. [Begin]
  *B604944,1 NAD 09/20/2001  Not to zap the sydtrans (START)
  *DO lpZapTrans
  *B604944,1 NAD (END)
  *B803990,1 MAB 02/04/2001 Zap the SYDTRANS. [End  ]

  SET SAFETY &lcSafty
  *E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*  ERASE (FULLPATH(SET('DEFAULT'))+"UPDMODUL.DAT")
  ERASE (SYS(5)+CURDIR()+"UPDMODUL.DAT")
  *E303062,3 TMI 02/14/2012 [End  ] 
  WAIT CLEAR
  *B601052,1Hesham El_Sheltawi (Start)                                       
  *B038431,1 MHM 09/04/2004 no need to use it [Start]
  *IF USED('TMPMENU')
  *  USE IN TMPMENU  
  *ENDIF  
  *B038431,1 MHM [End]
  *B601052,1Hesham El_Sheltawi (END) 
  
  *B605903,1 Erase temp files used. [Begin]
  *B038431,1 MHM 09/04/2004 no need to use it [Start]
  *IF USED('TmpSbMnu')
  *  USE IN TmpSbMnu
  **ENDIF
  *B038431,1  [End]
  IF USED('TmpEmpMn')
    USE IN TmpEmpMn
    ERASE (gcWorkDir + 'TmpEmpMn.DBF')
    ERASE (gcWorkDir + 'TmpEmpMn.CDX')
    ERASE (gcWorkDir + 'TmpEmpMn.FPT')
  ENDIF
  *B605903,1 Erase temp files used. [Begin]                                      
  
  *E300613,1 YMA 06/24/97 Update the SYCCOMP with the sample '99' company
  *E300613,1 YMA 06/24/97 record if it was installed.
  = lfUSmpData()
  *E300613,1 YMA End.
ENDIF

*B605445,1 NAD 01/30/2002 Fix Bug in the Realease 
=lfUpdTrans()
*B605445,1 NAD 01/30/2002 Fix Bug in the Realease 
*B602265,1 (Start)
*B602265,1 Checking if there is any one else updating the system
*USE IN sycresrc
*IF llStaticUs
*  USE IN SYUSTATC
*ENDIF  
*B602265,1 (End)

SET SAFETY &lcSetSafe

*!*************************************************************
*! Name      : gfOldset
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Not used any more
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfOldset

IF FILE("OLDSET.BAT")
  CREATE CURSOR OLDSET (MOLDSET M(10),MNEWSET M(10))
  APPEND BLANK
  APPEND MEMO MOLDSET FROM OLDSET.BAT
  IF !EMPTY(MOLDSET)
    REPLACE MNEWSET WITH "@ ECHO OFF"+CHR(13)+CHR(10)
    FOR lnLine = 1 TO MEMLINES(MOLDSET)
      IF !EMPTY(MLINE(MOLDSET,lnLine))
        REPLACE MNEWSET WITH MNEWSET+"SET "+MLINE(MOLDSET,lnLine)+CHR(13)+CHR(10)
      ENDIF  
    ENDFOR
    lcSaveSaf = SET ("SAFETY")
    SET SAFETY OFF 
    COPY MEMO MNEWSET TO OLDSET.BAT 
    SET SAFETY &lcSaveSaf
  ENDIF
  USE IN OLDSET
ENDIF


*!*************************************************************
*! Name      : gfWait
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : to display wait message from the dialog dectionary
*!*************************************************************
*! Calls     : 
*!      Called by: GFCPCOPY()               (function  in ARIA3.PRG)
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfWait
PARAMETERS lcMessagNo,lcNoWait,lcVarsStr

PUSH KEY
ON KEY
lcCurrDbf   = ALIAS()
lcNoWait    = IIF(TYPE('lcNoWait' )='C',lcNoWait ,'')
lcVarsStr   = IIF(TYPE('lcVarsStr')='C',lcVarsStr,'')
lnOldRec    = 0

*** Open dialog file if it is not opend
*E301077,78 Hesham (Start)
llDlUse = gfOpenFile(gcSysHome+"syddlobj",'cdlobjid')
*IF !USED('SydDlObj')
*  SELECT 0
*  USE (gcSysHome+"SydDlObj") ORDER TAG CDLOBJID
*ELSE
*  SELECT SydDlObj
*  lnOldRec = RECNO('SydDlObj')
*  SET ORDER TO TAG CDLOBJID IN ALIAS('SydDlObj')
*ENDIF
lnOldRec = IIF(llDlUse,0,RECNO('SydDlObj'))
*E301077,78 Hesham (End)


IF SEEK("M"+lcMessagNo)
  lcMesagtxt = ALLTRIM(SydDlObj.MDLOBJ)
   
  IF AT("",lcMesagtxt) > 0
    DECLARE laVarsStr [1]
    *** Collect variables to be replaced from string to array
    =gfSubStr(lcVarsStr,@laVarsStr,'|')

    *** Replace each  mark with variabe sent
    FOR lnVarsStr = 1  TO ALEN(laVarsStr,1)
      lcMesagtxt = STRTRAN(lcMesagtxt,'',laVarsStr[lnVarsStr],1,1)
    ENDFOR  
  ENDIF

  WAIT lcMesagtxt WINDOW &lcNoWait
ENDIF
*E301077,78 Hesham (Start)
=IIF(llDlUse,gfSysClose('SYDDLOBJ'),'')
*E301077,78 Hesham (End)
IF lnOldRec > 0
  GO lnOldRec IN SydDlObj
ENDIF

IF !EMPTY(lcCurrDbf)
  SELECT(lcCurrDbf)
ENDIF

POP KEY

*!*************************************************************
*! Name      : gfUpdatSYS
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO update the structure of the system files
*!*************************************************************
*! Calls     : 
*!      Called by: GFUPDMODUL()             (function  in ARIA3.PRG)
*!          Calls: GFTHERMO()               (function  in ARIA3.PRG)
*!          Calls: GFADEL()                 (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfUpdatSYS
*!*	FUNCTION x_gfUpdatSYS
*!*	*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
*!*	*--while the system files does not exist yet so we have to remark
*!*	*--the usable of the sycinst file
*!*	*IF !USED('SYCINST')
*!*	*  SELECT 0
*!*	*  USE(gcSysHome+"SYCINST")
*!*	*ELSE
*!*	*  SELECT SYCINST
*!*	*ENDIF    
*!*	*gcWorkDir = ALLTRIM(cinsdoswd)
*!*	*USE
*!*	*E301199,1 Hesham (Start)
*!*	IF !llFreshInst
*!*	  DECLARE laCompany [1,3] 
*!*	  STORE '' TO laCompany
*!*	  SELECT ccomp_id+" - "+cCom_Name,PADR(gfGetDataDir(ALLT(cCom_dDir)),LEN(cCom_dDir)),syccomp.mcomp_mdl;
*!*	    FROM (gcSyshome+"syccomp") ;
*!*	    INTO ARRAY laCompany ;
*!*	    ORDER BY 1
*!*	    IF USED('SYCCOMP')
*!*	      USE IN SYCCOMP
*!*	    ENDIF
*!*	ENDIF
*!*	*++NAD40
*!*	*=gfRunFxPrg('SM')
*!*	=gfRunFxPrg('SM',.F.)
*!*	*++NAD40
*!*	*E301199,1 Hesham (End)
*!*	SELECT 0
*!*	USE (gcSysHome+"SMDFILES")
*!*	SELECT 0
*!*	USE (gcSysHome+"SMDFIELD")

*!*	*SAMEH     SSE Add all the upgrade level 'U' or 'C'. [Begin]
*!*	IF FILE(gcSysHome+"SYDFIELD.DBF")
*!*	  SET ORDER TO TAG cFld_Name

*!*	  USE (gcSysHome+"SYDFIELD") IN 0

*!*	  *BSAMEH Change this code. [Begin]
*!*	  *APPEND FROM (gcSysHome+"SYDFIELD") FOR cUpGrdLvl $ 'UC' AND ;
*!*	  *            !SEEK(SydField.cFld_Name,'SMDFIELD')
*!*	  *USE IN SydField            
*!*	  *SET ORDER TO 
*!*	  SELECT SydField
*!*	  SCAN FOR cUpGrdLvl $ 'UC'
*!*	    IF !SEEK(cFld_Name,'SMDFIELD')
*!*	      SCATTER MEMVAR MEMO
*!*	      SELECT SMDFIELD
*!*	      APPEND BLANK
*!*	      GATHER MEMVAR MEMO
*!*	    ENDIF
*!*	  ENDSCAN
*!*	  SELECT SMDFIELD  
*!*	  SET ORDER TO
*!*	  *BSAMEH Change this code. [End]

*!*	ENDIF
*!*	*SAMEH     SSE  Add all the upgrade level 'U' or 'C'. [End]

*!*	SELECT 0
*!*	USE (gcSysHome+"SMDFLFLD")
*!*	SELECT 0
*!*	USE (gcSysHome+"SMDINDEX")

*!*	SET SAFETY OFF 

*!*	SELECT SMDFILES
*!*	DECLARE laMdlFiles[1,2]
*!*	*** get the name of all system files
*!*	SELECT CFILE_NAM,CFILE_TTL ;
*!*	       FROM (gcSysHome+"SMDFILES") ;
*!*	       WHERE LEFT(CFILE_NAM,2) = "SY"  .AND. CFILE_NAM <> 'SYCERROR' ;  
*!*	       INTO ARRAY laMdlFiles 

*!*	*.AND.  !lsys_data

*!*	lnRecords  = _TALLY
*!*	lcTempName = 'x'+RIGHT(SYS(3),7)
*!*	lcPathTemp = gcSysHome+lcTempName  


*!*	FOR lnCounter = 1 TO ALEN(laMdlFiles,1)
*!*	  lcFileNam  = UPPER(ALLTRIM(laMdlFiles[lnCounter,1]))
*!*	  lcPathFile = gcSysHome+lcFileNam

*!*	  =gfThermo(lnRecords,lnCounter,"Updating system file : ",laMdlFiles[lnCounter,2])
*!*	  
*!*	  ** Select the file structure in Array **
*!*	  DECLARE laFileStrc[1,5]
*!*	  laFileStrc = " "
*!*	  *** Get the structure of the file
*!*	  SELECT smdflfld.cfld_name,smdfield.cdata_typ, ;
*!*	         smdfield.nfld_wdth,smdfield.nfld_dec, ;
*!*	         smdflfld.nfld_pos ;
*!*	    FROM (gcSysHome+"smdflfld"),(gcSysHome+"smdfield") ;
*!*	         ORDER BY smdflfld.nfld_pos ;
*!*	         GROUP BY smdField.cFld_Name ;
*!*	    WHERE UPPER(smdflfld.cfile_nam) = lcFileNam .AND. ;
*!*	          smdfield.cfld_name = smdflfld.cfld_name ;
*!*	          INTO ARRAY laFileStrc

*!*	  =gfAdel(@laFileStrc,5,2)  && An additional colum holding the position 
*!*	                            && of each field has to be removed from the
*!*	                            && Array befor verification or building.
*!*	  
*!*	  SELECT SMDINDEX
*!*	  DECLARE laFileCDX[1,4]
*!*	  laFileCDX = " "
*!*	  ** Select the file index in Array **
*!*	  SELECT smdindex.cindx_exp,smdindex.cfile_tag, ;
*!*	         smdindex.lascend,smdindex.lunique ;
*!*	         FROM (gcSysHome+"smdindex") ;
*!*	         WHERE UPPER(smdindex.cfile_nam) = lcFileNam ;
*!*	         INTO ARRAY laFileCDX

*!*	  IF !FILE(lcPathFile+".DBF")
*!*	    CREATE DBF (lcPathFile) FROM ARRAY laFileStrc
*!*	    *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
*!*	    =lfCrFox2x()
*!*	    *E303074,1 TMI 02/20/2012 [End  ] 

*!*	    IF !EMPTY(laFileCDX[1])
*!*	      FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
*!*	        lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
*!*	        lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')

*!*	        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*!*	        *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2]; 
*!*	        *         ADDITIVE &lcAscend &lcUnique
*!*	        ON ERROR llErr=.T.
*!*	        lcNdx = laFileCDX[lnTagNo,1]
*!*	        lcTag = laFileCDX[lnTagNo,2]
*!*	        INDEX ON &lcNdx TAG &lcTag ; 
*!*	                 ADDITIVE &lcAscend &lcUnique
*!*	        ON ERROR
*!*	        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
*!*	      ENDFOR            
*!*	    ENDIF
*!*	    USE 
*!*	  ELSE 
*!*	    CREATE DBF (lcPathTemp) FROM ARRAY laFileStrc
*!*	    *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
*!*	    =lfCrFox2x()
*!*	    *E303074,1 TMI 02/20/2012 [End  ] 

*!*	    IF !EMPTY(laFileCDX[1])
*!*	      FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
*!*	        lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
*!*	        lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')
*!*	        
*!*	        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*!*	        *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2];
*!*	        *         ADDITIVE &lcAscend &lcUnique
*!*	        ON ERROR llErr=.T.
*!*	        lcNdx = laFileCDX[lnTagNo,1]
*!*	        lcTag = laFileCDX[lnTagNo,2]
*!*	        INDEX ON &lcNdx TAG &lcTag ; 
*!*	                 ADDITIVE &lcAscend &lcUnique
*!*	        ON ERROR
*!*	        *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
*!*	      ENDFOR            
*!*	    ENDIF
*!*	    SELECT (lcTempName)
*!*	    APPEND FROM (lcPathFile)
*!*	    USE 
*!*	    
*!*	    *--Ramy
*!*	    IF USED(lcFileNam)
*!*	      USE IN (lcFileNam)
*!*	    ENDIF
*!*	    
*!*	    IF FILE(lcPathFile+'.DBF')
*!*	      ERASE (lcPathFile+'.DBF')
*!*	    ENDIF  
*!*	    IF FILE(lcPathFile+'.FPT')
*!*	      ERASE (lcPathFile+'.FPT')
*!*	    ENDIF  
*!*	    IF FILE(lcPathFile+'.CDX')
*!*	      ERASE (lcPathFile+'.CDX')
*!*	    ENDIF  
*!*	    
*!*	    IF FILE(lcPathTemp+'.DBF')            
*!*	      RENAME (lcPathTemp+'.DBF') TO (lcPathFile+'.DBF')
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      flush
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
*!*	    ENDIF
*!*	    IF FILE(lcPathTemp+'.FPT') 
*!*	      RENAME (lcPathTemp+'.FPT') TO (lcPathFile+'.FPT')
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      flush
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
*!*	    ENDIF
*!*	    IF FILE(lcPathTemp+'.CDX')
*!*	      RENAME (lcPathTemp+'.CDX') TO (lcPathFile+'.CDX')
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [Start] 
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      flush
*!*	      wait window 'Flushing...' timeout 0.5
*!*	      *B609590,3 TMI 05/19/2011 Flush after file rename [End  ] 
*!*	    ENDIF  

*!*	  ENDIF
*!*	ENDFOR

*!*	USE IN SMDFILES
*!*	USE IN SMDFIELD
*!*	USE IN SMDFLFLD
*!*	USE IN SMDINDEX

*!*************************************************************
*! Name      : gfCodDes 
*! Developer : Malak Hanna Aziz
*! Date      : 1993-1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
*B600690,1 09/18/95 M.Hassan Add CRLTFIELDS field to the CODES index to let the record that hold the descreiption the first record.
*E300631,1 YMA 04/06/97 Reneamed this function as an old one and 
*E300631,1 YMA 04/06/97 re-write it underneith...

FUNCTION gfOldCodDes
PARAMETERS lcCodeVal, lcFldName
PRIVATE lcSavOrder,lcReturnVal,lcSavSelct

IF TYPE('lcCodeVal') <> 'C'
  RETURN ''
ENDIF
lcReturnVal = ''           
lcSavSelct  = ALIAS()   && Variable to save the currently selected file.
SELECT SYCCODES         && Select CODES file
lcSavOrder = SYS(22)    && Save the file order
SET ORDER TO TAG CODES  && Change the order

IF EMPTY(lcCodeVal) .OR. lcCodeVal = "*"
  *B801042,1 MAN Save Filter Start
  lcCurFlt = FILTER()
  lnFltRec = IIF(EOF() .OR. BOF(), 0, RECNO())
  SET FILTER TO
  *B801042,1 MAN Save Filter End
  *B801529,1 Some Programs call the function with "******"
  *IF !SEEK('  ' + lcCodeVal)
  IF !SEEK(SPACE(1)+LEFT(lcCodeVal,1))
  *B801529,1 end
    APPEND BLANK
    REPLACE cFld_Name  WITH IIF(lcCodeVal = '*','ALL','N/A') ;
            cCode_No   WITH IIF(lcCodeVal = '*','*','')      ;
            cDiscrep   WITH IIF(lcCodeVal = '*','All','N/A') ;
            cRltField  WITH 'N'
  ENDIF  
  lcReturnVal = SYCCODES.cDiscrep

  *B801042,1 MAN Restore Filter Start
  SET FILTER TO &lcCurFlt.
  IF BETWEEN(lnFltRec,1,RECCOUNT())
    GO lnFltRec
  ENDIF    
  *B801042,1 MAN Restore Filter End

ELSE
  IF SEEK(gcAct_Comp + lcCodeVal)
    lcReturnVal = SYCCODES.cDiscrep
  ELSE
    lcReturnVal = ''       && In case of this code record is deleted
  ENDIF  
ENDIF  
           
SET ORDER TO &lcSavOrder
SELECT IIF(EMPTY(lcSavSelct),0,lcSavSelct)
RETURN lcReturnVal

*!*************************************************************
*E300631,1 YMA 04/06/97 Changed the function to work with the 
*E300631,1 YMA 04/06/97 Codes file which is moved to the company
*E300631,1 YMA 04/06/97 level insted of the sysfiles level.
*E300631,1 YMA 04/06/97 We also changed the index tag "cCode_No"
*E300631,1 YMA 04/06/97 to include the "field name" field which is
*E300631,1 YMA 04/06/97 passed as a 2nd parameter to the function.
*E301278,4 MAB 06/23/99 lcCodeVal may be a Char. or an array hold codes and it values
*E301278,4              (Passed by reference)
*E301278,4              in this case array must be a 3 dimension array where
*E301278,4              First  Dimension : Code Value
*E301278,4              Second Dimension : Code Title
*E301278,4              Third  Dimension : Hold return value and filled by this function.
FUNCTION gfCodDes
*E301238,1 Add New logical parameter control print both code and description for editable codes,
*E301238,1 else print description only. [Begin]
*PARAMETERS lcCodeVal, lcFldName
PARAMETERS lcCodeVal, lcFldName , llChkEdit
*E301238,1 else print description only. [End  ]

PRIVATE lcSavOrder,lcReturnVal,lcSavSelct

*E301853,1 WAB (Start) - add variable to save the current filter , because in the gfstybrow we 
*E301853,1 WAB         - filtered  on the any style segment ( season for example ) so we have to 
*E301853,1 WAB         - remove the filter than return back to the fitler.
PRIVATE lcSavFltr
lcSavFltr = ""

*E301853,1 WAB (End)

*E301278,4 Rise array flag and the program is the same if it is direct value. [Begin]
llRetArray = (TYPE("lcCodeVal[1,1]") = "C")
*IF TYPE("lcCodeVal") <> "C" OR TYPE("lcFldName") <> "C"
IF !llRetArray AND (TYPE("lcCodeVal") <> "C" OR TYPE("lcFldName") <> "C")
  RETURN ''
ENDIF

IF !llRetArray
  lcCodeVal   = PADR(UPPER(lcCodeVal),6)
  lcFldName   = PADR(UPPER(lcFldName),10)
ENDIF  
*E301278,4 Rise array flag and the program is the same if it is direct value. [End  ]

lcReturnVal = ""
lcSavSelct  = ALIAS()      && Variable to save the currently selected file.

llUseCodes = .F.
IF !USED("CODES")
  USE (gcDataDir+"Codes") IN 0
  llUseCodes = .T.
ENDIF

SELECT CODES               && Select CODES file
lcSavOrder = SYS(22)       && Save the file order
SET ORDER TO TAG CODES     && Change the order

*E301278,4 if it is an array loop it to get all values. [Begin]
*-- if pass array of codes.
IF llRetArray
  PRIVATE lnArrLen , lnCodeLen
  lnCodeLen = 6
  lnArrLen  = 0
  FOR lnArrLen = 1 TO ALEN(lcCodeVal,1)
    lcCodeVal[lnArrLen,1] = PADR(UPPER(lcCodeVal[lnArrLen,1]),6)
    lcCodeVal[lnArrLen,2] = PADR(UPPER(lcCodeVal[lnArrLen,2]),10)
    IF EMPTY(lcCodeVal[lnArrLen,1]) .OR. lcCodeVal[lnArrLen,1] = "*"
      lcCurFlt = FILTER()
      lnFltRec = IIF(EOF() .OR. BOF(), 0, RECNO())
      SET FILTER TO
      *MAN Changed lcCodeVal to lcCodeVal[lnArrLen,1] Start
      IF !SEEK(SPACE(1)+LEFT(lcCodeVal[lnArrLen,1],1))
        APPEND BLANK
        REPLACE cFld_Name  WITH IIF(lcCodeVal[lnArrLen,1] = '*','ALL','N/A') ;
                cCode_No   WITH IIF(lcCodeVal[lnArrLen,1] = '*','*','')      ;
                cDiscrep   WITH IIF(lcCodeVal[lnArrLen,1] = '*','All','N/A') ;
                cRltField  WITH 'N'
        *T20060831.0032 TMI [Start] update the added line with trace infomation
        REPLACE COWNER WITH IIF(TYPE('lcProgName')='C','p:'+lcProgName,'r:'+SYDREPRT.CREP_ID) ;
                DADD_DATE WITH gdSysDate ;
                CADD_TIME WITH TIME() ;
                CADD_USER WITH gcUser_ID
        *T20060831.0032 TMI [End  ]         
      ENDIF  
      lcCodeVal[lnArrLen,3] = CODES.cDiscrep
      SET FILTER TO &lcCurFlt.
      IF BETWEEN(lnFltRec,1,RECCOUNT())
        GO lnFltRec
      ENDIF    

    ELSE
  
      IF SEEK('N' + lcCodeVal[lnArrLen,1] + "N" + lcCodeVal[lnArrLen,2])  
        lcCodeVal[lnArrLen,3] = CODES.cDiscrep
      ELSE
        lcCodeVal[lnArrLen,3] = ''       && In case of this code record is deleted
      ENDIF  

    ENDIF

    IF !EMPTY(lcCodeVal[lnArrLen,3]) AND gfIsEdtble(ALLTRIM(lcCodeVal[lnArrLen,2]) , @lnCodeLen)
       lcCodeVal[lnArrLen,3] = PADR(lcCodeVal[lnArrLen,1],lnCodeLen) + '-' + lcCodeVal[lnArrLen,3]
    ENDIF

  ENDFOR
*E301278,4 if it is an array loop it to get all values. [End  ]

*E301278,4 else it is direct value then do original code [Begin]
ELSE && Pass one code only

  IF EMPTY(lcCodeVal) .OR. lcCodeVal = "*"
    *B801042,1 MAN Save Filter Start
    lcCurFlt = FILTER()
    lnFltRec = IIF(EOF() .OR. BOF(), 0, RECNO())
    SET FILTER TO
    *B801042,1 MAN Save Filter End
    *E300789,1 Heaham (Start)
    *IF !SEEK(SPACE(2)+lcCodeVal)
    *MAN Some Programs call the function with "******"
    *IF !SEEK(SPACE(1)+lcCodeVal)
    IF !SEEK(SPACE(1)+LEFT(lcCodeVal,1))
    *E300789,1 Heaham (End)
      APPEND BLANK
      REPLACE cFld_Name  WITH IIF(lcCodeVal = '*','ALL','N/A') ;
              cCode_No   WITH IIF(lcCodeVal = '*','*','')      ;
              cDiscrep   WITH IIF(lcCodeVal = '*','All','N/A') ;
              cRltField  WITH 'N'
        *T20060831.0032 TMI [Start] update the added line with trace infomation
        REPLACE COWNER WITH IIF(TYPE('lcProgName')='C','p:'+lcProgName,'r:'+SYDREPRT.CREP_ID) ;
                DADD_DATE WITH gdSysDate ;
                CADD_TIME WITH TIME() ;
                CADD_USER WITH gcUser_ID
        *T20060831.0032 TMI [End  ]         
    ENDIF  
    lcReturnVal = CODES.cDiscrep
    *B801042,1 MAN Restore Filter Start
    SET FILTER TO &lcCurFlt.
    IF BETWEEN(lnFltRec,1,RECCOUNT())
      GO lnFltRec
    ENDIF    
    *B801042,1 MAN Restore Filter End
  ELSE
    *E301853,1 WAB (Start) - save the current filter
    lcSavFltr = FILTER()
    lnFltRec = IIF(EOF() .OR. BOF(), 0, RECNO())
    SET FILTER TO 
    *E301853,1 WAB (End)

    *E300789,1 Heaham (Start)
    *IF SEEK(gcAct_Comp + lcCodeVal + "N" + lcFldName)
    IF SEEK('N' + lcCodeVal + "N" + lcFldName)  
    *E300789,1 Heaham (End)
      lcReturnVal = CODES.cDiscrep
    ELSE
      lcReturnVal = ''       && In case of this code record is deleted
    ENDIF  

    *E301853,1 WAB (START) returned back the filter
    SET FILTER TO &lcSavFltr 
    IF BETWEEN(lnFltRec,1,RECCOUNT())
      GO lnFltRec
    ENDIF    
    *E301853,1 WAB (End) 
  ENDIF  

  *E301238,1 Add Code + Description if editable code, else nothing to do. [Begin]
  PRIVATE lnCodeLen
  lnCodeLen = 6
  IF llChkEdit AND !EMPTY(lcReturnVal) AND gfIsEdtble(ALLTRIM(lcFldName) , @lnCodeLen)
    lcReturnVal = PADR(lcCodeVal,lnCodeLen) + '-' + lcReturnVal
  ENDIF
  *E301238,1 Add Code + Description if editable code, else nothing to do. [End  ]

*E301278,4 else it is direct value then do original code [End  ]

ENDIF

SET ORDER TO &lcSavOrder
IF llUseCodes
  USE IN Codes
ENDIF
SELECT IIF(EMPTY(lcSavSelct),0,lcSavSelct)
RETURN lcReturnVal
*-- end of gfCodDes.
           
*!*************************************************************
*! Name      : gfGetVld
*! Developer : Malak Hanna Aziz
*! Date      : 1993-1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!          Calls: GFSUBSTR()               (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfGetVld
PARAMETERS lcFieldNam, laArrName,llAddAll
PRIVATE lcCurrFile,lcOldTag,lcSetExct,llSydField,lnMaxLen

*** Save current environment
lcCurrFile    = SELECT()
lcSetExact    = SET('EXACT')
llSydField    = .F.
lnMaxLen      = 0

*** Check if fields system file is opened, if it is 
*** set the appropriate tag, if not open use it with
*** the appropriate tag.
*** Tag to be used is 'cFld_Name'
*** Its expression is
IF !USED('SYDFIELD')
  SELECT 0
  USE &gcSysHome.SYDFIELD ORDER TAG cFld_Name 
  llSydField       = .T.
ELSE
  SELECT SYDFIELD
  lcOldTag         = SYS(22)
  SET ORDER TO TAG cFld_Name
ENDIF

*** Search for field name
IF SEEK(UPPER(lcFieldNam), 'SYDFIELD')
  =gfSubStr(SYDFIELD.mVEntries, @laArrName, "|~")   
  lnMaxLen = LEN(laArrName[1,1])
  FOR lnCount = 2 TO ALEN(laArrName,1) 
    lnMaxLen = MAX(lnMaxLen,LEN(laArrName[lnCount,1]))
  ENDFOR  
ELSE
  laArrName = " "
ENDIF  

IF llAddAll
  *** Add one element on top to be used for 'All' option.     
  *** Assign a value to this element later.
  IF !EMPTY(laArrName[1,1])
    DIMENSION laArrName[ALEN(laArrName,1)+1,2]
    =AINS(laArrName, 1, 1)
  ENDIF  
  laArrName[1,1] = "All"
  laArrName[1,2] = " "
ENDIF  

*** Restore environment
IF llSydField .AND. USED('SYDFIELD')
  USE IN 'SYDFIELD'   
ELSE
  IF !EMPTY(lcOldTag)
    SET ORDER TO TAG (lcOldTag)
  ENDIF  
ENDIF

SELECT (lcCurrFile)
SET EXACT &lcSetExact
RETURN lnMaxLen

*!*************************************************************
*! Name      : gfRltFld
*! Developer : Malak Hanna Aziz
*! Date      : 1993-1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*****************************************************************************
* Modifications:
*!*B603246,1 Fix the bug of the 'Variable lcObjValue not found' error message.
*!*************************************************************
* 
FUNCTION gfRltFld
*E300631,1 YMA 04/06/97 Added the 3rd parameter "lcFldName"
PARAMETERS lcCodeVal,laArrayNam, lcFldName
*B603246,1 (Begin) Add a new var. to PRIVATE command.
*PRIVATE laTempCodes,lcObjValue
PRIVATE laTempCodes,lcObjValue,llFileUsd,lcOldOrdr
*B603246,1 (End)

*Ren Save alias before using SYDFIELD
lcSavSelct  = ALIAS()   && Variable to save the currently selected file.
*Ren end

*B603246,1 (Begin) Open sydfield file with Cfld_name tag .
*--Is 'sydfield ' file used?
llFileUsd = .F.
IF !USED('sydfield')
  *B606420,1 TMI [Start] 
  *USE gcSysHome+'sydfield' ORDER TAG Cfld_name IN 0
  PRIVATE lnSlct
  lnSlct = SELECT()
  =gfOpenFile(gcSysHome+'sydfield','Cfld_name','SH')
  SELECT (lnSlct)
  *B606420,1 TMI [End  ] 
  llFileUsd = .T.
ELSE
  *-- Save old order OF sydfield.
  lcOldOrdr = ORDER('sydfield')
  SET ORDER TO TAG Cfld_name IN sydfield
ENDIF
*B603246,1 (End)

IF EMPTY(lcCodeVal)   && Case N/A 
  FOR lnCount  = 1 TO ALEN(laArrayNam,1) 
    *B603246,1 (Begin) Remark the following lines and get the field type from sydfield file.
    *DO CASE
    *   CASE SUBSTR(laArrayNam[lnCount,1],1,1) $ 'Cc'
    *        lcObjValue = ''
    *      CASE SUBSTR(laArrayNam[lnCount,1],1,1) $ 'Nn'
    *        lcObjValue = 0
    *      CASE SUBSTR(laArrayNam[lnCount,1],1,1) $ 'Ll'
    *        lcObjValue = .F.
    *      CASE SUBSTR(laArrayNam[lnCount,1],1,1) $ 'Dd'
    *        lcObjValue = {}
    *    ENDCASE
    *--Get field type from sydfield instead of any guess cases like naming convensions errors..
    lcObjValue = UPPER(IIF(SEEK(PADR(laArrayNam[lnCount,1],10),'sydfield'),sydfield.cData_Typ,''))
    *--Initialize the related filed variable according to the field type.
    DO CASE
      *-- Case char
      CASE lcObjValue = "C"
        lcObjValue = ''

      *-- Case Numeric
      CASE lcObjValue = "N"  
        lcObjValue = 0

      *-- Case Logical
      CASE lcObjValue = "L"  
        lcObjValue = .F.

      *-- Case date
      CASE lcObjValue = "D"
        lcObjValue = {}
    ENDCASE
    *B603246,1 (End)    
    lcFieldNam  = laArrayNam[lnCount,2]
    &lcFieldNam = lcObjValue
    SHOW GET (lcFieldNam)
  ENDFOR  
  RETURN
ENDIF

*Ren Move this statement up to be executed before using SYDFIELD
*lcSavSelct  = ALIAS()   && Variable to save the currently selected file.
*Ren end

*E300631,1 YMA 04/06/97 Select the codes file instead of SYCCodes.
*SELECT SYCCODES         && Select CODES file
llUseCodes = .F.
IF !USED("CODES")
  USE (gcDataDir+"Codes") IN 0
  llUseCodes = .T.
ENDIF
SELECT CODES         && Select CODES file
*E300631,1 YMA 04/06/97 End.
lcSavOrder = SYS(22)    && Save the file order
SET ORDER TO 0          && To activate rushmore

DECLARE laTempCodes[1]
laTempCodes = ' '

*E300631,1 YMA 04/06/97 Changed the file name to be "Codes" instead of "SYCCodes".
*E300631,1 YMA 04/06/97 And include the lcFldName in the "where" clause.
*SELECT CRLTD_NAM,CRLTD_TYP,CRLTD_VLU ;
*  FROM SYCCODES;
*  WHERE CCOMP_ID + CRLTFIELD + CFLD_NAME = gcAct_Comp + 'Y' ;
*  AND   CCODE_NO = lcCodeVal ;
*  INTO ARRAY laTempCodes

*E300789,1 Heaham (Start)
*SELECT CRLTD_NAM,CRLTD_TYP,CRLTD_VLU ;
  FROM CODES;
  WHERE CCOMP_ID + CRLTFIELD + CFLD_NAME = gcAct_Comp + 'Y' + lcFldName;
  AND   CCODE_NO = lcCodeVal ;
  INTO ARRAY laTempCodes

SELECT CRLTD_NAM,CRLTD_TYP,CRLTD_VLU ;
  FROM CODES;
  WHERE cdefcode + CRLTFIELD + CFLD_NAME =  'NY' + lcFldName;
  AND   CCODE_NO = lcCodeVal ;
  INTO ARRAY laTempCodes

*E300789,1 Heaham (End)
*E300631,1 YMA 04/06/97 End.

FOR lnCount  = 1 TO ALEN(laArrayNam,1) 
  lnPosition = ASCAN(laTempCodes,laArrayNam[lnCount,1])

  IF lnPosition = 0     && not found
    *B603246,1 (Begin) Get the field type from sydfield file and if 
    *B603246,1         the related field was not saved in the codes file.
    *B603246,1         then inisialize it's value.
    *--Get field type.    
    lcObjValue = UPPER(IIF(SEEK(PADR(laArrayNam[lnCount,1],10),'sydfield'),sydfield.cData_Typ,''))
    *--Initialize the related filed variable according to the field type.
    DO CASE
      *-- case char
      CASE lcObjValue = "C"
        lcObjValue = ''

      *-- case Numeric
      CASE lcObjValue = "N"  
        lcObjValue = 0

      *-- case Logical
      CASE lcObjValue = "L"  
        lcObjValue = .F.

      *-- case date
      CASE lcObjValue = "D"
        lcObjValue = {}
    ENDCASE
    lcFieldNam  = laArrayNam[lnCount,2]
    &lcFieldNam = lcObjValue
    *B603246,1  (End)    
  ELSE
    lnPosition = ASUBSCRIPT(laTempCodes,lnPosition,1)
    DO CASE
      CASE laTempCodes[lnPosition,2] = 'C'
        lcObjValue = laTempCodes[lnPosition,3]

      CASE laTempCodes[lnPosition,2] = 'N'
        lnDecimPos = AT('.',laTempCodes[lnPosition,3])
        IF lnDecimPos > 0
          lcSavDecim = SET('DECIMALS')  && Save old decimals setting
          SET DECIMALS TO lnDecimPos
          lcObjValue = VAL(laTempCodes[lnPosition,3])
          SET DECIMALS TO &lcSavDecim          
        ELSE
          lcObjValue = VAL(laTempCodes[lnPosition,3])
        ENDIF  

      CASE laTempCodes[lnPosition,2] = 'L'
        lcObjValue = IIF(ALLTRIM(laTempCodes[lnPosition,3]) $ 'YT',.T.,.F.)

      CASE laTempCodes[lnPosition,2] = 'D'      
        lcObjValue = CTOD(laTempCodes[lnPosition,3])
    ENDCASE

    lcFieldNam  = laArrayNam[lnCount,2]
    &lcFieldNam = lcObjValue
    SHOW GET (lcFieldNam)
  ENDIF  
ENDFOR  

SET ORDER TO &lcSavOrder
IF llUseCodes
  USE IN Codes
ENDIF
*B603246,1 (Begin) If the sydfield file was not used close it, else restore the old order.
IF llFileUsd
  *B606420,1 TMI [Start] 
  *USE IN sydfield
  =gfCloseFile('SYDFIELD')  
  *B606420,1 TMI [End  ] 
ELSE
  SET ORDER TO TAG lcOldOrdr IN sydfield
ENDIF  
*B603246,1 (End)
SELECT IIF(EMPTY(lcSavSelct),0,lcSavSelct)

*!*************************************************************
*! Name      : gfCompSets
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To reload global variabels with company settings
*!*************************************************************
*! Calls     : 
*!      Called by: GFMENUBLD()              (function  in ARIA3.PRG)
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Company ID
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfCompSets
PARAMETERS lcCont_ID

gcSavAlias = ALIAS()
*B600422,1 Test the status of the SYCINT file (Open or not)
llUsd_INT = .T.  && Variable to hold the status of the SYCINT file (Open or not)
IF !USED("SYCINT")
  *B600422,1 The file was not opened
  llUsd_INT = .F.
  SELECT 0
  USE (gcSysHome+"SYCINT")
ELSE
  SELECT SYCINT
ENDIF
SET ORDER TO TAG CCONTCODE 

IF SEEK(lcCont_ID)
  lccurrency  = ALLTRIM(ccurrency)
  lccurrenci = ALLTRIM(ccurrencyi)
  lcdate_type = ALLTRIM(cdate_type)
  lccentury   = ALLTRIM(ccentury)
  lcseparator = ALLTRIM(cseparator)

  gcTelTemp  = IIF(!EMPTY(cPhoneTemp),ALLTRIM(cPhoneTemp),gcTelTemp)
  
  *E300680,1 Change phone width according to font MS SANS SERIF 
  *gnPhonSize = LEN(ALLTRIM(gcTelTemp))
  gnPhonSize = LEN(ALLTRIM(gcTelTemp))*(fontme(7,'MS SANS SERIF',9)/9)
  *E300680,1 end
  
  SET CENTURY  &lccentury
  SET CURRENCY TO lccurrenci
  SET CURRENCY &lccurrency

  SET DATE &lcdate_type
  SET SEPARATOR TO lcseparator
  *E300680,1 Change date width according to font MS SANS SERIF 
  *gnDateWdth = IIF('ON'$SET('CENT'),10,8)
  gnDateWdth = IIF('ON'$SET('CENT'),10,8)*(fontme(7,'MS SANS SERIF',9)/9)
  *E300680,1 end
ENDIF


IF !EMPTY(gcSavAlias)
  SELECT(gcSavAlias)
ENDIF
*B600422,1 Colse the file if itwas opened
IF !llUsd_INT
  USE IN SYCINT
ENDIF

*!*************************************************************
*! Name      : gfWinFn
*! Developer : Hesham Shereef
*! Date      : 1993-1995 
*! Purpose   : To call any windows function through the foxtools.fll
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Command to be excuted
*!*************************************************************
*! Returns            : Falls in case of falier
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfWinFn
PARAMETERS lcCommand
*!*	lcLib=SYS(2004)+"foxtools.fll"
*!*	IF FILE(lcLib)
*!*	  SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
*!*	  SW_HIDE = 0
*!*	  lnFnWinExec =EVALUATE("RegFn('WinExec', 'CI', 'I')")
*!*	  =EVALUATE("CALLFN("+STR(lnFnWinExec)+;
*!*	   ",'control.exe &lcCommand',"+STR(SW_Hide)+")")
*!*	   RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*!*	ELSE
*!*	  WAIT "LIBRARY NOT FOUND" WINDOW
*!*	  RETURN .F.
*!*	ENDIF   

*!*************************************************************
*! Name      : gfDoHelp
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO activate the help window 
*!*************************************************************
*! Calls     : 
*!             Procedures : 
*!             Functions  : 
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDoHelp

HELP

*!*************************************************************
*! Name      : gfSendMsg
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To open the send message dialog
*!*************************************************************
*! Calls     : 
*!          Calls: SYSNDMSG.SPR             
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfSendMsg

gcSaveAlias = ALIAS()

DO SYSNDMSG.SPR

IF !EMPTY(gcSaveAlias)
  SELECT (gcSaveAlias)
ENDIF

*!*************************************************************
*! Name      : gfPopMesag
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To dispaly a message sent to the current user
*!*************************************************************
*! Calls     : 
*!      Called by: GFMAINCONT()             (function  in ARIA3.PRG)
*!      Called by: GFOBJ_MSG()              (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfPopMesag  

gcSavAlias = ALIAS()

SELECT syuCkmsg

lcMsgFrom = cusr_name 
lcMessage = syuCkmsg.cMessage

IF RLOCK()
  REPLACE cusr_name WITH  " ";
          cmessage  WITH  " ";
          lreceived WITH  .T.
ENDIF 
UNLOCK

=gfModalGen('','DIALOG','','',"From : "+lcMsgFrom+chr(13)+lcMessage)



IF !EMPTY(gcSavAlias)
  SELECT (gcSavAlias)
ENDIF

*!*************************************************************
*! Name      : gfFixPath
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To fix a path if it was maped in a network environment
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : Old path
*!*************************************************************
*! Returns            : New path
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfFixPath
PARAMETERS gcOldPath

gcOldPath = gcAllCmp + SUBSTR(gcOldPath,RAT("\",gcOldPath,2)+1)

RETURN gcOldPath

*!*************************************************************
*! Name      : gfEscap
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To trape the escap button under windows
*!*************************************************************
*! Calls     : 
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!          Calls: GFCPSAVE()               (function  in ARIA3.PRG)
*!          Calls: GFCHCLOSE()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Names of base window
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : 
*!*************************************************************
*
*B600915,1 Hesham change the name of the function to be unusable
*FUNCTION gfEscap
FUNCTION gfEscap1
PARAMETERS lcWin2Close

lcWin2Close = IIF(TYPE('lcWin2Close')="C",lcWin2Close,WONTOP())

DO CASE
  CASE WONTOP(gcBaseWind) .OR. WPARENT(WONTOP()) = gcBaseWind
    IF (laScrMode[3] .OR. laScrMode[4]) .AND. llCUpDate
        *** Do you want to save chanes befor closing this progrm
        *** Yes, No , Cancel
        lnOption = gfModalGen("QRM00140B00025","ALERT")
        DO CASE
          CASE lnOption = 1
           IF gfCpSave()
             glQuitting = .T.
             CLEAR READ                                    
           ENDIF  
          CASE lnOption = 2
            glQuitting = .T.
            CLEAR READ
        ENDCASE
    ELSE
      IF laScrMode[3]
        IF ALIAS()<>lcBaseFile
          SELECT (lcBaseFile)
        ENDIF
        =gfObj_Lock(.F.)
      ENDIF
      glQuitting = .T.   
      CLEAR READ
    ENDIF
  CASE SUBSTR(WONTOP(),1,2) = "CW" .OR. SUBSTR(WPARENT(WONTOP()),1,2) = "CW"
    =gfChClose(lcWin2Close)
ENDCASE

*B600915,1 Hesham (START)
FUNCTION gfEscap
PARAMETERS lcWin2Close

lcWin2Close = IIF(TYPE('lcWin2Close')="C",lcWin2Close,WONTOP())
lcWindPar=WPARENT(WONTOP())
lcParWinds = ''
DO WHILE !EMPTY(lcWindPar)
  lcParWinds = lcParWinds+IIF(EMPTY(lcParWinds),'',',')+lcWindPar
  lcWindPar=WPARENT(lcWindPar)
ENDDO

DO CASE
*WPARENT(WONTOP()) = gcBaseWind
  CASE WONTOP(gcBaseWind) .OR. UPPER(gcBaseWind) $ lcParWinds .OR. WONTOP('gwcContrl1')
    DEACTIVATE POPUP ALL
    DO CASE
      CASE (laScrMode[3] OR laScrMode[4]) AND WREAD('gwcContrl1')
          IF ALIAS()<>lcBaseFile
            SELECT (lcBaseFile)
          ENDIF
          ACTIVATE WINDOW gwcContrl1
          _CUROBJ=OBJNUM(pbCls)
          KEYBOARD "{SPACEBAR}"
      CASE (laScrMode[3] .OR. laScrMode[4]) .AND. llCUpDate
          *** Do you want to save chanes befor closing this progrm
          *** Yes, No , Cancel
          lnOption = gfModalGen("QRM00140B00025","ALERT")
          DO CASE
            CASE lnOption = 1
             IF gfCpSave()
               glQuitting = .T.
               CLEAR READ                                    
             ENDIF  
            CASE lnOption = 2
              glQuitting = .T.
              CLEAR READ
          ENDCASE

        CASE (laScrMode[3] OR laScrMode[2] OR laScrMode[1]) AND WREAD('gwcContrl1')
          IF ALIAS()<>lcBaseFile
            SELECT (lcBaseFile)
          ENDIF
          ACTIVATE WINDOW gwcContrl1          
          _CUROBJ=OBJNUM(pbCls)
          KEYBOARD "{SPACEBAR}"
        CASE laScrMode[3] OR laScrMode[2] OR laScrMode[1]
          IF laScrMode[3]
            IF ALIAS()<>lcBaseFile
              SELECT (lcBaseFile)
            ENDIF
            =gfObj_Lock(.F.)
          ENDIF  
          glQuitting = .T.   
          CLEAR READ
      ENDCASE
  CASE SUBSTR(WONTOP(),1,2) = "CW" .OR. SUBSTR(WPARENT(WONTOP()),1,2) = "CW"
          *WAIT '5' WINDOW
    DEACTIVATE POPUP ALL
    =gfChClose(lcWin2Close)
ENDCASE


  
*!*************************************************************
*! Name      : gfDecript
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Decript the activation key
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!          Calls: GFDECR1()                (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Encripted Modules IDs
*!*************************************************************
*! Returns            : Decripted modules IDs in a string
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDecript
PARAMETERS lcStr2Dec
lnMdCount  = VAL(LEFT(lcStr2Dec,1))
lcVldpart  = SUBSTR(lcStr2Dec,2,lnMdCount*4)
lcModules  = ""

IF SYS(2007,lcVldpart+SUBSTR(lcStr2Dec,AT("-",lcStr2Dec))) ;
      =SUBSTR(lcStr2Dec,(lnMdCount*4)+2,AT("-",lcStr2Dec)-(lnMdCount*4)-2)
  FOR lnMdl = 1 TO LEN(lcVldpart) STEP 4
    lcModules = lcModules +IIF(EMPTY(lcModules),"","|")+gfDecr1(SUBSTR(lcVldpart,lnMdl,4))
  ENDFOR
ENDIF

RETURN lcModules 

*!*************************************************************
*! Name      : gfDecr1
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Decript one module ID
*!*************************************************************
*! Calls     : 
*!      Called by: GFDECRIPT()              (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Encripted module ID
*!*************************************************************
*! Returns            : Decripted module ID
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfDecr1
PARAMETERS lcMdl2Dec

lcLeter1= CHR(INT(VAL(LEFT(lcMdl2Dec,1)+RIGHT(lcMdl2Dec,1))))
lcLeter2= CHR(INT(VAL(SUBSTR(lcMdl2Dec,2,2))))
RETURN UPPER(lcLeter1+lcLeter2)

*!*************************************************************
*! Name      : gfGetUsers
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Collect the number of users from encripted number
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!*************************************************************
*! Passed Parameters  : Encripted number of users
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfGetUsers
PARAMETERS lcNumber

lnRetNum = 0 

FOR lnCount= 1 TO 999
  IF SYS(2007,ALLTRIM(STR(lnCount))) = lcNumber
    lnRetNum = lnCount
    EXIT
  ENDIF
ENDFOR

RETURN lnRetNum

*!*************************************************************
*! Name      : gfActHelp
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : Redefine the help bar
*!*************************************************************
*! Calls     : 
*!             Procedures :
*!             Functions  :
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfActHelp
*E300399,1 Hesham El-Sheltawi (Start)
PRIVATE lcError,llError
lcError = ON('ERROR')
ON ERROR llError=.T.
*E300399,1 Hesham El-Sheltawi (End)

DEFINE BAR gnHlpBar OF &gcHlpPop PROMPT gcHlpPrm

*E300399,1 Hesham El-Sheltawi (Start)
ON ERROR &lcError               
*E300399,1 Hesham El-Sheltawi (End)
               


*!*************************************************************
*! Name      : gfReadVld
*! Developer : Mohamed Abdel Salam
*! Date      : 06/07/1995 
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!             Procedures :
*!             Functions  :
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : =gfReadVld()
*!*************************************************************
*

FUNCTION gfReadVld               
IF INLIST(READKEY(),12,268)
  lcWin2Close = IIF(TYPE('lcWin2Close')="C",lcWin2Close,WONTOP())
  DO CASE
    CASE WONTOP(gcBaseWind) .OR. WPARENT(WONTOP()) = gcBaseWind
      =gfCPClose()
      RETURN glQuitting
    CASE SUBSTR(WONTOP(),1,2) = "CW" .OR. SUBSTR(WPARENT(WONTOP()),1,2) = "CW"
      =gfChClose(lcWin2Close)
      RETURN .F.
  ENDCASE
*  IF !glQuitting
*     RETURN _CUROBJ
*  ENDIF
ELSE
  IF !glQuitting AND ( WPARENT(WONTOP()) = gcBaseWind .OR.;  
                       WREAD(WPARENT(WONTOP()))       .OR.;
                       WREAD(WONTOP())                      )
    RETURN _CUROBJ
  ENDIF
ENDIF  


*!*************************************************************
*! Name      : gfMenuBld
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : TO build the menu from  the menu file
*!*************************************************************
*! Calls     : 
*!      Called by: ARIA3.PRG                
*!      Called by: GPCHNGMODL               (procedure in ARIA3.PRG)
*!      Called by: GPCHANGCOM               (procedure in ARIA3.PRG)
*!          Calls: GPMENUBAR                (procedure in ARIA3.PRG)
*!          Calls: GFCOMPSETS()             (function  in ARIA3.PRG)
*!          Calls: GPCHANGCOM               (procedure in ARIA3.PRG)
*!          Calls: GFWINARNG()              (function  in ARIA3.PRG)
*!          Calls: GFMODALGEN()             (function  in ARIA3.PRG)
*!*************************************************************
*! Passed Parameters  : Module ID,Categury,Show or no show 
*!*************************************************************
*! Returns            : .f. if not successful
*!*************************************************************
*! Example   : 
*!*************************************************************
* This function is to bild the menu from the system file SYCMENU
* three level of menu can be built :
* Sytem initial menu , System second menu , Any Module menu
* Prameters to be send : module Id , Menu level (I,S,A)
*
FUNCTION gfMenuBld
PARAMETERS lcModul,lcSub_Ctg,lcNoShow

*** Default module id to system
lcModul    = IIF(TYPE('lcModul'  )='C',lcModul   ,'SY')
*** Defualt menu level ti initial
lcSub_Ctg  = IIF(TYPE('lcSub_Ctg')='C',lcSub_Ctg ,'I')
*** In the file pad system barsare going to be defined staring from bar # 50
lcNoShow   = IIF(TYPE('lcNoShow') ='C' ,lcNoShow,'SHOW')
lcNoShow   = IIF(_WINDOWS,'SHOW',lcNoShow)

lnExsBar   = 51
llRetFlag  = .T.
PRIVATE llApplUsed
llApplUsed = .F.
***
*E301077,78 Hesham (Start)
llObjctUse=gfSysOpen(gcSysHome+'SYDOBJCT','CAPP_ID')
*IF !USED("SYDOBJCT")
*  SELECT 0 
*  USE (gcSysHome+"SYDOBJCT")
*ELSE
*   SELECT SYDOBJCT 
*ENDIF   
*SET ORDER TO TAG CAPP_ID
*E301077,78 Hesham (End)

*E301077,78 Hesham (Start)
llUsPrv = .F.
*E301077,78 Hesham (End)
IF glLog_Requ 
  *E301077,78 Hesham (Start)
  *IF !USED("SYUUSRPR")
  *  SELECT 0 
  *  USE (gcSysHome+"SYUUSRPR")
  *ELSE
  *   SELECT SYUUSRPR 
  *ENDIF   
  llUsPrv=gfSysOpen(gcSysHome+'SYUUSRPR','cuser_id')
  *E301077,78 Hesham (End)
  SET ORDER TO TAG CUSER_ID
ENDIF  

IF lcModul='SY' 
  IF !USED('SYDAPPL')
    SELECT 0 
    USE (gcSysHome+"SYDAPPL")
    llApplUsed = .T.
  ELSE
    SELECT SYDAPPL
  ENDIF  
  SET ORDER TO TAG CAPP_ID
ENDIF   

***
*E301077,78 Hesham (Start)
llMenUse = gfSysOpen(gcSysHome+'SYCMENU','APPPOPBAR')

*IF !USED('SYCMENU')
*  SELECT 0 
*  USE (gcSysHome+"SYCMENU")
*ELSE
*  SELECT SYCMENU
*ENDIF   
SET ORDER TO TAG APPPOPBAR
*E301077,78 Hesham (End)

**E302767,1 TMI [START] build the temp file that does not contain the lines A4xp related
*E302767,4 TMI [START] Define the variable in the start of Aria27
*lcTMPMENU = gfTempName()
*E302767,4 TMI [START] Define the variable in the start of Aria27

*- Rebuild the menu file only if A4 installed, else do as normal
=IIF(TYPE('SYDOBJCT.LRUNFROMA4')='L',  lfBldTmpMn()  ,  ''  )
**E302767,1 [END]

lcExact = SET ("EXACT")
SET EXACT OFF

*** Chek if this module has any records in the menu file
IF SEEK(lcModul)

  SET EXACT &lcExact
  
  *** If this is the first time to run this function,
  *** remove all the system menu and define it automatic
  IF lcModul = 'SY' .AND. lcSub_Ctg = 'I' .AND. lcNoShow = 'SHOW'
    SET SYSMENU TO
    SET SYSMENU  AUTOMATIC
  ENDIF

  *** By hiding the menu we gain more speed in building the menu
  IF _DOS
    HIDE MENU _MSYSMENU SAVE
  ENDIF  

  *** In case bildin the menu for any module,  restore the fixed menu
  *** configuration befor building the module menu options
  IF lcModul <> 'SY'
    POP  MENU _MSYSMENU
    PUSH MENU _MSYSMENU
  ENDIF  

  *** Check if building a module menu and the current user has
  *** right limits, add a relation with the user priv. file
  *** and disable the unpermited programs.
  IF glLog_Requ .AND. lcModul <> "SY" 
    SELECT SYUUSRPR
    SET ORDER TO TAG MDLCMPPRSS
    SET FILTER TO (CUSER_ID=GCUSER_ID  .AND. cgrporuser='U') .OR.;
                  (CUSER_ID=GCUSER_GRP .AND. cgrporuser='G')
                  
    SELECT SYCMENU
    SET RELATION TO lcModul+gcAct_Comp+cPross_ID+cproctype ;
                 INTO SYUUSRPR ADDITIVE 
 
 
  ENDIF

  SET RELATION TO cApp_ID+cPross_ID INTO SYDOBJCT ADDITIVE 
 
  *** Loop for all records in the menu file for this moudle
  SCAN REST ;
       WHILE cApp_ID  = lcModul ;
       FOR   cSub_Ctg = lcSub_Ctg 

    *** If the bar or pad to be defined have no hot key defined in
    *** the menu file it will give an error if we type KEY null
    lcHotKey  = IIF(EMPTY(cSub_hKey),[],[KEY ]+ALLTRIM(cSub_hKey))   
 
    DO CASE
      *** Check if the type of this line is  pad 
      CASE  ALLTRIM(cSub_Typ) = 'P'
        *** Check if this new pad has not been defined before
        IF TYPE([PRMPAD('_MSYSMENU',ALLTRIM(cMstr_Nam))]) = 'U'
          *** Get the name of the privious pad to define the 
          *** new pad in the right position 
          lcPrivpad = "P"+PADL(INT(VAL(SUBSTR(cMstr_Nam,2))-1),2,'0')

          *** Define new meny pad
          DEFINE PAD    (ALLTRIM(cMstr_Nam)) ;
                 OF     _mSYSMENU ;
                 PROMPT ALLTRIM(cSub_prpt);
                 AFTER &lcPrivpad &lcHotKey

          *** Define new menu popup that going to be opend from this pad
          DEFINE POPUP (ALLTRIM(cPross_ID)) MARGIN SHADOW RELATIVE

          *** link the pad to the popup
          ON PAD (ALLTRIM(cMstr_Nam)) ;
             OF _mSYSMENU ;
             ACTIVATE POPUP (ALLTRIM(cPross_ID))
        ENDIF          
 
      *** Define all menu bars
      OTHERWISE
        *** Get the popup and bar name to be send to the gfBarSkip function
        *** to get the right help message fro array
        lcPopBar = ALLTRIM(cMstr_Nam)+"-"+cBar_pos

        *** To add the bars of the file pad befor the system bars
        *** we have to define the popups relativ and defien all the 
        *** menu bars befor bar # 51 of the file pad 
        *** But in case of system bars no need for the BEROFE cluase
        IF lcModul = "SY"

          *** Define fox system bars      
          IF cProcType = 'S'
            *** Fox system bars are defined without bar no 
            *** so we have to calculat the relative positon
            *** to define the bar after
            lnAftrBar = IIF(VAL(cBar_pos)-1 > 0,VAL(cBar_pos)-1,1)     

            DEFINE BAR EVAL(cPross_ID) OF (ALLTRIM(cMstr_Nam));
                  PROMPT ALLTRIM(cSub_prpt) AFTER lnAftrBar;
                  COLOR SCHEME 3 ;
                  &lcHotKey
            *SKIP FOR gfBarSkip("&lcPopBar")
            *B606582,1 AMH 11/03/2002 Fix the bug menu bars.
            lcCommand = "ON SELECTION BAR EVAL(cPross_ID) OF (ALLTRIM(cMstr_Nam))"+;
                        "DO gpMenuBar WITH '"+ALLTRIM(cMstr_Nam)+"',"+cPross_ID
            &lcCommand.
          *** Define Aria system bars    
          ELSE
            *** Only system bars can have skip expretion comming from the 
            *** Modules objects file
            
            IF UPPER(ALLTRIM(cPross_id)) = "GFDOHELP"
              gcHlpPop = ALLTRIM(cMstr_Nam)
              gcHlpPrm = ALLTRIM(cSub_prpt)
              gnHlpBar = VAL(cBar_pos) 
            ENDIF   
            *E300897,1 Hesham (Start)
            *E300897,1 if the bar we are going to define is for a visual fox
            *E300897,1 module then skip this bar
            IF TYPE('SYDAPPL.CMODULEVER')='C'
              IF CPROCTYPE = 'M' AND SEEK(ALLT(CPROSS_ID),'SYDAPPL') AND SYDAPPL.CMODULEVER='V'
                LOOP
              ENDIF
            ENDIF  
            *E300897,1 Hesham (End)

            lcSkipExp = IIF(EMPTY(SYDOBJCT.mskipexpr),[],[SKIP FOR ]+;
                        ALLTRIM(SYDOBJCT.mskipexpr))

            *E300709,1 Hesham (Start)
            *E300709,1 if the bar is a program called from the main system
            *E300709,1 menu then get the user priv. for this process
            *E300709,1 from the user priv. file
            IF cProcType = 'P' AND glLog_Requ
              llSkip = SEEK(ALLT(gcUser_Grp)+'SY'+gcAct_Comp+cPross_ID,'SYUUSRPR')
              llSkip = llSkip OR SEEK(ALLT(gcUser_ID)+'SY'+gcAct_Comp+cPross_ID,'SYUUSRPR') 
              IF !llSkip
                lcSkipExp = 'SKIP FOR .T.'
              ENDIF  
            ENDIF
            *E300709,1 Hesham (End)
            DEFINE BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam));
                   PROMPT ALLTRIM(cSub_prpt);
                   &lcSkipExp &lcHotKey;
                   COLOR SCHEME 3
            IF !EMPTY(SYDOBJCT.mMarkExpr)
              SET MARK OF BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam));
                 EVAL(ALLTRIM(SYDOBJCT.mMarkExpr)) 
            ENDIF
            *B606582,1 AMH 11/03/2002 Fix the bug menu bars.
            lcCommand = "ON SELECTION BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam))"+;
                        "DO gpMenuBar WITH '"+ALLTRIM(cMstr_Nam)+"',"+cBar_pos
            &lccommand.
            
          ENDIF
     
        *** Define other modules bars
        ELSE
          *** If the current user have lemeted rights, disable
          *** the unpermited programs 
          IF glLog_Requ
            *** Check if the current user have access to this bar in
            *** the user prevelage file or not
            IF cSub_Typ <> 'S' .AND. EOF('SYUUSRPR') 

              DEFINE BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam));
                    PROMPT ALLTRIM(cSub_prpt)  BEFORE lnExsBar;
                    COLOR SCHEME 3 SKIP FOR .T. &lcHotKey
            ELSE
              DEFINE BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam));
                    PROMPT ALLTRIM(cSub_prpt)  BEFORE lnExsBar;
                    COLOR SCHEME 3 ;
                    &lcHotKey
              * SKIP FOR gfBarSkip("&lcPopBar")                    
            ENDIF
          ELSE
            DEFINE BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam));
                   PROMPT ALLTRIM(cSub_prpt)  BEFORE lnExsBar;
                   COLOR SCHEME 3 ;
                   &lcHotKey
            *SKIP FOR gfBarSkip("&lcPopBar")                   
          ENDIF
          *B606582,1 AMH 11/03/2002 Fix the bug menu bars.
          lcCommand = "ON SELECTION BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam))"+;
                        "DO gpMenuBar WITH '"+ALLTRIM(cMstr_Nam)+"',"+cBar_pos
          &lcCommand. 
        ENDIF

        *** Check if this bar is a branching bar and define new
        *** popup if it is
        IF ALLTRIM(cSub_Typ) = 'S'
          DEFINE POPUP (ALLTRIM(cPross_ID)) ;
                 MARGIN SHADOW RELATIVE

          ON BAR VAL(cBar_pos) OF (ALLTRIM(cMstr_Nam)) ;
             ACTIVATE POPUP (ALLTRIM(cPross_ID))
        ENDIF
    ENDCASE
  ENDSCAN

  *** Now we are going to link all the menu bars to the global procedure
  *** gpMneuBar to excute the selected option
 
  *B606582,1 AMH 11/03/2002 Fix the bug menu bars.
  *ON SELECTION POPUP ALL DO gpMenuBar WITH POPUP(),BAR()  
  
     
  *** In case of creating the second level of the menu we are
  *** going to save the configuration to be restored when changing
  *** the module and ther is no need to collect the prosses names
  IF lcModul = 'SY' .AND. lcSub_Ctg = 'S'
    PUSH MENU _MSYSMENU
    gnWinSepta = CNTBAR('P08PU08')
  ELSE

    IF !glRestore
      IF (lcModul = 'SY' .AND. lcSub_Ctg = 'I') .OR. glCmpCreat

       *** Now we are going to collect the companies names and link it's 
       *** bars to the change company procedure
       *E301077,78 Hesham (Start)
       PRIVATE llCompUse
       llCompUse =gfSysOpen(gcSysHome+'SYCCOMP',"CCOMP_ID")
       *IF !USED("SYCCOMP")
       *   SELECT 0
       *   USE(gcSysHome+"SYCCOMP")
       * ELSE
       *   SELECT SYCCOMP
       * ENDIF
        *SET ORDER TO TAG CCOMP_ID
        *E301077,78 Hesham (End)


        IF !glCmpCreat
          gcAct_Comp = IIF(!EMPTY(gcUser_Com),gcUser_Com,gcDef_Comp)

          *** In case of dos we have to set the mark to deferant chr. 
          IF _DOS 
            SET MARK OF POPUP _COMPANIES TO ""
          ENDIF
        ELSE
          SET MARK OF POPUP _COMPANIES TO .F.
          RELEASE BAR  ALL OF _COMPANIES
        ENDIF  

        lnCompBar  = 0
        *** Collect all avalilabe companies to the compamies popup
        SCAN
          lnCompBar = lnCompBar + 1
    
          IF glLog_Requ
            SELECT SYUUSRPR
            LOCATE FOR INLIST(cUser_ID,gcUser_ID,gcUser_Grp) .AND.;
                       cComp_ID = SYCCOMP.cComp_ID
                     
            SELECT SYCCOMP
            
            IF FOUND('SYUUSRPR')      
              DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name)
            ELSE
              DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name) ;
                     SKIP FOR .T. 
            ENDIF  
          ELSE
            DEFINE BAR lnCompBar OF _COMPANIES PROMPT ccomp_id+"-"+ALLTRIM(cCom_Name)
          ENDIF  
         
 
          IF gcAct_Comp = cComp_Id
            SET MARK OF BAR lnCompBar OF _COMPANIES TO .T.
            gnCompBar = lnCompBar
            gcCom_Name = ALLTRIM(sycComp.cCom_Name)
            *E301098,1 Hesham (Start)
            *gcDataDir  = ALLTRIM(cCom_dDir)
            gcDataDir  = gfGetDataDir(ALLTRIM(cCom_dDir))
            *E301098,1 Hesham (End)
            *E038621,1 WAM 04/05/2005 Prevent Aria4XP programs & reports from running under Aria27
            glRunFrmA4 = lRunFromA4 
            *E038621,1 WAM 04/05/2005 (End)
           
            *300273,1 Change the data path to the currently mapped drive.
            *B601081,1 Hesham (Start)
            *E301098,1 Hesham (Start)
            *IF UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) = UPPER(SUBSTR(gcDataDir,1,ATC('\',gcDataDir,2))) AND ;
            *   UPPER(SUBSTR(gcOrgPath,1,ATC('\',gcOrgPath,2))) <>  UPPER(SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2)))
            *  gcDataDir= SUBSTR(gcSysHome,1,ATC('\',gcSysHome,2))+SUBSTR(gcDataDir,ATC('\',gcDataDir,2)+1)
             * gcDataDir = gcAllCmp + RIGHT(gcDataDir, LEN(gcDataDir) - ATC("\DBFS",gcDataDir) - 5)
            *ENDIF            
           *E301098,1 Hesham (End)
            
            *B601081,1 Hesham (End)
            gcComp_Mdl = ALLTRIM(mComp_Mdl)
            gcComp_Lvl = IIF(EMPTY(ccompprnt),'P','C')
            gcPrnt_Cmp = IIF(EMPTY(ccompprnt),cComp_Id,ccompprnt)
            gcBaseCurr = IIF(EMPTY(gcBaseCurr),'USDLR',gcBaseCurr)
            *E300713,1 Hesham (Start)
            *E300713,1 Initialize global variables for current year & period
            gcCurrYear = ccurr_yer
            gcCurrPrd  = ccurr_Prd
            *E300713,1 Hesham (End)
			*E300705,1 MAN 09/13/97 Open Company files (Not related to any module)
			*E300705,1              while changing the company
			DO gpOpnCmp
			*-- End Open Files Related to the company and not related to any module &&MAN

            =gfCompSets(ALLTRIM(syccomp.ccont_code))            
          ENDIF
          
          lcComp_Id = '"'+SYCCOMP.cComp_Id+'"'
          ON SELECTION BAR lnCompBar OF _COMPANIES ;
                       DO gpChangCom WITH &lcComp_Id

        ENDSCAN
        
        *** If the company record still exist in the file, 
        *** get the company data path 
        *IF SEEK(gcAct_Comp)
        *  gcDataDir  = ALLTRIM(cCom_dDir)
        *  gcComp_Mdl = ALLTRIM(mComp_Mdl)
        *ELSE
        *  WAIT "User default company record was deleted without updating the user defaults" WINDOW
        *  gcAct_Comp = "  "
        *ENDIF
        *E301077,78 Hesham (Start)
        USE IN IIF(llCompUse,'SYCCOMP',0)
        *E301077,78 Hesham (End)

        *** Close the companies file 
        * USE IN ALIAS('syccomp')

        *** Open the module popup with the initial menu
        IF lcNoShow = 'SHOW'  
          IF glUser_Tsk 
*            KEYBOARD "{ENTER}" PLAIN CLEAR
          ELSE
*            KEYBOARD "{ALT+M}" PLAIN CLEAR
          ENDIF  
        ENDIF
      ELSE
        =gfWinArng()
        *** Reselect the currend company
        SET MARK OF POPUP _COMPANIES TO .F.
        IF gnCompBar > 0
          *** there is posible error in case of deleting the current company
          SET MARK OF BAR gnCompBar OF _COMPANIES TO .T.
        ENDIF  
         
        *** open the file popup with all other modules
        IF lcNoShow = 'SHOW'        
          *(MAN) Changed the following IF
          *IF glUser_Tsk .OR. glToolActv 
          IF glUser_Tsk .OR. glToolActv .OR. !EMPTY(gcExtPrg)
 *           KEYBOARD "{ENTER}" PLAIN CLEAR
          ELSE
            IF !glReLogIn       
*              KEYBOARD "{ALT+F}" PLAIN CLEAR
            ENDIF  
          ENDIF  
        ENDIF  
      ENDIF
    ENDIF  

    *** Now we can show the menu 

    IF lcNoShow = 'SHOW' .AND. _DOS
      SHOW MENU _MSYSMENU 
    ENDIF  

    
    *** Collect the process name and base window name for all menu options
    *E300279,1  Add the help topic field to the array
    *SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),RTRIM(SYDOBJCT.cbasewind),cSub_Msg;
      FROM SYCMENU, SYDOBJCT;
     WHERE SYDOBJCT.CAPOBJNAM = SYCMENU.CPROSS_ID;
       AND SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE = 'P';
     UNION;
    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),SPACE(10),cSub_Msg;
     FROM  SYCMENU;
     WHERE SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('R','G','C','E','M');
           INTO ARRAY  gaProcess
    
*       OR  SYCMENU.csub_typ = 'S'
*E300306,1 M.H Update the SQL to work with system program & the custom
*E300306,1 M.H program by add 'C' to the WHERE of the upper SELECT & remove 
*E300306,1 M.H it from the UNION.
*    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),RTRIM(SYDOBJCT.cbasewind),cSub_Msg,cHlpTopic;
      FROM SYCMENU, SYDOBJCT;
     WHERE SYDOBJCT.CAPOBJNAM = SYCMENU.CPROSS_ID;
       AND SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE = 'P';
     UNION;
    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTPIM(cProcPath),SPACE(10),cSub_Msg,cHlpTopic;
     FROM  SYCMENU;
     WHERE SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('R','G','C','E','M');
           INTO ARRAY  gaProcess

*E300581,1 Hesham El-Sheltawi (Start)
*E300581,1 Add Program Paramters to the menu array
*    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),RTRIM(SYDOBJCT.cbasewind),cSub_Msg,cHlpTopic;
      FROM SYCMENU, SYDOBJCT;
     WHERE SYDOBJCT.CAPOBJNAM = SYCMENU.CPROSS_ID;
       AND SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('C','P');
     UNION;
    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),SPACE(10),cSub_Msg,cHlpTopic;
     FROM  SYCMENU;
     WHERE SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('R','G','E','M');
           INTO ARRAY  gaProcess
           

*E300710,1 Hesham (Start)
*E300710,1 add a column to the process array it determine if the program is
*E300710,1 calling from the main system menu bars or from the module menu bars
*E300710,1 if it is a main system bar the call the SM module else call the Active
*E300710,1 module

*    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),RTRIM(SYDOBJCT.cbasewind),cSub_Msg,cHlpTopic,cmenuparam;
      FROM SYCMENU, SYDOBJCT;
     WHERE SYDOBJCT.CAPOBJNAM = SYCMENU.CPROSS_ID;
       AND SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('C','P');
     UNION;
    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),SPACE(10),cSub_Msg,cHlpTopic,cmenuparam;
     FROM  SYCMENU;
     WHERE SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('R','G','E','M');
           INTO ARRAY  gaProcess


    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),RTRIM(SYDOBJCT.cbasewind),cSub_Msg,cHlpTopic,cmenuparam,;
           IIF(SYCMENU.CAPP_ID='SY','S','A');
      FROM SYCMENU, SYDOBJCT;
     WHERE SYDOBJCT.CAPOBJNAM = SYCMENU.CPROSS_ID;
       AND SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('C','P');
     UNION;
    SELECT RTRIM(cMstr_Nam)+"-"+cBar_pos,RTRIM(cPross_ID),cProcType,;
           RTRIM(cProcPath),SPACE(10),cSub_Msg,cHlpTopic,cmenuparam,;
           IIF(SYCMENU.CAPP_ID='SY','S','A');
     FROM  SYCMENU;
     WHERE SYCMENU.CAPP_ID+SYCMENU.CPAD_POS+SYCMENU.CPOP_POS+SYCMENU.CPOP_LEVL+;
           SYCMENU.CBAR_POS IN (lcModul,'SY');
       AND SYCMENU.CPROCTYPE IN ('R','G','E','M');
           INTO ARRAY  gaProcess
*E300710,1 Hesham (End)
*E300581,1 Hesham El-Sheltawi (End)           
*E300306,1 M.H End.
  ENDIF
 
  SELECT SYCMENU
  SET RELATION TO
  
ELSE
  SET EXACT &lcExact
  *** There is no menu bares define for this module, go to the menu
  *** program and define new bars for this module.
  *E302767,5 TMI 3/12/2011 , do not show this message if the lcModule is empty [start]
  IF !EMPTY(lcModul)
    *E302767,5 TMI 3/12/2011 , do not show this message if the lcModule is empty [end]
  
    =gfModalgen("INM00150B00000","DIALOG")
    llRetFlag = .F.
    
    *E302767,5 tmi [start]
  ENDIF
  *E302767,5 tmi [start]
ENDIF
*E301077,78 Hesham (Start)

**E302767,1-TMI [START] comment this part 
*IF llMenUse
*  USE IN SYCMENU
*ENDIF
**E302767,1- TMI [END] comment this part

**E302767,1- TMI [START] Close the SYCMENU and remove the lcTMPMENU table 
IF USED('SYCMENU')
  use in SYCMENU
ENDIF
ERASE (gcWorkDir+lcTMPMENU+'.dbf')
ERASE (gcWorkDir+lcTMPMENU+'.cdx')
**E302767,1- TMI [END] remove the lcTMPMENU table 

USE IN IIF(llObjctUse,'SYDOBJCT',0)
IF llUsPrv
  USE IN SYUUSRPR
ENDIF
*E301077,78 Hesham (End)
IF llApplUsed
  USE IN SYDAPPL
ENDIF
*E300897,1 Hesham (Start)
*E300897,1 Erase all the beging bars of the modules pad if it is a seprator
DO WHILE EMPTY(PRMBAR('P07PU07',GETBAR('P07PU07',1)))
  RELEASE BAR GETBAR('P07PU07',1) OF P07PU07
ENDDO 
*E300897,1 Erase all the ending bars of the modules pad if it is a seprator
DO WHILE EMPTY(PRMBAR('P07PU07',GETBAR('P07PU07',CNTBAR('P07PU07'))))
  RELEASE BAR GETBAR('P07PU07',CNTBAR('P07PU07')) OF P07PU07
ENDDO 
*E300897,1 Hesham (End)

RETURN llRetFlag


****************************************************************************************************
*
*  RETURN llRetFlag
*  Purpose    : This function is to create a temp copy of the SYCMENU file, remove from it the unneeded lines and 
*  				open it with alias SYCMENU again to build the menu from it
*  Developer : Tarek Mohammed Ibrahim
****************************************************************************************************
FUNCTION lfBldTmpMn
**E302767,1

*E302767,3 TMI 03/01/2011 [Start] decide whether the comany is A4 or not
PRIVATE lnSlct
lcAlias = ALIAS()
IF !USED('SYCCOMP')
  =gfSysOpen(gcSysHome+'SYCCOMP','CCOMP_ID')
ENDIF
SET ORDER TO CCOMP_ID IN SYCCOMP
=SEEK(gcAct_Comp,'SYCCOMP')
PRIVATE llA4Co
llA4Co = TYPE('SYCCOMP.LRUNFROMA4')='L' AND SYCCOMP.LRUNFROMA4
*E302767,4 TMI 03/09/2011 [Start] no need for this check
*-* IF !llA4Co
*E302767,4 TMI 03/09/2011 [End  ] 
IF USED('SYCMENU')
  USE IN SYCMENU
ENDIF
USE (gcSysHome+'SYCMENU') ORDER TAG 'APPPOPBAR' IN 0  &&CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS
*E302767,4 TMI 03/09/2011 [Start] comment this part
*-*   SELECT (IIF(!EMPTY(lcAlias),lcAlias,0))
*-*   RETURN
*-* ENDIF
*E302767,4 TMI 03/09/2011 [End  ] 
*E302767,3 TMI 03/01/2011 [End  ] 

STORE .F. TO llSYDREPRT
IF !USED('SYDREPRT')
  llSYDREPRT = gfOpenFile(gcSysHome+'SYDREPRT','CREP_ID','SH')
ENDIF

SELECT SYCMENU
COPY TO (gcWorkDir+lcTMPMENU) WITH CDX
USE IN SYCMENU
USE (gcWorkDir+lcTMPMENU) IN 0 ALIAS SYCMENU ORDER PROSS_ID   && CPROSS_ID

*- Loop along the SYDOBJCT to run from A4 and discard the related lines in SYCMENU 
*E302767,4 TMI 03/09/2011 [START] open the SYDOBJCT
IF !USED('SYDOBJCT')
  =gfOpenFile(gcSysHome+'SYDOBJCT','CAPP_ID','SH')
ENDIF
*E302767,4 TMI 03/09/2011 [END  ] 

SELECT Sydobjct
SCAN FOR LRUNFROMA4 
  *E302767,4 TMI 03/09/2011 [Start]   add a check to the new field LRUNA4ONLY
  IF llA4Co OR Sydobjct.LRUNA4ONLY
    *E302767,4 TMI 03/09/2011 [End  ] 
    IF SEEK(sydobjct.CAPOBJNAM,'SYCMENU')
      SELECT SYCMENU
      *E302767,4 
      *DELETE REST WHILE CPROSS_ID = sydobjct.CAPOBJNAM
      DELETE REST WHILE CPROSS_ID = sydobjct.CAPOBJNAM FOR SYCMENU.CPAD_POS $ '01|04'
      *E302767,4 
    ENDIF
    *E302767,4 TMI 03/09/2011 [Start] 
  ENDIF
  *E302767,4 TMI 03/09/2011 [End  ] 
ENDSCAN 

*- Loop along the SYDREPRT to run from A4 and discard the related lines in SYCMENU 
SELECT SYDREPRT
SCAN FOR LRUNFROMA4
  *E302767,4 TMI 03/09/2011 [Start] add a check to the new field LRUNA4ONLY
  IF llA4Co OR SYDREPRT.LRUNA4ONLY    
    *E302767,4 TMI 03/09/2011 [End  ] 
    IF SEEK(SYDREPRT.CREP_ID ,'SYCMENU')
      SELECT SYCMENU
      *E302767,4 
      *DELETE REST WHILE CPROSS_ID = SYDREPRT.CREP_ID
      DELETE REST WHILE CPROSS_ID = SYDREPRT.CREP_ID FOR SYCMENU.CPAD_POS = '05'
      *E302767,4 
    ENDIF
    *E302767,4 TMI 03/09/2011 [Start] 
  ENDIF
  *E302767,4 TMI 03/09/2011 [End  ] 
ENDSCAN 

*E302767,1 TMI 9/29/2010 [START] Comment this block, reason : I checked with Wael and he advised that no need to remove specific lines as we assume the correctness of SYDOBJCT 
*-                                                  of Aria27\sysfiles
*-                               but later on I found that some of the lines found in SYCMENU to be run from Aria4 has not
*-                               cite in SYDOBJCT of Aria27, they are in the variable lcPrg2Rmv  except the MFPTHWZ,ARVINV
**- special lines to remove
*lcPrg2Rmv = 'MFPJMON   |ARVINV    |MFPTHWZ   |MFCSTTM   |POCSTTM |'
lcPrg2Rmv = 'MFPJMON   |MFCSTTM   |POCSTTM   |'   && these are deviced for A4 specifically
*E302767,1 TMI 9/29/2010 [END]
SELECT SYCMENU
DO WHILE !EMPTY(lcPrg2Rmv)  
  lcPrg = PADR(SUBSTR(lcPrg2Rmv,1,AT('|',lcPrg2Rmv)-1),10)
  lcPrg2Rmv = SUBSTR(lcPrg2Rmv,AT('|',lcPrg2Rmv)+1)
  IF SEEK(lcPrg)
    DELETE REST WHILE CPROSS_ID = lcPrg
  ENDIF
ENDDO

*- Loop again on SYCMENU to check first lines in each module to be correctly labled

SELECT SYCMENU
SET ORDER TO APPPOPBAR   && CAPP_ID+CPAD_POS+CPOP_POS+CPOP_LEVL+CBAR_POS
LOCATE
LOCATE FOR EMPTY(CPOP_POS  +CBAR_POS  +CPOP_LEVL)
DO WHILE FOUND()
  IF !CAPP_ID $ 'SY|SM'
    SKIP  
    REPLACE CPOP_POS  WITH '01' ;
            CBAR_POS  WITH '01' ;
            CPOP_LEVL WITH '01'
  ENDIF
  CONTINUE
ENDDO
LOCATE

IF llSYDREPRT
  USE IN SYDREPRT
ENDIF

*!*************************************************************
*! Name      : gfCkOpnFls
*! Developer : Yasser El Oraby
*! Date      : June 1995 
*! Purpose   : To Check the number of open files and make sure they
*!             does not exceed one fourth the files handlers
*!*************************************************************
*! Called by : GFSETUP()
*!*************************************************************
*! Passed Parameters  : NONE
*!*************************************************************
*! Returns            : .T. if no of opend files exceed one fourth 
*!                          the files handlers
*!*************************************************************
*! Example   : =gfCkOpnFls()
*!*************************************************************
*
FUNCTION gfCkOpnFls

  PRIVATE ALL LIKE l*
  lnFiles    = 0                          && Number of opened DBFs
  lnMaxFiles = INT(VAL(SYS(2010))/3.5)      && Max. number of DBFs to be opened

  *B600422,1 For loop to count opened files
  FOR lnCount = 1 TO 225
    *B600422,1 If the work are contains an alias count it
    IF !EMPTY(ALIAS(lnCount))
      *B600422,1 Increase the files counter by one
      lnFiles = lnFiles + 1
      *B600422,1 Check if the no. of files exceed the limit
      IF lnFiles = lnMaxFiles
        RETURN .T.
      ENDIF
      *B600422,1 End Check if the no. of files exceed the limit
    ENDIF
    *B600422,1 End If the work are contains an alias count it
  ENDFOR
  *B600422,1 End For loop to count opened files
  RETURN .F. 
  
*!*************************************************************
*! Name      : lfClrStatc  
*! Developer : Yasser El Oraby
*! Date      : June 1995 
*! Purpose   : To Check the number of open files and make sure they
*!             does not exceed one fourth the files handlers
*!*************************************************************
*! Called by : ARIA3
*!*************************************************************
*! Passed Parameters  : NONE
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : =lfClrStatc()
*!*************************************************************
*
FUNCTION lfClrStatc  

PRIVATE ALL LIKE l*  
*E300256,1 Get the initial work area
lnWrkArea = SELECT()

*E300256,1 Open the SYUSTATC file exclusive
*E300256,1 If the file is no opened select empty work are elese select the file
IF !USED ("SYUSTATC")
  SELECT 0
ELSE
  SELECT SYUSTATC
ENDIF
USE (gcSysHome+"syustatc")  ORDER TAG CUSER_ID EXCLUSIVE

*E300256,1 Delete the temp. users records left from previous runs
IF SEEK ("INI"+"OLDVARS")
  SCAN WHILE !EMPTY(CUSER_ID)
    IF CUSER_ID + CSTATION <> GCUSER_ID + GCSTATION
      DELETE
    ENDIF
  ENDSCAN
ENDIF

*E300256,1 PACK the file
PACK

*E300256,1 Open the SYUSTSTC file in share mode
USE (gcSysHome+"syustatc")  ORDER TAG CUSER_ID
*E300256,1 Return to the initial work area
SELECT (lnWrkArea)



*!*************************************************************
*! Name      : lfvAddress
*! Developer : HESHAM EL-SHELTAWI
*! Date      : 07/19/95
*! Purpose   : valid function for the international addresses
*!*************************************************************
*! Called by : any screen using addresses
*!*************************************************************
*! Passed Parameters  : lcAdrInt     && international code 
*!                      lcAdrInt1    && variable to init. with contury name
*!                      lnYst        && row start of the popup
*!                      lnXst        && col start of the popup
*!                      lnYed        && row end of the popup
*!                      lnXed        && col end of the popup
*!                      lcAdrPop     && popup variable name "windows only"
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : lfvAddress('LADATA[16]','LADATA[8]',11.083,2.250,17.083,24.250,'puCountry')
*!*************************************************************
*
FUNCTION lfvAddress
PARAMETERS lcAdrInt,lcAdrInt1,lnYst,lnXst,lnYed,lnXed,lcAdrPop
PRIVATE lcHeadDesc ,lcOldVal
lcHeadDesc =LOOKUP(SYCINT.cCont_Desc,IIF(EMPTY(&lcAdrInt),'USA',&lcAdrInt),sycint.ccont_code,'CCONTCODE')
lcOldVal=EVAL(lcAdrInt)
DO CASE
  CASE _DOS
    &lcAdrInt = gfActPop(lnYst,lnXst,lnYed,lnXed, "SYCInt","ccont_Code","cCont_Desc",@lcHeadDesc)
  CASE _WINDOWS
     &lcAdrInt = gfActPop(lnYst,lnXst,lnYed,lnXed, "SYCInt","ccont_Code","cCont_Desc",@lcHeadDesc)  
     &lcAdrPop=LOOKUP(SYCINT.CPARt1LAB,IIF(EMPTY(&lcAdrInt),'USA',&lcAdrInt),sycint.ccont_code,'CCONTCODE')     
    SHOW GET (lcAdrPop)
ENDCASE

IF  lcOldVal<>EVAL(lcAdrInt)
  &lcAdrInt1 = LOOKUP(SYCINT.cCont_Desc,IIF(EMPTY(EVAL(lcAdrInt)),'USA',EVAL(lcAdrInt)),sycint.ccont_code,'CCONTCODE')
  SHOW GET (lcAdrInt1)
ENDIF
=lfRefresh(WONTOP())

*!**************************************************************************
*!
*!      Function:  lfGetAdr
*!
*!**************************************************************************
*  Gets address according to the address code, returns address
*
*E301278,1 MAB 06/23/99 lnLineNo may be a numeric or an array hold addresses (Passed by reference)
FUNCTION gfGetAdr
PARAMETERS lcAlias, lcTag, lcKeyCode, lcAdrCode,lnLineNo,lcAddGrp,lcCurrCode

*** lcAlias   : source file name 
*** lcTag     : source file tag that is to be used in seeking
*** lckeycode : search key code (of the source file) (optional)
*** lcAdrCode : address code (optional)
*** lnLineNo  : The Address line number to return

*B802961,1 BWA 08/02/2000 Fix the bug of Comma should be removed after 2 letter state code in the address for USA country.[START]
*B802961,1                Add the variable lnCounter and get it initial value.
*PRIVATE lnSavIntTg, lnSavCmpTg, lcCurAlias, lnOldTag,;
        llOpenInt, llOpenCmp, llContinue, lnCompRec,lcCurrCode
        
PRIVATE lnSavIntTg, lnSavCmpTg, lcCurAlias, lnOldTag,;
        llOpenInt, llOpenCmp, llContinue, lnCompRec,lcCurrCode,lnCounter

lnCounter = 0
*B802961,1 [END]

*MAN Start
 
 * You have to send the source file and 1 or more from the following parameters
 * 1 - The alias name for the source file or you have it the currently selected
 * 2 - Address code to be used in getting the address line  OR
 * 3 - Tag name and Seek Expression to get the  Address code
 * 4 - You can have the source file opened with the proper tag and just send
 *     the seek expr. (In case of not sending Tag ID there must be an active one)      
 
 IF EMPTY(lcAlias) .OR. TYPE('lcTag') <> 'C'
   IF EMPTY(ALIAS())
     RETURN .F.
   ELSE   
     lcAlias = ALIAS()
   ENDIF  
 ENDIF
 IF EMPTY(lcAddGrp) OR TYPE('lcAddGrp') <> 'C'
   lcAddGrp  = ''
   lcGrpCode = 'E'
 ELSE  
   lcAddGrp  = ALLTRIM(lcAddGrp)
   lcGrpCode = lcAddGrp
 ENDIF   
 lcCurAlias = ALIAS()
 SELECT (lcAlias)
 *ymo kanet commented
 lnOldTag = VAL(SYS(21))   

 *-- No Address code has been sent
 IF EMPTY(lcAdrCode) 
   IF !EMPTY(lcKeyCode) .AND. TYPE('lcKeyCode') <> 'C'
     DO CASE

       *-- A Search Expr has been sent and no Tag Has been Sent and no active tag
       CASE (EMPTY(lcTag) .OR. TYPE('lcTag') <> 'C') AND EMPTY(SYS(22))
         SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
         RETURN .F.

       *-- A Search Expr and a Tag ID have been sent 
       CASE !EMPTY(lcTag)
         *lnOldTag = VAL(SYS(21))   
         SET ORDER TO TAG (lcTag)
         *-- The Search expr is not found
         IF !SEEK(lcKeyCode)
           SET ORDER TO lnOldTag
           SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
           RETURN .F.
         ENDIF
 
       *-- A search expr has been sent without a Tag 
       OTHERWISE 
         *-- There is no active tag
         IF EMPTY(SYS(22)) 
           SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
           RETURN .F.
         ENDIF
         *-- The Search Expr. is not found
         IF !SEEK(lcKeyCode)
           SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
           RETURN .F.
         ENDIF
     ENDCASE 
   ENDIF  

   *-- Just to be able to set the old tag even if it has not been 
   *-- changed in the above DO CASE
   *lnOldTag = VAL(SYS(21))   

   lcAdrCode = cCont_Cod&lcGrpCode
 ENDIF

DECLARE laAddress[6,3]
laAddress = " "

*E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [begin]
*lnLineNo  = IIF(TYPE('lnLineNo')='N' AND BETWEEN(lnLineNo,1,5),INT(lnLineNo),1)
llRetArray = (TYPE("lnLineNo[1]") = "C")

IF llRetArray
  lnLineNo = ""

ELSE

  lnLineNo  = IIF(TYPE('lnLineNo')='N' AND BETWEEN(lnLineNo,1,5),INT(lnLineNo),1)
ENDIF
*E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [end  ]

STORE .F. TO llOpenInt, llOpenCmp
*** Check being on a correct alias
   
IF !USED('SYCINT')  && Check if the internationals file is open or not.
  llOpenInt  = .T.     && Indicates that the file is open by the function.
  ** Use the file and assign the index.
  USE &gcSysHome.SYCINT ORDER TAG cContCode IN 0 
ELSE
  SELECT SYCINT       
  lnSavIntTg = VAL(SYS(21))
  SET ORDER TO TAG cContCode   && Change the order
ENDIF  

IF !USED('SYCCOMP')  && Check if the internationals file is open or not.
  llOpenCmp  = .T.     && Indicates that the file is open by the function.
  ** Use the file and assign the index.
  USE &gcSysHome.SYCCOMP ORDER TAG cComp_ID IN 0 
ELSE
  SELECT SYCCOMP       
  lnSavCmpTg = VAL(SYS(21))
  lnCompRec  = RECNO()
  SET ORDER TO TAG cComp_ID   && Change the order
ENDIF  

IF SEEK(lcAdrCode,'SYCINT') .OR. (SEEK(gcAct_Comp,'SYCCOMP') ;
   .AND.  SEEK(SYCCOMP.cCont_Code,'SYCINT'))
  laAddress[1,1] = SYCINT.nPart1Ord
  laAddress[1,2] = EVAL(lcAlias+'.cAddress1'+lcAddGrp)
  laAddress[1,3] = SYCINT.nPart1LEN
  laAddress[2,1] = SYCINT.nPart2Ord
  laAddress[2,2] = EVAL(lcAlias+'.cAddress2'+lcAddGrp) 
  laAddress[2,3] = SYCINT.nPart2LEN
  laAddress[3,1] = SYCINT.nPart3Ord
  laAddress[3,2] = EVAL(lcAlias+'.cAddress3'+lcAddGrp)
  laAddress[3,3] = SYCINT.nPart3LEN      
  laAddress[4,1] = SYCINT.nPart4Ord
  laAddress[4,2] = EVAL(lcAlias+'.cAddress4'+lcAddGrp)
  laAddress[4,3] = SYCINT.nPart4LEN      
  laAddress[5,1] = SYCINT.nPart5Ord
  laAddress[5,2] = EVAL(lcAlias+'.cAddress5'+lcAddGrp)
  laAddress[5,3] = SYCINT.nPart5LEN      
  laAddress[6,1] = SYCINT.nPart6Ord
  laAddress[6,2] = EVAL(lcAlias+'.cAddress6'+lcAddGrp)
  laAddress[6,3] = SYCINT.nPart6LEN
  IF TYPE("lcCurrCode") = 'C'
    &lcCurrCode    = SYCINT.cCurrCode
    SHOW GET (lcCurrCode)
  ENDIF  
  =ASORT(laAddress,1)
  lcRetVal=''

  *E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [begin]
  *FOR lnCount = 1 TO ALEN(laAddress,1)
  *  IF laAddress[lnCount,1] = lnLineNo
  *    *lcRetVal=lcRetVal+IIF(EMPTY(lcRetVal),'',',')+PADR(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]),laAddress[lnCount,3])
  *    lcAddPart = ALLTRIM(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]))
  *    lcRetVal  = lcRetVal+IIF(EMPTY(lcRetVal) .OR. RIGHT(lcRetVal,1) = ',' ,'',', ') + lcAddPart
  *   ENDIF
  *ENDFOR
  *-- if it is array
  IF llRetArray
    PRIVATE lnArrLen
    lnArrLen = 0
    FOR lnArrLen = 1 TO ALEN(lnLineNo,1)

      FOR lnCount = 1 TO ALEN(laAddress,1)
        IF laAddress[lnCount,1] = lnArrLen
          lcAddPart = ALLTRIM(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]))
          lnLineNo[lnArrLen]  = lnLineNo[lnArrLen]+;
                                  IIF(EMPTY(lnLineNo[lnArrLen]) .OR. ;
                                  RIGHT(lnLineNo[lnArrLen],1) = ',' ,'',', ') + lcAddPart
         ENDIF
      ENDFOR
    
    ENDFOR

  ELSE  && else numeric value.

    FOR lnCount = 1 TO ALEN(laAddress,1)
      IF laAddress[lnCount,1] = lnLineNo
      
        *B802961,1 BWA 08/02/2000 Use the counter to check the 2nd time to remove the comma.[START]
        lnCounter = lnCounter + 1
        *B802961,1 [END]

        lcAddPart = ALLTRIM(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]))

        *B802961,1 BWA 08/02/2000 Remove the comma in the 2nd time after the state code for the address of USA country.[START]
        *lcRetVal  = lcRetVal+IIF(EMPTY(lcRetVal) .OR. RIGHT(lcRetVal,1) = ',' ,'',', ') + lcAddPart
        lcRetVal  = lcRetVal+IIF(EMPTY(lcRetVal) .OR. RIGHT(lcRetVal,1) = ',' ,'',;
                             IIF(ALLTRIM(gcContCode) = "USA" AND lnCounter > 2 ,'  ' ,', ')) + lcAddPart
        *B802961,1 [END]
       ENDIF
    ENDFOR
  ENDIF
  *E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [end  ]

ELSE

  *E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [begin]
  *lcRetVal= EVAL(lcAlias+'.cAddress'+STR(lnLineNo,1)+lcAddGrp)
  *-- if it is an array
  IF llRetArray
    PRIVATE lnArrLen
    lnArrLen = 0
    FOR lnArrLen = 1 TO ALEN(lnLineNo,1)
      lnLineNo[lnArrLen]= EVAL(lcAlias+'.cAddress'+STR(lnArrLen,1)+lcAddGrp)
    ENDFOR
  
  ELSE  && else it is numeric value.
    lcRetVal= EVAL(lcAlias+'.cAddress'+STR(lnLineNo,1)+lcAddGrp)
  ENDIF  
  *E301278,1 lnLineNo may be a numeric or an array hold addresses (Passed by reference) [end  ]

ENDIF  

IF USED('SYCCOMP')
  IF llOpenCmp 
    USE IN SYCCOMP
  ELSE
    SET ORDER TO lnSavCmpTg IN SYCCOMP  
    IF BETWEEN(lnCompRec,1,RECCOUNT("SYCCOMP"))
      GOTO lnCompRec IN SYCCOMP
    ENDIF  
  ENDIF
ENDIF
  
IF USED('SYCINT')
  IF llOpenInt
    USE IN SYCINT
  ELSE
    SET ORDER TO lnSavIntTg IN SYCINT
  ENDIF  
ENDIF
SET ORDER TO lnOldTag IN (lcAlias)
SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  

*ENDMAN

* MAN Remarked all the following lines
*DECLARE laAddress[6,3]
*laAddress = " "

*lcTag = IIF(TYPE('lcTag') = 'C' .AND. !EMPTY(lcTag),lcTag,;
            IIF(TYPE('lcAlias') = 'C' .AND. ALIAS() = lcAlias,;
            SYS(22),"")) 
*IF TYPE('lcAlias') = 'C' .AND. !EMPTY(lcAlias) .AND.;
  !EMPTY(lcTag)

*  llContinue = .T.
*  lcCurAlias = ALIAS()
  
*  SELECT (lcAlias)
*  lnOldTag = VAL(SYS(21))   
*  SET ORDER TO TAG (lcTag)
    
*  lcAdrCode = IIF(TYPE('lcAdrCode') = 'C'.AND. !EMPTY(lcAdrCode), lcAdrCode,;
                  &lcAlias..cCont_Code)
*  IF (TYPE('lcKeyCode') = 'C' .AND. !SEEK(lcKeyCode,lcAlias)) ;
     .OR. lcAdrCode <> &lcAlias..cCont_Code
*   llContinue = .F.  
*  ENDIF
  
*  IF llContinue
*    STORE .F. TO llOpenInt, llOpenCmp
    *** Check being on a correct alias
   
*    IF !USED('SYCINT')  && Check if the internationals file is open or not.
*      llOpenInt  = .T.     && Indicates that the file is open by the function.
      ** Use the file and assign the index.
*      USE &gcSysHome.SYCINT ORDER TAG cContCode IN 0 
*    ELSE
*      SELECT SYCINT       
*      lnSavIntTg = VAL(SYS(21))
*      SET ORDER TO TAG cContCode   && Change the order
*    ENDIF  

*    IF !USED('SYCCOMP')  && Check if the internationals file is open or not.
*      llOpenCmp  = .T.     && Indicates that the file is open by the function.
      ** Use the file and assign the index.
*      USE &gcSysHome.SYCCOMP ORDER TAG cComp_ID IN 0 
*    ELSE
*      SELECT SYCCOMP       
*      lnSavCmpTg = VAL(SYS(21))
*      SET ORDER TO TAG cComp_ID   && Change the order
*    ENDIF  

*    IF SEEK(&lcAlias..cCont_Code,'SYCINT');
      .OR. (SEEK(gcAct_Comp,'SYCCOMP') ;
           .AND. SEEK(SYCCOMP.cCont_Code,'SYCINT'))
*      laAddress[1,1] = SYCINT.nPart1Ord
*      laAddress[1,2] = &lcAlias..cAddress1
*      laAddress[1,3] = SYCINT.nPart1LEN
*      laAddress[2,1] = SYCINT.nPart2Ord
*      laAddress[2,2] = &lcAlias..cAddress2
*      laAddress[2,3] = SYCINT.nPart2LEN
*      laAddress[3,1] = SYCINT.nPart3Ord
*      laAddress[3,2] = &lcAlias..cAddress3
*      laAddress[3,3] = SYCINT.nPart3LEN      
*      laAddress[4,1] = SYCINT.nPart4Ord
*      laAddress[4,2] = &lcAlias..cAddress4      
*      laAddress[4,3] = SYCINT.nPart4LEN      
*      laAddress[5,1] = SYCINT.nPart5Ord
*      laAddress[5,2] = &lcAlias..cAddress5
*      laAddress[5,3] = SYCINT.nPart5LEN      
*      laAddress[6,1] = SYCINT.nPart6Ord
*      laAddress[6,2] = &lcAlias..cAddress6
*      laAddress[6,3] = SYCINT.nPart6LEN            
      
*      =ASORT(laAddress,1)
*      lcRetVal=''
*      FOR lnCount = 1 TO ALEN(laAddress,1)
*        IF laAddress[lnCount,1] = lnLineNo
          *lcRetVal=lcRetVal+IIF(EMPTY(lcRetVal),'',',')+PADR(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]),laAddress[lnCount,3])
*           lcRetVal=lcRetVal+IIF(EMPTY(lcRetVal),'',',')+ALLTRIM(SUBSTR(laAddress[lnCount,2],1,laAddress[lnCount,3]))
*        ENDIF
*      ENDFOR
*    ELSE
*       lcLineNo=STR(lnLineNo,1)
*       lcRetVal=&lcAlias..cAddress&lcLineNo
*    ENDIF  

*    IF USED('SYCCOMP')
*      IF llOpenCmp 
*        USE IN SYCCOMP
*      ELSE
*        SET ORDER TO lnSavCmpTg IN SYCCOMP  
*      ENDIF
*    ENDIF
  
*    IF USED('SYCINT')
*      IF llOpenInt
*        USE IN SYCINT
*      ELSE
*        SET ORDER TO lnSavIntTg IN SYCCOMP  
*      ENDIF  
*    ENDIF
*  ENDIF    
*  SET ORDER TO lnOldTag IN (lcAlias)
*  SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
*ENDIF  

*RETURN PADR(RTRIM(laAddress[1,2]) + RTRIM(laAddress[2,2]) +;
       RTRIM(laAddress[3,2]),40)

RETURN lcRetVal

*!*************************************************************
*! Name      : gfHlpTopic
*! Developer : Yasser El Oraby
*! Date      : 08/13/95
*! Purpose   : Set help topic
*!*************************************************************
*! Called by : GFSETUP, GPMENUBAR
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : lfvAddress('LADATA[16]','LADATA[8]',11.083,2.250,17.083,24.250,'puCountry')
*!*************************************************************
*
FUNCTION gfHlpTopic

PARAMETER lcPop_Name,lnBar_no
*E300279,1  SET Help Topic to the related one in the menu file.
*gcHelpTopc = UPPER(SUBSTR(gcBaseWind,4))
IF lnBar_No > 0  .AND. !EMPTY(lcPop_Name)
  lnPrgNum   = ASCAN(gaProcess,ALLTRIM(lcPop_Name)+"-"+PADL(lnBar_no,2,'0'))
  IF lnPrgNum > 0
    lnPrgNum    = ASUBSCRIPT(gaProcess,lnPrgNum,1)
    gcHelpTopc  = ALLTRIM(gaProcess[lnPrgNum,7])
  ELSE
    gcHelpTopc  = " "
  ENDIF
ELSE
  gcHelpTopc  = " "
ENDIF
 
 
 
 *--HESHAM
FUNCTION lfUpInsFile
PARAMETERS lcPlatForm
lnAlias = SELECT()
USE (gcSyshome+"SYCINST.DBF") IN 0
SELECT SYCINST
GOTO TOP
IF EOF()
  APPEND BLANK
ENDIF
REPLACE SYCINST.lInsUsDos WITH "D" $ lcPlatForm ,;
        SYCINST.lInsUsMac WITH "M" $ lcPlatForm ,;
        SYCINST.lInsUsUnx WITH "U" $ lcPlatForm ,;
        SYCINST.lInsUsWin WITH "W" $ lcPlatForm
USE IN SYCINST
SELECT(lnAlias) 

*!*************************************************************
*! Name      : gfGetMemVar
*! Developer : Hesham El-Sheltawi
*! Date      : 10/05/95
*! Purpose   : Return Variable(s) for company settings from SYCSETUP
*!*************************************************************
*! Parameters: lcArray   && variable to restore
*!                       && OR one dimension array to restore the variable(s)
*!                       name with the same variable name
*!                       && OR two dimension array to restore the variable(2)
*!                       in column 1 into variable names in column 2
*!             lcCompID  &&company id to get its settings
*!*************************************************************
*! Called by : 
*!*************************************************************
*! Returns            : VALUE OF VARIABLE OR no of variables restored
*!*************************************************************
*! Example   : lcVarName=gfGetMemVar('LLMULCURR ','01')
*!             WILL return from the sycsetup file the setting
*!             value for company 01 the variable called "LLMULCURR "
*!*************************************************************
*
FUNCTION gfGetMemVar
PARAMETERS lcArray,lcCompID
PRIVATE lnAliasNo,llCUsedBy,llArrayORvar,llTwoDimen,lcSetupTag,;
        lcConfgTag,lnRetCount,lcOnErr,llError,laVarArr,llUseSycC
*B601818,1  Get company path
*E301077,1 Add private variable llCompUsed 
*PRIVATE lcCompDir, lcSetPath, llReUsedBy, lnCurTag, lnCurRec
PRIVATE lcCompDir, lcSetPath, llReUsedBy, lnCurTag, lnCurRec, llCompUsed
*E301077,1 end
*B601818,1  end

lnAliasNo=SELECT()
llUsedBy  = .F.
llCUsedBy = .F.
llSUsedBy = .F.
llUseSycC = .F.
*E301077,1 Check if SYCCOMP is used
*E301077,78 Hesham (Start)
*llCompUsed = USED('SYCCOMP')
lcCompID  = IIF(TYPE('lcCompId')<>'C' OR EMPTY(lcCompID),gcAct_Comp,lcCompID)
*B601818,1  Get company path
llCompUse = gfOpenFile(gcSysHome+"SYCCOMP",'CCOMP_ID')
*IF !llCompUsed
*  USE (gcSysHome+'SYCCOMP') IN 0 ORDER TAG CCOMP_ID SHARED
*ENDIF
*E301077,78 Hesham (End)
*E301077,1  end
*E301098,1 Hesham (Start)
*lcCompDir  = IIF(SEEK(lcCompID, 'SYCCOMP'), ALLTRIM(SYCCOMP.cCom_DDir), gcDataDir)
lcCompDir  = IIF(SEEK(lcCompID, 'SYCCOMP'), gfGetDataDir(ALLTRIM(SYCCOMP.cCom_DDir)), gcDataDir)
*E301098,1 Hesham (End)
*E301077,1 Close it if we have opened it
*E301077,78 Hesham (Start)
=IIF(llCompUse,gfSysClose("SYCCOMP"),'')
*IF !llCompUsed
*  USE IN SYCCOMP
*ENDIF
*E301077,78 Hesham (End)
*E301077,1 end
llReUsedBy = .F.
*B601818,1  end
llArrayORvar = TYPE('lcArray[1]')='C'
llTwoDimen = IIF(llArrayORvar AND ALEN(lcArray,2)=2,IIF(TYPE('lcArray[1,2]')='L' OR TYPE(lcArray[1,1])='U','A','N'),'V' )
IF !llArrayORvar AND ',' $ lcArray
   DIMENSION laVarArr[1]
   =gfSubStr(lcArray,@laVarArr)
   DIMENSION lcArray[ALEN(laVarArr)]
   =ACOPY(laVarArr,lcArray)
   llArrayORvar = .T.
   llTwoDimen = 'V'
*ELSE
*  lcArray = UPPER(PADR(LCARRAY,10))   
ENDIF
IF !USED('SETUPS')
  SELECT 0
  *B601818,1 use SETUPS from the company directory
  *USE (gcDataDir+'SETUPS')
  USE (lcCompDir+'SETUPS') AGAIN
  *B601818,1 end
  llSUsedBy = .T.
ELSE
  SELECT SETUPS
  *B601818,1 Check if the file is opened from the company path
  lcSetPath = SET('FULLPATH')
  SET FULLPATH ON
  lcSetupsDir = DBF()
  SET FULLPATH &lcSetPath
  IF !(lcCompDir) $ lcSetupsDir
    lnCurTag  = VAL(SYS(21))
    lnCurRec  = RECNO()
    USE (lcCompDir+'SETUPS') AGAIN
    llReUsedBy = .T.
  ENDIF  
  *B601818,1 end  
ENDIF
lcSetupTag =TAG()
SET ORDER TO TAG VARNAME
lcRetVal=''
lnRetCount=0
lcOnErr=ON('ERROR')
ON ERROR llError = .T.
IF !llArrayORvar
  IF SEEK(PADR(UPPER(lcArray),10))
    DO CASE
      CASE cDefa_Typ='V'
        lcRetVal = lfTrnsStr(STRTRAN(mData_Def,CHR(13)+CHR(10),''),cData_Typ)
      CASE cDefa_Typ='E'
       lcRetVal=EVAL(STRTRAN(mData_Def,CHR(13)+CHR(10),''))
    ENDCASE
  ELSE
    llUseSycC = .T.
    IF !USED('SYCCONFG')
      SELECT 0
      USE (gcSysHome+'SYCCONFG')
      llCUsedBy = .T.
    ELSE
      SELECT SYCCONFG
    ENDIF
    lcConfgTag=TAG()
    SET ORDER TO TAG VARNAME

    IF SEEK(PADR(UPPER(lcArray),10))
      DO CASE
        CASE cDefa_Typ='V'
          lcRetVal=lfTrnsStr(STRTRAN(mData_Def,CHR(13)+CHR(10),''),cData_Typ)
        CASE cDefa_Typ='E'
         lcRetVal=EVAL(STRTRAN(mData_Def,CHR(13)+CHR(10),''))
      ENDCASE    
    ENDIF
  ENDIF
ELSE
  llUseSycC = .T.
  IF !USED('SYCCONFG')
    SELECT 0
    USE (gcSysHome+'SYCCONFG')
    llCUsedBy = .T.
  ELSE
    SELECT SYCCONFG
  ENDIF
  lcConfgTag=TAG()
  SET ORDER TO TAG VARNAME

  FOR lnCount = 1 TO ALEN(lcArray,1)
    llError = .F.
    lcRetVal=''
    SELECT SETUPS
    IF SEEK(PADR(UPPER(IIF(llTwoDimen = 'V',lcArray[lnCount],lcArray[lnCount,1])),10))
      DO CASE
        CASE cDefa_Typ='V'
          lcRetVal=lfTrnsStr(STRTRAN(mData_Def,CHR(13)+CHR(10),''),cData_Typ)
        CASE cDefa_Typ='E'
         lcRetVal=EVAL(STRTRAN(mData_Def,CHR(13)+CHR(10),''))
      ENDCASE
    ELSE
      SELECT SYCCONFG
      IF SEEK(PADR(UPPER(IIF(llTwoDimen = 'V',lcArray[lnCount],lcArray[lnCount,1])),10))
        DO CASE
          CASE cDefa_Typ='V'
            lcRetVal=lfTrnsStr(STRTRAN(mData_Def,CHR(13)+CHR(10),''),cData_Typ)
          CASE cDefa_Typ='E'
           lcRetVal=EVAL(STRTRAN(mData_Def,CHR(13)+CHR(10),''))
        ENDCASE    
      ENDIF
    ENDIF  
    DO CASE
      CASE llTwoDimen = 'N'
        &lcArray[lnCount,2] = lcRetVal
      CASE llTwoDimen = 'V'
        &lcArray[lnCount] = lcRetVal
      CASE llTwoDimen = 'A'
        lcArray[lnCount,2] = lcRetVal
    ENDCASE
    lnRetCount=lnRetCount+IIF(!llError,1,0)    
  ENDFOR
ENDIF
ON ERROR &lcOnErr
IF llUseSycC
  SELECT SYCCONFG
  IF !EMPTY(lcConfgTag)
    SET ORDER TO TAG (lcConfgTag)
  ELSE
    SET ORDER TO
  ENDIF
  IF llcUsedBy
    USE IN SYCCONFG
  ENDIF
ENDIF  

SELECT SETUPS
IF !EMPTY(lcSetupTag)
  SET ORDER TO TAG (lcSetupTag)
ELSE
  SET ORDER TO
ENDIF
IF llSUsedBy
  USE IN SETUPS
ENDIF

*B601818,1 ReUse SETUPS file
IF llReUsedBy .AND. !EMPTY(lcSetupsDir)
  *B609556,3  TMI 03/31/2011 [Start] 
  *SELECT SETUPS
  *USE (lcSetupsDir) ORDER lnCurTag
  SELECT (IIF(USED('SETUPS'),'SETUPS',0))  
  USE 
  USE (lcSetupsDir) ORDER lnCurTag AGAIN
  *B609556,3  TMI 03/31/2011 [End  ] 
  IF BETWEEN(lnCurRec, 1, RECCOUNT())
    GO lnCurRec
  ELSE
    GO TOP
  ENDIF  
ENDIF  
*B601818,1 end  

SELECT (lnAliasNo)
RETURN IIF(!llArrayORvar,lcRetVal,lnRetCount)

*!********************************************************************
*!
*!              Function: lfTrnsStr
*!
*!********************************************************************
*
FUNCTION lfTrnsStr
PARAMETERS lcValueStr,lcDataType,lcDirection
DO CASE
  CASE lcDataType $ 'CM'
     RETURN ALLT(lcValueStr)
  CASE lcDataType = 'N'
      RETURN VAL(lcValueStr)
  CASE lcDataType='D'
     RETURN CTOD(lcValueStr)
  CASE lcDataType = 'L'
     RETURN IIF(UPPER(ALLTRIM(lcValueStr))='.F.',.F.,.T.)
ENDCASE

*!*************************************************************
*! Name      : gfChkRate
*! Developer : Hesham El-Sheltawi
*! Date      : 10/09/95
*! Purpose   : Return Exchange Rate for Currency in spec. date
*!*************************************************************
*! Parameters: lcExUnit    && hold variable name to return Currency Units
*!             lcCurrency  && Currency to define or return exh. rate for
*!             ldDate      && Date to define or return exch. rate for
*!             llDispMsg   && Display message or not
*!             lcCompID    && company id to use its settings
*!             lcBaseCurr  && The currency that you want to use as default.
*E300309,1     llNoErrMsg  && .T. if the default error message is
*E300309,1                     not to be displayed, .F. otherwise.
*!*************************************************************
*! Call      : gfGetMemVar
*!*************************************************************
*! Returns            : VALUE OF exchage rate
*!*************************************************************
*! Example   : lcVarName=gfChkRate("lcEngUnit",'ENG',DATE(),.T.)
*!             WILL return from the sycexch file the exchange rate
*!             value for the currency "ENG" at the system date 
*!             and its units in variable called lcEngUnit
*!*************************************************************
*E300309,1 RENEE 11/15/95. Add a parameter to control the display
*E300309,1                 of the message that is displayed if a 
*E300309,1                 valid exchange rate is not found.
*E300309,1                 parameter : llNoErrMsg
*
*E300336,1 RENEE 01/08/96. Enhance performance as concerning to speed
*E300336,1                 of execution.
FUNCTION gfChkRate
*E300309,1 Add parameter llNoErrMsg  
*PARAMETERS lcExUnit,lcCurrency,ldDate,llDispMsg,lcCompID,lcBaseCurr
PARAMETERS lcExUnit,lcCurrency,ldDate,llDispMsg,lcCompID,lcBaseCurr, llNoErrMsg
*E300309,1 end.
PRIVATE llExUsedBy,lcOldAlias,lcOldTag,lnRetRate,ldCurrDay,lcOldFlt,;
        llCurUsedBy, lnExRate
lnRetRate   = 0
lcCompID    = IIF(TYPE('lcCompId') <> 'C',gcAct_Comp,lcCompID)
*B602463,4 Reduce currency width to 3 characters 
*lcBaseCurr  = PADR(IIF(TYPE('lcBaseCurr') <> 'C',gcBaseCurr,lcBaseCurr),5)
lcBaseCurr  = PADR(IIF(TYPE('lcBaseCurr') <> 'C',gcBaseCurr,lcBaseCurr),3)
*B602463,4 end
lcOldAlias  = SELECT()
llCurUsedBy = .F.

IF lcCurrency = lcBaseCurr
  IF TYPE('lcExUnit') = 'C'
    &lcExUnit = 1
    RETURN 1.0000    
  ENDIF
ENDIF

IF !USED('SYCCURR')
  llExUsedBy=.T.
  SELECT 0
  USE (gcSysHome+'SYCCURR') 
ELSE
  SELECT SYCCURR
ENDIF

llExUsedBy=.F.
IF !USED('SYCEXCH')
  llExUsedBy=.T.
  SELECT 0
  USE (gcSysHome+'SYCEXCH') 
ELSE
  SELECT SYCEXCH
ENDIF

lcOldFlt=FILTER()
lcOldTag=TAG()
*E300336,1 Set index descendingly
*SET ORDER TO TAG CURRENCY
SET ORDER TO TAG CURRENCY DESCENDING
*E300336,1 Get current NEAR setting
lcSetNear = SET('NEAR')
SET NEAR ON 
*E300336,1 end.
SET FILTER TO
*B602463,4 Reduce currency width to 3 characters 
*IF SEEK(lcBaseCurr+PADR(lcCurrency,5)+DTOS(ldDate))
IF SEEK(lcBaseCurr+PADR(lcCurrency,3)+DTOS(ldDate))
*B602463,4 end
  lnRetRate= nExRate
ELSE
  STORE .F. TO LLMULCURR,LLEXCHRATE
  STORE 0 TO LNEXRATDAY
  lnNoVar=gfGetMemVar('LLMULCURR,LLEXCHRATE,LNEXRATDAY',lcCompID)
  *E300336,1 Using set near with a descending index places the record
  *E300336,1 pointer on the next best match. Remarked the following,
  *ldCurrDay={}
  *llFound = .F.
  *lnCount = 1
  *DO WHILE !llFound AND lnCount<=lnExratDay
  *  LOCATE FOR CBASECURR+CCURRCODE+DTOS(DRATEDATE) = lcBaseCurr+PADR(lcCurrency,5)+DTOS(ldDate-lnCount)
  *  llFound = FOUND()
  *  lnCount = lnCount + 1
  *ENDDO  
  *IF llFound
  *    lnRetRate= nExRate    
  *E300336,1 Check the validity of the closest matching record
  *B602463,4 Reduce currency width to 3 characters 
  *IF cBaseCurr + cCurrCode = lcBaseCurr + PADR(lcCurrency,5) ;
  *  .AND. dRateDate >= ldDate - lnExRatDay
  IF cBaseCurr + cCurrCode = lcBaseCurr + PADR(lcCurrency,3) ;
    .AND. dRateDate >= ldDate - lnExRatDay    
  *B602463,4 end  
    lnRetRate = nExRate    
  *E300336,1 end. 
  ELSE
    IF llExchRate AND llDispMsg
      DO SYCHRATE.SPR
    ELSE
      *E300309,1 Display the default error message only if 
      *E300309,1 llDispMsg is .T. and llNoErrMsg is .F.
      *IF llDispMsg
      IF llDispMsg .AND. !llNoErrMsg
      *E300309,1 end.
        ** Message : "The last defined excahnge rate exceeds     "
        **           "the valid number of days."+CHR(13)+CHR(10)+"
        **           "The currency will be defaulted to the base "
        **           "currency.                                  "
        **           "                        Ok               "
 
        =gfModalGen("TRM00249B00000","DIALOG")
      ENDIF
    ENDIF
  ENDIF  
ENDIF

IF TYPE('lcExUnit') = 'C'
  &lcExUnit = LOOKUP(SYCCURR.NCURRUNIT,lcCurrency,SYCCURR.CCURRCODE,"CCURRCODE")
ENDIF

IF !EMPTY(lcOldTag)
  SET ORDER TO TAG (lcOldTag)
ENDIF
SET FILTER TO &lcOldFlt
IF llExUsedBy
  USE IN SYCEXCH
ENDIF
IF llCurUsedBy
  USE IN SYCCURR
ENDIF

*E300336,1 Restore near settings
SET NEAR &lcSetNear
*E300336,1 end.

SELECT (lcOldAlias)
RETURN lnRetRate 

*!********************************************************************
*! Name      : gfGetExSin
*! Developer : Mohamed Hassan
*! Date      : 11/27/95
*! Purpose   : Return Exchange Rate sign
*!********************************************************************
*! Parameters: lcCurrency  && Currency to define or return exh. rate for
*!             lcBaseCurr  && Variable to define base currency. 
*!             lcUntSin    && Pointer to unit sign character.
*!********************************************************************
*! Call      : 
*!********************************************************************
*! Returns   : * OR /
*!********************************************************************
*! Example   : lcExSign = gfGetExSin(@lcUntSin,'ENG')
*!             The user can pass the currency as a parametter 
*!             or the function is going to use the base currency.
*!             The function is going to return the exchnage rate
*!             sign.
*!********************************************************************
*
FUNCTION gfGetExSin
PARAMETERS lcUntSin, lcCurrency, lcBaseCurr
*B602658,5 Declare lcCAlias variable to hold current alias as private 
PRIVATE lnCAlias
*B602658,5 end

IF TYPE('lcUntSin') = 'C' 
  lcUntSin = '/'
ENDIF

IF TYPE('lcBaseCurr') $ 'UL'
  lcBaseCurr = gcBaseCurr
ENDIF

IF lcCurrency = lcBaseCurr
  RETURN '*'
ENDIF

*B602658,5 Store current alias
lnCAlias = SELECT(0)
*B602658,5 end

** This file should always be in use if the system is multi currency,
** Sometimes it is closed by Apparel programs, so, if it is
** not used,open the file.
*E301077,78 Hesham (Start)
llCurUse = gfSysOpen(gcSysHome+'SYCCURR','CCURRCODE')
*IF !USED('SYCCURR')
*  USE (gcSysHome+"SYCCURR") IN 0
*ENDIF  
*E301077,78 Hesham (End)
SET ORDER TO TAG CCURRCODE IN SYCCURR
=SEEK(lcBaseCurr,'SYCCURR')

*B601623,1 Change this line [Begin]
*RETURN IIF((SYCCURR.cCurMeth = 'M' .AND. !(lcCurrency $ SYCCURR.mCurExcept)) .OR. SYCCURR.cCurMeth = 'D' .AND.  (lcCurrency $ SYCCURR.mCurExcept),'*', '/')
*E301077,78 Hesham (Start)
llRetrunVal = IIF((SYCCURR.cCurMeth = 'M' .AND. !(ALLTRIM(lcCurrency) $ SYCCURR.mCurExcept)) .OR. SYCCURR.cCurMeth = 'D' .AND.  (ALLTRIM(lcCurrency) $ SYCCURR.mCurExcept),'*', '/')
IF llCurUse
  USE IN SYCCURR
ENDIF

*B602658,5 Restore current alias
SELECT (lnCAlias)
*B602658,5 end

RETURN llRetrunVal
*RETURN IIF((SYCCURR.cCurMeth = 'M' .AND. !(ALLTRIM(lcCurrency) $ SYCCURR.mCurExcept)) .OR. SYCCURR.cCurMeth = 'D' .AND.  (ALLTRIM(lcCurrency) $ SYCCURR.mCurExcept),'*', '/')
*E301077,78 Hesham (End)
*B601623,1 Change this line [End]

*B600875,1 function to create the upmodule txt file if needed 

*!*************************************************************
*! Name      : gfCrtModul 
*! Developer : Hesham El-Sheltawi
*! Date      : 12/10/95
*! Purpose   : create upmodule txt file if needed
*!*************************************************************
*! Called by : 
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : 
*!*************************************************************
*
FUNCTION gfCrtModul 
* UPDMODUL.DAT
*B609580,2 TMI 05/10/2011 [Start] update   lcSysFiles with  lcInitHome
*lcSysFiles = FULLPATH(SET('DEFAULT'))+'SYSFILES\'
lcSysFiles =  lcInitHome
*B609580,2 TMI 05/10/2011 [End  ] 


*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
lcAria27Dir = FULLPATH('')
GCMULTIINST  = .F.
IF FILE(lcAria27Dir+'Clients.DBF')
  GCMULTIINST  = .T.
  *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
  *gcSysHome  = 'X:\Aria27\SysFiles\'
  *E302876,1 TMI 03/20/2011 [End  ] 
ENDIF 
IF GCMULTIINST  
  *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
  *lcSysFiles =  'X:\Aria27\SysFiles\'
  *B609580,2 TMI 05/10/2011 [Start] this line is no more needed as it is updated anyway by the lcInitHome in the start of 
  *          the function where lcInitHome is passed to aas_win from the shortcut indicating the client folder contians 
  *          system files
  *lcSysFiles =  lcInitHome
  *B609580,2 TMI 05/10/2011 [End  ] 
  *E302876,1 TMI 03/20/2011 [End  ] 
ENDIF 
*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]

PRIVATE laFiles,llFound,lnCount,laModuls,lcDefa
=ADIR(laFiles,lcSysFiles+'*.DBF')
DIMENSION laModuls[1]
STORE '' TO laModuls
llFound = .F.
*E300441,4 HESHAM EL-SHELTAWI (START)
IF ASCAN(laFiles,'XXDAPPL')>0
  laModuls[ALEN(laModuls,1)] ='SY'
  llFound = .T.
ENDIF
*E300441,4 HESHAM EL-SHELTAWI (END)

*B801893,1 AMM check if SM exist, put it to be first of all after SY directly.
IF ASCAN(laFiles,'SMDAPPL')>0
  IF !EMPTY(laModuls[1])
    DIMENSION laModuls[ALEN(laModuls,1)+1]
  ENDIF
  laModuls[ALEN(laModuls,1)] ='SM'
  llFound = .T.
ENDIF
*B801893,1 AMM end

FOR lnCount = 1 TO ALEN(laFiles,1)
  IF SUBSTR(laFiles[lnCount,1],3,5)='DAPPL' AND LEFT(laFiles[lnCount,1],2)<>'SY'
    *E300441,4 HESHAM EL-SHELTAWI (START)
    *laModuls[ALEN(laModuls,1)] =IIF(LEFT(laFiles[lnCount,1],2)<>'XX',LEFT(laFiles[lnCount,1],2),'SY')
    *B801893,1 AMM If any module except SY and SM.
    *IF LEFT(laFiles[lnCount,1],2)<>'XX'
    IF LEFT(laFiles[lnCount,1],2)<>'XX' .AND. LEFT(laFiles[lnCount,1],2)<>'SM'
    *B801893,1 AMM end
      llFound = .T.
      IF !EMPTY(laModuls[1])
        DIMENSION laModuls[ALEN(laModuls,1)+1]
      ENDIF
      laModuls[ALEN(laModuls,1)] = LEFT(laFiles[lnCount,1],2)
    ENDIF  
    *E300441,4 HESHAM EL-SHELTAWI (End)
  ENDIF
ENDFOR

IF llFound
  SET TEXTMERGE TO (SET('DEFAULT')+'UPDMODUL.DAT') NOSHOW
  SET TEXTMERGE ON
  FOR lnCount = 1 TO ALEN(laModuls,1)
    \<<laModuls[lnCount]>> <<laModuls[lnCount]>>
  ENDFOR
  SET TEXTMERGE TO 
  SET TEXTMERGE OFF
  
  *E300613,1 YMA 06/22/97 Changed the winapps directory to be PRGS...
  *E300613,1 YMA 06/22/97 and added the screens and the images
  *E300613,1 YMA 06/22/97 directories
  *\<<lcDefa>>WINAPPS\
  
  *E301060,1 YMA 11/10/98 Added to save the full path of the new
  *E301060,1 YMA 11/10/98 added directories (CLASSES and EDI)
  
  *B609580,2 TMI 05/10/2011 [Start] create the file PATH.DAT on the client path with the same name
  *SET TEXTMERGE TO (SET('DEFAULT')+'PATH.DAT') NOSHOW
  SET TEXTMERGE TO (lcInitHome+'PATH.DAT') NOSHOW
  *B609580,2 TMI 05/10/2011 [End  ] 
  SET TEXTMERGE ON

  *B609580,2 TMI 05/10/2011 [Start] update the following fields of SYCINST in the gfSetPath to start with the client 
  *B609580,2                        folder path :
  *B609580,2                        cinsysfdr,CINSALLCMP, CINSDOSWD, CINSWINWD  & cinsrsrdr
  *B609580,2                        They are numbered 1,2,5,8 & 10 resp.
  PRIVATE lcClientRt
  lcClientRt = SUBSTR(lcInitHome,1,RAT('\',lcInitHome,2))
  *B609580,2 TMI 05/10/2011 [End  ]     
  
  *E303062,3 TMI 02/14/2012 [Start] replace the command FULLPATH(SET('DEFAULT')) with SYS(5)+CURDIR() [MEDIA 2012]
*  lcDefa = FULLPATH(SET('DEFAULT'))
  lcDefa = SYS(5)+CURDIR()
  *E303062,3 TMI 02/14/2012 [End  ] 
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\\<<lcDefa>>SYSFILES\
  *\<<lcDefa>>DBFS\
  \\<<lcClientRt>>SYSFILES\
  \<<lcClientRt>>DBFS\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>DOSAPPS\    
  \<<lcDefa>>REPORTS\
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\<<lcDefa>>WORK\
  \<<lcClientRt>>WORK\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>PRGS\
  \<<lcDefa>>REPORTS\
  *B609580,2 TMI 05/10/2011 [Start] replace lcDefa with lcClientRt
  *\<<lcDefa>>WORK\
  \<<lcClientRt>>WORK\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>BMPS\
  *B609580,2 TMI 05/10/2011 [Start]  replace lcDefa with lcClientRt
  *\<<lcDefa>>RESOURCE\
  \<<lcClientRt>>RESOURCE\
  *B609580,2 TMI 05/10/2011 [End  ] 
  \<<lcDefa>>IMAGES\
  \<<lcDefa>>SCREENS\
  \<<lcDefa>>CLASSES\
  \<<lcDefa>>EDI\
  *E301603,5 Hesham (Start)
  *E301603,5 Check For Unupdated Service Packs
  \<<lcDefa>>SPACK\
  *E301603,5 Hesham (End)
  SET TEXTMERGE TO 
  SET TEXTMERGE OFF  
  *E301060,1 YMA 11/10/98 End.
  *E300613,1 YMA 06/22/97 End.
  
  *B609601,5 TMI 06/16/2011 [Start] check if the file is there
  IF FILE(lcInitHome+'SYUEROR.DBF')
    *B609601,5 TMI 06/16/2011 [End  ] 
  
    *B609601,4 TMI 06/09/2011 [Start] Delete the recored in SYUEROR 6 months before the first run[media]  
    USE (lcInitHome+'SYUEROR') IN 0 EXCLUSIVE
    SELECT SYUEROR
    DELETE FOR DDATE<GOMONTH(DATE(),-6)
    PACK
    USE IN SYUEROR
    *B609601,4 TMI 06/09/2011 [End  ] 

    *B609601,5 TMI 06/16/2011 [Start] close the above IF
  ENDIF
  *B609601,5 TMI 06/16/2011 [End  ] 
  
ENDIF
*B600875,1 END

*B600975,1 Hesham El-Sheltawi (START)
*B600975,1 adding function to check for any installed modules for the
*B600975,1 apparel system or not 
*!*************************************************************
*! Name      : lfBldModStr
*! Developer : Yasser Mohammed Aly (YMA).
*! Date      : 10/15/95
*! Purpose   : E500034,1
*!             Check the catalogs generated by the installation
*!             program to see if this is a new installation
*!             or there is any new installed module, so the
*!             prepare program should be run.
*!*************************************************************
*! Returns   : String tells the new installed modules.
*!*************************************************************
*! Example   : lcNewMod = lfBldModStr()
*!*************************************************************

FUNCTION lfBldModStr
PRIVATE lcInsMod

lcInsMod = ''
FOR lnI  = 1 TO 9
  *B600975,9 Hesham El-Sheltawi (Start)
  *B600975,9 adding the characters "PENC" TO the next line
  *B600975,9 so the system can check for the Edi & Prod. Man. moules
  lcCahrID = SUBSTR("BAMSRPENC",lnI,1)
  *B600975,9 Hesham El-Sheltawi (End)
  IF FILE(lcAriaPath+"LIB\"+lcCahrID+"Catalog.DBF")
    lcInsMod = lcInsMod + IIF(EMPTY(lcInsMod),"",",") + "Z" + lcCahrID
  ENDIF  
ENDFOR
RETURN lcInsMod

*! 
*B600975,1 (END)

*B600998,1 Hesham El-Sheltawi (START)
*!*************************************************************
*! Name      : lfAddAprBar
*! Developer : Hesham El-Sheltawi
*! Date      : 03/11/96
*! Purpose   : *B600998,1
*!              If installing Apparel Modules With out
*!              ADV. Modules Add menu bar for the Apparel System
*!*************************************************************
*! Returns   : None
*!*************************************************************
*! Example   :  = lfAddAprBar()
*!*************************************************************
FUNCTION lfAddAprBar
PARAMETERS lcAppPath
*B601440,1 MAN 11/27/96 Save Work Area
 PRIVATE lnOldArea
 lnOldArea = SELECT(0)
   
lcCompSet = SET('COMP')
lcDeleSet = SET('DELE')
SET COMP ON
SET DELE ON
IF FILE(gcSysHome+'SYCMENU.DBF')
   *B601440,1 MAN 11/27/96 Select Availabel Work Area Before Open the file Start
   *USE (gcSysHome+'SYCMENU') ORDER TAG APPPOPBAR DESC IN 0
   SELECT 0
   USE (gcSysHome+'SYCMENU') ORDER TAG APPPOPBAR DESC
   *B601440,1 MAN End
               
  LOCATE FOR CPROCTYPE = 'E' AND '\ARIA.' $ UPPER(CPROCPATH)
  IF !FOUND()
    IF SEEK('SY07')
      SCATTER MEMVAR
      APPEND BLANK
      GATHER MEMVAR
      REPLACE CPOP_POS WITH PADL(ALLT(STR(VAL(CPOP_POS)+1)),2,'0');
              CBAR_POS WITH PADL(ALLT(STR(VAL(CBAR_POS)+1)),2,'0');
              CPOP_LEVL WITH '01';
              CSUB_CTG  WITH 'I';
              CSUB_TYP  WITH 'B';
              CSUB_PRPT WITH '\<Aria Apparel System';
              cmstr_nam WITH 'P07PU07';
              cpross_id WITH 'ARIA';
              cproctype WITH 'E';
              cSub_pos  WITH '05';
              cSub_hkey WITH '';
              cSub_msg  WITH 'Aria Apparel System';
              cProcPath WITH lcAppPath+'ARIA.FXP';
              cupgrdlvl WITH 'A';
              cHlpTopic WITH ''
    ENDIF        
  ELSE
    REPLACE cProcPath WITH lcAppPath+'ARIA.FXP'  
  ENDIF
  USE IN SYCMENU
ENDIF
SET DELE &lcDeleSet
SET COMP &lcCompSet
*B601440,1 MAN 11/27/96 Return the old Area
SELECT (lnOldArea)

RETURN
*B600998,1 (END)

*E300374,1 Hesham El-Sheltawi (START)
*E300374,1 function to recreate the static file if corrupted and rebuild
*E300374,1 it if needed otherwise make the variable called llNoErr .f.
FUNCTION lfStaticErr
PARAMETERS lnErrorNo
PRIVATE lcOnErr,llOpnObjct,lcSetSave
llOpnObjct=.F.
llErrOc=llNoErr
lcOnErr = ON('ERROR')
ON ERROR llNoErr = .F.
IF INLIST(lnErrorNo,41,15,1,26,114,1707,1683)
    DECLARE laFileStrc[1,1],laFileAStr[1,1]
    *** Dictionary file strc.
    *E301077,78 Hesham (Start)
    llflfld = gfSysOpen(gcSysHome+'sydflfld')
    llfield = gfSysOpen(gcSysHome+'sydfield')
    *E301077,78 Hesham (End)
    SELECT sydflfld.cfld_name,sydfield.cdata_typ,;
           sydfield.nfld_wdth,sydfield.nfld_dec,sydflfld.nfld_pos;
           FROM  (gcSyshome+"sydflfld"),(gcSyshome+"sydfield");
           ORDER BY sydflfld.nfld_pos;
           GROUP BY sydField.cFld_Name;
           WHERE UPPER(sydflfld.cfile_nam) =UPPER("SYUSTATC");
           AND sydfield.cfld_name = sydflfld.cfld_name;
           INTO ARRAY laFileStrc

    *E301077,78 Hesham (Start)
    USE IN IIF(llflfld ,'sydflfld',0)
    USE IN IIF (llfield,'sydfield',0)
    *E301077,78 Hesham (End)

    =gfAdel(@laFileStrc,5,2)       && An additional colum holding the position 
                                   && of each field has to be removed from the
                                   && Array befor verification or building.

 IF !EMPTY(laFileStrc[1])
   lcSetSave = SET('SAFETY')
   SET SAFETY OFF
   IF !USED("SYUSTATC")
     CREATE DBF  (gcSysHome+"SYUSTATC") FROM ARRAY laFileStrc
     *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
     =lfCrFox2x()
     *E303074,1 TMI 02/20/2012 [End  ] 
   ENDIF
    DECLARE laFileCDX[1,1]
    lcSavAlias = SELECT(0)
    *E301077,78 Hesham (Start)
    llIndex = gfSysOpen(gcSysHome+'sydindex')
    *E301077,78 Hesham (End)

    SELECT ALLTRIM(sydindex.cindx_exp),ALLTRIM(sydindex.cfile_tag),sydindex.lascend,;
           sydindex.lunique;
           FROM (gcSyshome+"sydindex");
           WHERE UPPER(sydindex.cfile_nam) = "SYUSTATC";
           INTO ARRAY laFileCDX

    *E301077,78 Hesham (Start)
    USE IN IIF(llIndex,'sydindex',0)
    *E301077,78 Hesham (End)

    IF !USED("SYUSTATC")
      SELECT 0
    ELSE
      SELECT ("SYUSTATC")
    ENDIF  
    IF FILE(ALLTRIM(gcSysHome)+ALLTRIM("SYUSTATC")+'.DBF')
      USE (ALLTRIM(gcSysHome)+ALLTRIM("SYUSTATC")) EXCL

      IF !EMPTY(laFileCDX[1])
          FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
            lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
            lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')
            *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
            *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2]; 
            *      ADDITIVE &lcAscend &lcUnique
        ON ERROR llErr=.T.
        lcNdx = laFileCDX[lnTagNo,1]
        lcTag = laFileCDX[lnTagNo,2]
        INDEX ON &lcNdx TAG &lcTag ; 
                  ADDITIVE &lcAscend &lcUnique
        ON ERROR
            *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
          ENDFOR            
      ENDIF
      USE
    ENDIF  
    SET SAFETY &lcSetSave
  ENDIF
  IF llNoErr
    USE (gcSysHome+"syustatc")  EXCLUSIVE ORDER TAG CUSER_ID
    IF INLIST(lnErrorNo,41,15,1) AND llNoErr     
      IF llNoErr AND gfModalgen("QRM00253B00006","ALERT")=1
        IF !USED('sydObjct')
          llOpnObjct = .T.
          SELECT 0
          USE (gcSysHome+"sydObjct") 
        ENDIF  
        =gfBldStatc()
        IF llOpnObjct AND USED('sydObjct')
          USE IN sydObjct
        ENDIF
      ENDIF   
    ENDIF
    SELECT syustatc 
    SET ORDER TO TAG CUSER_ID    
  ENDIF
ELSE
  llNoErr = .F.
ENDIF
ON ERROR &lcOnError
RETURN
*E300374,1 Hesham El-Sheltawi (END)



*E300374,1 Hesham El-Sheltawi (Start)
FUNCTION gfSysProc

*** Open installation 
SET EXCL OFF
*E301077,78 Hesham (Start)
llInstUse=gfSysOpen(gcSysHome+'SYCINST')
*E302121,1 Hesham (Start)
*E302121,1 check if the system is locked and the sycinst
*E302121,1 record is locked by another user then prevent
*E302121,1 the user from loging into the system
IF sycinst.lLockSys AND !RLOCK("SYCINST")
  llError = .T.
  lcErrMessage = 'System is locked by the administrator. Please try later'
  RETURN 
ENDIF
UNLOCK IN SYCINST
*E302121,1 Hesham (End)

*IF !USED('SYCINST')
*  SELECT 0
*  *** Open the
*  USE (gcSysHome+"sycinst")
*ELSE
*  SELECT SYCINST
*ENDIF  
*E301077,78 Hesham (End)


*** Load intial data from install data file
glLog_Requ  = sycinst.lInsLogRq                && Login required flag
*MAN
glSys_Log   = glLog_Requ
gcDef_Comp  = sycinst.cInsDfCom                && Default company   
*E300842,1 Hesham (Start)
*E300842,1 initialize variable to hold the current site id
*E300842,1 to be used in the controling of the data modifications

*E301508,1 WAM Get current Site ID
*gcCurSite = IIF(TYPE('SYCINST.CCURSITEID')#'C',SPACE(6),SYCINST.CCURSITEID)			   && Current site ID
*E301508,1 (End)

*E300842,1 Hesham (Start)
gcAct_Comp  = gcDef_Comp
gcAllCmp    = ALLTRIM(sycinst.cInsAllCmp)
gcRsrcHome  = ALLTRIM(sycinst.cInsRsrDr)
gcColorSet  = IIF(ISCOLOR(),sycinst.cInsDfclc,sycinst.cInsDfclm)
*B601081,1 Hesham (Start)
gcOrgPath   = ALLTRIM(sycinst.cInsysFDr)
*B601081,1 Hesham (End)

glMapPath = !(UPPER(ALLTRIM(sycinst.cInsysFDr)) = UPPER(gcSysHome))
gcIntCont = IIF(EMPTY(SYCINST.CCONT_CODE),'USA   ',SYCINST.CCONT_CODE)

*#IF _DOS
*        *** Activate the dos on line help and set help filter and topic
*        IF FILE (gcSysHome+"SYHHELP.DBF")
*          *E300279,1  Activate the comman help file  
**          SET HELP TO (gcSysHome+"GL")
*          SET HELP TO (gcSysHome+"SYHHELP")
**          SET HELPFILTER TO cApp_ID = gcAct_Appl .OR. cApp_ID ="SY"
**          SET TOPIC TO ALLTRIM(cApObjNam)=gcHelpTopc
*          SET TOPIC TO gcHelpTopc
*        ENDIF
*        gcWorkDir = ALLTRIM(sycinst.cInsDosWD)
*        gcAppHome = ALLTRIM(sycinst.cInsDosPD)
*        gcRepHome = ALLTRIM(sycinst.cInsDosRD)
*
*        *E300581,1 Hesham El-Sheltawi (Start)
*        gcImagDir = ALLTRIM(sycinst.cImagDir)
*        gcLibDir  = ALLTRIM(sycinst.cLibDir)
*        gcScrDir  =  ALLTRIM(sycinst.cScrDir)
*        *E300581,1 Hesham El-Sheltawi (End)
*
*
*       *** Update all the directory variables in case of maped drive name
*       
*       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
*       IF !GCMULTIINST
*       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]
*       IF glMapPath
*         gcDef_path = SUBSTR(gcSysHome,1,RAT("\",gcSysHome,2))
*         gcWorkDir =  gcDef_path + SUBSTR(gcWorkDir,RAT("\",gcWorkDir,2)+1)
*         gcAppHome =  gcDef_path + SUBSTR(gcAppHome,RAT("\",gcAppHome,2)+1)
*         gcRepHome =  gcDef_path + SUBSTR(gcRepHome,RAT("\",gcRepHome,2)+1)
*         gcAllCmp  =  gcDef_path + SUBSTR(gcAllCmp ,RAT("\",gcAllCmp,2)+1)
*        *E300581,1 Hesham El-Sheltawi (Start)
*        gcImagDir = gcDef_path + SUBSTR(gcImagDir,RAT("\",gcImagDir,2)+1)
*        gcLibDir  = gcDef_path + SUBSTR(gcLibDir,RAT("\",gcLibDir,2)+1)
*        gcScrDir  =  gcDef_path + SUBSTR(gcScrDir,RAT("\",gcScrDir,2)+1)
*        *E300581,1 Hesham El-Sheltawi (End)
*        *B802105,1 Hesham (Start)
*        gcRsrcHome =  gcDef_path + SUBSTR(GCRSRCHOME,RAT("\",GCRSRCHOME,2)+1)
*        *B802105,1 Hesham (End) 
*       ENDIF 
*       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
*	  ENDIF 
*       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]
*		
*       CREATE COLOR SET DEFAULT
*       SET RESOURCE OFF
*       lcResource = gfTempName()
*       SELECT * FROM  (gcSysHome+"SYCRESRC") INTO DBF (gcWorkDir+lcResource)
*       IF USED (lcResource)
*         USE IN ALIAS(lcResource)
*       ENDIF
*       
*       SET RESOURCE TO (gcWorkDir+lcResource)
*       SET COLOR SET TO &gcColorSet
*       *SET RESOURCE OFF
*
*       @ 0,0,SROWS(),79 BOX REPLICATE("",9)
*       gcPlatform = "DOS"
*#ELSE
       *E300279,1  Activate the comman help file  
       IF FILE (gcSysHome+"SYHHELP.HLP")
         SET HELP TO (gcSysHome+"SYHHELP.HLP")
         SET TOPIC TO gcHelpTopc
       ENDIF

       gcWorkDir = ALLTRIM(sycinst.cInsWinWD)
       gcAppHome = ALLTRIM(sycinst.cInsWinPD)
       gcRepHome = ALLTRIM(sycinst.cInswinRD)
       gcBmpHome = ALLTRIM(sycinst.cInswinBM)

      *E300581,1 Hesham El-Sheltawi (Start)
      gcImagDir = ALLTRIM(sycinst.cImagDir)
      gcLibDir  = ALLTRIM(sycinst.cLibDir)
      gcScrDir  =  ALLTRIM(sycinst.cScrDir)
      *E300581,1 Hesham El-Sheltawi (End)

       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
       IF !GCMULTIINST
       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]
       IF glMapPath
         gcDef_path = SUBSTR(gcSysHome,1,RAT("\",gcSysHome,2))
         gcWorkDir =  gcDef_path + SUBSTR(gcWorkDir,RAT("\",gcWorkDir,2)+1)
         gcAppHome =  gcDef_path + SUBSTR(gcAppHome,RAT("\",gcAppHome,2)+1)
         gcRepHome =  gcDef_path + SUBSTR(gcRepHome,RAT("\",gcRepHome,2)+1)
         gcBmpHome =  gcDef_path + SUBSTR(gcBmpHome,RAT("\",gcBmpHome,2)+1)
         gcAllCmp  =  gcDef_path + SUBSTR(gcAllCmp ,RAT("\",gcAllCmp,2)+1)
        *E300581,1 Hesham El-Sheltawi (Start)
        gcImagDir = gcDef_path + SUBSTR(gcImagDir,RAT("\",gcImagDir,2)+1)
        gcLibDir  = gcDef_path + SUBSTR(gcLibDir,RAT("\",gcLibDir,2)+1)
        gcScrDir  =  gcDef_path + SUBSTR(gcScrDir,RAT("\",gcScrDir,2)+1)
        *E300581,1 Hesham El-Sheltawi (End)
        *B802105,1 Hesham (Start)
        gcRsrcHome =  gcDef_path + SUBSTR(GCRSRCHOME,RAT("\",GCRSRCHOME,2)+1)
        *B802105,1 Hesham (End) 
       ENDIF 
       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
       EndIF
       *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]

       IF !EMPTY(sycinst.cDef_BMP) and file(gcBmpHome+ALLTRIM(sycinst.cDef_BMP))
         DEFINE WINDOW fndation   ;
                FONT "FoxFont", 9 ;
                AT 0,0 SIZE SROWS(),SCOLS();
                NONE &&FILL FILE (gcBmpHome+ALLTRIM(sycinst.cDef_BMP)) 
        *E300791,1 Hesham (Start)                       
          ACTIVATE WINDOW FNDATION
          @0,0 say (gcBmpHome+ALLTRIM(sycinst.cDef_BMP)) bitmap size SROW(),SCOL() CENTER STYLE "Q"
        *E300791,1 Hesham (End)                 
       ELSE
         DEFINE WINDOW fndation   ;
                FONT "FoxFont", 9 ;
                AT 0,0 SIZE SROWS(),SCOLS();
                 NONE 
  
       ENDIF         


       ACTIVATE WINDOW fndation
       gcPlatform = "WINDOWS"
       
       *B500754,1 Set a temp. resource file for each user's session under windows
       SET RESOURCE OFF
       lcResource = gfTempName()

       *E300613,1 YMA 06/25/97 Create the resource file using CREATE TABLE 
       *E300613,1 YMA 06/25/97 instead of the SQL, because the length of 
       *E300613,1 YMA 06/25/97 the "Type" field has been changed in the 
       *E300613,1 YMA 06/25/97 dictionary, so we cannot use the "SYCRESRC"
       *E300613,1 YMA 06/25/97 file anymore.
       CREATE TABLE (gcWorkDir+lcResource) (Type C(12), ID C(12), Name C(24), ReadOnly L, CkVal N(6), Data M, Updated D)
       *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
       =lfCrFox2x()
       *E303074,1 TMI 02/20/2012 [End  ] 
       *SELECT * FROM  (gcSysHome+"SYCRESRC") INTO DBF (gcWorkDir+lcResource)
       *E300613,1 YMA 06/25/97 End.

       IF USED (lcResource)
         USE IN ALIAS(lcResource)
       ENDIF
       SET RESOURCE TO (gcWorkDir+lcResource)
       *B500754,1 End Modifications
       
*#ENDIF

*E301077,78 Hesham (Start)
USE IN IIF(llInstUse,'SYCINST',0)
*E301077,78 Hesham (End)

*B600422,1 Close the moduler resource file as we are not going to use it in this session any more
IF USED ("SYCRESRC")
  USE IN SYCRESRC
ENDIF  
*E300254,1 make the genpd application "printer drivers application"
*E300254,1 work in any platform "DOS,WINDOWS"
*#IF _DOS
*  _genpd = gcAppHome+"Genpd1.app"
  _genpd = SUBSTR(SYS(16,1),1,RAT('\',SYS(16,1)))+"Genpd1.app"
*#ENDIF  

*** If in the developing mode redirect apphome and rephome to local settings
gcAppHome   = IIF(EMPTY(GETENV('APPHOME')),gcAppHome,GETENV('APPHOME'))
gcRepHome   = IIF(EMPTY(GETENV('REPHOME')),gcRepHome,GETENV('REPHOME'))


SELECT 0
*E301077,78 Hesham (Start)
*USE (gcSysHome+"syclogo")
=gfSysOpen(gcSysHome+"syclogo")
gcSysName = cSysName  
USE IN SYCLOGO
*E301077,78 Hesham (End)


IF _WINDOWS
  MODIFY WINDOW SCREEN FONT"FOXFONT",9 STYLE 'N';
                TITLE ALLTRIM(gcSysName);
                FLOAT;
                ZOOM;
                GROW 
ELSE
  USE
ENDIF  

*E301874,1 Abd - Modify the activation key file to be as EXE not a Bin File
*E301874,1 Abd - And get our needed dat from this exe After Build A0039. [Begin]
IF llOldVersn
  *E301874,1 Abd -[End]


  IF FILE(gcSysHome+"ACT_KEY.BIN")
    lcHandel    = FOPEN(gcSysHome+"ACT_KEY.BIN")
    lcContent   = FGET(lcHandel)
                = FCLOSE(lcHandel)
    gcCompName  = gfSubstr(lcContent,1,"|")
    gcAct_Key   = gfSubstr(lcContent,2,"|")
    gcLicence   = gfSubstr(lcContent,3,"|")
    IF !lfvAct_K(gcAct_Key,@gcPrmtMdls,@gnMaxUsers,@gcPlatForm)
      lcCompName = gcCompName
      lcAct_Key  = gcAct_Key
      lclicence  = gcLicence
      llAllDone  = .F. 
      DO SYACTKEY.SPR
      IF llAllDone
        gcCompName = ALLTRIM(lcCompName)
        gcAct_Key  = ALLTRIM(lcAct_Key)
        gclicence  = ALLTRIM(lcLicence)

        lcHandel   = FCREAT(gcSysHome+"ACT_KEY.BIN")
                 = FPUT(lcHandel,gcCompName+"|"+gcAct_Key+"|"+gclicence)
                 = FCLOSE(lcHandel)
      ENDIF             
    ENDIF
  ELSE
    lcCompName = gcCompName
    lcAct_Key  = gcAct_Key
    lclicence  = gcLicence
    llAllDone  = .F. 
    DO SYACTKEY.SPR
    IF llAllDone
      gcCompName = ALLTRIM(lcCompName)
      gcAct_Key  = ALLTRIM(lcAct_Key)
      gclicence  = ALLTRIM(lcLicence)

      lcHandel   = FCREAT(gcSysHome+"ACT_KEY.BIN")
                 = FPUT(lcHandel,gcCompName+"|"+gcAct_Key+"|"+gclicence)
                 = FCLOSE(lcHandel)
    ENDIF             
  ENDIF
  *E301874,1 Abd - Else For If Statment. [Begin]
ELSE
  STORE '' TO lcFilePath,lcNewFile,lcFilePath,lcFileName 
  IF FILE(gcSysHome+"ACT_KEY.BIN")
    IF lfvKeyValu () .AND. !lfvAct_K(gcAct_Key,@gcPrmtMdls,@gnMaxUsers,@gcPlatForm)
      lcNewFile = ''
      llProcess = .F.
      *-- Call the Screen.
      DO SyGetact.SPR
      *-- If this flage is fase don't complete the Process.
      IF !llProcess .OR. EMPTY(lcNewFile)
        llError = .T.
        lcErrMessage = 'Invalid Activation Key ! System will be terminated.'        
        RETURN
      ENDIF
      lnPathPos  = RAT('\',lcNewFile)
      lcFilePath = Left(lcNewFile,lnPathPos)
      lcFileName = Substr(lcNewFile,lnPathPos+1,Len(lcNewFile))
      IF lfvKeyValu () .AND. llError
        RETURN
      ENDIF
    ENDIF
  ELSE
    lcNewFile = ''
    llProcess = .F.
    *-- Call the Screen.
    DO SyGetact.SPR
    *-- If this flage is fase don't complete the Process.
    IF !llProcess .OR. EMPTY(lcNewFile)
      llError = .T.
      lcErrMessage = 'Invalid Activation Key ! System will be terminated.'      
      RETURN
    ENDIF
 
    lnPathPos  = RAT('\',lcNewFile)
    lcFilePath = Left(lcNewFile,lnPathPos)
    lcFileName = Substr(lcNewFile,lnPathPos+1,Len(lcNewFile))
    IF lfvKeyValu () .AND. llError
      RETURN
    ENDIF
  ENDIF
ENDIF  
*E301874,1 Abd - [End]
    
*B601996,1 Hesham (Start)
*B601996,1 in case the user have an invalid key display message before terminating
*B601996,1 the program
*=lfvAct_Key(gcAct_Key,@gcPrmtMdls,@gnMaxUsers,@gcPlatForm)
IF !lfvAct_K(gcAct_Key,@gcPrmtMdls,@gnMaxUsers,@gcPlatForm)
  =gfDialog("?",'Invalid Activation Key ! System will be terminated?',"\?\!\<Ok")
ENDIF
*B601996,1 Hesham (End)


*E300579,1 Hesham El-Sheltawi (Start)
*E300579,1 Check if the Activation Key contain that
*E300579,1 the runing version is a Demo Version Then validate the Expire Date
*E300579,1 of the running version
IF 'T' $ gcPlatForm
  IF FILE(gcSysHome+"I900INV.FXP")
    RESTORE FROM (gcSysHome+"I900INV.FXP") ADDI
    IF DATE() > ldExpDate+30
      llError = .T.
      lcErrMessage = 'The Demo version has been expired.'
      RETURN
    ENDIF
  ELSE
    ldExpDate = DATE()
    SAVE TO (gcSysHome+"I900INV.FXP") ALL LIKE ldExpDate
  ENDIF
ENDIF
*E300579,1 Hesham El-Sheltawi (End)


  IF FILE(gcSysHome+"I900INVA.FXP")
    RESTORE FROM (gcSysHome+"I900INVA.FXP") ADDI 
    IF DATE() > ldExpDate
      llError = .T.
      lcErrMessage = 'The system is running out of resources.'
      RETURN
    ENDIF
  ENDIF
  IF FILE(gcScrDir+"I900INVA.SPX")
    lnFileHnd = FOPEN(gcScrDir+"I900INVA.SPX")
    lnFileSiz = FSEEK(lnFileHnd,0,2)
    = FSEEK(lnFileHnd,0)
    lcDate = ALLTRIM(FGETS(lnFileHnd,lnFileSiz))
    lcDate = "{"+lcDate+"}"
    ldExpDate = &lcdate.
    IF DATE() > ldExpDate
      llError = .T.
      lcErrMessage = 'The system is running out of resources.'
      RETURN
    ENDIF
  ENDIF


*B800122,1 M.Hassan 09/13/95 Add a new message to indicate if the platform
*          that you running from is supported or not.
lcThisPlat = IIF(_DOS,'D',IIF(_WINDOWS,'W',IIF(_MAC,'M','U')))
IF !(lcThisPlat $ gcPlatForm) AND !EMPTY(gcPlatForm)
  ** MESSAGE : " The  platform is not supported in the"
  **           " installed system.                     "
  **           "                   Ok                "
  =gfModalgen("TRM00243B00000","ALERT",IIF(_DOS,'DOS',IIF(_WINDOWS,'WINDOWS',IIF(_MAC,'MAC','UNIX'))))
  
  RETURN
ENDIF

*** Open system files
*B600422,1 We are not using the message check file any more (Some day we will)
*SELECT 0
*USE (gcSysHome+"syuckmsg") ORDER TAG CUSER_ID

SELECT 0
USE (gcSysHome+"sydSuPrg") ORDER TAG PRGCOMP

*E301077,78 Hesham (Start)
*SELECT 0
*USE (gcSysHome+"sycComp")  ORDER TAG CCOMP_ID 
*E301077,78 Hesham (End)


SELECT 0
USE (gcSysHome+"syuuser")  ORDER TAG CUSER_ID

SELECT 0
*ymo (start)
*USE (gcSysHome+"syustatc")  ORDER TAG CUSER_ID

llCrErr = ON ("ERROR")
llNoErr = .T.
*E300374,1 Hesham El-Sheltawi (Start)
*E300374,1 remark the next line and add new on error command
* ON ERROR llNoErr = .F.
ON ERROR DO lfStaticErr WITH ERROR()
USE (gcSysHome+"syustatc")  EXCLUSIVE ORDER TAG CUSER_ID
ON ERROR llNoErr = .F.
*E300374,1 Hesham El-Sheltawi (END)
IF llNoErr
   =lfClrStatc()
   *E500419,1 BWA 08/26/2001 Delete the temp. files that ARIA27 create it.[START]
   =lfDelTemp()
  *E500419,1 BWA 08/26/2001.[END]

  *E039995,1 AMH Add Enhancment to update system audit [Start]
  PRIVATE lnAlias
  lnAlias = SELECT(0)
  USE (gcSysHome+"SYAUDIT") EXCLUSIVE IN 0
  SELECT SYAUDIT
  
  PRIVATE lcData
  lcData = STRTRAN(STR(YEAR(DATE())-1,4,0),' ','0')+STRTRAN(STR(MONTH(DATE()),2,0),' ','0')+STRTRAN(STR(DAY(DATE()),2,0),' ','0')
  
  DELETE FOR DTOS(DADD_DATE) <= lcData
  PACK
  USE IN SYAUDIT
  USE (gcSysHome+"SYAUDITB") EXCLUSIVE IN 0
  SELECT SYAUDITB
  
  DELETE FOR DTOS(DADD_DATE) <= lcData
  PACK
  USE IN SYAUDITB
  SELECT (lnAlias)
  *E039995,1 AMH [End]
  
ELSE
  gnThermNo  = 0
  FOR lnCount = 1 TO 500
    gnThermNo = gnThermNo + 1
    =gfThermo(500,gnThermNo,"Opening the static file...","")
    llNoErr = .T.
    USE (gcSysHome+"syustatc")  ORDER TAG CUSER_ID
    IF llNoErr
      =gfThermo(500,500,"Opening the static file...","")
      EXIT     
    ENDIF
  ENDFOR
  llError = llError .OR. !llNoErr
  lcErrMessage = IIF(llError,MESSAGE(),lcErrMessage)
ENDIF

ON ERROR &llCrErr
*ymo (end)
*** Check if the current station have a local drive to use it as
*** a working directory
SELECT 0
USE (gcSyshome+"SYCWRKST") ORDER TAG CWRKST_ID
IF SEEK(PADR(gcStation,6))
  IF sycwrkst.lhavelocl
    IF !EMPTY(sycwrkst.ctemppath) .AND.;
       gfValdPath(ALLTRIM(sycwrkst.ctemppath))
      gcWorkDir = ALLTRIM(sycwrkst.ctemppath)
      gcWorkDir = IIF(RIGHT(gcWorkDir,1)="\",gcWorkDir,gcWorkDir+"\")
    ENDIF     
  ENDIF
ENDIF
USE
*E301077,78 Hesham (Start)
*IF EMPTY(GETENV('DEVELOP'))
*  SELECT 0
*  USE (gcSyshome+"SYCERROR") ORDER 1
*ENDIF  
*E301077,78 Hesham (End)
*E300374,1 (End)

*E300441,4 Hesham El-Sheltawi (Start)
Dimension laErrModules[1,2]
STORE '' TO laErrModules
lcActivePlat = IIF(_DOS,'Dos',IIF(_WINDOWS,'Windows',IIF(_MAC,'MAC','UNIX')))
lcErrCond    = 'C'+IIF(_DOS,'Dos',IIF(_WINDOWS,'Win',IIF(_MAC,'MAC','UNIX')))+'BUILD'
*E301077,78 Hesham (Start)
llAppUse = gfSysOpen(gcSysHome+'SYDAPPL')
*E301077,78 Hesham (End)
SELECT cmdlbuild,&lcErrCond ;
WHERE capp_id='SY' ;
FROM  (gcSysHome+"SYDAPPL") INTO ARRAY laErrModules

If !(laErrModules[1,1]==laErrModules[1,2])
     lcMessage = "The "+lcActivePlat+" Main system version Build # is different than System files dictionary Build# "+;
                  "You have to upgrade the main system to be able to run the system."
  =gfMsgBox('TR',lcMessage,'\?\!\<Ok','ALERT')
  llError = .T.
  lcErrMessage = ''

  RETURN
ENDIF
*E300441,4 Hesham El-Sheltawi (End)

*E300441,4 Hesham El-Sheltawi (Start)
STORE '' TO laErrModules
lcErrCond    = 'C'+IIF(_DOS,'Dos',IIF(_WINDOWS,'Win',IIF(_MAC,'MAC','UNIX')))+'BUILD<>CMDLBUILD'
  SELECT cApp_id,Capp_Name ;
  WHERE &lcErrCond ;
  FROM  (gcSysHome+"SYDAPPL") INTO ARRAY laErrModules
 IF !EMPTY(laErrModules[1,1])
   lcMessage=[The system has detected one or more modules that have not ]+;
             [been upgraded to the latest build number on the current ]+;
             [platform ( ]+lcActivePlat+[ )!]+CHR(13)+CHR(10)+[ If you proceed and use these ]+;
             [modules, errors may occur and data may be lost. It is highly ]+;
             [recommended to abort now and install files for these modules ]+;
             [from the latest builds!]+CHR(13)+CHR(10)+[Modules needed to be updated:]+CHR(13)+CHR(10)
             FOR lnCount = 1 TO ALEN(laErrModules,1)
               lcMessage = lcMessage +'    '+ laErrModules[lnCount,1]+'  '+laErrModules[lnCount,2]+CHR(13)+CHR(10)
             ENDFOR
   llError = gfMsgBox('TR',lcMessage,'\?\!\<Abort;\<Proceed','ALERT')=1
   lcErrMessage = ''
 ENDIF
*E301077,78 Hesham (Start)
USE IN IIF(llAppUse ,'SYDAPPL',0)
*E301077,78 Hesham (End)
*E300441,4 Hesham El-Sheltawi (End)

*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
IF GCMULTIINST
  *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
  *gcCBmpHome = 'X:\Aria27\Bmps\'                && Bmps location
  *gcRsrcHome = 'X:\Aria27\Resources\'           
  *gcCRepHome = 'X:\Aria27\Reports\'                   && Hold the path of reports
  *gcCappHome = 'X:\Aria27\Prgs\'                
  *gcCScrDir  = 'X:\Aria27\Screens\'             
  *gcWorkDir  = 'X:\Aria27\Work\'                
  lcRootDir = SUBSTR(gcSysHome,1,RAT('\',gcSysHome,2))
  gcCBmpHome = lcRootDir+'Bmps\'                && Bmps location
  *B609556,3 TMI 03/31/2011 [Start] folder names in fox2 should not be more than 8 chracters
  *gcRsrcHome = lcRootDir+'Resources\'           
  gcRsrcHome = lcRootDir+'Resource\'           
  *B609556,3 TMI 03/31/2011 [End  ] 
  gcCRepHome = lcRootDir+'Reports\'                   && Hold the path of reports
  gcCappHome = lcRootDir+'Prgs\'                
  gcCScrDir  = lcRootDir+'Screens\'             
  gcWorkDir  = lcRootDir+'Work\'                
  *E302876,1 TMI 03/20/2011 [End  ] 
ENDIF 
*E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]


*E300374,1 Hesham El-Sheltawi (Start)
*E300374,1 Startup Error handler function
*E300374,1 this function to detect any error happened with setup the
*E300374,1 system and get the right error message
FUNCTION lfStartUpErr
PARAMETERS lnErrorNo,lcErrorMsg
ON ERROR
lcErrMessage = lcErrorMsg 
llError = .T.
RETURN TO MASTER
*E300374,1

*B600975,10 Hesham El-Sheltawi (START)
*B600975,1 function to update specific module files in all companies
*!*******************************************************************
*!
*!      Function: gfUpdModFl
*!
*!*******************************************************************
*
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfUpdModFl
FUNCTION x_gfUpdModFl
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcAction,lcMod_ID
DIMENSION laSelected[1,2]
STORE '' TO laSelected
lcUpGrdLvl = IIF(lcMod_ID='SY','S','A')
*E301077,78 Hesham (Start)
llfiles = gfSysOpen(gcSysHome+'sydfiles')
*E301077,78 Hesham (End)

*Ren 
*SELECT cFile_nam,cfile_ttl ;
   FROM (gcSyshome+"sydfiles") ;
   INTO ARRAY laSelected ;
   WHERE LEFT(cFile_nam,2) <> "SY" .AND. CUPGRDLVL=lcUpGrdLvl .AND. lcMod_ID $ ALLTRIM(mfile_app);
   ORDER BY 1

lcMod_ID = IIF(lcMod_ID='SM', 'SY', lcMod_ID) 
SELECT cFile_nam,cfile_ttl ;
   FROM (gcSyshome+"sydfiles") ;
   INTO ARRAY laSelected ;
   WHERE LEFT(cFile_nam,2) <> "SY" .AND. lcMod_ID $ ALLTRIM(mfile_app);
   ORDER BY 1
*Ren end

*E301077,78 Hesham (Start)
USE IN IIF(llfiles,'sydfiles',0)
*E301077,78 Hesham (End)

PRIVATE lnCount
IF !EMPTY(laSelected [1,1])   && Exit if None 

  DECLARE laFileStrc[1,1],laFileAStr[1,1]

  llOpenRep  = .F.               && Open Report flage
  lcFilHandl = ''
  lcTempNam  = ''
  lnRepLine  = 0
  llYes2All  = .F.
  lcTherMesg  = "Updating file structure..."
  *** Verify files for all companies
    *** Check all selected files
    lnLastComp = ALEN(laCompany,1)

    *** Loop all or one company
    FOR lnCompNo = 1 TO lnLastComp
      lcFilePath = ALLTRIM(laCompany[lnCompNo,2])
      lnSelected = ALEN(laSelected,1)

      *B801893,1 AMM if SM module, behave as if SY module
      lcMod_ID = IIF(lcMod_ID='SM', 'SY', lcMod_ID) 
      *B801893,1 AMM end

      *** Check if there is one module selecet if this module is not installed to
      *** the company in the loop skip this company
      *B602329,1 Update file structure of data files used by 'SY' as well
      *IF !EMPTY(lcMod_ID) .AND. !(lcMod_ID $ ALLTRIM(laCompany[lnCompNo,3]))
      IF !EMPTY(lcMod_ID) .AND. !(lcMod_ID $ 'SY'+ALLTRIM(laCompany[lnCompNo,3]))
	  *B602329,1 end
        LOOP
      ENDIF
      
      *** Loop all selected files
      FOR lnCount = 1 TO lnSelected
        lcFileNam = UPPER(ALLTRIM(laSelected[lnCount,1]))
        lcTargDir = UPPER(IIF(UPPER(LEFT(lcFileNam ,2))='SY',gcSysHome,lcFilePath))

        IF lcMod_ID $ ALLTRIM(laCompany[lnCompNo,3]) OR lcMod_ID='SY'
          *** If the to be cheked file belong to one of the installed modules
          *** for this company, then verify it
          lcSubsVar = ALLTRIM(laSelected[lnCount,2])
          =gfThermo(lnSelected ,lnCount-.01,lcTherMesg,lcSubsVar)
          IF !lfVer_Upd(lcFileNam,.T.)  
            EXIT
          ENDIF
          =lfClrLock(lcFileNam)
          =gfThermo(lnSelected ,lnCount,lcTherMesg,lcSubsVar)
        ELSE
          *** If not skip this files but keep the thermometer running
          lcSubsVar = " "
          =gfThermo(lnSelected ,lnCount,lcTherMesg,lcSubsVar)
        ENDIF
      ENDFOR
      *E301065,1 AMM, Update Form Codes files of the current module and company.
      *Ren Restore lcMod_ID
      lcMod_ID = IIF(lcMod_ID='SY','SM',lcMod_ID)
      =lfUpFCode(lcMod_ID,lcFilePath)
      *Ren end
      *E301065,1 AMM end

      *E301252,1 AMM Update setups file due to SYCCONFG file 
      =lfUSetup('A',lcMod_ID,lcFilePath)
      *E301252,1 AMM end
    ENDFOR
ENDIF



*!*******************************************************************
*!
*!      Function: lfVer_Upd
*!
*!*******************************************************************
*
* Function to verify or update data and system files
*
FUNCTION lfVer_Upd
PARAMETERS lcFileNam,llUpdate

DECLARE laFileStrc[1,1],laFileAStr[1,1]

llUpdate   = IIF(TYPE('llUpdate')='U',.F.,llUpdate)
lcTmpFNm   = ''
llFileCorr = .F.               && Flage If file Corrupted
llRetFlag  = .T.


*** Dictionary file strc.
*E301077,78 Hesham (Start)
llflfld = gfSysOpen(gcSysHome+'sydflfld')
llfield = gfSysOpen(gcSysHome+'sydfield')
*E301077,78 Hesham (End)

*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*SELECT sydflfld.cfld_name,sydfield.cdata_typ,;
       sydfield.nfld_wdth,sydfield.nfld_dec,sydflfld.nfld_pos;
       FROM  (gcSyshome+"sydflfld"),(gcSyshome+"sydfield");
       ORDER BY sydflfld.nfld_pos;
       GROUP BY sydField.cFld_Name;
       WHERE UPPER(sydflfld.cfile_nam) =UPPER(PADR(lcFileNam,8));
       AND sydfield.cfld_name = sydflfld.cfld_name;
       INTO ARRAY laFileStrc
LOCAL lnSlct 
lnSlct = SELECT(0)
SELECT sydflfld.cfld_name,sydfield.cdata_typ,;
       sydfield.nfld_wdth,sydfield.nfld_dec,MAX(sydflfld.nfld_pos) as nfld_pos;
       FROM  (gcSyshome+"sydflfld"),(gcSyshome+"sydfield");
       GROUP BY sydflfld.cfld_name,sydfield.cdata_typ,;
                sydfield.nfld_wdth,sydfield.nfld_dec;
       WHERE UPPER(sydflfld.cfile_nam) =UPPER(PADR(lcFileNam,8));
       AND sydfield.cfld_name = sydflfld.cfld_name;
       INTO CURSOR FileStrc_CURSOR
SELECT * FROM FileStrc_CURSOR ORDER BY NFLD_POS INTO ARRAY laFileStrc
USE IN FileStrc_CURSOR
SELECT (lnSlct)

*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
*E301077,78 Hesham (Start)
USE IN IIF(llflfld,'sydflfld',0)
USE IN IIF(llfield,'sydfield',0)
*E301077,78 Hesham (End)

=gfAdel(@laFileStrc,5,2)       && An additional colum holding the position 
                               && of each field has to be removed from the
                               && Array befor verification or building.
*E301167,1 hesham (Start)
*E301167,1 copy array in another and then sort it
=ACOPY(laFileStrc,laFileFields)
*E301167,1 hesham end
DIME laFileFields[ALEN(laFileStrc,1),ALEN(laFileStrc,2)]

PRIVATE lnCount     
FOR lnCount = 1 TO ALEN(laFileStrc,1)
  laFileStrc[lnCount,1] = ALLT(laFileStrc[lnCount,1])
ENDFOR
*** Check if file exist or build new one
*B602147,1 Get full path for an opened DBF
=ASORT(laFileStrc)
llOpened  = USED(lcFileNam)
lcSetFull = SET('FULL')
SET FULL ON
lcDbfFile = IIF(llOpened,FULL(DBF(lcFileNam)),'')
SET FULL &lcSetFull
*B602147,1 end
IF FILE(lcTargDir+lcFileNam+".DBF")

  *** File was found in target directory
  IF USED(lcFileNam)
    llOpened = .T.
    SELECT(lcFileNam)
    *B602147,1 Open the file from the correct directory
    IF FULL(DBF(lcFileNam))<>lcTargDir+lcFileNam
      USE
      USE (lcTargDir+lcFileNam)       
    ENDIF
    *B602147,1 end
  ELSE  
    llOpened = .F.
    SELECT 0
    USE (lcTargDir+lcFileNam) 
  ENDIF

  *** Actual file structure
  =AFIELDS(laFileAStr)
  IF !EMPTY(laFileStrc[1])            && Found data for this file
    *E301167,1 hesham (Start)
    *E301167,1 check if the struc. of file in dic. is diff. that the phiscal file
    *E301167,1 structure
    WAIT 'Verifying file structure for file '+lcTargDir+lcFileNam Window nowait

    llFileCorr = ALEN(laFileStrc,1)<>ALEN(laFileAStr,1)
    *** Check all fields information
    IF !llFileCorr
        *E301167,1 Hesham (Start)
        *E301167,1 sorting phisc. fields in file
        =ASORT(laFileAStr)
        *E301167,1 Hesham (End)
        FOR lnFieldNo = 1 TO ALEN(laFileStrc,1)     &&All Fields
          lnFieldPos = ASCAN(laFileAStr,laFileStrc[lnFieldNo,1])
          FOR lnFieldPos  = 1 TO ALEN(laFileAStr,1)
            IF ALLTRIM(laFileAStr[lnFieldPos,1]) == ALLTRIM(laFileStrc[lnFieldNo,1])
              EXIT
            ENDIF
          ENDFOR
          IF lnFieldPos > ALEN(laFileAStr,1)
            lnFieldPos = 0
          ENDIF
          IF lnFieldPos = 0
             llFileCorr = .T.
             EXIT
          ELSE   
            IF laFileAStr[lnFieldPos,1] <> laFileStrc[lnFieldNo,1] OR ;
               laFileAStr[lnFieldPos,2] <> laFileStrc[lnFieldNo,2] OR ;
               laFileAStr[lnFieldPos,3] <> laFileStrc[lnFieldNo,3] OR ;
               laFileAStr[lnFieldPos,4] <> laFileStrc[lnFieldNo,4]
               llFileCorr = .T.
               EXIT
            ENDIF   
         ENDIF 
        ENDFOR       
    ENDIF
    *E301167,1 hesham (End)
    IF llFileCorr AND llUpdate
      *E301167,1 hesham (Start) 
      *E301167,1 restore the array to retrieve the fields position
      =ACOPY(laFileFields,laFileStrc)
      *E301167,1 hesham (End)
      IF !llYes2All
        lnOption = 3 &&gfModalGen('QRM00004B00004','Dialog',lcSubsVar)  
        DO CASE
          CASE lnOption = 1
            *** Fix file structure
            =lfUpdate(lcFileNam)
          CASE lnOption = 3
            llYes2All  = .T.
            =lfUpdate(lcFileNam)
          CASE lnOption = 4
            llRetFlag  = .F.
        ENDCASE
      ELSE
        *** Fix file structure
        =lfUpdate(lcFileNam)
      ENDIF  

    ENDIF
  ENDIF    
  IF !llOpened 
     USE
  ENDIF  
ELSE
  *E301167,1 hesham (Start) 
  *E301167,1 restore the array to retrieve the fields position
  =ACOPY(laFileFields,laFileStrc)
  *E301167,1 hesham (End)
 llYes2All  = .T.
 =lfUpdate(lcFileNam,.T.)
ENDIF
*B602147,1 Close DBF
IF USED(lcFileNam)
  USE IN (lcFileNam)
ENDIF  
*B602147,1 end
=lfIndex(lcFileNam) 
*B602147,1 Reopen the file if it was opened before
IF llOpened AND !EMPTY(lcDbfFile)
  USE (lcDbfFile) IN 0
ENDIF
*B602147,1 end
RETURN llRetFlag


*!*******************************************************************
*!
*!      Function: lfVer_Upd
*!
*!*******************************************************************
*
* Function to verify or update data and system files
*
*Obsolete. Please remove after testing lfVer_Upd()
FUNCTION lf_Ver_Upd
PARAMETERS lcFileNam,llUpdate

DECLARE laFileStrc[1,1],laFileAStr[1,1]

llUpdate   = IIF(TYPE('llUpdate')='U',.F.,llUpdate)
lcTmpFNm   = ''
llFileCorr = .F.               && Flage If file Corrupted
llRetFlag  = .T.


*** Dictionary file strc.
*E301077,78 Hesham (Start)
llflfld = gfSysOpen(gcSysHome+'sydflfld')
llfield = gfSysOpen(gcSysHome+'sydfield')
*E301077,78 Hesham (End)

SELECT sydflfld.cfld_name,sydfield.cdata_typ,;
       sydfield.nfld_wdth,sydfield.nfld_dec,sydflfld.nfld_pos;
       FROM  (gcSyshome+"sydflfld"),(gcSyshome+"sydfield");
       ORDER BY sydflfld.nfld_pos;
       GROUP BY sydField.cFld_Name;
       WHERE UPPER(sydflfld.cfile_nam) =UPPER(PADR(lcFileNam,8));
       AND sydfield.cfld_name = sydflfld.cfld_name;
       INTO ARRAY laFileStrc

*E301077,78 Hesham (Start)
USE IN IIF(llflfld,'sydflfld',0)
USE IN IIF(llfield,'sydfield',0)
*E301077,78 Hesham (End)

=gfAdel(@laFileStrc,5,2)       && An additional colum holding the position 
                               && of each field has to be removed from the
                               && Array befor verification or building.
*E301167,1 hesham (Start)
*E301167,1 copy array in another and then sort it
=ACOPY(laFileStrc,laFileFields)
=ASORT(laFileStrc)
*E301167,1 hesham end
DIME laFileFields[ALEN(laFileStrc,1),ALEN(laFileStrc,2)]

PRIVATE lnCount     
FOR lnCount = 1 TO ALEN(laFileStrc,1)
  laFileStrc[lnCount,1] = ALLT(laFileStrc[lnCount,1])
ENDFOR
*** Check if file exist or build new one
*B602147,1 Get full path for an opened DBF
llOpened  = USED(lcFileNam)
lcSetFull = SET('FULL')
SET FULL ON
lcDbfFile = IIF(llOpened,FULL(DBF(lcFileNam)),'')
SET FULL &lcSetFull
*B602147,1 end
IF FILE(lcTargDir+lcFileNam+".DBF")

  *** File was found in target directory
  IF USED(lcFileNam)
    llOpened = .T.
    SELECT(lcFileNam)
    *B602147,1 Open the file from the correct directory
    IF FULL(DBF(lcFileNam))<>lcTargDir+lcFileNam
      USE
      USE (lcTargDir+lcFileNam)       
    ENDIF
    *B602147,1 end
  ELSE  
    llOpened = .F.
    SELECT 0
    USE (lcTargDir+lcFileNam) 
  ENDIF

  *** Actual file structure
  =AFIELDS(laFileAStr)
  IF !EMPTY(laFileStrc[1])            && Found data for this file
    *E301167,1 hesham (Start)
    *E301167,1 check if the struc. of file in dic. is diff. that the phiscal file
    *E301167,1 structure
    WAIT 'Verifying file structure for file '+lcTargDir+lcFileNam Window nowait
    llFileCorr = ALEN(laFileStrc,1)<>ALEN(laFileAStr,1)
    *** Check all fields information
    IF !llFileCorr
        *E301167,1 Hesham (Start)
        *E301167,1 sorting phisc. fields in file
        =ASORT(laFileAStr)
        *E301167,1 Hesham (End)
        FOR lnFieldNo = 1 TO ALEN(laFileStrc,1)     &&All Fields
          IF laFileAStr[lnFieldNo,1] <> laFileStrc[lnFieldNo,1] OR ;
             laFileAStr[lnFieldNo,2] <> laFileStrc[lnFieldNo,2] OR ;
             laFileAStr[lnFieldNo,3] <> laFileStrc[lnFieldNo,3] OR ;
             laFileAStr[lnFieldNo,4] <> laFileStrc[lnFieldNo,4]
             llFileCorr = .T.
             EXIT
          ENDIF   
        ENDFOR       
    ENDIF
    *E301167,1 hesham (End)
    IF llFileCorr AND llUpdate
      *E301167,1 hesham (Start) 
      *E301167,1 restore the array to retrieve the fields position
      =ACOPY(laFileFields,laFileStrc)
      *E301167,1 hesham (End)
      IF !llYes2All
        lnOption = 3 &&gfModalGen('QRM00004B00004','Dialog',lcSubsVar)  
        DO CASE
          CASE lnOption = 1
            *** Fix file structure
            =lfUpdate(lcFileNam)
          CASE lnOption = 3
            llYes2All  = .T.
            =lfUpdate(lcFileNam)
          CASE lnOption = 4
            llRetFlag  = .F.
        ENDCASE
      ELSE
        *** Fix file structure
        =lfUpdate(lcFileNam)
      ENDIF  

    ENDIF
  ENDIF    
  IF !llOpened 
     USE
  ENDIF  
ELSE
  *E301167,1 hesham (Start) 
  *E301167,1 restore the array to retrieve the fields position
  =ACOPY(laFileFields,laFileStrc)
  *E301167,1 hesham (End)
 llYes2All  = .T.
 =lfUpdate(lcFileNam,.T.)
ENDIF
*B602147,1 Close DBF
IF USED(lcFileNam)
  USE IN (lcFileNam)
ENDIF  
*B602147,1 end
=lfIndex(lcFileNam) 
*B602147,1 Reopen the file if it was opened before
IF llOpened AND !EMPTY(lcDbfFile)
  USE (lcDbfFile) IN 0
ENDIF
*B602147,1 end
RETURN llRetFlag

*!*******************************************************************
*!
*!      Function: lfUpdate
*!
*!*******************************************************************
*
* This function will build a new data files from the dectionary 
* and their indexes
*
FUNCTION lfUpdate
PARAMETERS lcFileNam,llBldFile

*E301167,1 Hesham (Start)
WAIT 'Updating file structure for file '+lcTargDir+lcFileNam Window nowait
*E301167,1 Hesham (End)

llBldFile = IIF(TYPE('llBldFile')='U',.F.,llBldFile)
lcTempNam = gfTempName()

IF !EMPTY(laFileStrc[1])
  IF llBldFile 
    CREATE DBF  (lcTargDir+lcFileNam) FROM ARRAY laFileStrc
    *B602147,1 Close DBF after creation
    *E303074,1 TMI 02/20/2012 [Start] force creating table in fox2.6 format
    =lfCrFox2x()
    *E303074,1 TMI 02/20/2012 [End  ] 
    USE
    *B602147,1 end
  ELSE
    CREATE DBF  (lcTargDir+lcTempNam) FROM ARRAY laFileStrc
    *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
    lfCrFox2x()
    *E303074,1 TMI 02/20/2012 [End  ] 
    APPEND FROM (lcTargDir+lcFileNam)
    USE

    IF USED(lcFileNam)
      USE IN (lcFileNam)
    ENDIF  

    ERASE  (lcTargDir+lcFileNam+".DBF")
    ERASE  (lcTargDir+lcFileNam+".FPT")
    ERASE  (lcTargDir+lcFileNam+".CDX")
            
    RENAME (lcTargDir+lcTempNam+".DBF") TO (lcTargDir+lcFileNam+".DBF")

    IF FILE(lcTargDir+lcTempNam+'.FPT')	
      RENAME (lcTargDir+lcTempNam+".FPT") TO (lcTargDir+lcFileNam+".FPT")
    ENDIF 

    SELECT 0
    USE (lcTargDir+lcFileNam)
  ENDIF

*  =lfIndex(lcFileNam) 

ENDIF  

*!*******************************************************************
*!
*!      Function: lfIndex
*!
*!*******************************************************************
* This function will creat or fix the index for one file
*
FUNCTION lfIndex
PARAMETERS lcFileNam

DECLARE laFileCDX[1,4]

*E301167,1 Hesham (Start)
WAIT 'Reindexing file '+lcTargDir+lcFileNam Window nowait
*E301167,1 Hesham (End)

lcSavAlias = SELECT(0)
*B602147,1 Clear array
laFileCDX  = ''
*B602147,1 end
*E301077,78 Hesham (Start)
llIndex = gfSysOpen(gcSysHome+'sydindex')
*E301077,78 Hesham (End)
SELECT ALLTRIM(sydindex.cindx_exp),ALLTRIM(sydindex.cfile_tag),sydindex.lascend,;
       sydindex.lunique;
       FROM (gcSyshome+"sydindex");
       WHERE UPPER(sydindex.cfile_nam) = PADR(lcFileNam,8);
       INTO ARRAY laFileCDX

*E301077,78 Hesham (Start)
USE IN IIF(llIndex,'sydindex',0)
*E301077,78 Hesham (End)

IF !USED(lcFileNam)
  SELECT 0
ELSE
  SELECT (lcFileNam)
ENDIF  
IF FILE(ALLTRIM(lcTargDir)+ALLTRIM(lcFileNam)+'.DBF')
  USE (ALLTRIM(lcTargDir)+ALLTRIM(lcFileNam)) EXCL

  IF !EMPTY(laFileCDX[1])
    *B603497,1 KHM 03/03/2000 (Begin) Adding the following code in order
    *B603497,1                to remove the index that does not exist 
    *B603497,1                in the SydIndex file.
    lnTagCnt = 1
    DO WHILE !EMPTY(TAG(lnTagCnt))
      llDelIndx = .T.
      FOR lnArryCnt = 1 TO ALEN(laFileCDX,1)
        IF UPPER(ALLTRIM(laFileCDX[lnArryCnt,2])) = UPPER(ALLTRIM(TAG(lnTagCnt)))
          llDelIndx = .F.
          EXIT
        ENDIF        
      ENDFOR
      IF llDelIndx
        lcTagNam = TAG(lnTagCnt)
        DELETE TAG &lcTagNam OF ALLTRIM(lcTargDir)+ALLTRIM(lcFileNam)+'.CDX'
      ELSE 
        lnTagCnt = lnTagCnt + 1
      ENDIF 
    ENDDO
    *B603497,1 KHM 03/03/2000 (End)
    
    FOR lnTagNo = 1 TO ALEN(laFileCDX,1)
        IF !EMPTY(laFileCDX[lnTagNo,1])
          lcAscend  =IIF(laFileCDX[lnTagNo,3],'ASCENDING','DESCENDING')
          lcUnique  =IIF(laFileCDX[lnTagNo,4],'UNIQUE','')
          *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
          *INDEX ON &laFileCDX[lnTagNo,1] TAG &laFileCDX[lnTagNo,2]; 
          *      ADDITIVE &lcAscend &lcUnique
        ON ERROR llErr=.T.
        lcNdx = laFileCDX[lnTagNo,1]
        lcTag = laFileCDX[lnTagNo,2]
        INDEX ON &lcNdx TAG &lcTag ; 
                ADDITIVE &lcAscend &lcUnique
        ON ERROR
          *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
        ENDIF      
      ENDFOR            
  ENDIF
  USE
ENDIF  

SELECT (lcSavAlias)


*!*******************************************************************
*!
*!      Function: lfClrLock
*!
*!*******************************************************************
*
FUNCTION lfClrLock
PARAMETERS lcFileNam
IF FILE(lcTargDir+lcFileNam+".DBF")
  IF !USED(lcFileNam)
    SELECT 0
  ELSE
    SELECT (lcFileNam)
  ENDIF  
  USE (lcTargDir+lcFileNam) EXCL
 IF TYPE(lcFileNam+'.llok_stat')='L' AND TYPE(lcFileNam+'.dlok_date')='D';
    AND TYPE(lcFileNam+'.clok_user')='C' AND TYPE(lcFileNam+'.clok_time')='C'
    REPLACE ALL llok_stat WITH .F. ;
                dlok_date WITH {} ;
                clok_user WITH "" ;
                clok_time WITH "" ;
            FOR llok_stat
  ENDIF
  SELECT (lcFileNam)
  USE
ENDIF


*B600975,10 Hesham El-Sheltawi (End)

*E600823,1 Hesham El-Sheltawi (Start)
*E600823,1 function to get the programm than called the browse
*E600823,1 to create the prefrence of the browse
FUNCTION gfBrowPref
PARAMETERS lcBrCmdFields,lcAliasName,llCmtPrgTree
PRIVATE lcProgName,lcUsrFile,lcPref,lcFields,lcSelectAlias
lcUsrFile = 'X'+SYS(2007,PADR(gcUser_ID,10))
lcAliasName = IIF(TYPE('lcAliasName')='C',lcAliasName,'')
*B601272,1 Hesham El-Sheltawi (Start)
*B601272,1 if using Temprory file return browse fields without a
*B601272,1 prefrence ID for the browse
*lcAliasName = IIF(EMPTY(lcAliasName),IIF(UPPER(gcWorkDir) $ FULL(DBF()) AND LEFT(ALIAS(),1)='X','',ALIAS()),lcAliasName)
lcAliasName = IIF(EMPTY(lcAliasName),IIF(LEFT(ALIAS(),1)='X' OR LEFT(ALIAS(),1)='T','',ALIAS()),lcAliasName)
IF EMPTY(lcAliasName) OR !(gcRsrcHome $ SET('RESO',1))
  RETURN "Fields "+lcBrCmdFields
ENDIF
*B601272,1 Hesham El-Sheltawi (End)
lcProgName=''
IF !llCmtPrgTree
  lnCount = 2
  lcProgName=lcProgName + IIF(LEFT(PROG(1),2)='ON','',PROG(1))  
  DO WHILE !('GFBROWS' $ SYS(16,lnCount)) AND !('ARIABROW' $ SYS(16,lnCount)) AND !EMPTY(SYS(16,lnCount))
   lcProgName = lcProgName+IIF(LEFT(PROG(lnCount),2)='ON','',PROG(lnCount))
   IF !('GFBROWS' $ SYS(16,lnCount)) AND !('ARIABROW' $ SYS(16,lnCount))
     lnCount = lnCount +1
   ENDIF  
  ENDDO
  lcProgName = lcProgName+SUBSTR(SYS(16,lnCount),ATC('IN ',SYS(16,lnCount)))
ENDIF
lcPref = IIF(_DOS,'D','W')+SYS(2007,PADR(lcProgName+lcAliasName,340))
lcFields = IIF(EMPTY(lcBrCmdFields),'','FIELDS '+lcBrCmdFields)
lcSelectAlias = SELECT()
IF gcRsrcHome $ SET('RESOURCE',1) AND SET('RESOURCE')='ON' AND FILE(gcRsrcHome+lcUsrFile+'.DBF')
  lcFields=''
  IF !USED(lcUsrFile)
    SELECT 0
    USE (gcRsrcHome+lcUsrFile) ORDER TAG cUserPref
  ENDIF  
  SELECT (lcUsrFile)
  SET ORDER TO TAG cUserPref
  =SEEK(lcPref)
  IF !FOUND()  OR !(ALLT(lcBrCmdFields) == ALLT(mBrowField)) OR !(ALLT(mBrowField)==ALLT(lcBrCmdFields))
    IF !FOUND()
      APPEND BLANK
    ELSE
      SELECT 0
      USE (SYS(2005))  AGAIN ORDER TAG 1
      IF SEEK(PADR('PREF'+IIF(_DOS,'2.5','W'),12)+PADR('WINDBROW',12)+PADR('B'+lcPref,24))
        REPLACE DATA WITH ''
      ENDIF
      USE
      SELECT (lcUsrFile)
    ENDIF
    REPLACE cUserPref WITH lcPref,;
            mBrowField WITH lcBrCmdFields
    lcFields = IIF(EMPTY(lcBrCmdFields),'','FIELDS '+lcBrCmdFields)
  ENDIF
ENDIF
IF USED(lcUsrFile)
  USE IN (lcUsrFile)
ENDIF
SELECT (lcSelectAlias)
lcPref = 'PREF B'+lcPref+' '
RETURN lcPref+lcFields
*E600823,1 Hesham El-Sheltawi (End)


*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4  Function to display any messag with any button . 
*E300441,4 The width and hight of the dialog window 
*E300441,4  will be calculated according to the messag width and No. of buttons.
*E300441,4  Parameters are:
FUNCTION gfMsgBox
PARAMETER lcMsgCatgry,lcDlgID,lcButton,lcDlgTyp

PRIVATE lcDlgID,lcDlgTyp,lcDlgValid,lcCurrDbf,lnButtons,lcDlgMessg

DECLARE laButtNo [1]         && Array to hold the buttons separetly
DECLARE laVarsStr[1]         && Array to hold variabels to be replaced
                             && in the messag

PUSH KEY
ON KEY
lcCurrDbf   = ALIAS()
lcDlgID     = IIF(TYPE('lcDlgID'   ) $ "UL",'',lcDlgID   )
lcDlgTyp    = IIF(TYPE('lcDlgTyp'  ) $ "UL",'D',lcDlgTyp )
lcDlgValid  = IIF(TYPE('lcDlgValid') $ "UL",'',lcDlgValid)
lcButton    = IIF(TYPE('lcButton') $ "UL","\!\?\<Ok",lcButton)
lcMsgCatgry = IIF(TYPE('lcMsgCatgry') $ "UL","TR",lcMsgCatgry)
gcSysName   = IIF(TYPE('gcSysName')<>'C','',gcSysName)

lnColrSchm  = VAL(SUBSTR('57',AT(LEFT(lcDlgTyp,1),'DA'),1))  
lnDlgOpTion = 1              && Variable to get the result in
lnButtSize  = 1
lnOldRec    = 0
lnTextStrt  = 7
lnRigtShft  = 10

*** Get Dialog messag
lcMessag    = ALLTRIM(lcDlgID)

*** Remove all controle characters " \ ! < ?" from the button string
lcButtChk  = STRTRAN(STRTRAN(STRTRAN(STRTRAN(lcButton,'\',''),'!',''),;
           '<',''),'?','')

*** Collect all Buttons in array 
=gfSubStr(lcButtChk,@laButtNo,';')
*** Get No of buttons from array len
lnButtNo   = ALEN(laButtNo,1)

*** Get the max width of button
FOR lnButtons = 1 TO lnButtNo
  lnButtSize = MAX(lnButtSize,LEN(laButtNo[lnButtons]))
ENDFOR



*** Buttons width should not be less than 10 after adding 4 (< >) 
lnButtSize = MAX(10,lnButtSize+ 4 )


*** Calculat window width accordin to total buttons size
lnWinWidth = MAX(50,(lnButtSize * lnButtNo)+6)

*** Calculat space between buttons 
lnBetwButt = INT((lnWinWidth -(lnButtSize * lnButtNo))/lnButtNo)

*** Calculat X position of the button to be centerd
lnButXPos  = (lnWinWidth/2)-((lnButtSize * lnButtNo)+;
             (lnBetwButt*(lnButtNo-1)))/2

*** Calculat window higth according to the length of the messag
lnWinHight = INT(LEN(ALLTRIM(lcMessag))/lnWinWidth) + 6 


*** Define dialog window with right width, hight and color
*#IF _DOS
*    DEFINE WINDOW gwdDialog ;
*           FROM 0,0 TO lnWinHight,lnWinWidth ;
*           SHADOW;
*           FLOAT ;
*           DOUBLE;
*           COLOR SCHEME lnColrSchm
*#ELSE
*B600914,1 Stop the user abilty to close the dialog messages, from the screen menu
*    DEFINE WINDOW gwdDialog ;
	       AT  0.000, 0.000  ;
		   SIZE lnWinHight,lnWinWidth;
		   FONT "System", 10 ;
		   STYLE "B" ;
		   FLOAT ;
           SYSTEM ;
           TITLE (gcSysName);
		   CLOSE ;
		   NOMINIMIZE ;
		   COLOR RGB(,,,192,192,192)

    DEFINE WINDOW gwdDialog ;
	       AT  0.000, 0.000  ;
		   SIZE lnWinHight,lnWinWidth;
		   FONT "System", 10 ;
		   STYLE "B" ;
		   FLOAT ;
           SYSTEM ;
           TITLE (gcSysName);
		   NOMINIMIZE ;
		   COLOR RGB(,,,192,192,192)

*#ENDIF
			  
*** Activate dialog window no show so the window will pop with messag 
*** when activated
ACTIVATE WINDOW gwdDialog NOSHOW

*** Move the dialog window to center of the screen
MOVE WINDOW gwdDialog CENTER

*#IF _DOS
*      @ 0,1,2,5 BOX
*      @ 1,3  SAY SUBSTR ("!?I",(AT(lcMsgCatgry,"TRQRIN")+1)/2,1)
*      IF LEN(lcMessag) > 253
*        @ 1,lnTextStrt  EDIT lcMessag SIZE lnWinHight-4,lnWinWidth-lnRigtShft ;
*          NoModify Scroll
*      ELSE
*        @ 1,lnTextStrt  SAY lcMessag SIZE lnWinHight-3,lnWinWidth-lnRigtShft
*      ENDIF  
*#ELSE
      @ 0.000,0.000 TO 0.000,lnWinWidth ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(255,255,255,255,255,255)
  	  @ 0.000,0.000 TO lnWinHight,0.000 ;
		PEN 1, 8 ;
		  COLOR RGB(255,255,255,255,255,255)
  	  @ 0.188,0.429 TO 0.188,lnWinWidth-.6 ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.188,0.429 TO lnWinHight-.3,0.429 ;
		PEN 1, 8 ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.000,lnWinWidth TO lnWinHight,lnWinWidth ;
		PEN 1, 8 ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ 0.188,lnWinWidth-.6 TO lnWinHight-.3,lnWinWidth-.6 ;
		PEN 1, 8 ;
		  COLOR RGB(255,255,255,255,255,255)
	  @ lnWinHight,0.143 TO lnWinHight,lnWinWidth ;
		PEN 1, 8 ;
		STYLE "1" ;
		  COLOR RGB(128,128,128,128,128,128)
	  @ lnWinHight-.3,0.4 TO lnWinHight-.3,lnWinWidth-.4 ;
		PEN 1, 8 ;
		STYLE "1" ;
	      COLOR RGB(255,255,255,255,255,255)
    
*!*	        lcIcon = SUBSTR ("TR  QRY INFO",;
*!*	             ((AT(lcMsgCatgry,"TRQRIN")+1)/2-1)*4+1,4)+".BMP" 
*!*	        @ 1.5,1.5 SAY lcIcon BITMAP STYLE "T"
      IF LEN(lcMessag) > 253
        @ 0.5,lnTextStrt EDIT lcMessag SIZE lnWinHight-3,lnWinWidth-lnRigtShft;
          NOMODIFY SCROLL COLOR RGB(192,192,192,,,)
      ELSE
        @ 1.5,lnTextStrt SAY lcMessag SIZE lnWinHight-3,lnWinWidth-lnRigtShft
      ENDIF  
*#ENDIF

  
  @ lnWinHight -2 ,lnButXPos ;
    GET lnDlgOpTion ;
    PICTURE "@*HT "+lcButton;
    SIZE 1.5,lnButtSize,lnBetwButt

  
*** When the read is activated fox will activate the window 
ACTIVATE WINDOW gwdDialog

READ CYCLE MODAL


IF !EMPTY(lcCurrDbf)
  SELECT (lcCurrDbf)
ENDIF

RELEASE WINDOW gwdDialog

POP KEY
RETURN lnDlgOpTion

*E300441,4 Hesham El-Sheltawi (End)


*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 FUNCTION TO RETURN THE PLATFORMS BUILD# AND THE RECENT PLATFORM
FUNCTION lfGetPlatBuild
PARAMETERS lcModID,laBuildMod
PRIVATE lnCount,lcCurrsorName,llUsedBy,lcCurArea,lcRecBuild,lnCount,lcModId,;
lcModUp
llUsedBy = .f.
lcModUp=lcModID
lcModID = IIF(lcModID='SY','XX',lcModID)
lcCurArea = SELECT()
lcCurrsorName = gfTempName()
IF FILE (gcSysHome+lcModID+"DAPPL.DBF") AND !USED(lcModID+"DAPPL")
  SELECT 0
  USE (gcSysHome+lcModID+"DAPPL") ORDER TAG  CAPP_ID
  llUsedBy= .T.
ENDIF
CREATE CURS &lcCurrsorName (MdlBuild M,cPlatBuild M)
APPEND BLANK
REPLACE MdlBuild WITH EVAL(lcModID+"DAPPL.cMdlBuild")
lcRecBuild = ALLT(MdlBuild)

*B803757,1 NAD 11/02/2000 (Start) Assign the value of the nSrvcPak 
lnNSrvPak=EVAL(lcModID+"DAPPL.nSrvcPak")
*B803757,1 NAD 11/02/2000 (End)

FOR lnCount = 1 TO ALEN(laBuildMod,1)
  lcFileToCheck = gcSysHome+lcModUp+laBuildMod[lnCount,1]+'.TXT'
  IF FILE(lcFileToCheck)
     APPEND MEMO cPlatBuild FROM (lcFileToCheck) OVERWRITE
     laBuildMod[lnCount,2] = cPlatBuild
     laBuildMod[lnCount,3] = ALLT(MdlBuild) == ALLT(cPlatBuild)
  ELSE
    laBuildMod[lnCount,2] = ''
    laBuildMod[lnCount,3] = .F.
  ENDIF
ENDFOR
USE IN (lcCurrsorName)
IF llUsedBy AND USED(lcModID+"DAPPL")
  USE IN (lcModID+"DAPPL")
ENDIF
SELECT (lcCurArea)
RETURN lcRecBuild
*E300441,4 Hesham El-Sheltawi (End)

*E300441,4 Hesham El-Sheltawi (Start)
*E300441,4 Function to delete all the module splitted files
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION lfDelSplit
FUNCTION x_lfDelSplit
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcMd_id
PRIVATE laModFiles,lcMd_id,lcMdUpd,lnCount

*E301065,1 start. Add two elements for SYFRMCDH, SYFRMCDD files
*DIMEN laModFiles[15,1]
*E301199,1 Hesham (Start)
*DIMEN laModFiles[17,1]
*E301252,1 AMM Add a new element SYCCONFG file to the array
*DIMEN laModFiles[18,1]
*B802980,1 Hesham (Start)
*DIMEN laModFiles[19,1]

*++NAD40
*DIMEN laModFiles[20,1]
DIMEN laModFiles[19,1]
*++NAD40

*B802980,1 Hesham (End)
*E301252,1 AMM end

*E301199,1 Hesham (End)
*E301065,1 end

lcMdUpd = lcMd_id
lcMd_id = IIF(lcMd_id='SY','XX',lcMd_id)
laModFiles[1,1] = lcMd_id+"DAPPL"
laModFiles[2,1] = lcMd_id+"DFILES"
laModFiles[3,1] = lcMd_id+"DFIELD"
laModFiles[4,1] = lcMd_id+"DFLFLD"
laModFiles[5,1] = lcMd_id+"DINDEX"
laModFiles[6,1] = lcMd_id+"CMENU"
laModFiles[7,1] = lcMd_id+"DDLOBJ"
laModFiles[8,1] = lcMd_id+"DOBJCT"
laModFiles[9,1] = lcMd_id+"DREPRT"
laModFiles[10,1] = lcMd_id+"DSCOBJ"
laModFiles[11,1] = lcMd_id+"REPSRT"
laModFiles[12,1] = lcMd_id+"REPUVR"
laModFiles[13,1] = lcMd_id+"CPRINT"
laModFiles[14,1] = lcMd_id+"CP_ESC"
laModFiles[15,1] = lcMd_id+"CINT"
*E301065,1 start. Add two elements for SYFRMCDH, SYFRMCDD files
laModFiles[16,1] = lcMd_id+"FRMCDD"
laModFiles[17,1] = lcMd_id+"FRMCDH"
*E301065,1 end
*E301199,1 Hesham (Start)

*++NAD40
*laModFiles[18,1] = lcMd_id+"DFXPRG"
*++NAD40
*E301199,1 Hesham (End)

*E301252,1 AMM Add the file to be closed

*++NAD40
*laModFiles[19,1] = lcMd_id+"CCONFG"
laModFiles[18,1] = lcMd_id+"CCONFG"
*++Nad40

*E301252,1 AMM end
*B802980,1 Hesham (Start)
*++Nad40
*laModFiles[20,1] = lcMd_id+"SZONES"
laModFiles[19,1] = lcMd_id+"SZONES"
*++Nad40

*B802980,1 Hesham (End)
ERASE (gcSysHome+lcMdUpd+'DOS.TXT')
ERASE (gcSysHome+lcMdUpd+'WIN.TXT')
ERASE (gcSysHome+lcMdUpd+'UNIX.TXT')
ERASE (gcSysHome+lcMdUpd+'MAC.TXT')

FOR lnCount = 1 TO ALEN(laModFiles,1)
  IF USED(laModFiles[lnCount,1]) 
    USE IN laModFiles[lnCount,1]
  ENDIF
  ERASE gcSysHome+laModFiles[lnCount,1]+'.DBF'
  ERASE gcSysHome+laModFiles[lnCount,1]+'.FPT'
  ERASE gcSysHome+laModFiles[lnCount,1]+'.CDX'
ENDFOR

*E300441,4 Hesham El-Sheltawi (End)


*E300441,4 Hesham El-Sheltawi (Start) 
*E300441,4 FUNCTION TO CHECK THE VERSION OF THE SYDAPPL FILE
*E300441,4 IF the file does not contain the fields that hold 
*E300441,4 the platform build# it create new file with these
*E300441,4 fields and copy the existing file records
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION lfUpdAppl
FUNCTION x_lfUpdAppl
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PRIVATE lcTmpName,lnCount
lcTmpName = gfTempName()
IF FILE(gcSysHome+'SYDAPPL.DBF')
  SELECT 0
  USE (gcSysHome+'SYDAPPL.DBF')
  IF TYPE('SYDAPPL.CDOSBUILD')$'UL'
    DIME laApplField[1,4]
    STORE '' TO laApplField
    =AFIELDS(laApplField)
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CDOSBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CWINBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CMACBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplField[ALEN(laApplField,1)+1,ALEN(laApplField,2)]   
    laApplField[ALEN(laApplField,1),1] = 'CUNIXBUILD'
    laApplField[ALEN(laApplField,1),2] = 'C'    
    laApplField[ALEN(laApplField,1),3] = 10
    laApplField[ALEN(laApplField,1),4] = 0
    DIME laApplIndex[1,2]
    STORE '' TO laApplIndex
    lnCount = 1
    DO WHILE !EMPTY(TAG(lnCount))
      IF !EMPTY(laApplIndex[1,1])
        DIME laApplIndex[ALEN(laApplIndex,1)+1,2]
      ENDIF
      laApplIndex[ALEN(laApplIndex,1),1] = TAG(lnCount)
      laApplIndex[ALEN(laApplIndex,1),2] = SYS(14,lnCount)
      lnCount = lnCount+1
    ENDDO
    USE IN SYDAPPL
    CREATE DBF (gcSysHome+lcTmpName) FROM ARRAY laApplField
    *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
    =lfCrFox2x()
    *E303074,1 TMI 02/20/2012 [End  ] 
    FOR lnCount = 1 TO ALEN(laApplIndex,1)
      IF !EMPTY(laApplIndex[lnCount,1])
        INDEX ON &laApplIndex[lnCount,2] TAG &laApplIndex[lnCount,1] ADDI
      ENDIF
    ENDFOR
    APPEND FROM (gcSysHome+'SYDAPPL.DBF')
    REPLACE ALL CDOSBUILD WITH CMDLBUILD,;
                CWINBUILD WITH CMDLBUILD,;
                CUNIXBUILD WITH CMDLBUILD,;
                CMACBUILD WITH CMDLBUILD
    USE IN (lcTmpName)
    ERASE (gcSysHome+'SYDAPPL.DBF')
    ERASE (gcSysHome+'SYDAPPL.FPT')
    ERASE (gcSysHome+'SYDAPPL.CDX')        
    RENAME (gcSysHome+lcTmpName+'.DBF') TO (gcSysHome+'SYDAPPL.DBF')
    RENAME (gcSysHome+lcTmpName+'.CDX') TO (gcSysHome+'SYDAPPL.CDX')    
    IF FILE (gcSysHome+lcTmpName+'.FPT')
      RENAME (gcSysHome+lcTmpName+'.FPT') TO (gcSysHome+'SYDAPPL.FPT')        
    ENDIF
  ENDIF
ENDIF
IF USED('SYDAPPL')
  USE IN SYDAPPL
ENDIF
*E300441,4 Hesham El-Sheltawi (End) 


*E300454,1 Hesham El-Sheltawi New function to update the setup file
*E300454,1 for the companies installed in the system
*E300633,1 Hesham El-Sheltawi (Start)
*E300633,1 change the function name to be removed later 
*E300633,1 because it will be completed changed
FUNCTION gfDumy
*FUNCTION gfUpdSetup
*E300633,1 Hesham End
PRIVATE lnCount,laCmpSetup,laApplField,lcTmpName,laApplIndex,lcActWord
DIME laCmpSetup[1,1]
STORE '' TO laCmpSetup
lcActWord=SELECT()
SELECT DIST cComp_ID FROM (gcSysHome+'SYCSETUP');
       INTO ARRAY laCmpSetup
IF USED('SYCSETUP')
  USE IN SYCSETUP
ENDIF

IF !EMPTY(laCmpSetup[1,1])
  lcTmpName=gfTempName()
  SELECT 0
  USE (gcSysHome+'SYCSETUP.DBF')
  DIME laApplField[1,4]
  STORE '' TO laApplField
  =AFIELDS(laApplField)
  DIME laApplIndex[1,2]
  STORE '' TO laApplIndex
  lnCount = 1
  DO WHILE !EMPTY(TAG(lnCount))
    IF !EMPTY(laApplIndex[1,1])
      DIME laApplIndex[ALEN(laApplIndex,1)+1,2]
    ENDIF
    laApplIndex[ALEN(laApplIndex,1),1] = TAG(lnCount)
    laApplIndex[ALEN(laApplIndex,1),2] = SYS(14,lnCount)
    lnCount = lnCount+1
  ENDDO
  USE IN SYCSETUP
  CREATE DBF (gcSysHome+lcTmpName) FROM ARRAY laApplField
  *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
  =lfCrFox2x()
  *E303074,1 TMI 02/20/2012 [End  ] 
  FOR lnCount = 1 TO ALEN(laApplIndex,1)
    IF !EMPTY(laApplIndex[lnCount,1])
      INDEX ON &laApplIndex[lnCount,2] TAG &laApplIndex[lnCount,1] ADDI
    ENDIF
  ENDFOR
  FOR lnCount = 1 TO ALEN(laCmpSetup,1)
    IF !EMPTY(laCmpSetup[lnCount,1])
      APPEND FROM (gcSysHome+'SYCCONFG')
      REPLACE ALL CCOMP_ID WITH laCmpSetup[lnCount,1];
           FOR EMPTY(cComp_id)
    ENDIF
  ENDFOR
  IF USED('SYCCONFG')
    USE IN SYCCONFG
  ENDIF
  IF !USED('SYCSETUP')
    SELECT 0
    USE (gcSysHome+'SYCSETUP')
  ENDIF
  SELECT SYCSETUP
  SET ORDER TO TAG VARNAME
  SELECT (lcTmpName)
  SET ORDER TO TAG VARNAME
  lcTagExp = SYS(14,VAL(SYS(21)))
  SET RELATION TO &lcTagExp INTO SYCSETUP ADDI
  GO TOP
  SCAN
    IF !EOF('SYCSETUP')
      REPLACE MDATA_DEF WITH SYCSETUP.MDATA_DEF
    ENDIF
  ENDSCAN
  IF USED('SYCSETUP')
    USE IN SYCSETUP
  ENDIF
  IF USED(lcTmpName)
    USE IN (lcTmpName)
  ENDIF
  ERASE (gcSysHome+'SYCSETUP.DBF')
  ERASE (gcSysHome+'SYCSETUP.FPT')
  ERASE (gcSysHome+'SYCSETUP.CDX')
  IF FILE(gcSysHome+lcTmpName+'.DBF')
    RENAME (gcSysHome+lcTmpName+'.DBF') TO (gcSysHome+'SYCSETUP.DBF')
  ENDIF
  IF FILE(gcSysHome+lcTmpName+'.FPT')
    RENAME (gcSysHome+lcTmpName+'.FPT') TO (gcSysHome+'SYCSETUP.FPT')
  ENDIF  
  IF FILE(gcSysHome+lcTmpName+'.CDX')
    RENAME (gcSysHome+lcTmpName+'.CDX') TO (gcSysHome+'SYCSETUP.CDX')
  ENDIF  
ENDIF
SELECT (lcActWord)
*E300454,1 Hesham El-Sheltawi (End)


*!*************************************************************
*! Name      : gfSetHlpFl 
*! Developer : Yasser El Oraby
*! Date      : 03/05/96
*! Purpose   : Set application file 
*!*************************************************************
*! Called by : 
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : 
*!*************************************************************
*E300279,1 New function
*
FUNCTION gfSetHlpFl

PARAMETE lcApp_ID

DO CASE
  CASE _DOS .OR. _UNIX
    lcHelpFile = "SYH"+ALLTRIM(lcApp_ID)+".DBF"
    *** Activate the dos on line help 
    IF FILE (gcSysHome+lcHelpFile)
      SET HELP TO (gcSysHome+lcHelpFile)
    ELSE  
      IF FILE (gcSysHome+"SYHHELP.DBF")
        SET HELP TO (gcSysHome+"SYHHELP")
      ENDIF 
    ENDIF
  CASE _WINDOWS
    lcHelpFile = "SYH"+ALLTRIM(lcApp_ID)+".HLP"
    *** Activate the dos on line help 
    IF FILE (gcSysHome+lcHelpFile)
      SET HELP TO (gcSysHome+lcHelpFile)
    ELSE  
      IF FILE (gcSysHome+"SYHHELP.HLP")
        SET HELP TO (gcSysHome+"SYHHELP")
      ENDIF 
    ENDIF
ENDCASE

*B601274,1 Hesham El-Sheltawi (Start)
*B601274,1 New function to add the foxprint font to the windows ini file
FUNCTION gfAddFont
IF _WINDOWS
  PRIVATE lcOldAlias,lcWinPath,lcWinSys,lcLastError,llError,llWinNt
  lcOldAlias = SELECT()
  *B601996,1 Hesham (Start)
  *B601996,1 in case of windows nt the system variable called windir
  *B601996,1 does not appear for the run time library there for
  *B601996,1 we have to distinguish between the nt and window 
  *B601996,1 by the systemroot system variable
*  lcWinPath   = GetEnv("WinDir")+'\'
  lcWinPath   = GetEnv("WinDir") 
  lcWinPath = IIF(EMPTY(lcWinPath),GetEnv("SystemRoot"),lcWinPath)+ "\"
  llWinNt = IIF(EMPTY(GetEnv("SystemRoot")),.F.,.T.)
  lcWinSys  = lcWinPath + IIF(RIGHT (OS (1), 2) = '95' OR llWinNt, 'FONTS\', 'SYSTEM\')
  *B601996,1 Hesham (End)  
  CREATE CURSOR WININI (WININI M)
  APPEND BLANK
  APPEND MEMO WININI FROM (lcWinPath+'WIN.INI')
  IF !('FoxPrint (TrueType)' $ WININI.WININI)
    lcLastError = ON('ERROR')
    llError = .F.
    ON ERROR llError=.T.
    IF !FILE(lcWinSys+'FOXPRINT.FOT') 
      COPY FILE (FULL(SET('DEFAULT'))+'FOXPRINT.FOT') TO (lcWinSys+'FOXPRINT.FOT')
    ENDIF      
    IF !FILE(lcWinSys+'FOXPRINT.TTF')     
      COPY FILE (FULL(SET('DEFAULT'))+'FOXPRINT.TTF') TO (lcWinSys+'FOXPRINT.TTF')  
    ENDIF
    *B601996,1 Hesham (Start)    
    *B601996,1 if error happend and the operating system is not 95 or nt
*    IF !llError AND RIGHT(OS(1),2)<>'95'
    IF !llError AND !(RIGHT(OS(1),2)='95' OR llWinNt)
    *B601996,1 Hesham (End)        
      REPLACE WININI.WININI WITH STRTRAN(WININI.WININI,'[fonts]','[fonts]'+;
         CHR(13)+CHR(10)+'FoxPrint (TrueType)='+lcWinSys+'FOXPRINT.FOT')
      COPY MEMO WININI TO (lcWinPath+'WIN.INI')     
    ENDIF  
    ON ERROR &lcLastError
  ENDIF
  USE IN WININI
  SELECT (lcOldAlias)
ENDIF  
*B601274,1 Hesham El-Sheltawi (End)


*E300399,1 Hesham El_Sheltawi (Start)
FUNCTION gfPrtFile
PARAMETERS lcFilePrt,llPrtFile
    *-- set printer to local port
IF _WINDOWS    
    SET PRINTER TO (gcLoclPort)
    llError=.F.
    lcOnErr=ON('ERROR')
    ON ERROR llError=.T.
    lcSetSafe=SET('SAFE')
    SET SAFE OFF
    *-- copy temprory file to local port to print it
    IF FILE(lcFilePrt)
      *B600951,1 Get the value of the output port in another variable
      gcLoclPrt = gcLoclPort
      *B600951,1 HESHAM EL-SHELTAWI 30/01/96
      *B600951,1 ADDING NEW WAY OF PRINTING
      *-- IF ENVIROMENT VARIABLE FOR PRINTING IS DEFINED
      *-- THEN PRINT BY USING THE TECH. ??? ELSE USE THE COPY COMMAND
      *-- Take care that we are setting the printer to the port in which
      *-- we want to print to before starting printing
      DO CASE
        CASE GETENV('ARIAPRN')='???'
          lcTmpCur = gfTempName() && temprory cursor
          lcWorkA = SELECT()      && curr. work area
          CREATE CURS &lcTmpCur (mprnfile M) && create temp. cursor
          APPEND BLANK 
          *-- append memo with the output file
          APPEND MEMO mprnfile FROM (lcFilePrt) 
          *-- clear the printer port then set the device to printer with the 
          *-- port needed to print.
          SET PRINTER TO 
          SET DEVICE TO PRINTER
          *B600951,1
          *SET PRINTER TO (gcLoclPort)
          SET PRINTER TO (gcLoclPrt)
          SET PRINTER ON
          *-- reset the printing cursor then start printing the memo field
          @ 0,0 SAY ""
          ??? MPRNFILE
          *-- reset the device to screen and clear the printer buffer to make
          *-- the printer start printing.
          SET DEVICE TO SCREEN
          *B600951,1
          SET PRINTER OFF
          SET PRINTER TO
          *-- close the temp. cursor and select the curr. work area
          USE IN &lcTmpCur
          SELECT (lcWorkA)          
          
        CASE UPPER(GETENV('ARIAPRN'))="COPY"
          SET PRINTER TO (gcLoclPRT)  
          lcFileNm = lcFilePrt
         !COPY &lcFileNm &gcLoclPRT

        CASE UPPER(GETENV('ARIAPRN'))="LIB"
*!*	          IF FILE("TXTSPOOL.FLL") AND FILE("PRTWIN.EXE")
*!*	            SET LIBRARY TO TXTSPOOL.FLL ADDITIVE
*!*	            lcWinPrt  = "IBM Proprinter on " + ALLTRIM(gcLoclPRT)
*!*	            lcOrgPrnt =PRTWIN(LCWINPRT)
*!*	            lcFileNm = lcFilePrt
*!*	            =TXTSPOOL(lcFileNm ,"ARIA SYSTEMS")
*!*	            = PRTWIN(lcOrgPrnt)
*!*	            RELEASE LIBRARY TXTSPOOL.FLL
*!*	          ENDIF
          
        OTHERWISE
          COPY FILE (lcFilePrt) TO (gcLoclPort+'.DOS')
          
      ENDCASE
      IF llPrtFile
        ON ERROR &lcOnErr
        SET SAFE &lcSetSafe    
        *--delete temprory file
        ERASE (lcFilePrt)
      ENDIF  
    ENDIF  
ELSE
   lcPaprTyp= IIF(gnPrint_Wd=240,'XW',IIF(gnPrint_Wd=132,'W','N'))
   lcPrintset  = ""
   IF glPrnt_Lan                && if it is a lan option
     lcPrintSet = '\\SPOOLER\P='+ALLTRIM(STR(gnPrnt_No))+'\S='+ALLTRIM(gcServ_Nam);
                     +'\Q='+ALLTRIM(gcQueu_nam);
                     +IIF(glBaner,'\B='+gcBaner_H,'\N');
                     +IIF(_pCopies>1,"\C="+ALLTRIM(STR(_PCOPIES)),"")
   ELSE
     lcPrintSet = gcPrnt_Port               
   ENDIF       
   lnRMargin = _RMARGIN
   _RMARGIN = lnRepWidth
   SET PRINTER TO &lcPrintSet
  lcPdSetup = _PDSETUP
  _PDSETUP=''
  lcConsolr = SET('CONS')
  SET CONS OFF
  TYPE (lcFilePrt) TO PRINTER
  SET CONS &lcConsolr
  _RMARGIN = lnRMargin
  _PDSETUP=lcPdSetup
   SET PRINTER TO
   IF llPrtFile
     ERASE (lcFilePrt)
   ENDIF
ENDIF
RETURN

*!*********************************************************************
*!
*!      Procedure: PRDDOCST
*!
*!*********************************************************************
PROCEDURE PRDdocst
PARAMETER m.doc_height, m.doc_width
PRIVATE m.ctlchars, m.flen
IF TYPE('_PDPARMS')='U'
  RETURN ''
ENDIF
*WAIT 'Doc Height='+ALLT(STR(M.DOC_HEIGHT))+' ,Doc Width='+ALLT(STR(M.DOC_width)) WINDOW
	*
	* Build the control characters for the initialization of the printer.
	* These are stored in specific positions of the array _pdparms.
	* Also, for reports, store the page height and width.
	*

	_pdparms[28] = m.doc_height

	*
	* Check for embeded pagelength to be substitued in at runtime.
	*

	m.flen = ""
	m.first = AT("{#}",_pdparms[5])
	IF m.first > 0

		m.flen = LEFT(_pdparms[5],m.first-1) + ;
			ALLTRIM(STR(m.doc_height)) + ALLTRIM(SUBSTR(_pdparms[5], m.first+3))
	ELSE
		m.first = AT("{#B}",_pdparms[5])
		IF m.first > 0

			m.flen = LEFT(_pdparms[5],m.first-1) + ;
				CHR(m.doc_height) + ALLTRIM(SUBSTR(_pdparms[5], m.first+4))
		ENDIF

	ENDIF


	*
	* Calculate Dots per Column, if _pdparms[47] is not 0.  Otherwise,
	* the Horizontal Movement command will move by columns.
	*
	
	IF _pdparms[47] != 0
		
		*
		* In order to avoid printing in the dead space on the right side of 
		* the page we add 2 to the column width.
		*
		_pdparms[48] = _pdparms[47] / (m.doc_width +2)
	ENDIF
	
	IF _pdparms[49] != 0
		_pdparms[50] = INT(_pdparms[49] * _pdparms[44] * 300)
	ENDIF
    IF TYPE('glPrtAcomp')='L' AND glPrtAcomp=.T. AND TYPE('gnPrint_Wd')='N' AND m.doc_width>gnPrint_Wd
      lcCompType = ALLTRIM(gc16CPInch)
    ELSE  		
      lcCompType = _pdparms[8]
    ENDIF
      m.ctlchars = _pdparms[3] + _pdparms[10] + ;
		lcCompType + _pdparms[25] + _pdparms[26] + _pdparms[45] + ;
		IIF(EMPTY(_pdparms[40]), REPLICATE(IIF(EMPTY(_pdparms[22]), ;
 		  CHR(13)+CHR(10), _pdparms[22]), _pdparms[41]), _pdparms[40]) + ;
		_pdparms[7] + m.flen 

	_pdparms[29] = m.doc_width
	_pdparms[21] = .F.
	_pdparms[27] = 1
    _pdparms[39] = .F.           && page eject flag
RETURN m.ctlchars

*!*********************************************************************
*!
*!      Procedure: PRDDOCEND
*!
*!*********************************************************************
PROCEDURE PRDdocend			&& Return any reset printer characters.
PRIVATE m.ctlchars
IF TYPE('_PDPARMS')='U'
  RETURN ''
ENDIF
	m.ctlchars = IIF(EMPTY(_pdparms[3]), "", _pdparms[3])
	_pdparms[42] =""
RETURN m.ctlchars

*E300399,1 Hesham El_Sheltawi (End)

*E300581,1 Hesham El_Sheltawi (Start)
*!*********************************************************************
*!
*!      FUNCTION: gfRunAppPrg
*!
*!*********************************************************************
FUNCTION gfRunAppPrg
PARAMETERS lcPrgType,lcProgName,lcParamters
lcAppName = 'ARIA'
lcAPPPath = FULL(SET('DEFA'))
*lcAPPPath = SUBSTR(lcAPPPath,1,RAT("\",lcAPPPath))
IF RDLEVEL()>1 OR WONTOP()<> 'FNDATION'
  *** Please close all the open programs first...!
  =gfModalgen("TRM00160B00000","ALERT")
  glFirsTime = .F.
  RETURN .f.
ENDIF
IF lcPrgType = 'P'
  IF !gfSetup()
    glFirsTime = .F.
    RETURN .f.
  ENDIF
ENDIF  
*MAN Added !FILE((lcAPPPath+lcAppName+'.EXE'))
IF !FILE((lcAPPPath+lcAppName+'.FXP')) .AND. ;
   !FILE((lcAPPPath+lcAppName+'.PRG')) .AND. ;
   !FILE((lcAPPPath+lcAppName+'.EXE'))
  *** Program +lcAPPPath+lcAppName+ dose not exist...!
  =gfModalgen("TRM00161B00000","ALERT",lcAPPPath+lcAppName)
  RETURN
ENDIF

*B600991 MAN 06/05/96 Start
IF FILE((lcAPPPath+'CONTROL.DBF')) AND 'ARIA' $ lcAppName 
  IF EMPTY(gcAct_comp)
    *You have to create or select a company before selecting this module.    =gfModalgen("INM00058B00000","DIALOG")
    =gfModalgen("INM00058B00000","DIALOG")
    RETURN
  ENDIF

  lcCurAl = ALIAS()
  SELECT 0
  USE (lcAPPPath+'CONTROL.DBF')
  LOCATE FOR SYSCODE = gcAct_comp 
  IF !FOUND()
    =gfModalgen("INM00252B00000","DIALOG",gcAct_Comp)
    USE
    RETURN
  ENDIF
  USE
  SELECT IIF(EMPTY(lcCurAl),SELECT(0), lcCurAl)
ENDIF
*B600991 END

*E300279,1  SET Help Topic to the related one in the menu file.
*DECLARE laOldSets(64)                   && Array to save old values
DECLARE laOldSets(65)                   && Array to save old values
*E300279,1 End

*B600305,1 Define the temp name of the view, macro, and memory file to save the current environment
lcTmp_Nm = gfTempName()

*B600342,1 Stop screen saving
*SAVE SCREEN TO gcOldScreen

*B600305 use the temp file name instead of the fix one for the view file 
CREATE VIEW (gcWorkDir+lcTmp_Nm)
*CREATE VIEW (gcWorkDir+"AAS")

*B600421,1 Only save resource files under Dos and when the resources is ON
IF _DOS AND SET("RESOURCE") = "ON"
  CREATE COLOR SET OLDSET
ENDIF

*B600305 use the temp file name instead of the fix one for the macro file 
SAVE MACROS TO (gcWorkDir+lcTmp_Nm)
*SAVE MACROS TO (gcWorkDir+"AAS")

lcErorHand    = ON ('ERROR')
laOldSets(1)  = SET("AUTOSAVE")
laOldSets(2)  = SET("BELL")
laOldSets(3)  = SET("BLINK")
laOldSets(4)  = STR(SET("BLOCKSIZE"))
laOldSets(5)  = SET("CARRY")
laOldSets(6)  = SET("CENTURY")
laOldSets(7)  = SET("CLEAR")
laOldSets(8)  = SET("CLOCK")
laOldSets(9)  = SET("COLOR")
laOldSets(10) = SET("COMPATIBLE")
laOldSets(11) = SET("CONFIRM")
laOldSets(12) = SET("CONSOLE")
laOldSets(13) = SET("CURRENCY")
laOldSets(14) = SET("DATE")
laOldSets(15) = SET("DEBUG")
laOldSets(16) = STR(SET("DECIMALS"))
laOldSets(17) = FULLPATH(SET("DEFAULT"))
laOldSets(18) = SET("DELETED")
laOldSets(19) = SET("DELIMITERS")
laOldSets(20) = SET("DEVELOPMENT")
laOldSets(21) = SET("DEVICE")
laOldSets(22) = SET("DOHISTORY")
laOldSets(23) = SET("ECHO")
laOldSets(24) = SET("ESCAPE")
laOldSets(25) = SET("EXACT")
laOldSets(26) = SET("EXCLUSIVE")
laOldSets(27) = SET("FIELDS")
laOldSets(28) = SET("FILTER")
laOldSets(29) = SET("FIXED")
laOldSets(30) = SET("FULLPATH")
laOldSets(31) = SET("HEADING")
laOldSets(32) = SET("HELP")
laOldSets(33) = SET("HISTORY")
laOldSets(34) = STR(SET("HOURS"))
laOldSets(35) = SET("INTENSITY")
laOldSets(36) = STR(SET("MARGIN"))
laOldSets(37) = SET("MARK")
laOldSets(38) = STR(SET("MEMOWIDTH"))
laOldSets(39) = SET("MENU")
laOldSets(40) = SET("MESSAGE")
laOldSets(41) = STR(SET("MOUSE",1))
laOldSets(42) = SET("NEAR")
laOldSets(43) = STR(SET("ODOMETER"))
laOldSets(44) = SET("PATH")
laOldSets(45) = SET("POINT")
laOldSets(46) = SET("PRINT")
laOldSets(47) = SET("RESOURCE")
laOldSets(48) = SET("SAFETY")
laOldSets(49) = SET("SCOREBOARD")
laOldSets(50) = SET("SEPARATOR")
laOldSets(51) = SET("SHADOW")
laOldSets(52) = SET("SPACE")
laOldSets(53) = SET("STATUS")
laOldSets(54) = SET("STEP")
laOldSets(55) = SET("STICKY")
laOldSets(56) = SET("SYSMENUS")
laOldSets(57) = SET("TALK")
laOldSets(58) = SET("TITLE")
laOldSets(59) = STR(SET("TYPEAHEAD"))
laOldSets(60) = SET("UNIQUE")
laOldSets(61) = INSMODE()
laOldSets(62) = CAPSLOCK()
laOldSets(63) = NUMLOCK()
*E300279,1  SET Help Topic to the related one in the menu file.
laOldSets(65) = SET('TOPIC')
*E300279,1 End
lcOldAlias    = ALIAS()

SET CLOCK OFF

*B600305 use the temp file name instead of the fix one for the memory file 
SAVE ALL LIKE * TO &gcWorkDir.&lcTmp_Nm
*SAVE ALL LIKE * TO &gcWorkDir.AAS

*E300251,1 Release Public Variables before leaving the system
DO gpRlsPbl

*B600420,1 The menu pushing will be only under dos as we only pop it under dos
IF _DOS
  PUSH MENU _MSYSMENU
ENDIF
PUSH KEY

****************************************************************************
SET DEFAULT TO &lcAPPPath
llExitVal = .F.
IF WEXIST('FNDATION')
  ACTIVATE WINDOW FNDATION
ENDIF  
CLEAR TYPEAHEAD
IF TYPE('lcParamters')='C'
  DO (lcAppName) WITH IIF(lcPrgType='R','R','P'),lcProgName,lcParamters
ELSE
  DO (lcAppName) WITH IIF(lcPrgType='R','R','P'),lcProgName
ENDIF  
SET RESO ON
*WAIT "Restoring old environment.  Please standby...!" WINDOW NOWAIT
CLOSE DATABASES
****************************************************************************

POP KEY ALL
*B600303 IF WINDOWS DO NOT POP THE MENU
*E300581,1 HESHAM EL-SHELTAWI (START)
*IF _WINDOWS
*  POP MENU _MSYSMENU TO MASTER
*  SET SYSMENU TO
*ELSE
*  POP MENU _MSYSMENU
*ENDIF
*E300581,1 HESHAM EL-SHELTAWI (eND)
*E300251,1 Define the Public variables 
DO gpDfnPbl

*B600305,1 use the temp file name instead of the fix one for the memory file 
RESTORE FROM &gcWorkDir.&lcTmp_Nm ADDITIVE
*RESTORE FROM &gcWorkDir.AAS ADDITIVE

*B600304 SET the default path before reOpening the files
SET DEFAULT TO  &laOldSets(17)
*B600305 use the temp file name instead of the fix one for the VIEW file 
*B600303 The set view command was used before defining the foundation window as while defining the window we use the system file
SET VIEW TO  (gcWorkDir+lcTmp_Nm)


*B600303 If the foundation window not defined and running under windows
IF _WINDOWS .AND. !WEXIST('fndation')
  *B600303,1 Change the "Microsoft Fox" screen title to "Aria Advantage Series"
  *B600439,1 ADD THE ACTIVE COMPANY TO THE DISPLAY IN THE MAIN WINDOW TITLE
  MODIFY WINDOW SCREEN FONT"FOXFONT",9 STYLE 'N';
	 TITLE ALLTRIM(gcSysName)+IIF(EMPTY(gcApp_Name),""," - ")+ALLTRIM(gcApp_Name)+ ;
	 IIF(!EMPTY(gcAct_Comp),' ('+ALLTRIM(gcAct_Comp)+')','');
	 FLOAT;
	 ZOOM;
	 GROW 
  *E301077,78 Hesham (Start)
  llInstUse=gfSysOpen(gcSysHome+'SYCINST')
  *E301077,78 Hesham (End)


  *B600303 if there is default bmp file display it
  IF !EMPTY(sycinst.cDef_BMP) AND FILE(gcBmpHome+ALLTRIM(sycinst.cDef_BMP))
    DEFINE WINDOW fndation   ;
	   FONT "FoxFont", 9 ;
       AT 0,0 SIZE SROWS(),SCOLS() ;
	   NONE &&FILL FILE (gcBmpHome+ALLTRIM(sycinst.cDef_BMP)) 
	   ACTIVATE WINDOW FNDATION
      @0,0 say (gcBmpHome+ALLTRIM(sycinst.cDef_BMP))  bitmap size SROW(),SCOL() CENTER STYLE "Q"
  ELSE
    DEFINE WINDOW fndation   ;
	   FONT "FoxFont", 9 ;
       AT 0,0 SIZE SROWS(),SCOLS() ;
	   NONE 
  ENDIF         
*  ACTIVATE WINDOW fndation

  *B600342,1 Redraw the Aria Advantage Screen instead of saving and restoring it.
  *B600342,1 If there is default bmp file in the user file display it
  IF !EMPTY (gcUser_bmp) .and. ;
       ALLTRIM(sycinst.cDef_BMP) <> gcUser_bmp AND FILE(gcBmpHome+gcUser_bmp )
 *E300791,1 Hesham (Start)           
*      MODIFY WINDOW fndation FILL FILE (gcBmpHome+gcUser_bmp )
      @0,0 CLEAR TO SROW(),SCOL()
      @0,0 say (gcBmpHome+gcUser_bmp) bitmap size SROW(),SCOL() CENTER STYLE "Q"
 *E300791,1 Hesham (End)  
  ENDIF  
  *E301077,78 Hesham (Start)
  USE IN IIF(llInstUse,'SYCINST',0)
  *E301077,78 Hesham (End)
  
*E300791,1 Hesham (Start)  
*  @ 8.2,8.2 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W    
*  @ 8.1,8.1 SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR W  
*  @ 8,8     SAY "Aria Systems" FONT "Times New Roman",70 STYLE "BIT" COLOR R*	
*E300791,1 Hesham (End)
ENDIF
*B600303,1 Redefine the Aria Advantage Sysmenu as it is released under Aria Apparel (under WIN) due to the MDI settings
*E300581,1 HESHAM EL-SHELTAWI (START)
*IF _WINDOWS 
*  SET SYSMENU TO
*  glInitMenu = .T.
*  IF !EMPTY(gcAct_Appl)
   *B600420,1 Pop the menu before building the sysmenu
*    POP MENU _MSYSMENU
*    =gfMenuBld('SY','I','NOSHOW')
*    =gfMenuBld('SY','S')
*    =gfMenuBld(gcAct_Appl,'A')
*    glInitMenu = .F.
*  ELSE
*    =gfMenuBld('SY','I')       
*  ENDIF
*ENDIF
*E300581,1 HESHAM EL-SHELTAWI (END)


SET AUTOSAVE     &laOldSets(1)
SET BELL         &laOldSets(2)
SET blink        &laOldSets(3)
SET BLOCKSIZE TO &laOldSets(4)
SET CARRY        &laOldSets(5)
SET CENTURY      &laOldSets(6)
SET CLEAR        &laOldSets(7)
SET CLOCK        &laOldSets(8)
SET COLOR TO     &laOldSets(9)
SET compatible   &laOldSets(10)
SET CONFIRM      &laOldSets(11)
SET CONSOLE      &laOldSets(12)
SET CURRENCY     &laOldSets(13)
SET DATE         &laOldSets(14)
SET DEBUG        &laOldSets(15)
SET DECIMALS TO  &laOldSets(16)
*B600304 This line is moved before set view as the set view was moved before the defination of the foundation window
*SET DEFAULT TO   &laOldSets(17)
SET DELETED      &laOldSets(18)
SET DELIMITERS   &laOldSets(19)
SET DEVELOPMENT  &laOldSets(20)
SET DEVICE TO    &laOldSets(21)
SET DOHISTORY    &laOldSets(22)
SET ECHO         &laOldSets(23)
SET ESCAPE       &laOldSets(24)
SET EXACT        &laOldSets(25)
SET EXCLUSIVE    &laOldSets(26)


SET FIXED        &laOldSets(29)
SET FULLPATH     &laOldSets(30)
SET HEADING      &laOldSets(31)
SET HELP         &laOldSets(32)
SET HISTORY      &laOldSets(33)
SET HOURS TO     &laOldSets(34)
SET INTENSITY    &laOldSets(35)
SET MARGIN TO    &laOldSets(36)
SET MARK TO      &laOldSets(37)
SET MEMOWIDTH TO &laOldSets(38)
SET MENU         &laOldSets(39)
SET MESSAGE TO   &laOldSets(40)
SET mouse TO     &laOldSets(41)
SET NEAR         &laOldSets(42)
SET ODOMETER TO  &laOldSets(43)
SET PATH TO      &laOldSets(44)
SET POINT TO     &laOldSets(45)
SET PRINT        &laOldSets(46)
SET RESOURCE     &laOldSets(47)
SET SAFETY       &laOldSets(48)
SET SCOREBOARD   &laOldSets(49)
SET SEPARATOR TO &laOldSets(50)
SET SHADOW       &laOldSets(51)
SET SPACE        &laOldSets(52)
SET STATUS       &laOldSets(53)
SET STEP         &laOldSets(54)
SET sticky       &laOldSets(55)
*SET sysmenus     &laOldSets(56)
SET TALK         &laOldSets(57)
SET TITLE        &laOldSets(58)
SET TYPEAHEAD TO &laOldSets(59)
SET UNIQUE       &laOldSets(60)
*E300279,1  SET Help Topic to the related one in the menu file.
*SET TOPIC TO &gcHelpTopc
SET TOPIC TO &laOldSets(65)
*E300279,1  END

ON ERROR &lcErorHand

= INSMODE(laOldSets(61))                        && Note usefulness of
*MAN
*= CAPSLOCK(laOldSets(62))                       && '=' evaluate command.
*= NUMLOCK(laOldSets(63))
*B600303 Moved the files Opening before the defining of the foundtion window
*SET VIEW TO  (gcWorkDir+"AAS")



IF !EMPTY(lcOldAlias)
  SELECT (lcOldAlias)
  SET FIELDS       &laOldSets(27)
  SET FILTER TO    &laOldSets(28)
ENDIF  

*B600305 use the temp file name instead of the fix one for the macro file 
RESTORE MACROS FROM &gcWorkDir.&lcTmp_Nm
*RESTORE MACROS FROM &gcWorkDir.AAS

IF _DOS AND SET('RESOURCE') = "ON"
  SET COLOR SET TO OLDSET
ENDIF

*B600456,1 Restoring the old background and the status bar when coming back from Apparel
*B600456,1 system
*#IF _DOS
*  @ 0,0,SROWS(),79 BOX REPLICATE("",9)
*  DO gpDispStat  
*#ENDIF
  
*B600342,1 Stop the screen restoring and releasing
*RESTORE SCREEN FROM gcOldScreen
*RELEASE gcOldScreen


RELEASE laOldSets

*B600305 use the temp file name instead of the fix one 
ERASE (gcWorkDir +lcTmp_Nm +".MEM")
ERASE (gcWorkDir +lcTmp_Nm +".VUE")
ERASE (gcWorkDir +lcTmp_Nm +".FKY")
*ERASE &gcWorkDir.AAS.MEM
*ERASE &gcWorkDir.AAS.VUE
*ERASE &gcWorkDir.AAS.FKY
IF lcPrgType = 'P'
  glQuitting = .T.
  =gfCleanUp()
ENDIF  

*WAIT CLEAR

*IF llExitVal
*  KEYBOARD "{ENTER}"
*  =gpExit()
*ELSE
*  KEYBOARD "{ALT+M}" PLAIN CLEAR
*ENDIF
*E300581,1 Hesham El_Sheltawi (End)



*E300581,1 Hesham El-Sheltawi (Start)
*E300581,1 Merging the MainProc Functions that will be used by
*E300581,1 the apparel programs
**************** MainProc Functions For Apparel System ****************
*!*********************************************************************
*! Name : MAINPROC.PRG
*! Desc: MAIN PROCEDURE FILE
*! Date : 11/18/89
*! --------------------------------------------------------------------
*! Modifications :
*!    SMH 03/23/94 :
*!        1) Changed "RETURN TO MASTER" to "RETURN" in (PR_ERRORS,
*!           P0FLOCKD,P0RLOCKD,SEL_DEV)  
*!            (to be sutable with the new menuing system)
*!    WAM 03/29/94 
*!        1) Add a new field 'GlACNTTYPE' in 'GLDIST.MDL' file to hold
*!           Type of account [ Control account or Distribution account].
*!        2) Update the field 'GLACNTTYPE' with the account type depends
*!           on the passed category key.
*!        3) Modification in 'GLDIST Procedure' :-
*!           If the link code not found in 'GL_LINK' file (Zap the file 
*!           for example), Default link code to 'DEF'.
*!        4) Load the new public variables : QCURRPRD, QCURRYEAR, QPRDCNTRL
*!           and QBegBalDt in a separate procedure FLinkInfo to call it
*!           from SET100 also.
*!    WAM 04/20/94
*!        1) Modification in 'GLDIST' procedure :-
*!          Add three category keyes '015', '016' and '017' for material
*!          inventory control, inventory adjustment and P/O clearing.
*!    MFM 04/20/94 
*!        1) Added the glbal procedure to browse the styles for
*!           a specific warehouse procedure name gfWareStls.
*!    YMA 05/02/94 
*!        1) Inititalize the row for the pointer before going to 
*!           the browse procedure. (Procedure StyBrow)
*!    ARH 05/05/94 :
*!        1) Added the ability not to display the empty dyelots
*!             in the style dyelots browse (Procedure SDYEBROW).
*!    YMA 05/10/94 :
*!        1) Added a new gloabl procedure called 'gpStDyBrow' which is
*!           to browse the dyelots for a specific Style/Color at
*!           a specific warehouse. 
*!    YMA 05/03/94.
*!        1) Added a new procedure 'gpAdStyWar' to append a new record to 
*!           the StyDye file.
*!    WAM 05/08/94
*!        1) Add a new option 'Close period' in FILE UTILITY menu.
*!    MFM 05/30/94
*!        1) In PROCEDURE gpAdStyWar saved the current 
*!           alias befor doing any thing.
*!    ARH 05/31/94
*!        1) Removed the SKIP command from the SCAN loop to make the loop
*!           work fine (Procedure RABROW).
*!    TAK 06/05/94
*!           1) Added special character (~) to determine a new page in report
*!              heder printing to eleminate determination on company name.  
*!    YMA 06/12/94
*!        1) Added a new global procedure called gpClrBrow.
*!    ARH 06/12/94 :
*!        1) Set the value of BP(6) & BP(7) to 'N' so that it's not
*!           affected from any outside calling program (REPCHK).
*!    ARH 06/14/94
*!        1) Increased the color code to be 6 chrs. instead of 3 chrs.
*!           and decreased the style # to be 12 chrs. instead of 15 chrs.
*!           (Procedures : StyBrow/StyBrowC/FaBrow/FaBrowC/CutBrow)
*!           (Functions  : gfWareStls).
*!    YMA 06/28/94
*!        1) Added the following global procedures:
*!           A) : gpFbDyBrow.
*!           B) : gpWareFabs.
*!           C) : gpAdFabWar.
*!    YMA 06/30/94 
*!        1) Added the setup of the BP array in procedure 'FaBrow'.
*!    MFM 07/02/94
*!        1) Rewrite the device selection procedure to work with the batch
*!           printing and to be more redable.
*!        2) Added new function gfIntVar to initialize printer settings
*!           in both cases direct printing or batch printing.
*!        3) Added new function gfToPrn to set the printer and according to
*!           printer escap sequance saved in the file 'Printers' file.
*!        4) Added new function gfPrnErr a new error handler to cover the
*!           errors from setting the printer in the network version.
*!        5) Changed to work with batch mode in the error handler procedure.
*!    YMA 07/04/94
*!        1) Changed the gfWareStls browse technique to use a temp. file 
*!           instead of browsing the master StyDye file,
*!           (Function gfWareStls).
*!    TAK 07/05/94
*!        1) Added new function gfPrtBrow() to browse the
*!           Printer Personality numbers and models.
*!    TMI 07/06/94
*!        1) Changed the line of pointer from line#5 to line #6 in case of
*!           show the desc of colors. 
*!    TMI 07/07/94
*!        1) Commented out to point to the record in FABROW.
*!    MFM 07/12/94
*!        1) Added new brows for vendor to get and validate vendor code
*!           from the AP directory if system is seted to link with AP
*!           the brows called 'gfAPVnBrow' and the calling syntax is
*!           'gfAPVnBrow( @lcVenCod )'.
*!        2) Incresed the vendor code to 8 characters in the following
*!           'VenBrow', 'LCBrow', 'FaBrow', 'FaBrowC','PosBrow'
*!        3) Adde new function to get the order of the address if link with ap.
*!           use AP link.
*!    MFM 07/13/94
*!        1) Fixed bug of chacking the status of the printer in network
*!           printing mode( we should only check for the queue and server ).
*!    YMA 07/14/94 
*!        1) Removed the 'CodCharge, InsCharge' fields from the control
*!           file and added them to the code file.
*!        2) Removed the loading of the 'xCodCharge,xInsCharge' variables
*!           from the control file.
*!        3) Added tow extra parameter to the 'GetFrght' procedure called 
*!           'xCodCharge,xInsCharge' to hold the COD & Insurance charge 
*!           from the code file instead of the control file.
*!    YMA 07/25/94
*!        1) Added a new procedure called 'gpApLnkMsg'.
*!    TMI 07/27/94
*!          1) Added the ability to validate the vendor information
*!            from vendor file of the Aria Advantage series system 
*!            instead of our vendor file if the system was setup to
*!            link with the AP module.
*!    ARH 07/27/94 :
*!        1) Added the computing of the time the job is put 
*!           in the batch server file and added two fields 
*!           (DINDATE,CINTIME).
*!    TAK 08/18/94
*!        1) Change ORDBROWA and ORDBROWO due to adding the ability to
*!           enter multiple customer po# for multi store order.
*!    YMA 09/07/94
*!        1) Added the saving of the cost field in the 'gpAdStyWar' 
*!           procedure.
*!    MFM 09/14/94
*!        1) Changed the file from 'Codes' to be 'SycInt' to get
*!           the correct address order in 'gfVenAdr'.
*!    TMI 09/18/94
*!        1) Made the screen in insert mode all the time until
*!           the user press "ESC" or "ENTER" to abort [PROCEDURE gpClrBrow].
*!    MFM 09/18/94
*!        1) Fixed the bug of not creating notepade for style after the
*!           style increase in the notepade procedure.
*!    WAM 09/19/94
*!        1) Function 'Checkprd' has been modified to call the function 
*!           'gfDialog' instead of the function 'MsgCenter' to display 
*!           messages when validate transactions dates. Function
*!           'MsgCenter' has been deleted also.      
*!    YMA 11/01/94
*!        1) Modified procedure 'gpAdFabWar' to get the GL. link 
*!           code from the user instead of defaulting it from the 
*!           warehouse file.
*!    YMA 11/02/94
*!        1) Added the following new functions :
*!           A) gfMtLtBr.
*!           B) lfVldAply.
*!           C) lpPrpMtJlF.
*!           D) lfGetTran.
*!           To be used if useing the material lot costing method.
*!    TAK 11/03/94
*!        1) Added new procedure called GpCrtBom to create records
*!           with type two in bom detail file.
*!    WAM 11/23/94
*!        1) Add a new function 'lfBrowType' to browse all available link 
*!           code types.
*!        2) Add a new parameter in the 'GLBROW' function to browse only 
*!           link codes having a specific type. 
*!    TAK 11/24/94
*!        1) Added new procedure called gpApdBom to append a new records
*!           with type '1' in bom detail file and update the cuttkt bom
*!           file if added a new line in Open status P/O or CUTTKT .
*!    TMI 11/27/94
*!        1) Modified the coordinates of scale brows to be consistant with 
*!           the increased scale desc. field from 3 chars. to 5 chars. and 
*!           made all necessary modifications.        
*!        2) Modified the coordinates of PREPBROW to be consistant with 
*!           the increased scale desc. field from 3 chars. to 5 chars. and 
*!           made all necessary modifications.        
*!        11/27/94 TMI
*!         1) Modified the coordinates of Desplaying prepak desc. to be consistant with 
*!            the increased scale desc. field from 3 chars. to 5 chars. and 
*!            made all necessary modifications. in FUNCTION [COD_VAL]
*!        12/07/94 TAK
*!         1) Fixed bug when changing the style/color not in a wherhouse
*!            called form issue invoice (Warehowse not opend).
*!      MFM 12/11/94
*!          1) Made modifications to cover the required modifications in the
*!             LC program(Sty660) IN PROCEDURE LcBrow.
*!      TAK 12/18/94
*!          1) Added in procedure GpCrtBom to create type '2' in case of
*!             found type '2' but RSession no not empty ,we create type '2'
*!             with empty RSession to use it in PO receive program.
*!      TMI 12/27/94  
*!              1) Fixed the bug of return 3 digits from cancellation reason
*!                 xtype = 'O' instead of 2 digits , by adding xtype to IIF statment.         
*!      MFM 01/02/95.
*!          1) Added new filed to the control file 'nReleaseNo'.
*!          2) Added the memory var. 'M_ReleNo' holding the release number
*!             stored in the control file.
*!          3) Added new procedure 'Install' to handle the first time installation
*!             and the upgrade of the release (case of control.new) problems.
*!          4) Created a new file 'FIXPRG' holding the fix programs this file
*!             will be sended as a DBF file every time a new fix program is
*!             added (the file location at the LIB\ directory).
*!      YMA 01/12/95
*!          1) Added the facility to generate the sequence code according
*!             to the new added "Division Technique" which is :
*!             - Splitting the numeric fields in the sequence file into
*!               five different divisions, each of them has it's own code
*!               sequence. We will name these field by adding the main 
*!               field name + the division group which will be validated
*!               from the code file.
*!               This new added facility will be available if the
*!               value of the variable "M_Div_Seq" is "Y" otherwise the old
*!               technique will be used.
*!             - In order to add this facility to the "sequence" procedure
*!               we added a new parameter called "lcDivision" which will
*!               hold the nedded division number.
*!               If this parameter is not defined we assume that the calling
*!               program is tring to deal with a numeric sequence field
*!               that have no division groups.
*!      YMA 01/22/95 
*!          1) Modified the color width according to the "cSyClr126"
*!             field in the control file. PROCEDUER (gpClrBrow).
*!      TMI 01/23/95
*!           1) Fixed the bug of the pointer indecating to the headr record
*!             in template.   
*!      MFM 02/15/95
*!          1) Fixed bug of infinet traping in the browse when you exeed
*!             more than 1 page of entry in 'gpClrBrow'.
*!      TAK 02/16/95 
*!          1) Change the way of reading sequence numbers from sequence
*!             file and that by going to given division group.
*!      MFM 02/19/95
*!          1) Make the changes that was done by 'AMR HEGAZY (ARH)' in
*!             U.S.A. to work with the MAC.Ver and documented !?!?
*!             'EndPrt', 'gfToPrn'.
*!     WAM 03/05/95
*!          1) Add a new account '020' for Return Merchandise in GL_CATG file
*!          2) Do not add entry in the GLDIST file for zero amount.
*!          3) Modifications in procedure GLBROW()
*!     MFM 03/05/95
*!          1) Modified the SQL-command to select 'nUntCstBuy' to the 
*!             temp file in function 'gfMtLtBr'.
*!      WAM 03/08/95
*!          1) Check that the generated number is not redundant when generating
*!             a new sequence number.
*!     MFM 03/12/95
*!          1) Modified the SQL-command to select 'cTrn_Seq' to the 
*!             temp file in function 'gfMtLtBr'.
*!     TAK 03/30/95
*!          1) Added Global Procedure (gpUdtSJl) To Update The Style 
*!             Inventory Journal File.
*!****************************************************************************
*B500660,1 SHL 04/27/95 Fix the soft seek of the style browse
*B600331,1 YMA 05/30/95 Fixed a bug of saving the "Ave_Cost" field
*B600331,1              in case of adding a dyelot record using 
*B600331,1              procedure "gpAdStyWar".
*B500763,1 YMA 06/05/95 Added the soft seek part in the vendor browse
*B500763,1              when the system is linked with the AP module. 
*B500763,1              FUNCTION(gfApVnBrow).
*N000016,4 WAM 05/07/95 Add a new parameter 'lcFromWare' to procedures
*N000016,4              'FDYEBROW' to browse dyelots for specific warehouse 
*N000016,4 REN 05/17/95 Add function gfMFGOrdBr for validating material 
*N000016,4              maunufacturing orders to seek, or, browse through
*N000016,4              the file for selection.
*B500653,1 RAM 04/26/95 1) Change the fields width to prevent the 
*B500653,1                 horizontal scrolling in the browse.
*B500653,1              2) Fix calculating Open to sell field.
*B500661,1 RAM 04/26/95 Fix displaying the price in the style browse.
*B500661,1 RAM 06/12/95 ** {{  lfSum_OTS - lfSumSeasn  }} **
*B500661,1              Remarke the returned line to return with 
*B500661,1              fields because all of them integer anyway.
*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1              name to be in the status message. 
*E300247,1              PROCEDURE (NetUse, gfOpenFile)
*E300244,1 YI color for selected objects
*B600289,1 YI _ we need a new relation into the warehouse file
*B600289,1      and the styl journal
*B600289,1    _ Update the warehouse records with the new cose
*B600429,1 RAM 06/14/95
*B600429,1 1-  CUSBROW function --> change all the browse fields under windows
*B600429,1     to display all the customer browse in a proper way.
*B600429,1 2-  REPCHK function --> Add more fields to the browse fields.
*B600429,1 3-  FACCHK function --> Add more fields to the browse fields.
*B600429,1 4-  ORDBROW function --> Change the header of the ship Qty & Amt 
*B600429,1     & Open Qty & Amt. Add Open Qty field to the browse.
*B600429,1 5-  STYBROW function --> Change the width of the browse fields.
*B600429,1 RAM 06/15/95
*B600429,1 6-  VENBROW function --> Change the width of the browse fields.
*B600429,1 7-  POSBROW function --> Change the width of the browse fields.
*B600429,1 8-  gfApVnBrow function --> Change the width of the browse fields.
*B600429,1 9-  FABROW function --> Change the width of the browse fields.
*B600429,1 10- lfSumFab function --> Return with integer of the value.
*B600429,1 11- POFBROW function --> Change the width of the browse fields.
*B600429,1 RAM 06/17/95
*B600429,1 12- gfScalBrow function --> Change the scale sizes width in the browse.
*B600429,1 13- gfPrePBrow function --> Change prepak sizes under win in the browse.
*B600441,1 RENEE 06/15/95. Fix the problem of the browse window being
*B600441,1                 right shifted under WINDOWS in CODECHK, 
*B600441,1                 and gfBrowWare browses.
*B600455,1 MAN 06/16/95 Fix the problem of calling the ADV GETEXPR
*B600455,1 MAN          in case of running under ADV 
*B600455,1 MAN          Changed the name of GETEXPR to be AGETEXPR
*B600322 Hesham El-Sheltawi 06/18/95
*B600322 if the user pressed double click with the mouse in any of the
*B600322 scroll bars "Horz.,Vert." ignore it and dont select the active
*B600322 record, we added the checking if the MROW AND THE MCOL inside
*B600322 the browse window with out taking the position of the scroll
*B600322 bars in out consideration
*B600430,1 Malak 06/19/95 
*B600430,1 Adjusting the browse fields string according to scale.
*B600480,1 YI ON 06/20/95 wrong selection from the code file
*G000000,1 06/25/95 MFM Fixed bug in the function the creates records in
*G000000,1              in the bomline.
*B600507,1 TMI 06/28/95 Changed the index on BOMLINE to contains the new
*B600507,1              field called "CIMTYP" in the begining of the index.
*B500772,1 HISH 07/02/96 Displayed phone in browses with its format without
*B500772,1               any width because its changed before by RAM.
*E100219,9 WAM 07/04/95 Add new type codes for receiving materials & styles
*E100219,9              from operation.
*E100219,9              Add new category key '021' in the GL_CATG for
*E100219,9              Cost of Material Variance.
*N000016,6 WAM 07/04/95 Add new type code for M.F.G. order receiving.
*E300261,1 RENEE 07/11/95 Modified function gpAdFabWar to work under Fox26
*E300261,1                and Windows
*N16,5     RENEE 07/11/95 1. Added a new function gfvDyelots that validates
*N16,5                       a dyelot field for either style or fabric
*N16,5                       dyelots (including dyelots for a specific
*N16,5                       warehouse if the system is setup to use
*N16,5                       multi warehouses).
*N16,5                       May Browse, Add, or Reenter. 
*N16,5                    2. Add a new parameter 'lcFromWare' to procedures
*N16,5                       'SDYEBROW' to browse dyelots for a specific
*N16,5                        warehouse if required.
*B500826,1 MFM 07/12/95 Added check to the program that run all fix programs
*B500826,1 MFM          for the directory which the file will be opened from.
*B500826,1 MFM          and aloso work with the new created file holding
*B500826,1 MFM          printer personalities.
*B800027,1 ARH 07/26/95 Added the color description and the fabric code 
*B800027,1              in both DOS & WINDOWS (Procedure STYBROW)
*N16,5     RENEE 08/01/95 1. Added a global warehouse validation 
*N16,5                       function gfvWareHs.
*N16,5                       Validates a warehouse entry. If valid, checks 
*N16,5                       its assignment to the passed style or fabric 
*N16,5                       color. 
*N16,5                       If not found in the corresponding dyefile, 
*N16,5                       may browse, add, or reenter.
*N16,5                    2. Updated gfBrowWare so as to browse the
*N16,5                       warehouses that contain a specific
*N16,5                       style(or fabric) color.
*G000000,1 YMA 08/07/95 Fixed bug variable not found.
*B800077,1 TAK 08/15/95 Fixed the duplication in codes in the sequence function.
*B800136,1 Reham On 08/29/95 
*B800136,1 Change _ the name width from 14 to 11
*B800136,1        _ the open width from 7  to 10
*E300284,1 MAN 08/30/95 Data Dir depends on either a defined enviromental 
*                       Var. that holds a Remote path or depends on 
*                       the defaul path.
*B600667,1 WAM 09/03/95 Upon assigning a material to a new warehouse, Default
*B600667,1              warehouse average unit cost with fabric average unit 
*B600667,1              cost.
*B800153,1 TAK 09/03/95 Fixed the bug double pressing on F1 for help,make system freez.
*B800149,1 RENEE 09/04/95 Change color setting in procedure BEEP
*B800149,1                so as to set color if DOS or UNIX only.
*B800149,1                (called from NOTEPAD.PRG)
*B800149,1 RENEE 09/05/95 Function gfToPrn :
*B800149,1                1. Add checking if called from Notepad.
*B800149,1                2. Exit retry/Cancel loop if the printer is not
*B800149,1                   ready and the program is to return to the
*B800149,1                   calling program (llDontGoMast = .T.) and 
*B800149,1                   not to gfDrv.
*B600695,1 MFM 09/19/95 Changed the name of the mover screen to privent
*B600695,1 MFM          errors if running under prox.
*B600682,1 MFM 09/24/95 Added new parameter to privent escape from browse
*B600682,1              Procedure CODECHK
*B600696,1 MFM 09/26/95 Fixed the bug of not displaying correct browse
*B600696,1 MFM          in the case of !empty cust po and valid account
*B600696,1 MFM          in the ORDBROWA browse.
*B800184,1 MFM 09/26/95 Do not print border '||||' for empty notpads.
*B800214,1 TAK 10/08/95 Checking the existance of the files in demo check
*B800214,1              to avoide the infinite loop bug.
*Renee     REN 10/10/95 Added a function gfStr2Ar that cuts a string of 
*Renee                  elements separated by delimeter into an array.
*Renee                  Identical to gfSubStr() of Aria Advantage.
*B800261,1 TAK 10/26/95 Changed the fields Partition on orders Browse.
*B800284,1 TAK 11/05/95 Added beep after report to be optional. 
*B800299,1 TAK 11/08/95 Changed the ORDBROW to work faster.
*B800301,1 AYS 11/08/95 Added Field Order.Note1 to the ORDBROW Procedure
*B800301,1				and to the ORDBROWA Procedure
*B800339,1 MFM 11/20/95 In the order brow if !empty(PO) then only brow
*B800339,1 MFM          records matching to this PO.
*B600663,1 MFM 11/21/95 In the codechk procedure if there is no record to
*B600663,1 MFM          browse for a certin type then return spaces in the
*B600663,1 MFM          passed variable to avoid errors.
*B600760,1 MFM 11/21/95 In the StyBrow procedure do not initialize the
*B600760,1 MFM          variable holding the season becouse it is used
*B600760,1 MFM          in the calling program.
*B600879,1 RENEE 12/11/95 Windows platform version. Update ARIAMOVR.SCX,
*B600879,1                Called from gfMover() function.
*B600879,1                Change the valid function of lsSource so as to
*B600879,1                match the validation in DOS version.
*E300321,1 RENEE 12/11/95 gfMover() : Validate before selecting.
*E300321,1                Add a parameter that, if passed, should contain
*E300321,1                the name of a function to be executed upon 
*E300321,1                selecting the current element from the source 
*E300321,1                list. The result of this function should return 
*E300321,1                a .T., if selection is permitted, .F. otherwise.
*E300328,1 RENEE 12/21/95 Add global function gfStyPrice() and STYPRICE.SCX
*E300328,1                Multi currency.
*E300328,1                Gets a price for a style/color/currency/cust. level
*E300328,1                If none exists and adding on fly is alloed,
*E300328,1                calls screen STYPRICE.
*E300325,1 RENEE 12/25/95 Modify GLDIST procedure so as to update currency
*E300325,1                and equivalent amount fields in GLDIST.DBF
*E300325,1                (cCurrCode, nCurrUnit. nExRate, nEqvAmnt) 
*E300324,6 RENEE 12/28/95 function fErrInfo() : Change text of type 'IN'
*E300324,6                from 'System date' to 'Invoice date',
*E300324,6                and remove the checking message.
*E300325,4 RENEE 12/28/95. function GETFRGHT.
*E300325,4                 Add currency parameters, and calculate 
*E300325,4                 freight, insurance, and COD amounts in 
*E300325,4                 the passed currency.  
*B800360,1 TMI 12/24/95 Added the seek command to indicate to the first
*B800360,1              color in the browse in (gfWareStls)
*E300344,2 WAM 02/14/96 Add new transaction type for Differences in Exchange rate
*B600951,1 Hesham El-Sheltawi 01/30/96 solving the printing under windows
*B600951,1 problems and controling the output to the selected port.
*C100553,1 TAK 02/25/96 Added in GetFrght procedure the Ship type UPS Consignee
*C100553,1               which has the freight always equal zero.
*B600973,1 MFM 02/12/96 Modified the gfTempName, CleanUp, TempName to work 
*B600973,1 MFM          with the array holding temp files names batter.
*N40,1 TAK 03/19/96 Modified the gfDispRep (Print .FRX reports) to work
*N40,1              to print on file and on screen in DOS version.
*E300362,1 MFM 03/13/96 Changed the 'GetFrght' procedure to handle the new
*E300362,1 MFM          UPS type added for canada.
*B800509,1 MFM 03/17/96 In the season validation when entering style color
*B800509,1 MFM          with all year round season use alltrim to cover the
*B800509,1 MFM          entery of the sason ' Y' OR 'Y ' (look at the space).
*B600822,1 Hesham El-Sheltawi 05/29/96
*B600822,1 add new function to get a uniqe prefrence name for the
*B600822,1 browse use
*B600822,1 Remark the activation of the resource file so the system
*B600822,1 use the ADV. resource file
*B800647,1 ARH 06/20/96 Fixed the bug File does not exist in the invoicing 
*B800647,1              program when trying to issue more then one
*B800647,1              consolidated invoice in the same session
*B800647,1              (Procedure gpUdtSJl)
*B600822,1 Hesham El-Sheltawi ON 07/18/96
*B600822,1 replace setting of color set with global function
*E300433,1 TAK 07/20/96 Changed the gpStDyBrow to work with screens in 2.7.
*E300421,1 SWK 08/30/96 Change the gpWareFabs to use the ARIABROW function
*E300421,1 SWK 08/01/96 Change the gpFbDyBrow to use the ARIABROW function
*B601258,1 SWK 09/12/96 Modify the gpAdFabWar for dyelot not empty 
*B601257,1 TAK 09/12/96 Modify the gpAdStyWar to call GL link code screen.
*B601292,1 TAK 10/17/96 Fixed the bug of print FRX on screen in WINDOWS.
*B601292,1              Added parameter llNotEndPr in gfDispRep to control
*B601292,1              the ENDPRT procedure calling , Because some programs
*B601292,1              allready call the ENDPRT like INV800.
*B601292,1              Also controling the Beep procedure.
*B800831,1 TMI 11/11/96 Rewrite the lcBrFields to modify the prepack brows
*B601259,1 ASH 12/04/96 Don't save the ave_cost in the style dyelot record.procedure(gpAdStyWar)
*E300502,1 TAK 12/15/96 Added Royaltys to standards codes brow CODECHK.
*B800905,4 SWK 12/25/96 Modify the gpUdtSJI procedure to add a new record
*B800905,4              with issue the old quantity  in case of Physical
*B800905,4              and unlokc a style.
*E300592,1 WAM 02/25/97 Modify the GLDIST function to increase the link_Code 
*E300592,1              field to be 6 characters.
*E300592,1              Recategorize GL link types and modify the function
*E300592,1              gfGlBrowse
*E300399,1 Hesham El-Sheltawi 09/24/96
*E300399,1 make the modifications needed to call the option grid for
*E300399,1 the apparel reports

*!*************************************************************************





*!*************************************************************************
*
* ' Procedure Name:       P0FLOCKD
* ' Purpose or Function:  Locks file with display of prompt
* ' Parameters Passed:    None
* ' Variables Passed:     None
* ' Environment Passed:   File to be locked open in current area
* ' Variables Returned:   lockedf = logical, .t. if file locked
*
PROCEDURE P0flockd

IF S_TIMEOUT = 0
  DO WHILE .NOT. FLOCK()
    SET COLOR TO &QCLRMSG
    @ 23,00 SAY ' '
    SET COLOR TO &QCLRNRM
    @ 23,00 SAY ' '
  ENDDO
  XRETURN = 'Y'
ENDIF

DO WHILE S_TIMEOUT<>0
  XRETRY=1
  DO WHILE .NOT.FLOCK().AND.XRETRY<S_TIMEOUT
    XRETRY=XRETRY+1
  ENDDO
  IF XRETRY<S_TIMEOUT
    RETURN
  ELSE
    lnChoice = gfDialog("?","File cannot be locked ! Would you like to retry ?","\<Yes;\<No")
    IF lnChoice = 1
      RETRY
    ELSE
      RETURN TO GFDRV                               && SMH 03/23/94  
    ENDIF
  ENDIF
  EXIT
ENDDO

* ' EOP - P0FLOCKD
******************************************************************
* ' Procedure Name:       P0RLOCKD
* ' Purpose or Function:  Locks Record with display of prompt
* ' Parameters Passed:    None
* ' Variables Passed:     None
* ' Environment Passed:   Record to be locked open in current area
* ' Variables Returned:   lockedr = logical, .t. if record locked
*
PROCEDURE P0rlockd

IF S_TIMEOUT = 0
  DO WHILE .NOT. RLOCK()
    SET COLOR TO &QCLRMSG
    @ 23,00 SAY ' '
    SET COLOR TO &QCLRNRM
    @ 23,00 SAY ' '

  ENDDO
  XRETURN = 'Y'
ENDIF

DO WHILE S_TIMEOUT <> 0
  XRETRY=1
  DO WHILE .NOT.RLOCK().AND.XRETRY<S_TIMEOUT
    XRETRY=XRETRY+1
  ENDDO
  IF XRETRY<S_TIMEOUT
    RETURN
  ELSE
    lnChoice = gfDialog("?","Record cannot be locked ! Would you like to retry ?","\<Yes;\<No")
    IF lnChoice = 1
      RETRY
    ELSE
      RETURN TO GFDRV                  && SMH 03/23/94
    ENDIF
  ENDIF
  EXIT
ENDDO
*
*** EOF P0RLOCK()
*
*****************************************************************************
*PROG:MSG.PRG
*DESC:PROCEDURE THAT WILL DISPLAY ON LINE 23 FROM 2 TO 4 OPTIONS WITH LIGHT BAR
*DATE:02/10/89
*PROGRAMMER:OMAR RAMADAN
*PARAMETERS= PARAM1,PARAM2,PARAM3,PARAM4,CHOICE
*****************************************************************************
PROCEDURE MSG
PARAMETERS PARAM1,PARAM2,PARAM3,PARAM4,XBAR_CHOICE
SET COLOR TO &QCLRBLK
@ 22,02 TO 24,78 CLEAR
@ 22,02 TO 24,78 DOUBLE
IF ISCOLOR()
  SET COLOR TO N/W,W/R
ENDIF
XBAR_CHOICE = 0

DO CASE
  CASE EMPTY(PARAM4) .AND. .NOT. EMPTY(PARAM3)
    @ 23,10 PROMPT PARAM1
    @ 23,35 PROMPT PARAM2
    @ 23,61 PROMPT PARAM3
  CASE EMPTY(PARAM3) .AND. EMPTY(PARAM4)
    @ 23,20 PROMPT PARAM1
    @ 23,51 PROMPT PARAM2
  OTHERWISE
    @ 23,13 PROMPT PARAM1
    @ 23,28 PROMPT PARAM2
    @ 23,43 PROMPT PARAM3
    @ 23,57 PROMPT PARAM4
ENDCASE
MENU TO XBAR_CHOICE
XBAR_CHOICE = IIF(READKEY() =12,0,XBAR_CHOICE)

SET COLOR TO &QCLRNRM
@ 22,00 TO 24,79 CLEAR
RETURN
******************************************************************
*!**************************************************************************
*! PROG: REPCHK.PRG
*! program to browse through the SALESREP file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE SALESREP FILE HAS BEEN OPENED
*! 
*!**************************************************************************
PROCEDURE REPCHK
PARAMETERS XREPCODE,llRetAlias

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,laData
*E300637,1 (End)

DECLARE laData[3] && array to get values from browse
STORE '' TO laData
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not

*B600429,1 Change the salesrep browse fields.
*lcBrFields = [repCode:H="Code",Name]

*B500772,1 HISH 07/02/96 Displayed field phone with its format.

*E300637,1 Use the global phone template
*IF _WINDOWS
*  lcBrFields = [repCode:H="Code",Name:H="Name",Phone :P= "@R "+gcPhnFrmt :H="Phone",City:H="City"]
*ELSE
*  lcBrFields = [repCode:H="Code",Name:H="Name",Phone :P= "@R "+gcPhnFrmt :H="Phone",City:H="City"]
*ENDIF
IF _WINDOWS
  lcBrFields = [repCode:H="Code",Name:H="Name",Phone :P= gfPhoneTem() :H="Phone"]
ELSE
  lcBrFields = [repCode:H="Code",Name:H="Name",Phone :P= gfPhoneTem() :H="Phone"]
ENDIF
*E300637,1 (End)

lnCurAlias = SELECT()
SELE SALESREP

lcSROrder = TAG()
SET ORDER TO TAG SALESREP

*B601797,1 Reham On 06/23/97  *** Begin ***
*B601797,1 Force to browse if llbrowse = .T.
*IF SEEK(XREPCODE)
IF !llBrowse .AND. SEEK(XREPCODE)
*B601797,1 Reham On 06/23/97  *** End   ***
  DATA=SUBSTR(SALESREP->NAME,1,20)
  IF !EMPTY(lcSROrder)
    SET ORDER TO TAG (lcSROrder)
  ELSE
    SET ORDER TO
  ENDIF
  IF llRetAlias  
    SELECT (lnCurAlias)  
  ENDIF  
  RETURN
ENDIF
IF llBrowse OR !SEEK(XREPCODE)
  DATA=SPACE(20)
  lnSoftSeek=RECNO(0)
  *E300637,1 Check th record number
  *IF lnSoftSeek<>0
  IF lnSoftSeek<>0 .AND. lnSoftSeek <= RECCOUNT("SALESREP")
  *E300637,1 (End)
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
  IF ARIABROW('',"Sales Representatives",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","REPCODE","laData")
    XREPCODE  = laData[1]
    DATA=SUBSTR(SALESREP->NAME,1,20)
  ELSE
    XREPCODE  = SPACE(3)
  ENDIF  
ENDIF  
IF !EMPTY(lcSROrder)
  SET ORDER TO TAG (lcSROrder)
ELSE
  SET ORDER TO
ENDIF
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN

*!**************************************************************************
*! PROG: STYBROW.PRG
*! program to browse through the style file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE STYLE FILE HAS BEEN OPENED
*!       IF WE WANT TO DISPLAY NO COLORS THEN XCLR = '*'
*!       IF WE WANT TO DISPLAY ALL SEASONS XSEASON = '*'
*!
*!Modifications : 
*B800027,1 ARH 07/26/95 Added the color description and the fabric code 
*B800027,1              in both DOS & WINDOWS
*MODFIED 10/07/1997 HDM Make it run as style browse for the whole system
*                       called from GFSTYBRW()
*B602933,106/06/1999 HDM  Case browsing majors we have to calculate stock and wip for all non-major
*!**************************************************************************
PROCEDURE STYBROW
Parameters XSTYLE,XCLR,XSEASON,llRetAlias      && returns the STYLE AND COLOR selected

*Parameters llMajor,XSTYLE,XCLR,XSEASON,llRetAlias &&Parameter added (llMajor) .T. To Return Major .F. To Return NON-Major

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias, lcStyle && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias, lcStyle,laData ,lcStyOrder ,lcStyTtl ,lcTitle ,lcXMjr ,lcXNMjr ,lcClrTtl ,lcStyOrder
*E300637,1 (End)

DECLARE laData[3] && array to get values from browse
STORE '' TO laData,lcScope
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
*HDM MAKE IT VARIABLE lcTitle = "Style"+IIF('*' $ XCLR,'',' Colors') && variable to hold Browse title

IF !USED('Codes')
  lcCurAlias = ALIAS()
  *E300637,1 Use the new global variables names
  *SELECT 0
  *DO NetUse WITH '&qDD.Code','&qDD.Code','SH'
  =gfOpenFile(gcDataDir+'Codes',gcDataDir+'Codes','SH')
  *E300637,1 (End)
  SELECT(lcCurAlias)
ENDIF
*--HDM[START]
lcStyTtl = IIF(lcMajorOrNone='M',gfItemMask('HM'),gfItemMask('HN'))

lcTitle = IIF(lcMajorOrNone='M',gfItemMask('HM'),IIF(lcMajorOrNone="N",gfItemMask('HN'),gfItemMask('HI')))
lcXMjr  = gfItemMask('HM')
lcXNMjr = gfItemMask('HN')

lcClrTtl = lcXMjr +'/'+ lcXNMjr
lnMajLen = LEN(gfItemMask('PM'))

*--HDM[END]
*B800027,1 ARH 07/26/95 (Begin) Added the color description and
*B800027,1             the fabric code in both DOS & WINDOWS
*B600429,1 Make brow fields variable for windows.
IF _WINDOWS .OR. _MAC
  *E300637,1 WAM 04/08/97 Display Season and division names
  *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
  *lcBrFields = [Style:16,STYLE_A.COLOR:8:H="Clr",STYLE_A.DESC:13:H="Description",]+;
               [STYLE_A.Season:3:H="Se",STYLE_A.cdivision:3:H="Di",STYLE_A.pricea]+;
               [:6:h="Price",STYLE_A.totWip:7:h="WIP",STYLE_A.totstk:7:h="Stock",]+;
               [STYLE_A.totord:7:h="Orders",OTS=(STYLE_A.TOTWIP+STYLE_A.TOTSTK-STYLE_A.TOTORD):7:H="O.T.S.",]+;
               [LcDummy=gfCodDes(Style_A.Color, 'COLOR'):19:H="Color Desc.",Style_A.Fabric:9:h="Fabric"]
*HDM  lcBrFields = [Style:16,STYLE_A.COLOR:8:H="Clr",STYLE_A.DESC:13:H="Description",]+;
               [lcSesDesc=gfCodDes(STYLE_A.Season,'SEASON'):3:H="Season",lcDivDesc=gfCodDes(STYLE_A.cdivision,'CDIVISION'):3:H="Division",STYLE_A.pricea]+;
               [:6:h="Price",STYLE_A.totWip:7:h="WIP",STYLE_A.totstk:7:h="Stock",]+;
               [STYLE_A.totord:7:h="Orders",OTS=(STYLE_A.TOTWIP+STYLE_A.TOTSTK-STYLE_A.TOTORD):7:H="O.T.S.",]+;
               [LcDummy=gfCodDes(Style_A.Color, 'COLOR'):19:H="Color Desc.",Style_A.Fabric:9:h="Fabric"]

  IF lcMajorOrNone $ 'NI'
    lcBrFields = [STYLE :19 :H= ALLTRIM(lcClrTtl),DESC :15 :H="Description",DESC1 :15 :H= "Long Description",]+;
                 [lcSesDesc=gfCodDes(Season,'SEASON'):12 :H="Season",lcDivDesc=gfCodDes(cdivision,'CDIVISION'):12:H="Division",]

    lcBrFields = lcBrFields+;
                 [pricea :6:h="Price A" , PRICEB :6:h="Price B",PRICEC :6:h="Price C",]
    
    lcBrFields = lcBrFields+;
                 [totWip:7:h="WIP",totstk:7:h="Stock",]+;
                 [totord:7:h="Orders",]

    lcBrFields = lcBrFields+;
                 [Fabric:9:h="Fabric",OTS=(TOTWIP+TOTSTK-TOTORD):7:H="O.T.S.",]

    lcBrFields = lcBrFields+;
                 [CSTYGRADE :H='Grade', lcRoyDesc=gfCodDes(ROYALTY,'ROYALTY') :H='Royalty' , PATTERN , STATUS,]

    lcBrFields = lcBrFields + ;
                 [SCALE , PREPAK , CBUYPREPK :H='Buy Prepack', QTY_CTN , COMMISSION , LINK_CODE :H='Link Code',]+;
                 [lcMaked = IIF(MAKE,'Y','N') :H='Manuf.', NMCOST1 , NMCOST2 , NMCOST3 , NMCOST4,NMCOST5,]

    lcBrFields = lcBrFields + ;
                 [NICOST1 , NICOST2 , NICOST3 , NICOST4 , NICOST5,]

    lcBrFields = lcBrFields+;
                 [NPRCOST2,NPRCOST3,NPRCOST4,NPRCOST5,TOTCOST :H='Total Cost',]+;
                 [AVE_COST,NSTKVAL :H='Stock Value',SOLDOUT,START,FABRIC,LOCATION,LINVSTY :H='Inventory',]

    lcBrFields = lcBrFields+;
                 [MARKA :H='MarkUp A',MARKB:H='MarkUp B',MARKC :H='MarkUp C',]+;
                 [CCONSINFO1 :h='Cons. Info. 1',CCONSINFO2 :h='Cons. Info. 2']
  ELSE
    
    lcBrFields = [CSTYMAJOR:19:H=ALLTRIM(lcStyTtl),STYLE_A.DESC:15:H="Description",STYLE_A.DESC1:15:H="Lng. Desc.",]+;
                 [lcSesDesc=gfCodDes(STYLE_A.Season,'SEASON'):12:H="Seas.",lcDivDesc=gfCodDes(STYLE_A.cdivision,'CDIVISION'):12:H="Div.",]

    lcBrFields = lcBrFields+;
                 [STYLE_A.pricea:6:h="Price A",STYLE_A.PRICEB:6:h="Price B",STYLE_A.PRICEC:6:h="PriceC",]
    
    *--HDM B602933,1 [Start] Case browsing majors we have to calculate stock and wip for all non-major
    *lcBrFields = lcBrFields+;
                 [STYLE_A.totWip:7:h="WIP", STYLE_A.totstk:7:h="Stk",]+;
                 [STYLE_A.totord:7:h="Orders",]

    lcBrFields = lcBrFields+;
                 [lnTotWIP=lfSumSeasn(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen),'TotWip'):7:h="WIP",lnTotStk=lfSumSeasn(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen),'totstk'):7:h="Stk",]+;
                 [lnTotORD=lfSumSeasn(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen),'totord'):7:h="Ord",]
    

    *lcBrFields = lcBrFields+;
                 [Style_A.Fabric :9 :h="Fabric" , OTS=(STYLE_A.TOTWIP+STYLE_A.TOTSTK-STYLE_A.TOTORD):7:H="O.T.S.",]

    lcBrFields = lcBrFields+;
                 [Style_A.Fabric:9:h="Fabric",lnOts=lfSum_OTS(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen)):7:H="OTS",]


    *--HDM B602933,1 [End]
    lcBrFields = lcBrFields+;
                 [Style_A.CSTYGRADE:H='Grade',lcRoyDesc=gfCodDes(STYLE_A.ROYALTY,'ROYALTY'):H='Royalty',STYLE_A.PATTERN,STYLE_A.STATUS,]

    lcBrFields = lcBrFields + ;
                 [Style_A.SCALE,Style_A.PREPAK,Style_A.CBUYPREPK:H='Buy Prpk',Style_A.QTY_CTN,Style_A.COMMISSION,Style_A.LINK_CODE:H='Link Code',]+;
                 [lcMaked=IIF(Style_A.MAKE,'Y','N'):H='Manf.',STYLE_A.NMCOST1,STYLE_A.NMCOST2,STYLE_A.NMCOST3,STYLE_A.NMCOST4,STYLE_A.NMCOST5,]

    lcBrFields = lcBrFields + ;
                 [STYLE_A.NICOST1,STYLE_A.NICOST2,STYLE_A.NICOST3,STYLE_A.NICOST4,STYLE_A.NICOST5,]

    *--HDM B602933,1 [Start] Case browsing majors we have to calculate stk. Value
    *lcBrFields = lcBrFields+;
                 [STYLE_A.NPRCOST2,STYLE_A.NPRCOST3,STYLE_A.NPRCOST4,STYLE_A.NPRCOST5,STYLE_A.TOTCOST :H='Total Cost',]+;
                 [STYLE_A.AVE_COST,STYLE_A.NSTKVAL :H='Stock Value',STYLE_A.SOLDOUT,STYLE_A.START,STYLE_A.FABRIC,STYLE_A.LOCATION,STYLE_A.LINVSTY :H='Inventory',]

    lcBrFields = lcBrFields+;
                 [lnAvegCost=lfCalAvCst():H='Ave.Cst.',STYLE_A.SOLDOUT,STYLE_A.START,STYLE_A.FABRIC,STYLE_A.LOCATION,STYLE_A.LINVSTY:H='Inv.',]+;
                 [STYLE_A.NPRCOST2,STYLE_A.NPRCOST3,STYLE_A.NPRCOST4,STYLE_A.NPRCOST5,STYLE_A.TOTCOST:H='Tot.Cst',]
                 
    *--HDM B602933,1 [End]
    lcBrFields = lcBrFields+;
                 [STYLE_A.MARKA:H='MarkUp A',STYLE_A.MARKB:H='MarkUp B',STYLE_A.MARKC:H='MarkUp C',]+;
                 [STYLE_A.CCONSINFO1:h='Cons.Info. 1',STYLE_A.CCONSINFO2:h='Cons.Info. 2']
    
  ENDIF

  *E300637,1 WAM 04/08/97 (End)
*=LOOKUP(Code.cData,'C'+Style_A.Color,Code.Code)
ELSE
  *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
*HDM Color No Longer Used=>  lcBrFields = [Style:12,STYLE_A.COLOR:6:H="Clr",STYLE_A.DESC:8:H="Desc.",]+;
               [STYLE_A.Season:2:H="Se",STYLE_A.cdivision:2:H="Di",STYLE_A.pricea]+;
               [:6:h="Price",STYLE_A.totWip:7:h="WIP",STYLE_A.totstk:7:h="Stock",]+;
               [STYLE_A.totord:7:h="Orders",OTS=(STYLE_A.TOTWIP+STYLE_A.TOTSTK-STYLE_A.TOTORD):7:H="O.T.S.",]+;
               [LcDummy=gfCodDes(Style_A.Color, 'COLOR'):15:H="Color Desc.",Style_A.Fabric:7:h="Fabric"]

*STYLE_A.Season:2:H="Se",STYLE_A.cdivision:2:H="Di",
*OTS=(STYLE_A.TOTWIP+STYLE_A.TOTSTK-STYLE_A.TOTORD):7:H="O.T.S.",

  lcBrFields = [Style:19 :H= lcStyTtl , STYLE_A.DESC:8:H="Desc.",]+;
               [STYLE_A.pricea]+;
               [:6:h="Price",STYLE_A.totWip:7:h="WIP",STYLE_A.totstk:7:h="Stock",]+;
               [STYLE_A.totord:7:h="Orders",]+;
               [Style_A.Fabric:7:h="Fabric"]

*=LOOKUP(Code.cData,'C'+Style_A.Color,Code.Code)               
ENDIF
*B800027,1 ARH 07/26/95 (End)

*lcStyle = IIF(XCLR=CHR(240),XSTYLE,'')
lnCurAlias = SELECT()
SELECT 0
*E300637,1 Use the new global variables names
*USE (QDD+'STYLE') AGAIN ALIAS STYLE_A ORDER TAG STYLE

*B604104,1 BWA 10/30/2001 Fix the bug in the STYBROW function that gives "STYLE_A NOT FOUND".[START]
*USE (gcDataDir+'STYLE') AGAIN ALIAS STYLE_A ORDER TAG STYLE
PRIVATE llSTYLE_A
llSTYLE_A = .F.
IF !USED('STYLE_A')
  llSTYLE_A = .T.
  USE (gcDataDir+'STYLE') AGAIN ALIAS STYLE_A ORDER TAG STYLE
ENDIF
*B604104,1 BWA 10/30/2001.[END]

*E300637,1 (End)
SELECT STYLE
lcStyOrder = TAG()
*IF llMajor
  SET ORDER TO TAG CSTYLE
*ELSE
*  SET ORDER TO TAG STYLE
*ENDIF
DO CASE
  CASE '*' $ XCLR AND '*' $ XSEASON
    *B800027,1 ARH 07/26/95 (Begin) Added the color description and
    *B800027,1             the fabric code in both DOS & WINDOWS
    *B600429,1 Make brow fields variable for windows.
    IF _WINDOWS .OR. _MAC
      *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
      *E300637,1 WAM 04/08/97 Display Season and division names
     *lcBrFields = [STYLE:16,COLOR="******":6,DESC:15:H="Description",]+;
                   [Season:3:H="Se",cdivision:3:H="Di",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):19:H="Color Desc.",Fabric:9:h="Fabric"]

*HDM Color No Longer Used=> lcBrFields = [STYLE:16,COLOR="******":6,DESC:15:H="Description",]+;
                   [lcSesDesc=gfCodDes(Season,'SEASON'):3:H="Season",lcDivDesc=gfCodDes(cdivision,'CDIVISION'):3:H="Division",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):19:H="Color Desc.",Fabric:9:h="Fabric"]
*lcSesDesc=gfCodDes(Season,'SEASON'):3:H="Season",lcDivDesc=gfCodDes(cdivision,'CDIVISION'):3:H="Division",

      lcBrFields = [STYLE:16,DESC:15:H="Description",]+;
                   [pricea]+;
                   [:6:h="Price",totWip:7:h="WIP"]+;
                   [,totstk=totstk : 7 : h="Stock",]+;
                   [totord:7:h="Orders",]+;
                   [Fabric:9:h="Fabric"]

      *E300637,1 WAM 04/08/97 (End)
*=LOOKUP(Code.cData,'C'+Color,Code.Code)
    ELSE
      *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
*HDM Color No Longer Used=> lcBrFields = [STYLE:12,COLOR="******":6,DESC:8:H="Desc.",]+;
                   [Season:2:H="Se",cdivision:2:H="Di",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):15:H="Color Desc.",Fabric:7:h="Fabric"]

      lcBrFields = [STYLE:12,DESC:8:H="Desc.",]+;
                   [Season:2:H="Se",cdivision:2:H="Di",pricea]+;
                   [:6:h="Price",totWip:h="WIP"]+;
                   [,totstk:7:h="Stock",]+;
                   [totord:7:h="Orders",]+;
                   [Fabric:7:h="Fabric"]

*=LOOKUP(Code.cData,'C'+Color,Code.Code)
    ENDIF
    *B800027,1 ARH 07/26/95 (End)
  CASE '*' $ XCLR
    *B800027,1 ARH 07/26/95 (Begin) Added the color description and
    *B800027,1             the fabric code in both DOS & WINDOWS
    IF _WINDOWS .OR. _MAC
      *E300637,1 WAM 04/08/97 Display Season and division names
      *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
      *lcBrFields = [STYLE:16,COLOR="******":6,DESC:15:H="Description",]+;
                   [Season:3:H="Se",cdivision:3:H="Di",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):19:H="Color Desc.",Fabric:9:h="Fabric"]
*HDM Color No longer used
*      lcBrFields = [STYLE:16,COLOR="******":6,DESC:15:H="Description",]+;
                   [lcSesDesc=gfCodDes(Season,'SEASON'):3:H="Season",lcDivDesc=gfCodDes(cdivision,'CDIVISION'):3:H="Division",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):19:H="Color Desc.",Fabric:9:h="Fabric"]

*lcSesDesc=gfCodDes(Season,'SEASON'):3:H="Season",lcDivDesc=gfCodDes(cdivision,'CDIVISION'):3:H="Division",

      lcBrFields = [STYLE:16,DESC:15:H="Description",]+;
                   [pricea]+;
                   [:6:h="Price",totWip:7:h="WIP"]+;
                   [,totstk :7:h="Stock",]+;
                   [totord:7:h="Orders",]+;
                   [Fabric:9:h="Fabric"] &&gfCodDes(Color, 'COLOR'):19:H="Color Desc."

      *E300637,1 WAM 04/08/97 (End)
*=LOOKUP(Code.cData,'C'+Color,Code.Code)
    ELSE
      *B500661,1 Reham Alallamy on 04/26/95 Fix displaying the price in the browse.
*HDM Color No longer used
*      lcBrFields = [STYLE:12,COLOR="******":6,DESC:8:H="Desc.",]+;
                   [Season:2:H="Se",cdivision:2:H="Di",pricea]+;
                   [:6:h="Price",totWip=lfSumSeasn(style,'totWip'):7:h="WIP"]+;
                   [,totstk=lfSumSeasn(style,'totstk'):7:h="Stock",]+;
                   [totord=lfSumSeasn(style,'totord'):7:h="Orders",OTS=lfSum_OTS(style):7:H="O.T.S.",]+;
                   [LcDummy=gfCodDes(Color, 'COLOR'):15:H="Color Desc.",Fabric:7:h="Fabric"]

      lcBrFields = [STYLE:12,DESC:8:H="Desc.",]+;
                   [Season:2:H="Se",cdivision:2:H="Di",pricea]+;
                   [:6:h="Price",totWip:7:h="WIP"]+;
                   [,totstk :7:h="Stock",]+;
                   [totord:7:h="Orders",]+;
                   [Fabric:7:h="Fabric"]

*=LOOKUP(Code.cData,'C'+Color,Code.Code)
    ENDIF
    *B800027,1 ARH 07/26/95 (End)

    lcScope = [gfvSeason]
    
  OTHERWISE  
    IF !('*' $ XSEASON)
      lcScope = [gfvSeason]
    ENDIF  
ENDCASE
*--HDM
*IF !('*' $ XCLR)
*  SET RELATION TO STYLE.STYLE INTO STYLE_A
*  SET SKIP TO STYLE_A
*ENDIF
*--HDM
SELECT STYLE

IF lcMajorOrNon = 'M'
  SET ORDER TO CSTYLE
ELSE
  SET ORDER TO STYLE
ENDIF
SET RELATION TO PADR(STYLE.CSTYMAJOR,lnMajLen) INTO STYLE_A ADDI
IF lcMajorOrNon = 'M'
  lcStyle = [XSTYLE]
ELSE
  IF lcMajorOrNon $ 'N'
    *lnPrevTab = SELECT(0)
    *SET SKIP TO STYLE_A
    SELECT STYLE
    *SET ORDER TO STYLE
    *SET ORDER TO
    *lcStyle = "FOR STYLE.CSTYMAJOR='" + ALLTRIM(XSTYLE) + "'"
    lcStyle = [XSTYLE]
    *SELECT (lnPrevTab)
  ENDIF
ENDIF

*B500660,1 Made the soft seek inside a condition that the record is not found
IF !SEEK(xStyle)
  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
ENDIF  
*--HDM B602700,1 03/31/1999 [Start] Enable soft seek in case of browsing major
IF TYPE('lcStyle')='C'
  IF lcMajorOrNon = 'N'
    *HDM Color No Longer Used=>  llWasSel=ARIABROW([lcStyle],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,lcScope,"","STYLE,STYLE_A.COLOR,STYLE_A.SEASON","laData")
    llWasSel=ARIABROW(lcStyle,lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,lcScope,"","STYLE,STYLE_A.SEASON","laData")
  ELSE
    llWasSel=ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,lcScope,"","STYLE,STYLE_A.SEASON","laData")
  ENDIF
*--HDM B602700,1 03/31/1999 [End]
ELSE
*HDM Color No Longer Used=>  llWasSel=ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,lcScope,"","STYLE,STYLE_A.COLOR,STYLE_A.SEASON","laData")
  llWasSel=ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,lcScope,"","STYLE,STYLE_A.SEASON","laData")
ENDIF  
IF lcMajorOrNon = 'M'
  SET SKIP TO
  SET RELATION OFF INTO STYLE_A
ENDIF
IF llWasSel
  XSTYLE  = laData[1]
  XCLR    = laData[2]
  *B600760,1 MFM 11/21/95 (Begin) Commeted out this var must not be initialized
  *B600760,1 MFM          becouse it is initialized in the calling program.
  *XSEASON = laData[3]
  *B600760,1 MFM 11/21/95 (End).
  SET ORDER TO TAG STYLE
*HDM Color No longer used  SEEK xStyle + xClr
  SEEK xStyle
ELSE
  XSTYLE  = SPACE(12)
  XCLR    = SPACE(6)
ENDIF  

IF !EMPTY(lcStyOrder)
  SELECT STYLE
  SET ORDER TO TAG (lcStyOrder)
ELSE
  SET ORDER TO
ENDIF  

*B604104,1 BWA 10/30/2001 Fix the bug in the STYBROW function that gives "STYLE_A NOT FOUND".[START]
*USE IN STYLE_A
IF llSTYLE_A
  USE IN STYLE_A
ENDIF
*B604104,1 BWA 10/30/2001.[END]

IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
*RETURN llWasSel
RETURN XSTYLE

*!**************************************************************************
*! FUNCTION gfvSeason
*! program to validate the style selected by the user in the browse
*! if it use the same season or not 
*! written by Hesham El_Sheltawi 15/02/1995
*! 
*B800509,1 MFM 03/17/96 In the season validation when entering style color
*B800509,1 MFM          with all year round season use alltrim to cover the
*B800509,1 MFM          entery of the sason ' Y' OR 'Y '.
*!**************************************************************************
FUNCTION gfvSeason

*B800509,1 MFM 03/17/96 (Begin) Use alltrim to cover all cases.
*IF STYLE_A.Season = XSEASON  OR STYLE_A.Season = 'Y'
IF STYLE_A.Season = XSEASON  OR ALLTRIM(STYLE_A.Season) = 'Y'
*B800509,1 MFM 03/17/96 (End).
  SCATTER FIELDS &lcFieldsNam MEMO TO (lcArrName)
*  CLEAR READ
  llBrowTmnat = .T.
ELSE
   =gfDialog("I",'You are restricted to styles from season &XSEASON ! RETRY ')
ENDIF

*!**************************************************************************
*! FUNCTION lfSumSeasn
*! FUNCTION to sum a specific field for the current style in style file
*! written by Hesham El_Sheltawi 15/02/1995
*! 
*!**************************************************************************
FUNCTION lfSumSeasn
PARAMETERS lcstyle,lccomp
lnTotcomp = 0
SELECT STYLE_A
SUM &lcCOMP TO lnTotcomp WHILE STYLE=lcstyle
SELECT STYLE
GO RECNO()
*B500661,1 Remarke the returned line to return with integer of the calculated
*B500661,1 fields because all of them integer anyway.
*RETURN lnTotcomp
RETURN INT(lnTotcomp)

*!**************************************************************************
*! FUNCTION lfSum_OTS
*! FUNCTION to sum the open to sell quantities.
*! written by Reham Alallamy 04/26/95
*! 
*!**************************************************************************
FUNCTION lfSum_OTS
PARAMETERS lcstyle

*B500653,1 Reham Alallamy to fix calculating Open to sell field
lnTot_OTS = 0
SELECT STYLE_A
SUM (totWip+totStk-totOrd) TO lnTot_OTS WHILE STYLE=lcstyle
SELECT STYLE
GO RECNO()
*B500661,1 Remarke the returned line to return with integer of the calculated
*B500661,1 fields because all of them integer anyway.
*RETURN lnTot_OTS
RETURN INT(lnTot_OTS)

*!**************************************************************************
*! PROG: FABROW.PRG
*! program to browse through the fabric file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE fabric FILE HAS BEEN OPENED
*!       IF WE WANT TO DISPLAY NO COLORS THEN XCLR = '*'
*!**************************************************************************
*!Modifications :
*! HDM B602180,1 11/16/1998 adding 4th Parameter to add For Exp.
*! HDM B602176,1 11/29/1998 Display the item type description instead of code[start]
*!**************************************************************************
PROCEDURE FABROW
*--HDM B602180,1 11/16/1998[start]

*Parameters XFAB,XCLR,llRetAlias      && returns the FABRIC COLOR selected
Parameters XFAB , XCLR , llRetAlias , lcFabForEx

*--HDM B602180,1 11/16/1998[end]

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias,lcStyle && Variable to hold browse fields

PRIVATE lcBrFields,lnCurAlias,lcStyle,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
STORE '' TO laData
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lcTitle = "Item"+IIF('*' $ XCLR,'',' color')  && variable to hold Browse title
llWasSel=.T.
lcStyle=IIF(XCLR=CHR(240),XFAB,'')
lnCurAlias = SELECT()

SELECT 0
*E300637,1 Use the new global variables names
*USE (QDD+'FABRIC') AGAIN ALIAS FABRIC_A ORDER TAG FABRIC
USE (gcDataDir+'FABRIC') AGAIN ALIAS FABRIC_A ORDER TAG FABRIC
*E300637,1 (End)

*--HDM B602180,1 11/16/1998[START]
*IF EMPTY(lcFabForEx)
*  lcFabForEx = ".T."
*ENDIF
*--HDM B602180,1 11/16/1998[end]
SELECT FABRIC
lcFabOrder = TAG()
IF '*' $ XCLR
  *B600429,1 Change the browse fields variable to display the browse in 
  *B600429,1 a right way under windows.
  IF _WINDOWS
  *--'ITEM_TYPE'
  lcItmType = gfCodDes(item_Type,'ITEM_TYPE')

    *E301967,1 KHM 07/31/2002 (Begin) Adding the content field to the browse    
    *lcBrFields = [Fabric:10:h="Item",Color="******":6,Desc:h="Description":19,]+;
                 [lcItmType = gfCodDes(item_Type,'ITEM_TYPE') :h="Type",loc:8:h="Location",Vendor:11,]+;
                 [Pattern:10,Onhand=lfSumFab(Fabric,'onhand'):8:h=]+;
                 ["On Hand",OnOrder=lfSumFab(Fabric,'onorder'):8:h="On Order"]
    lcBrFields = [Fabric:10:h="Item",Color="******":6,Desc:h="Description":19,]+;
                 [lcItmType = gfCodDes(item_Type,'ITEM_TYPE') :h="Type",loc:8:h="Location",Vendor:11,]+;
                 [Pattern:10,Onhand=lfSumFab(Fabric,'onhand'):8:h=]+;
                 ["On Hand",OnOrder=lfSumFab(Fabric,'onorder'):8:h="On Order",]+;
                 [Content:60:h="Contents"]
    *E301967,1 KHM 07/31/2002 (End)
                 
  ELSE
    lcBrFields = [Fabric:h="Item",Color="******",Desc:7:h="Desc.",]+;
                 [lcItmType = gfCodDes(item_Type,'ITEM_TYPE'):h="Type",loc:h="Location",Vendor,]+;
                 [Pattern,Onhand=lfSumFab(Fabric,'onhand'):h=]+;
                 ["On Hand",OnOrder=lfSumFab(Fabric,'onorder'):h="On Order"]
  ENDIF
ELSE
  *B600429,1 Change the browse fields variable to display the browse in 
  *B600429,1 a right way under windows.
  *B602176,1 HDM Display the item type description instead of code[start]
  IF _WINDOWS
    
    *E301967,1 KHM 07/31/2002 (Begin) Adding the content field to the browse    
    *lcBrFields = [Fabric:10:h="Item",Fabric_A.Color:8,Fabric_A.Desc:h="Description":18,]+;
                 [lcItmType = gfCodDes(Fabric_A.item_Type,'ITEM_TYPE'):h="Type",Fabric_A.loc:8:h="Location",Fabric_A.Vendor:11,]+;
                 [Fabric_A.Pattern:10,Fabric_A.Onhand:8:h="On Hand",Fabric_A.OnOrder:8:h="On Order"]  
    lcBrFields = [Fabric:10:h="Item",Fabric_A.Color:8,Fabric_A.Desc:h="Description":18,]+;
                 [lcItmType = gfCodDes(Fabric_A.item_Type,'ITEM_TYPE'):h="Type",Fabric_A.loc:8:h="Location",Fabric_A.Vendor:11,]+;
                 [Fabric_A.Pattern:10,Fabric_A.Onhand:8:h="On Hand",Fabric_A.OnOrder:8:h="On Order",]+;
                 [Content:60:h="Contents"]
    *E301967,1 KHM 07/31/2002 (End)
                 

  ELSE
    lcBrFields = [Fabric:h="Item",Fabric_A.Color,Fabric_A.Desc:7:h="Desc.",]+;
                 [lcItmType = gfCodDes(Fabric_A.item_Type,'ITEM_TYPE'):h="Type",Fabric_A.loc:h="Location",Fabric_A.Vendor,]+;
                 [Fabric_A.Pattern,Fabric_A.Onhand:h="On Hand",Fabric_A.OnOrder:h="On Order"]  
  ENDIF
  *B602176,1 HDM Display the item type description instead of code[end]
ENDIF  
SET ORDER TO TAG CFABRIC
SET RELATION TO FABRIC.FABRIC INTO FABRIC_A
IF !('*' $ XCLR)
  SET SKIP TO FABRIC_A
ENDIF  
IF llBrowse OR !SEEK(XFAB+XCLR,'FABRIC_A')
  lnSoftSeek=RECNO(0)

  *B804123,1 KHM 04/17/2001 (Begin) Add the checking if the variable that
  *B804123,1                holds the record number is between 1 and the 
  *B804123,1                file reccount.
  *IF lnSoftSeek<>0 
  IF lnSoftSeek<>0 AND BETWEEN(lnSoftSeek,1,RECCOUNT())
  *B804123,1 KHM 04/17/2001 (End)
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF
*--HDM B602180,1 11/16/1998[START]
*IF !EMPTY(lcStyle)
*  lcFabForEx = IIF(!EMPTY(lcFabForEx) , lcFabForEx + ' AND ' + "FABRIC.FABRIC='" +lcStyle +"'" , "FABRIC.FABRIC='" +lcStyle +"'" )
*ENDIF
*lcFabForEx
*  llWasSel= ARIABROW([lcStyle],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","FABRIC,FABRIC_A.COLOR","laData")

IF EMPTY(lcFabForEx)
  llWasSel= ARIABROW([lcStyle],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","FABRIC,FABRIC_A.COLOR","laData")
ELSE
  SELECT FABRIC
  LOCATE &lcFabForEx
  IF FOUND()
    llWasSel= ARIABROW(lcFabForEx,lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","FABRIC,FABRIC_A.COLOR","laData")
  ELSE
    =gfModalGen('TRM00342B00000','DIALOG')
  ENDIF
ENDIF
*--HDM B602180,1 11/16/1998[end]  
  IF llWasSel
    XFAB  = laData[1]
    XCLR  = laData[2]  
    SET ORDER TO TAG FABRIC
    SEEK xFab + xClr
  ELSE
    XFAB  = SPACE(7)
    XCLR  = SPACE(6)
  ENDIF  
ENDIF  
IF !EMPTY(lcFabOrder)
  SET ORDER TO TAG (lcFabOrder)
ELSE
  SET ORDER TO  
ENDIF  
SET SKIP TO
SET RELATION TO
USE IN FABRIC_A
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN llWasSel


*!**************************************************************************
*! FUNCTION lfSumFab
*! FUNCTION to sum a specific field for the current style in style file
*! written by Hesham El_Sheltawi 15/02/1995
*! 
*!**************************************************************************
FUNCTION lfSumFab
PARAMETERS lcFab,lccomp
lnTotcomp = 0
SELECT Fabric_A
SUM &lcCOMP TO lnTotcomp WHILE Fabric=lcFab
SELECT Fabric
GO RECNO()
*B600429,1 Return with integer of this no. because its integer anyway.
*RETURN lnTotcomp  
RETURN INT(lnTotcomp)

*!**************************************************************************
*! PROG: CUSBROWM.PRG
*! program to browse through the Customer file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE fabric FILE HAS BEEN OPENED
*! 
*!**************************************************************************
PROCEDURE CUSBROWM
Parameters XACCOUNT,llRetAlias,lcMastStor
IF EMPTY(lcMastStor)
  RETURN CUSBROW(@XACCOUNT,'M',llRetAlias)
ELSE  
  RETURN CUSBROW(@XACCOUNT,lcMastStor,llRetAlias)
ENDIF  

*!**************************************************************************
*! PROG: CUSBROWS.PRG
*! program to browse The stores for a specific Customer by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE fabric FILE HAS BEEN OPENED
*! 
*!**************************************************************************
PROCEDURE CUSBROWS
Parameters XACCOUNT,llRetAlias
PRIVATE lcStore
lcStore=XSTORE
llWasSel=CUSBROW(@XACCOUNT,'S',@LCSTORE,llRetAlias)
XSTORE =lcStore
RETURN llWasSel

*!**************************************************************************
*! PROG: CUSBROW.PRG
*! program to browse The customer file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE fabric FILE HAS BEEN OPENED
*! Called by CUSBROWM.PRG & CUSBROWS.PRG
*!**************************************************************************
PROCEDURE CUSBROW
Parameters XACCOUNT,lcKey,XSTORE,llRetAlias     && returns the account code of the customer selected
*B602658,4 [BEGIN] Open SYCINT file and get information
PRIVATE lcCityHed , lcCityWid , lcStatHed , lcStatWid , lnCurAlias

IF !USED('SYCINT')
  =gfOpenFile(gcSysHome+'SYCINT',gcSysHome+'ccontcode','SH')
ENDIF
lnCurAlias = SELECT(0)
SELECT SYCINT
SET ORDER TO 1
SEEK(ALLTRIM(gcContCode))
SCATTER MEMVAR MEMO
lcCityHed=m.Cpart3Lab
lcCityWid=ALLTRIM(STR(m.Npart3Len))
lcStatHed=m.Cpart4Lab
lcStatWid=ALLTRIM(STR(m.Npart4Len))
SELECT (lnCurAlias)
*B602658,4 [END..]
*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*B801931,1 WAM 02/03/1999 Do not remove '?' from the store field if sent

*PRIVATE lcBrFields,lnCurAlias && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,laData
*E300637,1 Open International file to get company country address information
llSycInt = gfOpenFile(gcSysHome+'SycInt',gcSysHome+'Ccontcode','SH')
lnSycIntRc = RECNO('SycInt')
=SEEK(gcContCode,'SycInt')
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
*MAN
IF !EMPTY(XACCOUNT)
  *E300637,1 WAM 04/08/97 
  *XACCOUNT = IIF(ATC("?",XACCOUNT)<>0,STUFF(XACCOUNT,ATC("?",XACCOUNT),1,""),XACCOUNT)
  XACCOUNT = PADR(IIF(ATC("?",XACCOUNT)<>0,STUFF(XACCOUNT,ATC("?",XACCOUNT),1,""),XACCOUNT),5)
  *E300637,1 (End)
ENDIF  
IF !EMPTY(XSTORE)
  *E300637,1 WAM 04/08/97 
  *XSTORE   = IIF(ATC("?",XSTORE  )<>0,STUFF(XSTORE  ,ATC("?",XSTORE)  ,1,""),XSTORE  )
  *B801931,1 Commented out
  *XSTORE   = PADR(IIF(ATC("?",XSTORE  )<>0,STUFF(XSTORE  ,ATC("?",XSTORE)  ,1,""),XSTORE  ),8)
  *B801931,1 (End)
  *E300637,1 (End)
ENDIF  

STORE '' TO laData
llWasSel=.T.
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lnCurAlias = SELECT()
lcKey=IIF(TYPE('lcKey')='C',lcKey,'M')
IF lcKey='S'
  *B500653,1 Reham Alallamy :Remarked on (04/26/95) to prevent the 
  *B500653,1 horizontal scrolling in the browse.
  *B500772,1 HISH 07/02/96 Displayed field phone with its format.
  *lcBrFields = [Account:h="Acct#",btName:h="Name",CUSTOMER_A.STORE:h="Store",CUSTOMER_A.stName:h="Name",CUSTOMER_A.StCity:H="City",]+;
                [CUSTOMER_A.Status:H="ST.",CUSTOMER_A.Phone1 :P= "@R "+gcPhnFrmt :H="Phone #...",CUSTOMER_A.Buyer,]+;
                [CUSTOMER_A.salesrep:H="Rep"]
  *600429,1 Change the browse fields for windows to display the browse
  *600429,1 in a proper way.
  IF _WINDOWS
    *MAN Removed CUSTOMER_A.
    *B500772,1 HISH 07/02/96 Displayed field phone with its format.
    *lcBrFields = [CUSTOMER_A.STORE:12:h="Store",CUSTOMER_A.stName:23:h="Name",CUSTOMER_A.StCity:15:H="City",]+;
                 [CUSTOMER_A.stState:4:H="ST.",CUSTOMER_A.Phone1 :P= "@R "+gcPhnFrmt :18:H="Phone #...",CUSTOMER_A.Buyer:15:H="Buyer",]+;
                 [CUSTOMER_A.salesrep:4:H="Rep"]
    *E300637,1 Use the global phone template
    *lcBrFields = [STORE:12:h="Store",stName:23:h="Name",StCity:15:H="City",]+;
                 [stState:4:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :18:H="Phone #...",Buyer:15:H="Buyer",]+;
                 [salesrep:4:H="Rep"]
    *B801761,1 AMM Add the rest of bill and ship to addresses
    *lcBrFields = "STORE :h='Store',stName:23:h='Name',"+;
                 "cAddress3 :H=SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                 "cAddress4 :H=SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                 "cAddress5 :H=SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                 "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep'"
    lcBrFields = "STORE :h='Store',stName:23:h='Name',"+;
                 "cAddress1 :H='ST '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                 "cAddress2 :H='ST '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                 "cAddress3 :H='ST '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                 "cAddress4 :H='ST '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                 "cAddress5 :H='ST '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                 "cAddress12 :H='BT '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                 "cAddress22 :H='BT '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                 "cAddress32 :H='BT '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                 "cAddress42 :H='BT '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                 "cAddress52 :H='BT '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                 "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep'"
    *B801761,1 AMM  end
    *E300637,1 (End)
  ELSE
    *MAN Removed CUSTOMER_A.
    *B500772,1 HISH 07/02/96 Displayed field phone with its format.
    *lcBrFields = [CUSTOMER_A.STORE:8:h="Store",CUSTOMER_A.stName:14:h="Name",CUSTOMER_A.StCity:10:H="City",]+;
                 [CUSTOMER_A.stState:3:H="ST.",CUSTOMER_A.Phone1 :P= "@R "+gcPhnFrmt :16:H="Phone #...",CUSTOMER_A.Buyer:13:H="Buyer",]+;
                 [CUSTOMER_A.salesrep:3:H="Rep"]
    *E300637,1 Use the global phone template
    *lcBrFields = [STORE:8:h="Store",stName:14:h="Name",StCity:10:H="City",]+;
                 [stState:3:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :16:H="Phone #...",Buyer:13:H="Buyer",]+;
                 [salesrep:3:H="Rep"]
*B602658,4 [BEGIN] Change StCity , stState to cAddress3 , cAddress4
*          with variable header and width .                  

    *lcBrFields = [STORE:8:h="Store",stName:14:h="Name",StCity:10:H="City",]+;
                 [stState:3:H="ST.",Phone1 :P= GFPHONETEM() :16:H="Phone #...",Buyer:13:H="Buyer",]+;
                 [salesrep:3:H="Rep"]
    lcBrFields = [STORE:8:h="Store",stName:14:h="Name",cAddress3:]+lcCityWid+[:H="]+lcCityHed+[",]+;
                 [cAddress4:]+lcStatWid+[:H="]+lcStatHed+[",Phone1 :P= GFPHONETEM() :16:H="Phone #...",Buyer:13:H="Buyer",]+;
                 [salesrep:3:H="Rep"]
*B602658,4 [END..]                 
    *E300637,1 (End)
  ENDIF
  *MAN
  *SELECT 0
  *IF lcKey='S'
  *  USE (QDD+'CUSTOMER') AGAIN ALIAS CUSTOMER_A ORDER TAG CUSTOMER
  *ENDIF  
ELSE
  IF  lcKey='MSP'
    *B500653,1 Reham Alallamy :Remarked on (04/26/95) to prevent the 
    *B500653,1 horizontal scrolling in the browse.
    *B500772,1 HISH 07/02/96 Displayed field phone with its format.
    *lcBrFields = [Phone1 :P= "@R "+gcPhnFrmt :H="Phone #",Account:h="Acct#",STORE:h="Store",stName:h="Name",StCity:H="City",]+;
                  [Status:H="ST.",Buyer,]+;
                  [salesrep:H="Rep"]
     
     *600429,1 Change the browse fields for windows to display the browse
     *600429,1 in a proper way.
     *B500772,1 HISH 07/02/96 Displayed field phone with its format.
     IF _WINDOWS
       *E300637,1 Use the global phone template
       *lcBrFields = [Phone1 :P= "@R "+gcPhnFrmt :20:H="Phone #",Account:7:h="Acct#",stName:20:h="Name",StCity:10:H="City",]+;
                    [stState:4:H="ST.",Buyer:12:h="Buyer",]+;
                    [salesrep:4:H="Rep",NetBal:11:H="Balance"]
       *B801761,1 AMM Add the rest of bill and ship to addresses
       *lcBrFields = "Phone1 :P=GFPHONETEM() :20 :H='Phone #',Account :H='Acct#',stName:20:h='Name',"+;
                    "cAddress3 :H=SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                    "cAddress4 :H=SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                    "cAddress5 :H=SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                    "Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
       lcBrFields = "Phone1 :P=GFPHONETEM() :20 :H='Phone #',Account :H='Acct#',stName:20:h='Name',"+;
                    "cAddress1 :H='ST '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                    "cAddress2 :H='ST '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                    "cAddress3 :H='ST '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                    "cAddress4 :H='ST '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                    "cAddress5 :H='ST '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                    "cAddress12 :H='BT '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                    "cAddress22 :H='BT '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                    "cAddress32 :H='BT '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                    "cAddress42 :H='BT '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                    "cAddress52 :H='BT '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                    "Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
       *B801761,1 AMM  end
       *E300637,1 (End)
     ELSE
       *E300637,1 Use the global phone template
       *lcBrFields = [Phone1 :P= "@R "+gcPhnFrmt :14:H="Phone #",Account:5:h="Acct#",stName:13:h="Name",StCity:10:H="City",]+;
                    [stState:3:H="ST.",Buyer:8:h="Buyer",]+;
                    [salesrep:3:H="Rep",NetBal:11:H="Balance"]
*B602658,4 [BEGIN] Change StCity , stState to cAddress3 , cAddress4
*          with variable header and width .                                      
       *lcBrFields = [Phone1 :P= GFPHONETEM() :14:H="Phone #",Account:5:h="Acct#",stName:13:h="Name",StCity:10:H="City",]+;
                    [stState:3:H="ST.",Buyer:8:h="Buyer",]+;
                    [salesrep:3:H="Rep",NetBal:11:H="Balance"]
       lcBrFields = [Phone1 :P= GFPHONETEM() :14:H="Phone #",Account:5:h="Acct#",stName:13:h="Name",cAddress3:]+lcCityWid+[:H="]+lcCityHed+[",]+;
                   [cAddress4:]+lcStatWid+[:H="]+lcStatHed+[",Buyer:8:h="Buyer",]+;
                   [salesrep:3:H="Rep",NetBal:11:H="Balance"]             
*B602658,4 [END..]                   
       *E300637,1 (End)
     ENDIF
  ELSE
    IF  lcKey='MSN'
      *B500653,1 Reham Alallamy :Remarked on (04/26/95) to prevent the 
      *B500653,1 horizontal scrolling in the browse.
      *B500772,1 HISH 07/02/96 Displayed field phone with its format.
      *lcBrFields = [stName:h="Name",Account:h="Acct#",STORE:h="Store",StCity:H="City",]+;
                    [Status:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :H="Phone #",Buyer,]+;
                    [salesrep:H="Rep"]
      
      *600429,1 Change the browse fields for windows to display the browse
      *600429,1 in a proper way.
      IF _WINDOWS
        *B500772,1 HISH 07/02/96 Displayed field phone with its format.
        *E300637,1 Use the global phone template
        *lcBrFields = [stName:20:h="Name",Account:7:h="Acct#",StCity:11:H="City",]+;
                     [stState:4:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :17:H="Phone #",Buyer:14:h="Buyer",]+;
                     [salesrep:4:H="Rep",NetBal:11:H="Balance"]
        *B801761,1 AMM Add the rest of bill and ship to addresses
        *lcBrFields = "stName:20:h='Name',Account :H='Acct#',"+;
                     "cAddress3 :H=SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress4 :H=SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress5 :H=SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
        lcBrFields = "stName:20:h='Name',Account :H='Acct#',"+;
                     "cAddress1 :H='ST '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                     "cAddress2 :H='ST '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                     "cAddress3 :H='ST '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress4 :H='ST '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress5 :H='ST '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "cAddress12 :H='BT '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                     "cAddress22 :H='BT '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                     "cAddress32 :H='BT '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress42 :H='BT '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress52 :H='BT '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
        *B801761,1 AMM  end
        *E300637,1 (End)
      ELSE
        *B500772,1 HISH 07/02/96 Displayed field phone with its format.
        *E300637,1 Use the global phone template
        *lcBrFields = [stName:13:h="Name",Account:5:h="Acct#",StCity:10:H="City",]+;
                     [stState:3:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :14:H="Phone #",Buyer:8:h="Buyer",]+;
                     [salesrep:3:H="Rep",NetBal:11:H="Balance"]
*WALID                     
        lcBrFields = [stName:13:h="Name",Account:5:h="Acct#",StCity:10:H="City",]+;
                     [stState:3:H="ST.",Phone1 :P= GFPHONETEM() :14:H="Phone #",Buyer:8:h="Buyer",]+;
                     [salesrep:3:H="Rep",NetBal:11:H="Balance"]
        *E300637,1 (End)
      ENDIF
    ELSE
      *B500653,1 Reham Alallamy :Remarked on (04/26/95) to prevent the horizontal 
      *B500653,1 scrolling in the browse.
      *lcBrFields = [Account:h="Acct#",btName:h="Name",btCity:H="City",]+;
                    [Status:H="ST",Phone1 :P= "@R "+gcPhnFrmt :H="Phone #...",Buyer,salesrep]+;
                    [:H="Rep",NetBal:H="Balance"]

      *600429,1 Change the browse fields for windows to display the browse
      *600429,1 in a proper way.
      *B500772,1 HISH 07/02/96 Displayed field phone with its format.
      IF _WINDOWS
        *E300637,1 Use the global phone template and company address information
        *lcBrFields = [Account:7:h="Acct#",btName:21:h="Name",btCity:10:H="City",]+;
                     [btState:4:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :17:H="Phone #...",Buyer:14:H="Buyer",salesrep]+;
                     [:4:H="Rep",NetBal:11:H="Balance"]
        *B801761,1 AMM Add the rest of bill and ship to addresses
        *lcBrFields = "Account :H='Acct#', BtName :H='Name':R,"+;
                     "cAddress32 :H=SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress42 :H=SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress52 :H=SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
        lcBrFields = "Account :H='Acct#', BtName :H='Name':R,"+;
                     "cAddress1 :H='ST '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                     "cAddress2 :H='ST '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                     "cAddress3 :H='ST '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress4 :H='ST '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress5 :H='ST '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "cAddress12 :H='BT '+SycInt.cPart1Lab :R :P=REPLICATE('X',SycInt.nPart1Len),"+;
                     "cAddress22 :H='BT '+SycInt.cPart2Lab :R :P=REPLICATE('X',SycInt.nPart2Len),"+;
                     "cAddress32 :H='BT '+SycInt.cPart3Lab :R :P=REPLICATE('X',SycInt.nPart3Len),"+;
                     "cAddress42 :H='BT '+SycInt.cPart4Lab :R :P=REPLICATE('X',SycInt.nPart4Len),"+;
                     "cAddress52 :H='BT '+SycInt.cPart5Lab :R :P=REPLICATE('X',SycInt.nPart5Len),"+;
                     "Phone1 :P= GFPHONETEM() :H='Phone #...',Buyer :H='Buyer',salesrep :H='Rep',NetBal:11:H='Balance'"
        *B801761,1 AMM  end
        *E300637,1 (End)
      ELSE
        *E300637,1 Use the global phone template
        *lcBrFields = [Account:5:h="Acct#",btName:13:h="Name",btCity:10:H="City",]+;
                     [btState:3:H="ST.",Phone1 :P= "@R "+gcPhnFrmt :14:H="Phone #...",Buyer:8:H="Buyer",salesrep]+;
                     [:3:H="Rep",NetBal:11:H="Balance"]
*WALID                     
        lcBrFields = [Account:5:h="Acct#",btName:13:h="Name",btCity:10:H="City",]+;
                     [btState:3:H="ST.",Phone1 :P= GFPHONETEM() :14:H="Phone #...",Buyer:8:H="Buyer",salesrep]+;
                     [:3:H="Rep",NetBal:11:H="Balance"]
        *E300637,1 (End)
      ENDIF
    ENDIF
  ENDIF
ENDIF               
             
SELECT CUSTOMER
lcCustOrder = TAG()
IF lckey='MSP'
  SET ORDER TO TAG CUSTOMPH
ELSE
  IF lckey='MSN'
    SET ORDER TO TAG CUSTOMNM
  ELSE  
    SET ORDER TO TAG CUSTOMER
  ENDIF
ENDIF  
*MAN
*IF lcKey='S'
*  SET RELATION TO 'S'+XACCOUNT INTO CUSTOMER_A ADDI
*  SET SKIP TO CUSTOMER_A
*ENDIF
lnCusRec=0
*MAN Changed the following IF
*IF  IIF(lcKey<>'MSN' AND lcKey<>'MSP',!SEEK(lckey+XACCOUNT+IIF(lcKey='S',xstore,''),IIF(lcKey='S','customer_a','customer')),.T.) OR llBrowse

IF  IIF(lcKey<>'MSN' AND lcKey<>'MSP',!SEEK(lckey+XACCOUNT+IIF(lcKey='S',xstore,''),'customer'),.T.) OR llBrowse
  IF lcKey<>'MSN' AND lcKey<>'MSP'
    lnSoftSeek=RECNO(0)
    IF lnSoftSeek<>0 
      GO lnSoftSeek
    ELSE
      GO TOP
    ENDIF     
  ENDIF  
  IF lcKey='S' OR lcKey='MSP' OR lcKey='MSN'
    IF lcKey='S'
      *MAN
      *LOCATE REST FOR Account=xAccount AND TYPE='S'
      *IF !FOUND()
      IF !SEEK('S'+xAccount) 
        =gfDialog("I","No stores found for this account. !")
        IF !EMPTY(lcCustOrder)
          SET ORDER TO TAG (lcCustOrder)
        ELSE
          SET ORDER TO  
        ENDIF  
        *MAN Start
        *SET RELATION TO
        *SET SKIP TO
        *IF USED('CUSTOMER_A')
        *  USE IN CUSTOMER_A
        *ENDIF
        *MAN End
        xStore=SPACE(8)
        RETURN
      ENDIF 
       *MAN Start
       *llWasSel=ARIABROW(["M"+XACCOUNT],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',IIF(lcKey='S',"ACCOUNT,CUSTOMER_A.STORE","ACCOUNT"),"laData",IIF(lcKey='M',.T.,.F.))  
       IF lcKey='S'
         llWasSel=ARIABROW(["S"+XACCOUNT],"Locations for Customer : "+XACCOUNT ,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',"ACCOUNT,STORE","laData",.F.)  
       ELSE
         llWasSel=ARIABROW(["M"+XACCOUNT],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',"ACCOUNT","laData",IIF(lcKey='M',.T.,.F.))  
       ENDIF
       *lnCusRec = RECNO('CUSTOMER_A')
       lnCusRec = RECNO('CUSTOMER')
       *MAN End

    ELSE
      *MAN
      *llWasSel=ARIABROW(['M','S'],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',IIF(lcKey='S',"ACCOUNT,CUSTOMER_A.STORE","ACCOUNT"),"laData",IIF(lcKey='M',.T.,.F.))
      llWasSel=ARIABROW(['M','S'],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',IIF(lcKey='S',"ACCOUNT,STORE","ACCOUNT"),"laData",IIF(lcKey='M',.T.,.F.))
    ENDIF      
  ELSE
    *MAN
    *llWasSel=ARIABROW(["M"],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',IIF(lcKey='S',"ACCOUNT,CUSTOMER_A.STORE","ACCOUNT"),"laData",IIF(lcKey='M',.T.,.F.))
    llWasSel=ARIABROW(["M"],"Customers",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',IIF(lcKey='S',"ACCOUNT,STORE","ACCOUNT"),"laData",IIF(lcKey='M',.T.,.F.))
  ENDIF  
  IF llWasSel
    XACCOUNT  = laData[1]
    IF lcKey='S' OR lcKey='MSP' OR lcKey='MSN'
      XSTORE = laData[2]
    ENDIF
  ELSE
    XACCOUNT = SPACE(5)  
  ENDIF  
ENDIF  
IF !EMPTY(lcCustOrder)
  SET ORDER TO TAG (lcCustOrder)
ELSE
  SET ORDER TO  
ENDIF
*MAN  
*SET RELATION TO
*SET SKIP TO
IF llWasSel AND lnCusRec>0
  GO lnCusRec
ENDIF
*MAN
*IF USED('CUSTOMER_A')
*  USE IN CUSTOMER_A
*ENDIF
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
*E300637,1 Close International file if opened here
IF llSycInt 
  USE IN 'SycInt'
ELSE
  IF BETWEEN(lnSycIntRc,1,RECCOUNT('SycInt'))
    GO lnSycIntRc IN 'SycInt'
  ENDIF
ENDIF  
*E300637,1 (End)

RETURN llWasSel

*!**************************************************************************
*! PROG: ORDBROWA.PRG
*! program to browse The Order header file sorting by account by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE order header FILE HAS BEEN OPENED
*! 
*!**************************************************************************
PROCEDURE ORDBROWA

*E300676,1 Change this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
*Parameters XACCOUNT,llRetAlias
Parameters XACCOUNT , llRetAlias , lcOrdrType
*E300676,1 Change this line to add one more Parameter [End]

*E300676,1 Add this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
lcOrdrType = IIF(TYPE('lcOrdrType') <> 'C' .OR. EMPTY(lcOrdrType) , 'O' ,;
                 IIF(UPPER(lcOrdrType) = 'A' , '' , UPPER(lcOrdrType)))
*E300676,1 Add this line to add one more Parameter [End]

IF TYPE('XORDER')='U'
 STORE '' TO XORDER
ENDIF

*B600696,1 MFM 09/26/95 (Begin) Added to avoid errors.
IF TYPE('XPOSEARCH')='U'
  XPOSEARCH = .F.
ENDIF

IF TYPE('XSTORE') = 'U'
  XSTORE = ''
ENDIF
*B600696,1 MFM 09/26/95 (End).

*B600696,1 MFM 09/26/95 (Begin) Added to serch for a specific po.
IF XPOSEARCH
  DECLARE laValues[1]  && array to get values from browse
  STORE '' TO laValues
  lnOldWork = SELECT()
  SELECT ORDHDR

  *B800339,1 MFM 11/20/95 (Begin) Changed the way of working.
  lnOldOrder = SYS(21)
  SET ORDER TO TAG ORDCUST
  
  *E300676,1 Change this line to fix the SEEK Exprition [Begin]
  =SEEK(xAccount+UPPER(xCustPO)+IIF(EMPTY(xStore),'',xStore))
  =SEEK(xAccount+UPPER(xCustPO))
  *E300676,1 Change this line to fix the SEEK Exprition [End]
  
  *E300676,1 Add this lines to add the Store condition and to add one more
  *Parameter (lcOrdrType) to filter on the Order Type ('O' for Order ,
  *'C' for Contract) [Begin]
  IF FOUND()
    DO CASE
      CASE !EMPTY(xStore) .AND. !EMPTY(lcOrdrType)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR Store = xStore .AND. cOrdType = lcOrdrType
      
      CASE !EMPTY(xStore)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR Store = xStore
      
      CASE !EMPTY(lcOrdrType)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR cOrdType = lcOrdrType
      
    ENDCASE
  ENDIF
  *E300676,1 Add this lines [End]
  
  SET ORDER TO &lnOldOrder
  *=SEEK(xaccount)
  *LOCATE FOR Account+UPPER(CustPO)+Store = xAccount+UPPER(xCustPO)+IIF(EMPTY(xStore),'',xStore)
  *B800339,1 MFM 11/20/95 (End).
  
  
  *B800261,1 TAK 10/26/95 Changed the fields positions on orders Browse.
  
  IF _WINDOWS
   * lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",]+;
                 [cDivision:H="DI",ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
                 [:15:H="Name",Shipamt:H="Ship.Amt.",Ship:H="Ship.Qty.",OpenAmt:H="Open.Amt.",Open:H="Open.Qty.",]+;
                 [start:H="Start",Complete:H="Complete",CustPo=IIF(multipo,'*Multi_PO*',custpo):H="P/O#"]

  *B800301,1 AYS 11/07/95 Add Field Order.Note1 to lcBrFields
  *E300637,1 WAM 04/08/97 Display Season and division names
  *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",cDivision:H="DI",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",Note1:7:H="Notes"]
  lcBrFields = [Order:H="Order#",status:1:H="S",lcSesDesc=gfCodDes(Season,'SEASON'):H="Season",lcDivDesc=gfCodDes(cDivision,'CDIVISION'):H="Division",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",Note1:7:H="Notes"]
  *E300637,1 WAM 04/08/97 (End)
  ELSE
   * lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",]+;
                 [Division:H="DI",ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
                 [:15:H="Name",Shipamt:H="Ship.Amt.",Ship:H="Ship.Qty.",OpenAmt:H="Open.Amtt.",Open:H="Open.Qty.",]+;
                 [start:H="Start",Complete:H="Complete",CustPo=IIF(multipo,'*Multi_PO*',custpo):H="P/O#"]

  *B800301,1 AYS 11/07/95 Add Field Order.Note1 to lcBrFields
  lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",cDivision:H="DI",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",Note1:6:H="Notes"]
  ENDIF

  IF FOUND()
    *B800339,1 MFM 11/20/95 (Begin) Do not brow empty pos if not valid po number.
    *IF ARIABROW('FOR Account+UPPER(CustPO)+Store=xAccount+UPPER(xCustPO)+IIF(EMPTY(xStore),"",XSTORE) .OR. Account+UPPER(CustPO)+Store = xAccount+SPACE(10)+IIF(EMPTY(xStore),"",XSTORE)',"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','','ORDER','laValues')
  
    *E300676,1 Change this line to fix the FOR Exprition for the optmization
    *and to add one more Parameter (lcOrdrType) to filter on the Order Type
    *('O' for Order , 'C' for Contract) [Begin]
    *IF ARIABROW('FOR Account+UPPER(CustPO)+Store=xAccount+UPPER(xCustPO)+IIF(EMPTY(xStore),"",XSTORE)',"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','','ORDER','laValues')
    IF ARIABROW('FOR Account + UPPER(CustPO) + cOrdType + Order = xAccount + UPPER(xCustPO)' +;
                 IIF(EMPTY(lcOrdrType) , "" , " .AND. cOrdType + Order = lcOrdrType") ,;
                 IIF(EMPTY(xStore),""," .AND. Store = xStore") +;
                 "Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','','ORDER','laValues')
    *E300676,1 Change this line [End]
    
    *B800339,1 MFM 11/20/95 (End).
      xOrder = laValues[1]
    ELSE
      STORE SPACE(6)  TO xOrder
    ENDIF

  ELSE
    =gfDialog('I','No orders matching the selected criteria.')
    STORE SPACE(6) TO xOrder
  ENDIF  
  
  IF llRetAlias
    SELECT (lnOldWork)
  ENDIF
  
  RETURN xOrder
ELSE

  *E300676,1 Change this line to add one more Parameter (lcOrdrType) to
  *filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
  *RETURN ORDBROW(@XACCOUNT,'A',@XORDER,llRetAlias)
  RETURN ORDBROW(@XACCOUNT , 'A' , @XORDER , llRetAlias ,;
                 IIF(EMPTY(lcOrdrType) , 'A' , lcOrdrType))
  *E300676,1 Change this line to add one more Parameter [End]
  
ENDIF
*B600696,1 MFM 09/26/95 (End).

*!**************************************************************************
*! PROG: ORDBROWO.PRG
*! program to browse The Order header file sorting by order  by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE order header FILE HAS BEEN OPENED
*! 
*!**************************************************************************
PROCEDURE ORDBROWO

*E300676,1 Change this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
*Parameters XORDER,llRetAlias
PARAMETERS XORDER , llRetAlias , lcOrdrType
*E300676,1 Change this line to add one more Parameter [End]

IF TYPE('XACCOUNT')='U'
 STORE '' TO XACCOUNT
ENDIF

*E300676,1 Change this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
*RETURN ORDBROW(@XACCOUNT,'O',@XORDER,llRetAlias)
RETURN ORDBROW(@XACCOUNT , 'O' , @XORDER , llRetAlias , lcOrdrType)
*E300676,1 Change this line to add one more Parameter [End]


*!**************************************************************************
*! PROG: ORDBROW.PRG
*! program to browse The Order header file by using the new browse
*! written by Hesham El_Sheltawi 15/02/1995
*! NOTE: THIS PROGRAM ASSUMES THAT THE order header FILE HAS BEEN OPENED
*!  called by CUSBROWA.PRG & CUSBROWO.PRG
*!**************************************************************************
PROCEDURE ORDBROW

*E300676,1 Change this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
*Parameters XACCOUNT,lcKey,Xorder,llRetAlias    && returns the account code of the customer selected
PARAMETERS XACCOUNT , lcKey , Xorder , llRetAlias , lcOrdrType    && returns the account code of the customer selected
*E300676,1 Change this line to add one more Parameter [End]

*E300676,1 Add this line to add one more Parameter (lcOrdrType) to
*filter on the Order Type ('O' for Order , 'C' for Contract) [Begin]
lcOrdrType = IIF(TYPE('lcOrdrType') <> 'C' .OR. EMPTY(lcOrdrType) , 'O' ,;
                 IIF(UPPER(lcOrdrType) = 'A' , '' , UPPER(lcOrdrType)))
*E300676,1 Add this line to add one more Parameter [End]

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
DECLARE laOrdState[4,2]

laOrdState[1,1] = 'Open'
laOrdState[1,2] = 'O'
laOrdState[2,1] = 'Hold'
laOrdState[2,2] = 'H'
laOrdState[3,1] = 'Cancelled'
laOrdState[3,2] = 'X'
laOrdState[4,1] = 'Complete'
laOrdState[4,2] = 'C'
STORE '' TO laData
llWasSel=.T.
lnCurAlias = SELECT()
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
*B500653,1 Reham Alallamy :Remarked on (04/26/95) change the fields 
*B500653,1 width to prevent the horizontal scrolling in the browse.
*lcBrFields = [Order:H="Order#",lcStatus=IIF(ordhdr.status $ 'OHXC',laOrdState(AT(ordhdr.status,"OHXC"),1),''):H="Status",Season:H="SE",]+;
             [Division:H="DI",ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
             [:H="Name",start:H="Start",Complete:H="Complete",CustPo=IIF(multipo,'*Multi_PO*',custpo)]+;
             [:H="P/O#",Shipamt:H="Shipped",Ship,OpenAmt:H="Open"]
*B600429,1 Change the header of the ship Qty & Amt & Open Qty & Amt.
*B600429,1 Add Open Qty field to the browse.
*B800261,1 TAK 10/26/95 Changed the fields positions on orders Browse.
IF _WINDOWS
  *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",]+;
               [Division:H="DI",ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Shipamt:H="Ship.Amt.",Ship:H="Ship.Qty.",OpenAmt:H="Open.Amt.",Open:H="Open.Qty.",]+;
               [start:H="Start",Complete:H="Complete",CustPo=IIF(multipo,'*Multi_PO*',custpo):H="P/O#"]

  *B800301,1 AYS 11/07/95 Add Field Order.Note1 to lcBrFields
  *E300637,1 WAM 04/08/97 Display Season and division names
  *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",Division:H="DI",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",]+;
               [Note1:7:H="Notes"]
  lcBrFields = [Order:H="Order#",status:1:H="S",lcSesDesc=gfCodDes(Season,'SEASON'):H="Season",lcDivDesc=gfCodDes(cDivision,'CDIVISION'):H="Division",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",]+;
               [Note1:7:H="Notes"]
  *E300637,1 WAM 04/08/97 (End)
ELSE
  *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",]+;
               [Division:H="DI",ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Shipamt:H="Ship.Amt.",Ship:H="Ship.Qty.",OpenAmt:H="Open.Amtt.",Open:H="Open.Qty.",]+;
               [start:H="Start",Complete:H="Complete",CustPo=IIF(multipo,'*Multi_PO*',custpo):H="P/O#"]

  *B800301,1 AYS 11/07/95 Add Field Order.Note1 to lcBrFields
  lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",cDivision:H="DI",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",]+;
               [Note1:6:H="Notes"]
ENDIF

IF !USED('Customer')
  *E300637,1 Use the new global variables names
  *=gfOpenFile(QDD+'Customer',QDD+'Customer','SH')  
  =gfOpenFile(gcDataDir+'Customer',gcDataDir+'Customer','SH')
  *E300637,1 (End)
ENDIF

SELECT ORDHDR
SET RELATION TO IIF(STORE=SPACE(8),'M'+ACCOUNT,'S'+ACCOUNT+STORE) INTO CUSTOMER
lcOrdOrder = TAG()
IF lcKey='A'
  SET ORDER TO TAG ORDACCT
ELSE
  SET ORDER TO TAG ORDHDR
ENDIF  

**Added by hish  15/3/1995
IF lckey='A'  && called from cus. prog.
  IF !SEEK(xAccount)
    =gfDialog("I","No orders have been found for account# "+xAccount+".") 
    IF !EMPTY(lcOrdOrder)
      SET ORDER TO TAG (lcOrdOrder)
    ELSE
      SET ORDER TO  
    ENDIF  
    SET RELATION TO
    IF llRetAlias
      SELECT (lnCurAlias)
    ENDIF  
    RETURN .F.
  ENDIF
ENDIF
***end 

IF llBrowse OR !SEEK(XACCOUNT)
  lnSoftSeek=RECNO(0)
  *E300637,1 Check th record number
  *IF lnSoftSeek<>0 
  IF lnSoftSeek<>0 .AND. lnSoftSeek <= RECCOUNT("ORDHDR")
  *E300637,1 (End)
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
    lcPushB=IIF(lcKey="A",'',"Fi\<nd;;\<Descending;\<Filter;\!\<Select;\?\<Cancel")
    
    **B600696,1 MFM 09/26/95 (Begin) Changed to work with store.
    *llWasSel=ARIABROW(IIF(lcKey='A',[XACCOUNT],''),"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,IIF(lcKey='A','ORDER,Account','Order,ACCOUNT'),"laData")  
    *B800299,1 TAK 11/08/95 Changed to work faster.
    *llWasSel=ARIABROW(IIF(lcKey='A','FOR ACCOUNT+STORE = XACCOUNT+IIF(EMPTY(xSTORE),"",xStore)',''),;
                      "Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,;
                      IIF(lcKey='A','ORDER,Account','Order,ACCOUNT'),"laData")
    IF lcKey='A'
      
      *E300676,1 Change this line to add the Parameter (lcOrdrType) to the
      *Key Exprition to filter on the Order Type [Begin]
      *llWasSel=ARIABROW([XACCOUNT]+' FOR STORE = IIF(EMPTY(xSTORE),"",xStore)',;
      *         "Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'ORDER,Account',"laData")
      llWasSel=ARIABROW([XACCOUNT + lcOrdrType]+' FOR STORE = IIF(EMPTY(xSTORE),"",xStore)',;
               "Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'ORDER,Account',"laData")
      *E300676,1 Change this line [End]
      
    ELSE
      
      *E300676,1 Change this line to add the Parameter (lcOrdrType) to the
      *Key Exprition to filter on the Order Type [Begin]
      *llWasSel=ARIABROW('',"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'Order,ACCOUNT',"laData")
      llWasSel=ARIABROW('lcOrdrType',"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'Order,ACCOUNT',"laData")
      *E300676,1 Change this line [End]
      
    ENDIF
    **B600696,1 MFM 09/26/95 (End).

    IF llWasSel
      XORDER    = laData[1]    
      XACCOUNT  = laData[2]
    ELSE
      XORDER = SPACE(6)
      XACCOUNT = SPACE(5)
    ENDIF  
ENDIF  
IF !EMPTY(lcOrdOrder)
  SET ORDER TO TAG (lcOrdOrder)
ELSE
  SET ORDER TO  
ENDIF  
SET RELATION TO
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN llWasSel

*****************************************************************************
* PROG: RABROW
* DESC: UDF() PROGRAM TO BROWSE THE R/A FOR A SPECIFIC ACCOUNT
* using the new browse
*****************************************************************************
*****************************************************************************
* PROG: RABROW
* DESC: UDF() PROGRAM TO BROWSE THE R/A FOR A SPECIFIC ACCOUNT
* using the new browse
*****************************************************************************
PROCEDURE RABROW
PARAMETER XRANO,llRetAlias
*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
STORE '' TO laData
llWasSel=.T.
llBrowse = IIF(TYPE('llBrowse')='U',.F.,llBrowse) && variable to determine forcing browse or not

*B600429,1 Change the fields width only under windth & add more fields
*B600429,1 to the browse {Invoice - Order - Custpo - Cartons}
IF _WINDOWS
  lcBrFields = [RANO:7:H="R/A #",RADATE:8:H="Issued",VOID:8:]+;
               [H="Void",AUTH:7:H="Pieces",AUTHAMT:10:H="Amount",]+;
               [invoice:8:H="Invoice",order:8:H="Order",]+;
               [custpo:12:H="Cust P/O",cartons:7:H="Cartons"]
ELSE
  lcBrFields = [RANO:6:H="R/A #",RADATE:8:H="Issued",VOID:8:]+;
               [H="Void",AUTH:7:H="Pieces",AUTHAMT:10:H="Amount",]+;
               [invoice:7:H="Invoice",order:6:H="Order",]+;
               [custpo:10:H="Cust P/O"]
ENDIF

lnCurAlias = SELECT()
IF TYPE('XACCOUNT')='U'
 STORE '' TO XACCOUNT
ENDIF             

IF !USED('RETAUTH')
  *E300637,1 Use the new global variables names
  *SELECT 0
  *DO NETUSE WITH '&QDD.RETAUTH','','SH'
  =gfOpenFile(gcDataDir+'RETAUTH',gcDataDir+'RETAUTH','SH')
  *E300637,1 (End)
ENDIF
SELECT RETAUTH
lcRatOrder = TAG()
SET ORDER TO TAG RETAUTHA

IF SEEK(xAccount + xRaNo)
  IF STATUS <> 'O'
    =gfDialog('I', 'This R/A is already complete!')
    XRANO = SPACE(6)
  ELSE
    XRANO = RANO
  ENDIF
ELSE
  lnSoftSeek=RECNO(0)
  IF SEEK(xAccount)
    IF TYPE('XSTORE') = "U"
      XSTORE=SPACE(8)
    ENDIF
    LOCATE REST FOR STATUS='O' .AND. IIF(EMPTY(XSTORE),.T.,STORE=XSTORE) ;
                WHILE ACCOUNT=xAccount    
    IF FOUND()
      IF lnSoftSeek<>0 
        GO lnSoftSeek
      ELSE
        GO TOP
      ENDIF     
      llWasSel=ARIABROW([xaccount FOR STATUS='O' .AND.;
               IIF(EMPTY(XSTORE),.T.,STORE=XSTORE)],;
               "Return Authorizations",;
               gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'','RANO',"laData")  
      XRANO = IIF(llWasSel,laData[1],SPACE(6))
    ELSE
      =gfDialog("I",'There are no open R/As for this account')
      XRANO = SPACE(6)
    ENDIF
  ELSE
    =gfDialog('I', 'There are no R/As for this account ! ')
    XRANO = SPACE(6)
  ENDIF
ENDIF

IF !EMPTY(lcRatOrder)
  SET ORDER TO TAG (lcRatOrder)
ELSE
  SET ORDER TO  
ENDIF  
IF llRetAlias
  SELECT(lnCurAlias)
ENDIF
RETURN(XRANO)

*****************************************************************************
* PROG: VENBROW
* DESC: UDF() PROGRAM TO BROWSE THE VENBROW 
* using the new browse
*****************************************************************************
PROCEDURE VENBROW
PARAMETER XVEN,llRetAlias
*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
STORE '' TO laData
llWasSel=.T.
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
*B500653,1 Reham Alallamy :Remarked on (04/26/95) Change the fields 
*B500653,1 width to prevent the horizontal scrolling in the browse.
*lcBrFields = [Vendor,Name,City,State:H="St.",Phone,Account:H="Our Acc"]+;
             [,vendor_typ:H="Vendor Type"]

*B600429,1 Change the browse fields variable (Fields width) under windows.
*B500772,1 HISH 07/02/96 Displayed field phone with its format.
IF _WINDOWS
  lcBrFields = [Vendor:11,Name:20,City:15,State:4:H="St.",Phone :P= "@R "+gcPhnFrmt :17,Account:8:H="Our Acc"]+;
               [,vendor_typ:17:H="Vendor Type"]
ELSE
  lcBrFields = [Vendor:8,Name:13,City:10,State:3:H="St.",Phone :P= "@R "+gcPhnFrmt :15,Account:7:H="Our Acc"]+;
               [,vendor_typ:11:H="Vendor Type"]
ENDIF
lnCurAlias = SELECT()             
SELE VENDOR
lcVenOrder = TAG()
SET ORDER TO TAG VENDOR
IF llBrowse OR !SEEK(XVEN) 
  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
  llWasSel=ARIABROW([],"Vendors",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'','VENDOR',"laData")  
  XVEN    =IIF(llWasSel,laData[1],SPACE(8))
ENDIF  
IF !EMPTY(lcVenOrder)
  SET ORDER TO TAG (lcVenOrder)
ELSE
  SET ORDER TO 
ENDIF
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN (XVEN)


*****************************************************************************
* PROG: FDYEBROW
* DESC: UDF() PROGRAM TO BROWSE THE Dyelots for specific fabric,color 
* using the new browse
*! Modi : 
*!N000016,4 WAM 05/07/95 Add a new parameter 'lcFromWare' to browse dyelots 
*!N000016,4 WAM 05/07/95 for specefic warehouse 
*****************************************************************************

PROCEDURE FDYEBROW
PARAMETER XFAB,XCLR,XDYELOT,llRetAlias, lcFromWare 
*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias,llFound && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,llFound,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
STORE '' TO laData
llWasSel   = .T.
llBrowse   = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lcBrFields = [Dyelot:H="Dyelot #",Onhand:H="On Hand",Usage]
lnCurAlias = SELECT()
IF !USED('FABDYE')
  *E300637,1 Use the new global variables names
  *SELE 0
  *DO NETUSE WITH '&QDD.FABDYE','&QDD.FABDYE','SH'
  =gfOpenFile(gcDataDir+'FABDYE',gcDataDir+'FABDYE','SH')  
  *E300637,1 (End)
ELSE
  SELECT FABDYE
  lcFDyOrder = TAG()
  SET ORDER TO TAG FabDye
ENDIF
llFound = .F.
IF SEEK(xFab+xClr+IIF( TYPE('lcFromWare') $ 'UL','',lcFromWare) )
  IF TYPE('lcFromWare')$'UL'
    LOCATE REST WHILE Fabric + Color =  xFab + xClr FOR !EMPTY(DyeLot)
  ELSE
    LOCATE REST WHILE Fabric + Color + cWareCode = ;
    xFab + xClr + lcFromWare FOR !EMPTY(DyeLot)
  ENDIF
  llFound = FOUND()
ENDIF  
IF llFound
  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
  llWasSel = ARIABROW([xFab+xClr+IIF(TYPE('lcFromWare')$ 'UL','',lcFromWare) FOR !EMPTY(DYELOT)],;
             "Item/Color "+ALLTRIM(xFab)+"/"+ALLTRIM(xClr)+" Dyelots",;
             gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,"","",;
             "FABDYE.Dyelot","laData")
  XDYELOT  = IIF(llWasSel, laData[1], SPACE(10))
ELSE
  XDYELOT  = SPACE(10)
  =gfDialog('I','There are no dyelots for item/color ' +;
            ALLTRIM(xFab)+'/'+ALLTRIM(xClr)+IIF(TYPE('lcFromWare')$'UL',;
            ' on the file.',;
            ' for warehouse '+ ALLTRIM(lcFromWare)+'.'))
ENDIF  

IF !EMPTY(lcFDyOrder)
  SET ORDER TO TAG (lcFDyOrder)
ELSE
  SET ORDER TO  
ENDIF  
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN llWasSel


*****************************************************************************
* PROG: CODECHK
* DESC: UDF() PROGRAM TO BROWSE THE Code file for specific type
* using the new browse
* CALLS: PROCEDUR lpSelOnEnt ( Enter key trapping procedure)
*B600441,1 RENEE 06/15/95. Fix the problem of the browse window being
*B600441,1                 right shifted. 
*B600682,1 MFM 09/24/95 Added new parameter to privent escape from browse
*****************************************************************************
PROCEDURE CODECHK
PARAMETERS XTYPE,XCODE,xTitle,llRetAlias,llNoEsc
PRIVATE lcBrFields,lnCurAlias,lnCodeLen, lnCodeTag,;
        lnWinWdth, lnOthrWdth, llEntered ,laKeyExp
        

PUSH KEY
=gfClearKey()

*!B600363,1 HESHAM EL-SHELTAWI 06/11/95
*!B600363,1 Adding incremental search and using duble click in selection
*!B600363,1 array laKeyExp Holding the Xtype to use in seeking in inc. sear.
*!B600363,1 lnx,lny variables hold mouse row and mouse column if click the
*!B600363,1 leftmouse
*!B600363,1 variable lnCurR hold the last mouse click row
*!B600363,1 lntimelimt hold the time of last mouse click 
*!B600363,1 lnSeeklimt hold the time of last key pressed in the inc. sear.
*!B600363,1 llClick variable to tell if left mouse was pressed previously.
DIMENSION laKeyExp[1]
STORE 0 TO lnX,lnY,lnCurR,lnTimelimt,lnSeeklimt,lnSelRec
STORE .F. TO llClick
STORE '"'+XTYPE+'"' TO laKeyExp

CLEAR TYPEAHEAD

xTitle = IIF(TYPE('xTitle')$'UL', "Codes", ALLTRIM(PROPER(xTitle)))
lnCurAlias = SELECT()
llBrowse   = IIF(TYPE('llBrowse') = 'U', .F., llBrowse)
DO CASE 
   CASE XTYPE = 'C'
     lnCodeLen  = 6
     lcBrFields = [CODE=SUBSTR(CODE,2,lnCodeLen):6,CDATA:H="Color Description",]+;
                  [CLRLNAME:H="Color Long Description"]
     lnWinWdth  = 62
     lnOthrWdth = 56             
   CASE XTYPE = 'D'
     lnCodeLen  = 2
     lcBrFields = [CODE=SUBSTR(CODE,2,lnCodeLen),CDATA:H="Division Description",]+;
                  [divlname:H="Division Long Description"]
     lnWinWdth  = 63
     lnOthrWdth = 57             
   CASE XTYPE = 'V'
     lnCodeLen  = 2
     lcBrFields = [CODE=SUBSTR(CODE,2,lnCodeLen),CDATA:H="Ship Via",cups:H="Ship Type":9]
     lnWinWdth  = 40
     lnOthrWdth = 31             

   CASE XTYPE$'FKO'
     lnCodeLen  = 3
     lcBrFields = [CODE=SUBSTR(CODE,2,3),CDATA:H="Description"] 
     lnWinWdth  = 27
     lnOthrWdth = 21             

   *E300502,1 TAK 12/15/96 (Start) Added Royalty code.
   CASE XTYPE = 'Q'
     lnCodeLen  = 6
     IF _WINDOWS .OR. _MAC
       lcBrFields = [CODE=SUBSTR(CODE,2,lnCodeLen):6,CDATA:H="Royalty Description",]+;
                    [CLRLNAME:H="Long Description":30,nTaxRate:H="Roy.Per."]
     ELSE
       lcBrFields = [CODE=SUBSTR(CODE,2,lnCodeLen):6,CDATA:H="Royalty Description",]+;
                    [CLRLNAME:H="Long Description",nTaxRate:H="Roy.Per."]
     ENDIF
     lnWinWdth  = 75
     lnOthrWdth = 67             
   *E300502,1 (End).

   OTHERWISE
     lnCodeLen  = 2
     lcBrFields = [CODE=SUBSTR(CODE,2,2),CDATA:H="Description"]
     lnWinWdth  = 27
     lnOthrWdth = 21        
ENDCASE

SELECT CODE
lnCodeTag = VAL(SYS(21))
SET ORDER TO TAG CODE
IF SEEK(xType)
  IF !SEEK(xtype+xCode) .OR. llBrowse
    lnSoftSeek  = RECNO(0)
    lcBrWinName = gfTempName()

    IF _WINDOWS .OR. _MAC
     *B600441,1 Change window co-ordinates to upper left corner
     *B600441,1 and then move window to the center
     * DEFINE WINDOW (lcBrWinName);
         AT 5,(SCOL()-lnWinWdth)/2 SIZE 20, lnWinWdth;
	     FONT "FoxFont", 9 ;
         FLOAT ;
         NOCLOSE ;
         SHADOW ;
         NOMINIMIZE ;
         SYSTEM ;
         COLOR SCHEME 10  	   
         
      DEFINE WINDOW (lcBrWinName);
         AT 0,0 SIZE 20, lnWinWdth;
	     FONT "FoxFont", 9 ;
         FLOAT ;
         NOCLOSE ;
         SHADOW ;
         NOMINIMIZE ;
         SYSTEM ;
         COLOR SCHEME 10  	            
         
    ELSE 
     *B600441,1 Change window co-ordinates to upper left corner
     *B600441,1 and then move window to the center
     * DEFINE WINDOW (lcBrWinName);
         AT 5,(SCOL()-lnOthrWdth)/2 SIZE 12, lnOthrWdth;
         FLOAT ;
         NOCLOSE ;
         SHADOW ;
         NOMINIMIZE ;
         SYSTEM ;
   	     COLOR SCHEME 10
   	     
 	  DEFINE WINDOW (lcBrWinName);
         AT 0,0 SIZE 12, lnOthrWdth;
         FLOAT ;
         NOCLOSE ;
         SHADOW ;
         NOMINIMIZE ;
         SYSTEM ;
   	     COLOR SCHEME 10
     ENDIF   
     
    MOVE WINDOW (lcBrWinName) CENTER   
    *B600441,1 end.
           
    IF '?' $ xCode .OR. !BETWEEN(lnSoftSeek, 1, RECCOUNT())
      GO TOP
    ELSE
      GO lnSoftSeek
    ENDIF     
  
    xCode     = SPACE(lnCodeLen)
    DATA      = SPACE(15)
    llEntered = .F.
    *!B600363,1 Define the on key for the leftmouse
    
    ON KEY LABEL LEFTMOUSE  DO lfCdChkDcl WITH xTitle, llEntered   
    
    *!B600363,1 variable lcExpToSeek hold the inc. sear. pressed expr.
    lcExpToSeek="" 
    lcOrdExpr=""
    *!B600363,1 if there is active tag then define the on key for the
    *!B600363,1 inc. sear.
    IF SYS(21)<>"0"
      lcOrdExpr   = SYS(14,EVAL(SYS(21)))
      lcOrdExpT   = TYPE(lcOrdExpr)
      lnStartTrap = IIF(lcOrdExpT='N',48,32)
      lnEndTrap   = IIF(lcOrdExpT='N',57,126)
      FOR lnChrToTrap = lnStartTrap TO lnEndTrap
        ON KEY LABEL (CHR(lnChrToTrap)) DO lfcdchIncS
      ENDFOR
    ENDIF  
          
    ON KEY LABEL ENTER DO lpSelOnEnt  WITH xTitle, llEntered    
    
    *B600682,1 MFM 09/24/95 (Begin) Added.
    IF llNoEsc
      ON KEY LABEL ESCAPE lnDumi = 1
    ENDIF
    *B600682,1 MFM 09/24/95 (End).

    BROWSE FIELDS &lcBrFields;
           KEY  xType;
           WINDOW (lcBrWinName);
           LOCK 0;
           NOMENU;         
           NOAPPEND;
           NOEDIT;
           NODELETE;
           TITLE xTitle
   
    IF llEntered
      *B600480,1 YI ON 06/20/95 if the code browse window on top of any 
      *other browse window that by chance may affect the record pointer
      *in the code file by having a relation into it or looking up into
      *it fox will refresh that window first befor giving the control
      *back to the program after corrupting the selected record and the
      *function will return the wrong record, SO we have to save the 
      *selected record number and jump to it befor collecting any data.
      IF lnSelRec > 0 .AND. lnSelRec<=RECCOUNT()
        GO lnSelRec
      ENDIF
    
      xCode   = SUBSTR(CODE.CODE, 2, lnCodeLen)
      DATA    = CODE.CDATA
    ENDIF  
    WAIT CLEAR
    RELEASE WINDOW (lcBrWinName)

    *B600682,1 MFM 09/24/95 (Begin) Added.
    ON KEY LABEL ESCAPE 
    *B600682,1 MFM 09/24/95 (End).

  ELSE
    xCode   = SUBSTR(CODE.CODE, 2, lnCodeLen)
    DATA    = CODE.CDATA
  ENDIF
ELSE
  *B600663,1 MFM 11/21/95 (Begin) If no records found then init the passed
  *B600663,1 MFM          variables with spaces.
  xCode   = SPACE(LEN(xCode))
  DATA    = SPACE(15)
  *B600663,1 MFM 11/21/95 (End).

  =gfDialog('I', 'There are no records to browse.')
ENDIF

SET ORDER TO lnCodeTag
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
POP KEY

*!**************************************************************************
*!
*!              Function: lfcdchIncS
*!
*!**************************************************************************
*
*!B600363,1 function added for inc. search.
FUNCTION lfcdchIncS
PRIVATE lnBrRecNO
* if the last key pressed time = 0 get the new time
IF lnSeeklimt = 0
  lnSeeklimt = SECONDS()  
ENDIF  
* if time in the limit of the last key pressed time and the dblclick time
IF SECONDS() < lnSeeklimt + _DBLCLICK 
  lnSeeklimt = SECONDS()  
  lnBrRecNO = IIF(RECNO()>RECCOUNT(),0,RECNO())
  * loop through the key used for the browse
  FOR lnCount = 1 TO ALEN(laKeyExp,1)
    * if seek of key+keypressed
    IF SEEK(&lakeyExp[lnCount]+lcExpToSeek+UPPER(CHR(LASTKEY())))
      * add the keypressed to the exptoseek
      lcExpToSeek = lcExpToSeek+UPPER(CHR(LASTKEY()))
      WAIT lcExpToSeek WINDOW NOWAIT                
      RETURN
    ELSE
    *else if !seek of key+keypressed return to the current record
      IF lnBrRecNO>0
        GO lnBrRecNO
      ENDIF  
    ENDIF
  ENDFOR
ELSE
* else if time not in the limit of the last key pressed time and the dblclick time
  lnSeeklimt = 0
  lcExpToSeek=''
  =lfcdchIncS()
ENDIF


*!******************************************************************
*!
*!              Function: lfCdChkDcl
*!
*!******************************************************************
*
FUNCTION lfCdChkDcl
PARAMETERS lcBrName,llExit
lnX =INT(MROW())
lnY =INT(MCOL())
*B600322 if the user pressed double click with the mouse in any of the
*B600322 scroll bars "Horz.,Vert." ignore it and dont select the active
*B600322 record, we added the checking if the MROW AND THE MCOL inside
*B600322 the browse window with out taking the position of the scroll
*B600322 bars in out consideration

IF  (MROW(lcBrName)<>-1) AND (MCOL(lcBrName)<>-1) AND (MROW(lcBrName)>IIF(_DOS OR _UNIX,2,1.77));
     AND BETWEEN(MCOL(lcBrName),2,WCOL(lcBrName)-IIF(_DOS OR _UNIX,2,1.77));
     AND BETWEEN(MROW(lcBrName),2,WROWS(lcBrName)-IIF(_DOS OR _UNIX,2,1.77))

*    AND MCOL(xTitle)<(WCOLS(xTitle)+WLCOL(xTitle)-IIF(_DOS OR _UNIX,2,3.77));
    AND MROW(xTitle)<(WROWS(xTitle)+WLROW(xTitle)-IIF(_DOS OR _UNIX,2,1.77))

  * if leftmouse wasn't pressed  previously 
  IF !llClick
    lnTimelimt = SECONDS()  
    lnCurR     = lnX
    llClick    = .T.
  ELSE
  * else if leftmouse was pressed  previously   
    * if the second click of the mouse is in the time limit and clicking
    * on the same row
    IF SECONDS() < lnTimelimt + _DBLCLICK .AND. lnCurR  = INT(MROW()); 
       AND  lnX=lnCurR 
      
      lnSelRec   = RECNO()
      llClick    = .F.

      ON KEY
      DEACTIVATE WINDOW  (lcBrName)
      llExit = .T.
   
      *KEYBOARD lcKeyLable CLEAR  
    ENDIF
    IF lnCurR    = INT(MROW())
      lnTimelimt = SECONDS()  
    ELSE
      llClick    = .F.
    ENDIF   
  ENDIF
ELSE
  llClick    = .F.
ENDIF


***************************************************************************
* PROG: PREPBROW
* DESC: BROWSE PREPAKS FOR A SPECIFIC SIZE SCALE
* DATE: 03/12/95
* PARA: SIZE SCALE FOR WHICH TO BROWSE
*B800831,1 TMI 11/11/96 Rewrite the lcBrFields to modify the prepack brows
***************************************************************************
PROCEDURE PREPBROW
PARAMETER XSCALE,llRetAlias
*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lnCurAlias,lnCodeLen && Variable to hold browse fields
PRIVATE lcBrFields,lnCurAlias,lnCodeLen,laData
*E300637,1 (End)

DECLARE laData[2]  && array to get values from browse
STORE ' ' TO laData,lcBrFields
llWasSel=.T.
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lnCurAlias = SELECT()
SELECT SCALE
lcScaleTag = TAG()
SET ORDER TO TAG SCALE
llFound = .T.
IF SEEK ('P'+xScale)
  lcPreHed =''
  FOR lnCount = 1 TO Cnt
    lcPreHed = lcPreHed+IIF(lnCount>1,',','')+'PP'+STR(lnCount,1)+'H:="XXX"'
  ENDFOR
ELSE
  llFound = .F.
  =gfDialog("I",'There is no prepak for scale '+ XSCALE)
  XPREPAK = SPACE(1)
ENDIF

*B800831,1 TMI 11/11/96 Fill the vars. with the scale sizes.
IF SEEK('S'+xScale,'Scale')
  FOR I = 1 TO 8
    Z   = STR(I,1)
    lcScale&Z = Scale.SZ&Z
  ENDFOR  
ENDIF
*B800831,1 TMI 11/11/96 (End)


IF (!SEEK('P'+xScale) OR llBrowse) AND llFound
  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
  *B800831,1 TMI 11/11/96 Commented out the next line and rewrite it to 
  *B800831,1              modify the prepack brows
*  lcBrFields =[Prepak:H="Prepack",ppTot:H="Total"]+IIF(!EMPTY(lcPreHed),',','')+lcPreHed

  lcBrFields =[Prepak:H="Prepack",]+;
              [PP1 :H=lcScale1,]+;
              [PP2 :H=lcScale2,]+;
              [PP3 :H=lcScale3,]+;
              [PP4 :H=lcScale4,]+;
              [PP5 :H=lcScale5,]+;
              [PP6 :H=lcScale6,]+;
              [PP7 :H=lcScale7,]+;
              [PP8 :H=lcScale8,]+;
              [ppTot :H="Total"]+IIF(!EMPTY(lcPreHed),',','')+lcPreHed
  *B800831,1 TMI 11/11/96 (END)  
  llWasSel=ARIABROW(["P"+XSCALE],"Prepack",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'',"PREPAK","laData")  
  XPREPAK  = IIF(llWasSel,laData[1],SPACE(1))
ENDIF  
IF !EMPTY(lcScaleTag)
  SET ORDER TO TAG (lcScaleTag)
ELSE
  SET ORDER TO 
ENDIF
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN(XPREPAK)


*!**************************************************************************
*! PROG: STYBROWC.PRG
*! DESC: Program to browse through the Style database SHOWING ALL THE COLORS
*! DATE: 10/29/1990
*! NOTE: THIS PROGRAM ASSUMES THAT THE STYLE FILE HAS BEEN OPENED
*!
*! Modifications :
*!           3/13/92
*!           1) IF COLORS BEING DISPLAYED THEN BASED ON SYSTEM PARMETER
*!              M_COLOR EITHER DISPLAY COLOR NAME OR NOT.
*!       ARH 02/24/94
*!           1) Changed the browse to display the STYLE# 15 chrs. instead of
*!              7 chrs.
*!       ARH 06/14/94
*!           1) Increased the color code to be 6 chrs. instead of 3 chrs.
*!              and decreased the style # to be 12 chrs. instead of 15 chrs.
*!**************************************************************************
PROCEDURE STYBROWC

Parameters XSTYLE,XCLR      && returns the STYLE AND COLOR selected

***** ADDED 3/13/92 TO FIND OUT IF COLOR NAMES TO BE DISPLAYED OR NOT *****
RESTORE FROM ADPARA&QSYSCODE ADDI
X_COLOR =IIF(M_COLOR='Y',.T.,.F.)
RELEASE ALL LIKE M_*

*E300637,1 Use the new global variables names
*IF X_COLOR .AND. (.NOT. OPENED('CODE'))
*  DO NETUSE WITH '&QDD.CODE','&QDD.CODE','SH'
*ENDIF
=IIF(X_COLOR,gfOpenFile(gcDataDir+'CODE',gcDataDir+'CODE','SH'),.T.)
*E300637,1 (End)
***************************************************************************

SAVE SCREEN TO STYBROWC

SELE STYLE

PRIVATE ROW,X_COLOR

SET COLOR TO &QCLRNRM
CLEAR

DO HEADER WITH 'STYBROWC','STYLE BROWSE'
**  CHECK IF FILE IS EMPTY **
GG = SYS(2002)

IF RECCOUNT()=0
  = gfDialog ("I","Style file is empty. No records to browse.")
  
  *-- ARH 06/14/94 Decreased the style to 12 chrs. instead of 15 chrs.
  XSTYLE=SPACE(12)        && ARH 02/24/94 Increased to 15 instead of 7 
  *-- END  ARH  06/14/94

  RESTORE SCREEN FROM STYBROWC
  RETURN
ENDIF

XSTYLE = TRIM( XSTYLE )

SEEK XSTYLE

IF .NOT. FOUND()
  IF RECNO(0)=0
    GO TOP
  ELSE
    GO RECNO(0)
    IF DELETED()
      SKIP
      IF EOF()
        GO TOP
      ENDIF
    ENDIF
  ENDIF
ENDIF

XSTYLE = STYLE
*....*....1....*....2....*....3....*....4....*....5....*....6....*....7....*....
* STYLE        COLOR  DESCRIPTION  SE DI  PRICE     WIP   STOCK  ORDERS  O.T.S.
*   X XX XX  XX X X X

**** FOLLOWING FORMAT ADDED 3/13/92 ****
*....*....1....*....2....*....3....*....4....*....5....*....6....*....7....*...
* STYLE        ........COLOR...... DESCRIPTION     SE DI FABRIC  PRICE     WIP   STOCK
*   XXXXXXXXXXXX XXXXXXXXXXXXXXX XX XX XXXXXXX XXXXXX XXXXXXX XXXXXXX


XTOTWIP = 0
XTOTSTK = 0
XTOTORD = 0

DO WHILE .T.

  QRECNO = 0
  ROW    = 5

  DO DRAWBOX WITH QCLRMAG,'',2,0,21,79
  SET COLOR TO &QCLRMAG

  *-- ARH 06/14/94 Adjusted the color header.
  IF X_COLOR
    @ 03,01 SAY ' STYLE        .......COLOR....... DESCRIPTION     SE DI  PRICE     WIP   STOCK'  && ARH 02/24/94
  ELSE
    @ 03,01 SAY ' STYLE        COLOR  DESC.      SE DI   PRICE     WIP   STOCK  ORDERS  O.T.S.'  && ARH 02/24/94
  ENDIF
  *-- END  ARH  06/14/94

  @ 4,1 TO 4,78

  DO WHILE .NOT. EOF() .and. ROW < 21 .AND. (XSTYLE=STYLE)

    SET COLOR TO &QCLRSAY

    @ ROW,2 SAY STYLE

    QRECNO( ROW ) = RECNO()

    *-- ARH 06/14/94 Moved
    @ ROW,15 SAY COLOR         && ARH 02/24/94 Moved

    IF X_COLOR
      SELE CODE
      SEEK 'C'+STYLE->COLOR
      @ ROW,22 SAY IIF(FOUND(),SUBSTR(CDATA,1,12),'** ERROR **') && ARH 02/24/94 Moved

      SELE STYLE
      @ ROW,35 SAY SUBSTR(DESC,1,15)      && ARH 02/24/94 Moved
      @ ROW,51 SAY SEASON                 && ARH 02/24/94 Moved
      @ ROW,54 SAY DIVISION               && ARH 02/24/94 Moved
      @ ROW,57 SAY PRICEA PICTURE '999.99'
      @ ROW,64 SAY TOTWIP PICTURE '9999999'
      @ ROW,72 SAY TOTSTK PICTURE '9999999'

    ELSE

      ******
      ***ARH 02/24/94 Moved
      ******
      @ ROW,22 SAY SUBSTR(DESC,1,10)
      @ ROW,33 SAY SEASON
      @ ROW,36 SAY DIVISION
      @ ROW,40 SAY PRICEA PICTURE '999.99'
      @ ROW,47 SAY TOTWIP PICTURE '9999999'
      @ ROW,55 SAY TOTSTK PICTURE '9999999'
      @ ROW,63 SAY TOTORD PICTURE '9999999'
      *** END   ARH   02/24/94

      IF (TOTWIP+TOTSTK)-TOTORD<0
        SET COLOR TO &QCLRBLK
      ENDIF

      @ ROW,71 SAY (TOTWIP+TOTSTK)-TOTORD PICTURE '9999999'

    ENDIF

    ROW=ROW+1

    SKIP

  ENDDO

  SET COLOR TO &QCLRMAG
  BP(8)='STYLE->STYLE=XSTYLE'
  THISKEY=BROW()

  DO CASE
    CASE THISKEY = QRETKEY   && return key
      GG=SYS(2002,1)
      STORE COLOR TO XCLR
      EXIT
          
    CASE THISKEY = QESCKEY   && escape key
      GG=SYS(2002,1)
      
      *-- ARH 06/14/94 Increased the color to be 6 chrs. instead of 3 chrs.
      XCLR  = SPACE(6)

      EXIT

    OTHERWISE
  
  ENDCASE
ENDDO
         
GG= SYS(2002,1)

RESTORE SCREEN FROM STYBROWC

***
***END STYBROWC.PRG
***

*!**************************************************************************
*! PROG: FABROWC.PRG
*! DESC: Program to browse through the fabric database TO SHOW ALL IT'S COLORS
*! DATE: 10/29/1990
*! NOTE: ONLY PASS BACK THE COLOR
*! 
*! Modifications :
*!           3/13/92
*!           1) IF COLORS BEING DISPLAYED THEN BASED ON SYSTEM PARMETER
*!              M_COLOR EITHER DISPLAY COLOR NAME OR NOT.
*!      ARH 06/14/94
*!          1) Increased the color code to be 6 chrs. instead of 3 chrs.
*!             and adjusted the rest of the browse according to this.
*!      MFM 07/12/94
*!          1) Incresed the vendor code to 8 characters for the AP link changes.
*!**************************************************************************
PROCEDURE FABROWC

Parameters XFAB,XCLR      && returns the FABRIC COLOR selected

***** ADDED 3/13/92 TO FIND OUT IF COLOR NAMES TO BE DISPLAYED OR NOT *****
RESTORE FROM ADPARA&QSYSCODE ADDI
X_COLOR =IIF(M_COLOR='Y',.T.,.F.)
RELEASE ALL LIKE M_*

*E300637,1 Use the new global variables names
*IF X_COLOR .AND. (.NOT. OPENED('CODE'))
*  DO NETUSE WITH '&QDD.CODE','&QDD.CODE','SH'
*ENDIF
=IIF(X_COLOR,gfOpenFile(gcDataDir+'CODE',gcDataDir+'CODE','SH'),.T.)
*E300637,1 (End)

SAVE SCREEN TO FABROWC

SELE FABRIC

PRIVATE ROW,X_COLOR

SET COLOR TO &QCLRNRM
CLEAR

DO HEADER WITH 'FABROWC','MATERIAL COLOR BROWSE'
**  CHECK IF FILE IS EMPTY **
GG = SYS(2002)

IF RECCOUNT()=0
  = gfDialog ("I","Material file is empty. No records to browse.")
  XFAB=SPACE(7)
  RESTORE SCREEN FROM FABROWC
  RETURN
ENDIF

XFAB = TRIM( XFAB )

SEEK XFAB

IF .NOT. FOUND()
  IF RECNO(0)=0
    GO TOP
  ELSE
    GO RECNO(0)
    IF DELETED()
      SKIP
      IF EOF()
        GO TOP
      ENDIF
    ENDIF
  ENDIF
ENDIF

XFAB = FABRIC

*-- MFM 07/12/94.
*!    ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....
*!.. 
*!..  ITEM    COLOR  DESCRIPTION    TYP LOC.  VENDOR   PATTERN     ON HAND ON ORDER
*!.. 
*!..           
*!..  1234567 123456 12345678901234 12  12345 12345678 1234567890 99999999 99999999
*!.. 
*!
*!    ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....
*!.. 
*!..  ITEM    ......COLOR...... DESCRIPTION   TY LOC.  VENDOR   PATTERN     ON HAND
*!.. 
*!..          
*!..  1234567 123456 1234567890 1234567890123 12 12345 12345678 1234567890 99999999
*!.. 
*-- END MFM 07/12/94.

XONHAND = 0
XONORDER= 0

DO WHILE .T.
  QRECNO = 0
  ROW    = 5

  DO DRAWBOX WITH QCLRMAG,'',2,0,21,79
  SET COLOR TO &QCLRMAG

  *-- ARH 06/14/94
  IF X_COLOR
    @ 03,01 SAY ' ITEM    ......COLOR...... DESCRIPTION   TY LOC.  VENDOR   PATTERN     ON HAND'
  ELSE
    @ 03,01 SAY ' ITEM    COLOR  DESCRIPTION    TYP LOC.  VENDOR   PATTERN     ON HAND ON ORDER'
  ENDIF
  *-- END  ARH  06/14/94
  
  @ 4,1 TO 4,78

  DO WHILE .NOT. EOF() .and. ROW < 21 .AND. (FABRIC=XFAB)
    SET COLOR TO &QCLRSAY
    @ ROW,2 SAY FABRIC
    QRECNO( ROW ) = RECNO()
    @ ROW,10 SAY COLOR

    *-- ARH 06/14/94 Adjusted the coordinates according because we changed
    *-- the color code to be 6 chrs. instead of 3 chrs.
    IF X_COLOR
      SELE CODE
      SEEK 'C'+FABRIC->COLOR
      @ ROW,17 SAY IIF(FOUND(),SUBSTR(CDATA,1,10),'** ERROR**')

      SELE FABRIC
      @ ROW,28 SAY SUBSTR(DESC,1,13)
      @ ROW,42 SAY ITEM_TYPE
      @ ROW,45 SAY LOC
      @ ROW,51 SAY VENDOR
      @ ROW,60 SAY PATTERN
      @ ROW,71 SAY ONHAND PICTURE '99999999'
    ELSE
      @ ROW,17 SAY SUBSTR(DESC,1,14)
      @ ROW,32 SAY ITEM_TYPE
      @ ROW,36 SAY LOC
      @ ROW,42 SAY VENDOR
      @ ROW,51 SAY PATTERN
      @ ROW,62 SAY ONHAND PICTURE '99999999'
      @ ROW,71 SAY ONORDER PICTURE '99999999'
    ENDIF
    *-- END  ARH  06/14/94

    ROW=ROW+1
    SKIP
  ENDDO

  SET COLOR TO &QCLRMAG
  BP(8)="FABRIC->FABRIC=XFAB"

  THISKEY=BROW()

  DO CASE
    CASE THISKEY = QRETKEY   && return key
      GG=SYS(2002,1)
      STORE COLOR TO XCLR
      EXIT
          
    CASE THISKEY = QESCKEY   && escape key
      GG=SYS(2002,1)
      XCLR  = SPACE(6)    && ARH 06/14/94 Changed the size from 3 chrs.
                          && to be 6 chrs.
      EXIT
  ENDCASE
ENDDO
         
GG= SYS(2002,1)

RESTORE SCREEN FROM FABROWC

***
***END FABROWC.PRG
***

*!-----------------------------------------------------------------------------
*! PROG: SDYEBROW
*! DESC: PROGRAM TO BROWSE THE STYLE DYELOTS TO SELECT ONE
*! DATE: 06/11/91
*! PARA: STYLE/COLOR AND DYELOT
*! MODI: 13/03/95 HISH
*! Modifications :
*!      ARH 05/05/94 :
*!          1) Added the ability not to display the empty dyelots
*!             in the browse.
*****************************************************************************
*N16,5 Added a parameter lcFromWare (optional) to enable browsing 
*N16,5 style/color/dyelots for a specific warehouse
*E300511,4 Reham On 08/04/97
*E300511,4 Remove the color from the function.
*****************************************************************************
PROCEDURE SDYEBROW
*E300511,4 Reham On 08/04/97  ** Begin **
*PARAMETER XSTYLE,XCLR,XDYELOT,llRetAlias, lcFromWare 
*E301339,1 Add 2 parameters
*PARAMETER XSTYLE,XDYELOT,llRetAlias, lcFromWare 

*B802829,1 KHM 03/06/2000 (Begin) Adding new parameters, lcBrwAlias to hold
*B802829,1                the alias name, lcIndTag to hold the tag.
*PARAMETER XSTYLE,XDYELOT,llRetAlias, lcFromWare ,llIncAvail, llTop
PARAMETER XSTYLE,XDYELOT,llRetAlias, lcFromWare ,llIncAvail, llTop ,;
          lcBrwAlias , lcIndTag
*B802829,1 KHM 03/06/2000 (End)

*E301339,1 end
*E300511,4 Reham On 08/04/97  ** End   **

*N16,5 lcFromWare : If passed, browse style/color/dyelots for that
*N16,5              warehouse only, otherwise, or if empty, browse
*N16,5              all style/color/dyelots.

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lcAlias, lcFromWare, lnStyOrd, lnAlias && Variable to hold browse fields

*B802829,1 KHM 03/06/2000 (Begin) Adding the initialization of lcBrwAlias to,
*B802829,1                hold the alias name, lcDataDir to hold the directory
*B802829,1                of the passed file, and lcIndTag to hold the tag 
*B802829,1                of the passed file. Then check if there was no 
*B802829,1                file passed then use the StyDye file and the 
*B802829,1                data directory where it exists.
*PRIVATE lcBrFields,lcAlias, lcFromWare, lnStyOrd, lnAlias,laData
PRIVATE lcBrFields,lcAlias, lcFromWare, lnStyOrd, lnAlias,laData ,;
        lcBrwAlias, lcDataDir , lcIndTag
IF TYPE("lcBrwAlias") $ "UL"
  lcBrwAlias = "STYDYE"
  lcDataDir  = gcDataDir
ELSE
  lcDataDir  = gcWorkDir
ENDIF
lcIndTag = IIF(TYPE("lcIndTag") $ "UL","STYDYE",lcIndTag)
*B802829,1 KHM 03/06/2000 (End)

*E300637,1 (End)

DECLARE laData[3] && array to get values from browse
laData     = ' '
llBrowse   = IIF(TYPE('llBrowse')='U',.F.,llBrowse) && variable to determine forcing browse or not
*E301339,1 Position the browse in the upper half of the screen if a parameter is passed
PRIVATE lnBrHSRow1, lnBrHSCol1, lnBrHSRow2, lnBrHSCol2
IF llTop
  lnBrHSRow1 = gnBrFSRow1
  lnBrHSCol1 = gnBrFSCol1
  lnBrHSRow2 = gnBrHSRow1
  lnBrHSCol2 = gnBrHSCol1
ELSE
  lnBrHSRow1 = gnBrHSRow1
  lnBrHSCol1 = gnBrHSCol1
  lnBrHSRow2 = gnBrHSRow2
  lnBrHSCol2 = gnBrHSCol2
ENDIF
*E301339,1 End
*N16,5 Added adjusting parameters width (check)
xStyle     = PADR(xStyle, 19)

*E300511,4 Reham On 08/04/97  ** Begin **
*xClr       = PADR(xClr  ,  6)
*E300511,4 Reham On 08/04/97  ** End   **

*N16,5 If lcFromWare is empty, or is not passed browse for all warehouses.
lcFromWare = IIF(TYPE('lcFromWare') $ 'UL' .OR. EMPTY(lcFromWare),'', lcFromWare)
*N16,5 end.

*E300511,4 Reham On 08/04/97  ** Begin **
*lcTitle    = "Style/Color "+ALLTRIM(xStyle)+"/"+ALLTRIM(xClr)+" Dyelots"
lcTitle    = "Style "+ALLTRIM(xStyle)+" Dyelots"
*E300511,4 Reham On 08/04/97  ** End   **
*E301339,1 Add available fields, and show allocated before stock according to a parameter
*lcBrFields = "DYELOT:R :H='Dyelot #':10,"+;
*             "STK1  :R :H='Stk1':6,"+
lcBrFields = "DYELOT:R :H='Dyelot #':10,"
IF llIncAvail
  lcBrFields = lcBrFields +; 
	         "A1=STK1-ALO1  :R :H='Avl1':6,"+;	         	           	         
             "A2=STK2-ALO2  :R :H='Avl2':6,"+;
	         "A3=STK3-ALO3  :R :H='Avl3':6,"+;
	         "A4=STK4-ALO4  :R :H='Avl4':6,"+;
	         "A5=STK5-ALO5  :R :H='Avl5':6,"+;
	         "A6=STK6-ALO6  :R :H='Avl6':6,"+;
	         "A7=STK7-ALO7  :R :H='Avl7':6,"+;
	         "A8=STK8-ALO8  :R :H='Avl8':6,"+;
	         "A9=TOTSTK-TOTALO :R :H='TotAvl':7,"
  lcBrFields = lcBrFields +; 
	         "ALO1  :R :H='Alo1':6,"+;
  	         "ALO2  :R :H='Alo2':6,"+;
	         "ALO3  :R :H='Alo3':6,"+;
	         "ALO4  :R :H='Alo4':6,"+;
	         "ALO5  :R :H='Alo5':6,"+;
	         "ALO6  :R :H='Alo6':6,"+;
	         "ALO7  :R :H='Alo7':6,"+;
	         "ALO8  :R :H='Alo8':6,"+;
             "TOTALO:R :H='TotAlo':7,"+;
	         "STK1  :R :H='Stk1':6,"+;	         	           	         
             "STK2  :R :H='Stk2':6,"+;
	         "STK3  :R :H='Stk3':6,"+;
	         "STK4  :R :H='Stk4':6,"+;
	         "STK5  :R :H='Stk5':6,"+;
	         "STK6  :R :H='Stk6':6,"+;
	         "STK7  :R :H='Stk7':6,"+;
	         "STK8  :R :H='Stk8':6,"+;
	         "TOTSTK:R :H='TotStk':7"
	         
ELSE
*E301339,1 end
  lcBrFields = lcBrFields +; 
	         "STK1  :R :H='Stk1':6,"+;	         	           	         
             "STK2  :R :H='Stk2':6,"+;
	         "STK3  :R :H='Stk3':6,"+;
	         "STK4  :R :H='Stk4':6,"+;
	         "STK5  :R :H='Stk5':6,"+;
	         "STK6  :R :H='Stk6':6,"+;
	         "STK7  :R :H='Stk7':6,"+;
	         "STK8  :R :H='Stk8':6,"+;
	         "TOTSTK:R :H='TotStk':7,"+;
	         "ALO1  :R :H='Alo1':6,"+;
  	         "ALO2  :R :H='Alo2':6,"+;
	         "ALO3  :R :H='Alo3':6,"+;
	         "ALO4  :R :H='Alo4':6,"+;
	         "ALO5  :R :H='Alo5':6,"+;
	         "ALO6  :R :H='Alo6':6,"+;
	         "ALO7  :R :H='Alo7':6,"+;
	         "ALO8  :R :H='Alo8':6,"+;
             "TOTALO:R :H='TotAlo':7"

ENDIF
*N16,5 Removed the following lines and substituted with the new style
*N16,5 of coding and function calling

*lcAlias = ALIAS()   && Save the current alias.
*IF !USED('STYDYE')
*  SELECT 0
*  DO NETUSE WITH '&QDD.STYDYE','&QDD.STYDYE','SH'
*ENDIF
*SELECT STYDYE
*lcStyOrder = TAG()

lnAlias    = SELECT()
*E300637,1 Use the new global variables names
*llOpenFile = IIF(USED('STYDYE'), .F.,;
                 gfOpenFile(qDD+'STYDYE', 'STYDYE', 'SH'))  
*B802829,1 KHM 03/06/2000 (Begin) Changing the open file to open the
*B802829,1                passed file instead of opening the StyDye directly.
*llOpenFile = gfOpenFile(gcDataDir+'STYDYE',gcDataDir+'STYDYE','SH')
llOpenFile = gfOpenFile(lcDataDir+lcBrwAlias,lcDataDir+lcIndTag,'SH')
*B802829,1 KHM 03/06/2000 (End)

*E300637,1 (End)

*B802829,1 KHM 03/06/2000 (Begin) Select the passed file instead of selecting
*B802829,1                the stydye directly.
*SELECT STYDYE
SELECT (lcBrwAlias)
*B802829,1 KHM 03/06/2000 (End)

lnStyOrd   = VAL(SYS(21))
*N16,5 end.

*B802829,1 KHM 03/06/2000 (Begin) Setting the passed index.
*SET ORDER TO TAG STYDYE
SET ORDER TO TAG (lcIndTag)
*B802829,1 KHM 03/06/2000 (End)

GO TOP

*N16,5 Include warehouse parameter in search
*SEEK XSTYLE + XCLR
*LOCATE REST FOR !EMPTY(DYELOT);
       WHILE STYLE+COLOR = XSTYLE+XCLR

*E300511,4 Reham On 08/04/97  ** Begin **
*SEEK XSTYLE + XCLR + lcFromWare
*LOCATE REST FOR !EMPTY(DYELOT);
*       WHILE STYLE + COLOR + cWareCode = XSTYLE + XCLR + lcFromWare
SEEK XSTYLE + lcFromWare
LOCATE REST FOR !EMPTY(DYELOT) WHILE STYLE + cWareCode = XSTYLE + lcFromWare
*E300511,4 Reham On 08/04/97  ** End   **

*N16,5 end.

IF !FOUND()
  *N16,5 Present the message according to the case whether browsing
  *N16,5 for a specific warehouse or not.
  *=gfDialog('I','There are no dyelots for style/color ' +;
             ALLTRIM(xStyle)+'/'+ALLTRIM(xClr)+' on the file.')
  
  *E300511,4 Reham On 08/04/97  ** Begin **
  *E300511,4 Change to use gfModalGen.
  *=gfDialog('I', 'There are no dyelots for style/color ' +;
             ALLTRIM(xStyle) + '/' + ALLTRIM(xClr) + ;
             IIF(EMPTY(lcFromWare), ' on the file.',;
               ' for warehouse ' + ALLTRIM(lcFromWare) + '.'))
  *** There are no dyelots for style ALLTRIM(xStyle) ***
  *** <  Ok  > ***


  *B602163,4 Change for warehouse to in location in the following line.
  *lcTmpStr = ALLTRIM(xStyle) + ;
  *           IIF(EMPTY(lcFromWare) , ;
  *               ' on the file' , ;
  *               ' for warehouse ' + ALLTRIM(lcFromWare))
  lcTmpStr = ALLTRIM(xStyle) + ;
             IIF(EMPTY(lcFromWare) , ;
                 ' on the file' , ;
                 ' in location ' + ALLTRIM(lcFromWare))
  =gfModalGen("INM00277B00000" , "DIALOG" , lcTmpStr)
  *E300511,4 Reham On 08/04/97  ** End   **
  *N16,5 end.
               
  *N16,5 Removed. Resetting environment is done only once below.  
  *  IF !EMPTY(lcStyOrder)
  *    SET ORDER TO TAG (lcStyOrder)
  *  ELSE
  *    SET ORDER TO  
  *  ENDIF  
  *  IF llRetAlias
  *    SELECT (lcAlias)
  *  ENDIF  
  *  RETURN
  llWasSel = .F.
  *N16,5 end.
ELSE
  *N16,5 Include warehouse in the browse key parameter
  *llWasSel= ARIABROW('XSTYLE+XCLR'+[FOR !EMPTY(DYELOT)],lcTitle,;
            gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','',"Style,Color,Dyelot","laData")
  *E300511,4 Reham On 08/04/97  ** Begin **
  *E300511,4 Remove the color from the browse.
  *llWasSel= ARIABROW('XSTYLE + XCLR + lcFromWare'+[FOR !EMPTY(DYELOT)],lcTitle,;
             gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','',"Style,Color,Dyelot","laData")
*E301339,1 Use positioning variables for the browse position
*  llWasSel= ARIABROW('XSTYLE + lcFromWare'+[FOR !EMPTY(DYELOT)],lcTitle,;
            gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','',"Style,Dyelot","laData")
  llWasSel= ARIABROW('XSTYLE + lcFromWare'+[FOR !EMPTY(DYELOT)],lcTitle,;
            lnBrHSRow1, lnBrHSCol1, lnBrHSRow2, lnBrHSCol2,'','',"Style,Dyelot","laData")            
*E301339,1 End            
  *E300511,4 Reham On 08/04/97  ** End   **
  *N16,5 end.
  
  IF llWasSel
    *E300511,4 Reham On 08/04/97  ** Begin **
    *E300511,4 Remove the color
    *XCLR   = laData[2]
    XSTYLE = laData[1]
    XDYELOT= laData[2]
    *E300511,4 Reham On 08/04/97  ** End   **
  ELSE
    XDYELOT= SPACE(10)
  ENDIF  
ENDIF

*N16,5 Reset environment 
*IF !EMPTY(lcStyOrder)
*  SET ORDER TO TAG (lcStyOrder)
*ELSE
*  SET ORDER TO  
*ENDIF  
*IF llRetAlias
*  SELECT (lcAlias)
*ENDIF  
SET ORDER TO lnStyOrd

*B802829,1 KHM 03/06/2000 (Begin) Check if the passed file is open in this
*B802829,1                function then close it.
*IF llOpenFile .AND. USED('STYDYE')
*  USE IN STYDYE
*ENDIF   
IF llOpenFile .AND. USED(lcBrwAlias)
  USE IN (lcBrwAlias)
ENDIF   
*B802829,1 KHM 03/06/2000 (End)
SELECT (lnAlias)
*N16,5 end.

RETURN llWasSel


*-----------------------------------------------------------------------------
*HEADER.PRG
*PROGRAM TO DISPLAY PROGRAM NAME,TITLE,DATE AT ROW 1
*DATE:09/03/88
*-----------------------------------------------------------------------------
PROCEDURE HEADER
PARAMETERS PROG,TITLE
SET COLOR TO &QCLRMAG
PRIVATE X
@ 00,00
@ 00,01 SAY PROG+'('+QSYSCODE+')'
X = ((80-(LEN(TRIM(TITLE))))/2)
@ 00,X SAY TITLE
@ 00,71 SAY DATE()
SET COLOR TO &QCLRNRM
RETURN
******************************************************************************
* PROG: RPT_HDR
* DESC: PRINTS THE HEADER ON THE REPORTS (WIDE PAPER,NARROW PAPER)
* DATE: 05/19/90
* PARA: 1 PROGRAM
*       2 TITLE    ADDITIONAL TITLE (XRPTNAME)
*       3 TYPE     'N' -> NARROW   'W'-> WIDE    'XW'-> XTRA WIDE
* NOTE: THE ACTUAL REPORT CAN START ON LINE 5
*       R_TITLE => THE REPORT TITLE (STANDARD)
*       PAGENO=PAGE NUMBER
* MODI: TAK 06/05/94
*           1) Added special character '~' to determine a new page.  
******************************************************************************
PROCEDURE RPT_HDR
PARAMETER XPROG,XRPTNAME,XTYPE

PRIVATE ALL LIKE X*
XRPTNAME = TRIM(XRPTNAME)
R_TITLE  = TRIM(R_TITLE)
DO CASE
 CASE XTYPE = 'W'                            && WIDE REPORT
  X1 = ((130 - (LEN(TRIM(QCOMPANY))))/2)

  X2 = ((130 - (LEN( R_TITLE  )))/2)
  X3 = ((130 - (LEN( XRPTNAME )))/2)

  @ 01,000 SAY XPROG
  @ 01,X1  SAY QCOMPANY
  @ 01,120 SAY DATE()
  @ 01,129 SAY '~'   &&TAK 06/05/94
  @ 02,000 SAY TIME()
  @ 02,X2  SAY R_TITLE 
  @ 02,120 SAY 'PAGE#'
  @ 02,126 SAY STR(PAGENO,4)
  @ 03,X3  SAY XRPTNAME
  @ 04,00 SAY REPLICATE('*',132)

 CASE XTYPE = 'XW'                            && XTRA WIDE REPORT
  *E301115,1 AMM Change location
  *X1 = ((203 - (LEN(TRIM(QCOMPANY))))/2)
  *X2 = ((203 - (LEN( R_TITLE  )))/2)
  *X3 = ((203 - (LEN( XRPTNAME )))/2)
  X1 = ((186 - (LEN(TRIM(QCOMPANY))))/2)
  X2 = ((186 - (LEN( R_TITLE  )))/2)
  X3 = ((186 - (LEN( XRPTNAME )))/2)
  *E301115,1 AMM end

  @ 01,000 SAY XPROG
  @ 01,X1  SAY QCOMPANY
  *E301115,1 AMM change location
  *@ 01,190 SAY DATE()
  *@ 01,199 SAY '~'   &&TAK 06/05/94
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[start]
  *@ 01,175 SAY DATE()
  *@ 01,184 SAY '~'   &&TAK 06/05/94
  @ 01,165 SAY DATE()
  @ 01,174 SAY '~'   &&TAK 06/05/94
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[End]
  *E301115,1 AMM end

  @ 02,000 SAY TIME()
  @ 02,X2  SAY R_TITLE 
  
  *E301115,1 AMM  change location
  *@ 02,190 SAY 'PAGE#'
  *@ 02,196 SAY STR(PAGENO,4)
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[start]
  *@ 02,175 SAY 'PAGE#'
  *@ 02,181 SAY STR(PAGENO,4)
  @ 02,165 SAY 'PAGE#'
  @ 02,171 SAY STR(PAGENO,4)
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[End]
  *E301115,1 AMM end
  
  @ 03,X3  SAY XRPTNAME
  *E301115,1 AMM Change location
  *@ 04,00 SAY REPLICATE('*',225)
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[start]
  *@ 04,00 SAY REPLICATE('*',187)
  @ 04,00 SAY REPLICATE('*',177)
  *B804086,1 MHM 04/01/2001 move Page # to left 10 CHR[end]
  *E301115,1 AMM end

 CASE XTYPE='N'                                      && NARROW REPORT
  X1 = ((80 - (LEN(TRIM(QCOMPANY))))/2)
  X2 = ((80 - (LEN( R_TITLE  )))/2)
  X3 = ((80 - (LEN( XRPTNAME )))/2)

  @ 01,000 SAY XPROG
  @ 01,X1  SAY QCOMPANY
  @ 01,70 SAY DATE()
  @ 01,79 SAY '~'   &&TAK 06/05/94
  @ 02,000 SAY TIME()
  @ 02,X2  SAY R_TITLE
  @ 02,70 SAY 'PAGE#'
  @ 02,76 SAY STR(PAGENO,4)
  @ 03,X3 SAY XRPTNAME
  @ 04,00 SAY REPLICATE('*',80)
ENDCASE

RETURN

*!*************************************************************
*! Name      : RPT_HDR
*! Developer : MAB (Mohamed Atia Badran)
*! Date      : 02/04/1999
*! Purpose   : This procedure is instead of the original one to support
*!           : new standard header format.
*!*************************************************************
*! Passed Parameters  : 1- Program Name (for prototype only and no longer used )
*!                    : 2- Report Title
*!                    : 3- Report Type ('N' Normal,'W' Wide,'XW' extra wide)
*!                    : 4- Optional title
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Example   : DO RPT_HDR WITH 'ARSJOUR','Sales Journal','W',lcRpOpTitl
*!*************************************************************
*! Note      : Now you can remove the line QCompany = gcCom_Name
*!           : from all xxReport programs, because this variable 
*!           : is no longer in use by any function in report modules.
*!*************************************************************
*! Due to E301130,1 
*
PROCEDURE RPT_HDR1
PARAMETER XPROG,lcRptTitle,lcRptType,lcOptTitle
PRIVATE ALL LIKE l*

IF TYPE('lcOptTitle') $ 'UL'
  lcOptTitle = ''
ENDIF

lnRepLen  = IIF(lcRptType='N',80,IIF(lcRptType='W',132,187))  && Report Width
lnLftRght = 32     && Right and Left Titles (15 + 17)

*-- Variables to be printed. [Begin
lnCenWidth = IIF(lcRptType='N',40,80)              && Center title max. len
lcRepComp  = ALLTRIM(PADR(gcCom_Name,lnCenWidth))  && Company Name
lcOptTitle = ALLTRIM(PADR(lcOptTitle,lnCenWidth))  && Optional Title
lcRptTitle = ALLTRIM(PADR(lcRptTitle,lnCenWidth))  && Report Title
*-- Variables to be printed. [End

*-- Positions at them we start print Pre-defined variables [Begin
lnPrnComp  = 17 + INT((lnRepLen - lnLftRght - LEN(lcRepComp))/2)
lnPrnOpt   = IIF(EMPTY(lcOptTitle),0, 17 +;
              INT((lnRepLen - lnLftRght - LEN(lcOptTitle))/2))
lnPrnTitle = INT((lnRepLen - LEN(lcRptTitle))/2)
*-- Positions at it we start print Pre-defined variables [End..

*-- Print Header Code [Begin


*-- Line # 1 in Header[Begin]
@ 01,000          SAY 'By   : ' + ALLTRIM(gcUser_Id)
@ 01,lnPrnComp    SAY lcRepComp
@ 01,lnRepLen-15  SAY 'Date : ' + ALLTRIM(DTOC(gdSysDate))
*-- Line # 1 in Header[End  ]

*-- Line # 2 in Header[Begin]
@ 02,000          SAY 'Time : ' + TIME()
IF !EMPTY(lcOptTitle)
  @ 02,lnPrnOpt    SAY lcOptTitle
ENDIF  
@ 02,lnRepLen-15  SAY 'Page : ' + ALLTRIM(STR(PAGENO))
*-- Line # 2 in Header[End  ]

*-- Line # 3 in Header[Begin]
@ 03,lnPrnTitle   SAY lcRptTitle
*-- Line # 3 in Header[End  ]

*-- Line # 4 in Header[Begin]
@ 04,00 SAY REPLICATE(' ',lnRepLen)
*-- Line # 4 in Header[End  ]

*-- Print Header Code [End..
*-- end of RPT_HDR.


******************************************************************************
*-------------------------------------------
         PROCEDURE DEMO_CHECK
*-------------------------------------------
*----------------------------------------------------------------------------*
*  PROC : DEMO_CHECK
*  DESC : IF DEMO VERSION CHECK THE EXPIRATION OF THE SYSTEM
*  AUTH : FARRUKH NOOR AWAN                                                  *
*  DATE : 10/31/93
*  MODI : 02/26/94 FAR
*         1) Check for the existance of files before openeing, in order to
*            handle the first time installations.
******************************************************************************
DIMENSION XCHCK_FILE(4,2)

XCHCK_FILE(1,1)='CUSTOMER'           && FILENAME
XCHCK_FILE(1,2)=200                   && ALLOWED NUMBER OF RECORDS
XCHCK_FILE(2,1)='STYLE'
XCHCK_FILE(2,2)=300
XCHCK_FILE(3,1)='ORDHDR'
XCHCK_FILE(3,2)=1000
XCHCK_FILE(4,1)='INVHDR'
XCHCK_FILE(4,2)=1000

*B800214,1 10/08/95 TAK
*-Checking existance of the files.
*-Don't continue if at least one of them not found.
FOR I=1 TO 4
  XCHCK_NAME=XCHCK_FILE(I,1)
  *E300637,1 Use the new global variables names
  *IF !FILE('&QDD.&XCHCK_NAME..DBF')
  IF !FILE('&gcDataDir.&XCHCK_NAME..DBF')  
  *E300637,1 (End)
    =gfDialog("!","&XCHCK_NAME file does not exist, Cannot proceed. Please contact Aria Systems, INC.")
    IF 'TEST' $ UPPER(GETENV("FOX"))
      SET EXCLUSIVE OFF
      SET PROCEDURE TO
      SET SYSMENU TO DEFA
      ON ERROR
      ON KEY LABEL ESC
      ON KEY LABEL F1
      *E300285,1 MAN Change CLOSE DATABASES to gfClsData
      *CLOSE DATABASES
      =gfclsdata()
      CANCEL
    ELSE
      ON KEY LABEL F2
      ON KEY LABEL F3
      QUIT
    ENDIF
  ENDIF
ENDFOR
*B800214,1 End.

SELECT 0
XCHCK_COUNT=1
DO WHILE XCHCK_COUNT <= 4
  XCHCK_NAME=XCHCK_FILE(XCHCK_COUNT,1)
  *E300637,1 Use the new global variables names
  *IF FILE('&QDD.&XCHCK_NAME..DBF')
    *DO NETUSE WITH '&QDD.&XCHCK_FILE(XCHCK_COUNT,1)','','SH'
  IF FILE('&gcDataDir.&XCHCK_NAME..DBF')  
    DO NETUSE WITH '&gcDataDir.&XCHCK_FILE(XCHCK_COUNT,1)','','SH'
  *E300637,1 (End)
    IF RECCOUNT() > XCHCK_FILE(XCHCK_COUNT,2)          && CHECK FOR RECCOUNT
      =gfDialog("!","This demo version has expired.  Please contact Aria Systems, INC.")
      IF 'TEST' $ UPPER(GETENV("FOX"))
        SET EXCLUSIVE OFF
        SET PROCEDURE TO
        SET SYSMENU TO DEFA
        ON ERROR
        ON KEY LABEL ESC
        ON KEY LABEL F1
        *E300285,1 MAN Change CLOSE DATABASES to gfClsData
        *CLOSE DATABASES
        =gfClsData()
        CANCEL
      ELSE
        ON KEY LABEL F2
        ON KEY LABEL F3
        QUIT
      ENDIF
    ELSE
      XCHCK_COUNT=XCHCK_COUNT+1
    ENDIF
  ENDIF
ENDDO

USE 

RELEASE XCHCK_FILE,XCHCK_COUNT,XCHCK_NAME
RETURN

****
**** END OF DEMO_CHECK
****

*-------------------------------------------
         PROCEDURE MSG22
*-------------------------------------------
PARAMETER MSG,VALUES
PRIVATE COL,CENTER
STORE SPACE(1) TO CHOICE

* VALUES = $ - ANY KEY TO CONTINUE
* VALUES = @ - MSG DISPLAYED W/O RESPONSE
IF TYPE('VALUES')='U'
   VALUES='@'
ENDIF
lcDeviSc=''
IF SYS(101)<>'SCREEN'
  lcDeviSc=SET('DEVI')
  SET DEVICE TO SCREEN
ENDIF  

MSG=' '+MSG

IF LEN(MSG)<=80
   STORE SPACE((80-LEN(MSG))/2) TO CENTER
ELSE
   STORE SPACE(5) TO CENTER
ENDIF
COL=LEN(CENTER)

DO WHILE .T.
   CHOICE=' '
   SET COLOR TO &QCLRNRM
   @ 23,00 CLEAR
   SET COLOR TO &QCLRBLK

   IF VALUES $ '$@'
      @ 23,COL SAY MSG
      IF VALUES ='$'
         IF ISCOLOR()
            GETCLR = 'GR+/B,B/B'
         ELSE
            GETCLR = 'W+/N,N/N'
         ENDIF
         SET COLOR TO &GETCLR
         @ 24,COL SAY 'Press any key to continue ... '
         @ ROW(),COL() GET CHOICE PICTURE '!'
         READ
      ENDIF
   ENDIF

   IF .NOT. VALUES $ '$@'
      @ 23,COL SAY MSG GET CHOICE PICTURE '!'
      READ
      SET COLOR TO &QCLRNRM
      IF AT(CHOICE,VALUES)=0
         LOOP
      ENDIF
   ENDIF

   EXIT
ENDDO

SET COLOR TO &QCLRNRM
IF VALUES<>'@'
   @ 23,00 CLEAR
ENDIF
IF !EMPTY(lcDeviSc)
  SET DEVI TO &lcDeviSc
ENDIF
RETURN

*------------------------------------
* USER DEFINED FUNCTION THAT WILL RETURN .T. IF THE FILE WAS OPENED IN ANY
* WORK-AREA
*------------------------------------
 PROCEDURE OPENED
*------------------------------------
PARAMETER FILE_NAME
PRIVATE XOPEN,XALIAS,XWA
XOPEN  =.T.
XALIAS = ALIAS()
XWA    ='1'

*DO WHILE UPPER(XALIAS)<>UPPER(FILE_NAME).AND.VAL(XWA)<26
*  SELE &XWA
*  XOPEN=IIF(UPPER(ALIAS())=UPPER(FILE_NAME),.T.,.F.)
*  IF XOPEN
*    EXIT
*  ENDIF
*  XWA=STR(VAL(XWA)+1,2)
*ENDDO

*IF LEN(TRIM(XALIAS))=0.OR..NOT.XOPEN
*  IF WA_COUNT() < 1
*    SELE 25
*    USE
*  ENDIF

*  SELE 0
*ELSE
*  SELE &XALIAS
*ENDIF

**** MODIFIED BY FA ON 8/23 TO USE FOXPRO 2.0 USED FUNCTION ****
IF USED(FILE_NAME)
  SELE &FILE_NAME
  XOPEN=.T.
ELSE
  SELE 0
  XOPEN=.F.
ENDIF

RETURN XOPEN

********************
 PROCEDURE STARTPRT
********************
PARAMETER XPRT_SET
SET DEVICE TO PRINT
@ PROW(),PCOL() SAY &XPRT_SET
RETURN

********************
 PROCEDURE ENDPRT
********************
IF QREPO_SCR
*  DO RPTSCROL
   lcMemWidth=SET('MEMOWIDTH')
   SET MEMOWIDTH TO 230
   SET PRINTER TO 
   SET DEVI TO SCREEN
   lcOGWinTitl='Report'
   *E300637,1 Use the new global variables names
   *DO gpGetFile WITH qWD+qRepoTXT+'.TXT',lcOGWinTitl
   *SET MEMOWIDTH TO lcMemWidth
   *ERASE &qWD.&qRepoTXT..TXT
   DO gpGetFile WITH gcWorkDir+qRepoTXT+'.TXT',lcOGWinTitl
   SET MEMOWIDTH TO lcMemWidth
   ERASE &gcWorkDir.&qRepoTXT..TXT
   *E300637,1 (End)
ELSE
  IF .NOT. EMPTY(QP10CPI)               && ADDED BY FAR ON 04/17/93 TO HANDLE
    *-- MAC.Ver. MFM 02/19/95.
    IF _MAC
      SET PRINTER FONT 'FOXPRINT',14
    ELSE
      SET DEVICE TO PRINT                 && PRINTING TO A FILE IN WHICH CASE
      @ PROW(),PCOL() SAY &QP10CPI        && QREPO_sCR IS ALSO .F.
      *!B600410,1 06/10/95 Hesham El-Sheltawi
      *!B600410,1 sending a form feed to the printer insted of using
      *!B600410,1 the EJECT command becauses the EJECT command cause
      *!B600410,1 some problems
      @ PROW(),PCOL() SAY CHR(12)         && Send form feed to the printer to eject to next page
*      EJECT
    ENDIF  
  ENDIF
  IF S_CLOSEALL
    *E300285,1 MAN Change CLOSE DATABASES to gfClsData
    *CLOSE DATABASES
    =gfClsData()
  ENDIF
  S_CLOSEALL = .T.
  **  EJECT                             && commented out by FAR 04/26/93

  IF _UNIX
    SET PRINTER TO
  ELSE  
    SET PRINTER TO 
  ENDIF
  
  SET DEVICE TO SCREEN
  
  *-- MFM 07/13/94.
  IF !qBatchMod
    DO BEEP
  ENDIF
  *-- END MFM 07/13/94.
  *!B600410,1 Hesham el-sheltawi 06/10/95
  *-- if windows platform and the selected device is printer    
  IF _WINDOWS AND gcDevice = 'P'
    *-- set printer to local port
    SET PRINTER TO (gcLoclPort)
    llError=.F.
    lcOnErr=ON('ERROR')
    ON ERROR llError=.T.
    lcSetSafe=SET('SAFE')
    SET SAFE OFF
    *-- copy temprory file to local port to print it
    *E300637,1 Use the new global variables names
    *IF FILE(qWD+qRepoTXT+".TXT")
    IF FILE(gcWorkDir+qRepoTXT+".TXT")
    *E300637,1 (End)
      *B600951,1 Get the value of the output port in another variable
      gcLoclPrt = gcLoclPort
      *B600951,1 HESHAM EL-SHELTAWI 30/01/96
      *B600951,1 ADDING NEW WAY OF PRINTING
      *-- IF ENVIROMENT VARIABLE FOR PRINTING IS DEFINED
      *-- THEN PRINT BY USING THE TECH. ??? ELSE USE THE COPY COMMAND
      *-- Take care that we are setting the printer to the port in which
      *-- we want to print to before starting printing
      DO CASE
        CASE GETENV('ARIAPRN')='???'
          lcTmpCur = gfTempName() && temprory cursor
          lcWorkA = SELECT()      && curr. work area
          CREATE CURS &lcTmpCur (mprnfile M) && create temp. cursor
          APPEND BLANK 
          *-- append memo with the output file
          *E300637,1 Use the new global variables names
          *APPEND MEMO mprnfile FROM (qWD+qRepoTXT+".TXT") 
          APPEND MEMO mprnfile FROM (gcWorkDir+qRepoTXT+".TXT") 
          *E300637,1 (End)
          *-- clear the printer port then set the device to printer with the 
          *-- port needed to print.
          SET PRINTER TO 
          SET DEVICE TO PRINTER
          *B600951,1
          *SET PRINTER TO (gcLoclPort)
          SET PRINTER TO (gcLoclPrt)
          SET PRINTER ON
          *-- reset the printing cursor then start printing the memo field
          @ 0,0 SAY ""
          ??? MPRNFILE
          *-- reset the device to screen and clear the printer buffer to make
          *-- the printer start printing.
          SET DEVICE TO SCREEN
          *B600951,1
          SET PRINTER OFF
          SET PRINTER TO
          *-- close the temp. cursor and select the curr. work area
          USE IN &lcTmpCur
          SELECT (lcWorkA)          
          
        CASE UPPER(GETENV('ARIAPRN'))="COPY"
          SET PRINTER TO (gcLoclPRT)  
          *E300637,1 Use the new global variables names
          *lcFileNm = qWD+qRepoTXT+".TXT"
          lcFileNm = gcWorkDir+qRepoTXT+".TXT"
          *E300637,1 (End)
          !COPY &lcFileNm &gcLoclPRT

        CASE UPPER(GETENV('ARIAPRN'))="LIB"
*!*	          IF FILE("TXTSPOOL.FLL") AND FILE("PRTWIN.EXE")
*!*	            SET LIBRARY TO TXTSPOOL.FLL ADDITIVE
*!*	            lcWinPrt  = "IBM Proprinter on " + ALLTRIM(gcLoclPRT)
*!*	            lcOrgPrnt =PRTWIN(LCWINPRT)
*!*	            *E300637,1 Use the new global variables names
*!*	            *lcFileNm = qWD+qRepoTXT+".TXT"
*!*	            lcFileNm = gcWorkDir+qRepoTXT+".TXT"
*!*	            *E300637,1 (End)
*!*	            =TXTSPOOL(lcFileNm ,"ARIA SYSTEMS")
*!*	            = PRTWIN(lcOrgPrnt)
*!*	            RELEASE LIBRARY TXTSPOOL.FLL
*!*	          ENDIF
          
        OTHERWISE
          *E300637,1 Use the new global variables names
          *COPY FILE (qWD+qRepoTXT+".TXT") TO (gcLoclPort+'.DOS')
          COPY FILE (gcWorkDir+qRepoTXT+".TXT") TO (gcLoclPort+'.DOS')
          *E300637,1 (End)
      ENDCASE

    ENDIF  
    ON ERROR &lcOnErr
    SET SAFE &lcSetSafe    
    *--delete temprory file
    *E300637,1 Use the new global variables names
    *ERASE (qWD+qRepoTXT+".TXT")
    ERASE (gcWorkDir+qRepoTXT+".TXT")
    *E300637,1 (End)
  ENDIF
  *IF SUBSTR(VERSION(),1,12)='FoxPro/LAN 2.0'
  *  SET PRINTER OFF
  *ENDIF
ENDIF

RETURN

*------------------------------------
      PROCEDURE BEEP
*------------------------------------
PRIVATE I,MAX,CNT,lnRow,lnCol

*B800284,1 TAK 11/05/95 Start.
RESTORE FROM ADPARA&qSysCode ADDI
llBeep = ( M_Beep = 'Y' )
RELEASE ALL LIKE M_*

IF ! llBeep
  IF _DOS .OR. _UNIX
    SET COLOR TO &QCLRNRM
  ENDIF
  *--Return without beep.
  RETURN
ENDIF
*--Proceed with beep.
*B800284,1 TAK 11/05/95 End.

I  = 0
MAX= 500
*B800149,1 Set color under DOS or UNIX only
*SET COLOR TO &QCLRBLK
IF _DOS .OR. _UNIX
  SET COLOR TO &QCLRBLK
ENDIF  
*B800149,1 end.
lcTmpWind = ''
lnRow =23
lnCol=20
IF !EMPTY(WOUTPUT())
  lcTmpWind = SYS(2015)
  DEFINE WINDOW (lcTmpWind) FROM 1,1 TO 5,60 DOUBLE COLOR SCHEME 5
  MOVE WINDOW (lcTmpWind) center
  ACTIVATE WINDOW (lcTmpWind)
  lnRow = 2
  lnCol=3
ENDIF
DO WHILE I=0
   @ lnRow,00
   ? CHR(7)
   @ lnRow,lnCol SAY 'Report finished ! Press any key to continue ...'
   CNT=0
   DO WHILE CNT<=MAX
      CNT=CNT+1
   ENDDO
   I = INKEY()
ENDDO
IF !EMPTY(lcTmpWind)
  RELEASE WINDOW (lcTmpWind)
ENDIF
*B800149,1 Set color under DOS or UNIX only
*SET COLOR TO &QCLRNRM
IF _DOS .OR. _UNIX
  SET COLOR TO &QCLRNRM
ENDIF
*B800149,1 end.

RETURN
*****************************************************************************
PROCEDURE DRAWBOX
PARAMETERS COLOR,TITLE,TLINE,TCOL,BLINE,BCOL
PRIVATE COLOR,TCOL,TLINE,TITLE,BLINE,BCOL
SET COLOR TO &COLOR
@ TLINE+1,TCOL+1 TO BLINE-1,BCOL-1 CLEAR

@ TLINE,TCOL,BLINE,BCOL BOX CHR(219)+CHR(223)+CHR(219)+CHR(219)+CHR(219);
+CHR(220)+CHR(219)+CHR(219)+" "

IF .NOT. EMPTY(TITLE) .AND. LEN(TITLE)>1
  XCOL = CENTER(TCOL,BCOL,TITLE)
  @ TLINE,XCOL SAY TITLE
ENDIF

SET COLOR TO &QCLRNRM
RETURN

******************************************************************************
* PROCEDU : NETUSE                                                           *
* DESC.   : OPEN THE DATABASE FILES FOR MULTI/SINGLE USER SYSTEMS            *
* DATE    : NOV 5 1989                                                       *
* MODI    : MARCH 01, 1993
*              FAR - ADDED THE ABILITY TO OPEN STRUCTURED INDECES FOR FOX2 VERSION
******************************************************************************
*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
******************************************************************************
PROCEDURE NETUSE
PARAMETERS NFILE,NDEX,MODE
PRIVATE NMSG,MODE,lcActWin

*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
NMSG = 'OPENING '+NFILE+' INDEX TAG '+SUBSTR(NDEX,IIF('\' $ NDEX,ATC('\',NDEX,OCCURS('\',NDEX)),0)+1)+'....'
NMSG = PROPER(NMSG)
lnCurRow = ROW()
lnCurCol = COL()
IF 'SCREEN' $ SYS(101)
  DO CASE
    CASE _DOS OR _UNIX
      lcActWin = WONTOP()
      ACTIVATE SCREEN
      @ 24,00 SAY gfMsgStr(NMSG) COLOR &gcMsgClr
      IF !EMPTY(lcActWin)
        ACTIVATE WINDOW (lcActWin) 
      ENDIF  
    CASE _WINDOWS OR _MAC
      SET MESSAGE TO NMSG
  ENDCASE      
ENDIF
*E300247,1 YMA 06/13/95 End.

SET EXCL OFF
IF S_NET
  lcOpenMode = IIF(MODE='EX', "EXCLUSIVE", "SHARED")
  IF !EMPTY(NDEX) 
 * USE &NFILE ORDER TAG SUBSTR(NDEX,AT('\',NDEX)+1) &lcOpenMode
   USE &NFILE ORDER TAG SUBSTR(NDEX,IIF('\' $ NDEX,ATC('\',NDEX,OCCURS('\',NDEX)),0) +1) &lcOpenMode
  ELSE
    USE &NFILE &lcOpenMode
  ENDIF
ELSE 
  IF !EMPTY(NDEX)
 *  USE &NFILE ORDER TAG SUBSTR(NDEX,AT('\',NDEX)+1) EXCLUSIVE
    USE &NFILE ORDER TAG SUBSTR(NDEX,IIF('\' $ NDEX,ATC('\',NDEX,OCCURS('\',NDEX)),0)+1) EXCLUSIVE 
  ELSE
    USE &NFILE EXCL
  ENDIF
ENDIF

*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
IF 'SCREEN' $ SYS(101)
  DO CASE
    CASE _DOS OR _UNIX
      lcActWin = WONTOP()
      ACTIVATE SCREEN
      @ 24,00 SAY gfMsgStr("") COLOR &gcMsgClr
      @ lnCurRow,lnCurCol SAY ""
      IF !EMPTY(lcActWin)
        ACTIVATE WINDOW (lcActWin) 
      ENDIF  
    CASE _WINDOWS OR _MAC
      SET MESSAGE TO ""
  ENDCASE      
ENDIF
*E300247,1 YMA 06/13/95 End.

****************************************************************************
* PROG : BROW.PRG
* DESC : UDF() THAT CREATE BROWSE SCREENS
* AUTH : OMAR RAMADAN
* DATE : 03/17/90
* 
* NOTE : AN ARRAY IS INITIALIZED IN THE BEGINNING TO HOLD SOME PARAMETERS
*        ABOUT THE BROWSE SCREEN:
* BP[01] = LINE FOR THE ARROW
* BP[02] = COL FOR THE ARROW
* BP[03] = OPTIONAL PREFIX FOR INDEX
* BP[04] = ROW TO DISPLAY KEYS MESSAGE
* BP[05] = RIGHT COL OF THE WINDOW
* BP[06] = ENABLE <Ins> TO ADD
* BP[07] = ENABLE <Del> TO DELETE
* BP[08] = OPTIONAL CONDITION
* BP[09] = OPTIONAL SEARCH KEY INDICATOR
* BP[10] = OPTIONAL POINTER FOR THE ARROW     && ARH 08/22/93
* QRECNO[25] TO KEEP THE RECORD NUMBER FOR EACH RECORD DISPLAYED
* 1- PUT THE POINTER ON THE FIRST RECORD OF THE BROW
* 2- DISPLAY THE ARROWS PROMPT
* 3- GET THE USER'S INPUT
* 4- RETURN THE VALUE OF THE KEY PRESSED   thiskey
* 
* MODI : ARH 08/22/93
*            1) Added a new element BP(10) to the array BP which implements
*               an OPTIONAL POINTER FOR THE ARROW
*        TAK 09/09/93
*            1) REDISPLAY BROWSE MESSAGE AFTER MAKE A LOCATE IN NOT 
*               INDEX DATA
*****************************************************************************
PROCEDURE BROW
***
***** DISPLAY THE MESSAGE FOR THE KEYS
***

PRIVATE TOPROW,XOLDCOLOR

DO CASE
  CASE BP(6)='N'.AND.BP(7)='N'          && NO  <Ins> , NO  <Del>
    XMSG = '<'+CHR(24)+'> '+'<'+CHR(25)+'> '+'<PgUp> <PgDn> <Home> <End> <Esc>'
 *****************************************
  CASE BP(6)='N'.AND.BP(7)='Y'          && NO  <Ins> , YES <Del>
    XMSG = '<'+CHR(24)+'> '+'<'+CHR(25)+'> '+'<PgUp> <PgDn> <Home> <End> <Del> <Esc>'
  ******************************************
  CASE BP(6)='Y'.AND.BP(7)='N'          && YES <Ins> , NO  <Del>
    XMSG = '<'+CHR(24)+'> '+'<'+CHR(25)+'> '+'<PgUp> <PgDn> <Home> <End> <Ins> <Esc>'
  ******************************************
  CASE BP(6)='Y'.AND.BP(7)='Y'          && YES <Ins> , YES <Del>
    XMSG = '<'+CHR(24)+'> '+'<'+CHR(25)+'> '+'<PgUp> <PgDn> <Home> <End> <Ins> <Del> <Esc>'
ENDCASE

***
****** SAVE THE EXISTING COLOR
***
XOLDCOLOR = SYS(2001,'COLOR')

SET COLOR TO &QCLRBLK
XMSGCOL = CENTER(BP(2),BP(5),XMSG)

@ BP(4),XMSGCOL    SAY XMSG

***
*** DISPLAY THE ARROW
***
SET COLOR TO &XOLDCOLOR
*******Added by ARH on 08/22/93 to make the ARROW points at the last*********
************modified record if the modifications was permitted***************
IF BP(10) = 0 
  @ BP(1),BP(2) SAY CHR(16)
  ARROW = BP(1)
ELSE
  @ BP(10),BP(2) SAY CHR(16)
  ARROW = BP(10)
ENDIF    
**************************END   ARH   08/22/93********************************
TOPROW  = BP(1)
BOTROW  = BP(4)
XSEARCH = SPACE(1)

GG     =SYS(2002)
IF LEN(TRIM(BP(8)))<>0
  XCOND=BP(8)
ENDIF

IF QRECNO(ARROW) >0
  GO QRECNO(ARROW)
ENDIF

DO WHILE QRECNO(TOPROW)<>0
  THISKEY=INKEY(0)
  ***
  ****** CHECK THE USER'S INPUT
  ***
  DO CASE
    CASE THISKEY = QLFTKEY .OR. THISKEY = 127   && LEFT ARROW OR BACKSPACE

      XSEARCH = TRIM( XSEARCH )
      IF LEN(XSEARCH) > 0
        XSEARCH = SUBSTR(XSEARCH, 1,LEN(XSEARCH) - 1 )
        IF LEN(XSEARCH) = 0
          SET COLOR TO &QCLRNRM
          @ BP(4),BP(2) TO BP(4),BP(5) CLEAR
          SET COLOR TO &QCLRBLK
          @ BP(4),XMSGCOL SAY XMSG
        ENDIF

        SET COLOR TO &QCLRNRM
        @ BP(4),00
        @ BP(4),XMSGCOL SAY 'LOCATE=>'+' '+XSEARCH
      ENDIF

      LOOP

    CASE THISKEY = QUPKEY
      IF ARROW=TOPROW
        LOOP
      ENDIF

      XNEXTROW=ARROW-1

      DO WHILE QRECNO(XNEXTROW)=0
        XNEXTROW=XNEXTROW-1
      ENDDO
      SET COLOR TO &XOLDCOLOR
      @ ARROW,BP(2) SAY ' '
      @ XNEXTROW,BP(2) SAY CHR(16)
      GO QRECNO(XNEXTROW)
      ARROW=XNEXTROW

    CASE THISKEY = QDWNKEY
      IF ARROW=BOTROW
        LOOP
      ENDIF

      XNEXTROW=ARROW+1
      DO WHILE QRECNO(XNEXTROW)=0.AND.XNEXTROW<24
        XNEXTROW=XNEXTROW+1
      ENDDO

      IF .NOT.QRECNO(XNEXTROW)=0)
        SET COLOR TO &XOLDCOLOR
        @ ARROW,BP(2) SAY ' '
        @ XNEXTROW,BP(2) SAY CHR(16)
        GO QRECNO(XNEXTROW)
        ARROW=XNEXTROW
      ENDIF

    CASE THISKEY = QPGUKEY
      GO QRECNO(TOPROW)
      SKIP - (BOTROW- (TOPROW+5) )
      IF BOF()
        GO TOP
      ENDIF

      IF LEN(TRIM(BP(8)))<>0
        SCAN WHILE  !&XCOND
        ENDSCAN
      ENDIF
      EXIT

    CASE THISKEY = QPGDKEY
      XLASTROW=BOTROW

      DO WHILE QRECNO(XLASTROW)=0
        XLASTROW=XLASTROW-1
      ENDDO

      GO QRECNO(XLASTROW)
      EXIT

    CASE THISKEY = QHMEKEY
      IF LEN(TRIM(BP(8)))<>0
        DO WHILE (.NOT. BOF()) .AND. &XCOND
          SKIP -1
        ENDDO
        IF BOF()
          GO TOP
        ELSE
          SKIP
        ENDIF
      ELSE
        GO TOP
      ENDIF
      EXIT

    CASE THISKEY = QENDKEY
      IF LEN(TRIM(BP(8)))<>0
        SET COLOR TO &QCLRNRM
        @ BOTROW,00
        XCOL = CENTER(BP(2),BP(5),'WAIT..')
        @ BOTROW,XCOL SAY 'WAIT..'
        DO WHILE.NOT.EOF().AND.&XCOND
          SKIP
        ENDDO
        SKIP-1
        @ BOTROW,XCOL SAY SPACE(6)
      ELSE
        GO BOTT
      ENDIF
      EXIT

    CASE THISKEY = QRETKEY
      **
      ** IF SOMETHING WAS ENTERED FOR FAST SEARCH
      **
      THISREC = RECNO()

      IF LEN(TRIM(XSEARCH)) > 0
        XKEY = IIF(LEN(TRIM( BP(3) )) > 0 ,BP(3) + XSEARCH ,XSEARCH )

        SEEK XKEY
        XSEARCH = SPACE(1)

        ** CLEAR THE LINE FOR LOCATE
        SET COLOR TO &QCLRNRM
        @ BP(4),BP(2) TO BP(4),BP(5) CLEAR

        SET COLOR TO &QCLRBLK
        @ BP(4),XMSGCOL SAY XMSG
        THISKEY = 0

        IF .NOT. FOUND()
          ?? CHR(7)
          IF RECNO(0)=0
            GO THISREC
            LOOP
          ELSE
            GO RECNO(0)
            IF DELETED()
              SKIP
              IF LEN(TRIM(BP(8))) > 0
                IF EOF() .OR. (.NOT. &XCOND)
                  GO THISREC
                  LOOP
                ENDIF
              ELSE
                IF EOF()
                  GO THISREC
                  LOOP
                ENDIF   && EOF()
              ENDIF     && LEN OF BP(8)
            ENDIF       && DELETED
          ENDIF         && IF RECNO(0)=0
        ENDIF
      ENDIF

      EXIT
    CASE THISKEY = QESCKEY
      EXIT
    CASE THISKEY = QINSKEY
      IF BP(6)='Y'
        EXIT
      ELSE
        LOOP
      ENDIF
    CASE THISKEY = QDELKEY
      IF BP(7)='Y'
        EXIT
      ELSE
        LOOP
      ENDIF

    OTHERWISE
      IF THISKEY <= 0 .OR. THISKEY = 28     && NON STANDARD CHARACTERS
        IF THISKEY=28
          ON KEY LABEL F1 HELP           &&*B800153,1 TAK 09/03/95 Added.              
          HELP
          ON KEY LABEL F1 DO lpPressF1   &&*B800153,1 TAK 09/03/95 Added.
        ENDIF
        EXIT                                && ADDED CHECK FOR F1 FOR HELP
      ENDIF                                 && BY FAR ON 08/17/93
      IF BP(9)='Y'
        EXIT
      ENDIF

      **** CHECK IF DATABASE IS NOT INDEXED
      IF (!QFOXVER2 .AND. EMPTY( NDX(1))) .OR. (QFOXVER2 .AND. EMPTY(CDX(1)))
        = gfDialog ("I","Database not indexed! cannot locate..")
        **** TAK 09/09/93 ****
        SET COLOR TO &QCLRBLK
        @ BP(4),XMSGCOL    SAY XMSG
        SET COLOR TO &QCLRNRM
        **** END TAK *********
        LOOP
      ENDIF

      LASTKEY = UPPER(CHR(THISKEY))
      XSEARCH = ALLTRIM( XSEARCH + LASTKEY )

      SET COLOR TO &QCLRNRM
      @ BP(4),00

      @ BP(4),XMSGCOL SAY 'LOCATE=>'+' '+ XSEARCH

      IF BP(9)='Y'
       EXIT
      ELSE
       LOOP
      ENDIF

  ENDCASE
ENDDO
***
****** RESET THE DEFAULTS
***
 BP(1)  = 5   && LINE FOR THE ARROW
 BP(2)  = 1   && COL FOR THE ARROW
 BP(3)  = ''  && OPTIONAL PREFIX FOR INDEX
 BP(4)  = 23  && ROW TO DISPLAY KEYS MESSAGE
 BP(5)  = 79  && RIGHT COL OF THE WINDOW
 BP(6)  = 'N' && ENABLE <Ins> TO ADD
 BP(7)  = 'N' && ENABLE <Del> TO DELETE
 BP(8)  = ''  && SPECIAL USED FOR SEEK COMMAND
 BP(9)  = 'N' && FOR SEARCH SPECIFIC KEY
 BP(10) = 0   && OPTIONAL POINTER FOR THE ARROW     && ARH 08/22/93

GG=SYS(2002,1)
IF QRECNO(TOPROW)=0
  = gfDialog ("I","No records to display !")
  THISKEY = 27
ENDIF

STORE 0 TO QRECNO
RETURN(THISKEY)

***
****** END BROW.PRG *****

*****************************************************************
*PROG:GRID.PRG
*DESC:PROCEDURE TO DRAW A SELECTION GRID FOR PRINTING REPORTS
*DATE:04/02/90
*MODI:04/14/90
*PARA:XOPT_CNT    => NUMBER OF OPTIONS TO BE ENTERED IN THE GRID (LINES)
*PARA:XMID_LINE   => Y/N TO DISPLAY A SEPARATION LINE IN THE MIDDLE
*NOTE: START DATA ON LINE 3
*
*************************************************************************
PROCEDURE GRID
PARAMETERS XOPT_CNT,XMID_LINE

PRIVATE XOPT_CNT,ROW,TOP_ROW,BOT_ROW,XMID_LINE
*0....*....1....*....2....*....3....*....4....*....5....*....6....*....7....*.
*2
*  3                                                    99/99/99 99/99/99   
*4
*  5                                                                        
*6
*  7                                                                        
*8
BOT_ROW=(2*XOPT_CNT)+2
SET COLOR TO &QCLRNRM

@ 02,0 TO BOT_ROW,79 DOUBLE

TOP_ROW =2
ROW     = TOP_ROW

DO WHILE ROW<=BOT_ROW

  IF ROW=TOP_ROW
    IF XMID_LINE='Y'
      @ ROW,38 SAY ''
    ENDIF
    ROW=ROW+1
    LOOP
  ENDIF

  IF ROW=BOT_ROW
    IF XMID_LINE='Y'
      @ ROW,38 SAY ''
    ENDIF
    ROW=ROW+1
    LOOP
  ENDIF

  IF ROW=3.OR.ROW=5.OR.ROW=7.OR.ROW=9.OR.ROW=11.OR.ROW=13.OR.ROW=15.OR.ROW=17;
.OR.ROW=19.OR.ROW=21
    IF XMID_LINE='Y'
      @ ROW,38 SAY ''
    ENDIF
    ROW=ROW+1
    LOOP
  ENDIF

  IF ROW=4.OR.ROW=6.OR.ROW=8.OR.ROW=10.OR.ROW=12.OR.ROW=14.OR.ROW=16.OR.ROW=18;
.OR.ROW=20.OR.ROW=22
    @ ROW,00 SAY REPLICATE('',79)
    @ ROW,00 SAY ''
    IF XMID_LINE='Y'
      @ ROW,38 SAY ''
    ENDIF
    @ ROW,79 SAY ''
    ROW=ROW+1
    LOOP
  ENDIF

ENDDO
SET COLOR TO &QCLRNRM
GG=SYS(2002,1)
RETURN



**********************************************************************
*  PROC: GETZONE()
*  DESC: WE PASS THE 3 CHR STRING OF THE ZIP CODE AND THE PROGRAM WILL
*  RETURN THE ZONE
*  DATE: 04/20/90
*  NOTE: XUPS HOLDS THE SHIPPERS ZIP => WE CHOOSE THE CORRESPONDING ZONE FILE
*  PARA: ZIP
**********************************************************************
PROCEDURE GETZONE

PARAMETER XCSTZIP

PRIVATE XCSTZIP,ZN,ZONEFILE

RESTORE FROM CONTRL&QSYSCODE ADDI

ZONEFILE= QLB+'UPS'+XUPSFROM+'.DBF'
ZONEWA  = 'UPS'+XUPSFROM
XOLDWA  = ALIAS()

IF FILE(ZONEFILE)
  IF .NOT. OPENED(ZONEWA)
    DO NETUSE WITH ZONEFILE,'','SH'
  ENDIF
  SELE &ZONEWA
  IF XCSTZIP>000 .AND. XCSTZIP<1000
    GO XCSTZIP
    IF .NOT. EOF()
      ZN = IIF( EMPTY(ZONE) , '*' , ZONE )
    ELSE
      = gfDialog ("!","Invalid zip code or zone file not complete ! Unable to get zone")
      ZN ='0'
    ENDIF
  ELSE
    ZN = '0'
  ENDIF
ELSE
  ??CHR(7)
  ZN = ''
  = gfDialog ("!","The zone file "+ &zonefile + " is missing, unable to compute zone.")
ENDIF
  
IF LEN(TRIM(XOLDWA)) <> 0
 SELE &XOLDWA
ENDIF

RETURN(ZN)

***
*** EOF GETZONE()
***
****************************************************************************
* PROG: GETUPS.PRG
* DESC: CALCULATE UPS FREIGHT, COD AND INSURANCE CHARGE
* DATE: 12/28/90
*
*
*   VARIABLES INITIALIZED BY THE CALLING PROGRAM
*       XFREIGHT   =     TOTAL FREIGHT CHARGE
*       XINSURAMT  =     TOTAL INSURANCE AMOUNT
*       XCODAMT    =     TOTAL COD CHARGE
*       XCARTONS   =     # OF CARTONS
*       XWEIGHT    =     TOTAL WEIGHT
*       XUPSFROM   =     SHIPPER ZONE
*       XTOZONE    =     STANDARD SHIP TO ZONE
*       XTOZIP     =     SHIP TO ZIP
*       XUPSTYPE   =     'G'   GROUND
*                  =     '2'   2ND DAY
*                  =     'N'   NEXT DAY
*                  =     'T'   GROUND TRAC
*                  =     '3'   3 Day Select
*       XCODYN     =     'Y'   YES COD
*                  =     'N'   NO  COD
*       XINSURYN   =     Y/N  INSURANCE
*
*       12/09/93 FAR
*           1) Modified the GETUPS function to handle GroundTrac and
*              3 Day Select.  Also changed the way we were making sure
*              that the zone is valid.
*      02/02/94 ARH
*          1) Modified the GETUPS function to handle 150 records in 
*             the UPSRATES file instead of 70 records
*****************************************************************************
*0....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+
PROCEDURE GETUPS

IF VAL(XUPSFROM) <= 0
  = gfDialog ("!","Shipper postal zone invalid ! Unable to calculate UPS charge..")
  RETURN
ENDIF

IF VAL(XTOZONE)<=0 .AND. ( .NOT. '*' $ XTOZONE )
  = gfDialog ("!","Shipto zone invalid! Unable to calculate UPS charge..")
  RETURN
ENDIF

*----------------------------------------------------------------------
* If from/to zone is Alaska, Hawaii or Puerto Rico, you cannot
* ship ground
*----------------------------------------------------------------------

DO CASE

  * GROUND & GROUNDTRAC
  CASE XUPSTYPE = 'G' .OR. XUPSTYPE = 'T'
    RATECODE = IIF(XUPSTYPE='G',XTOZONE,'T'+XTOZONE)
    XOKGRD = .T.
    XOKGRD = IIF(XUPSFROM $ '967 968 969 995 996 997 998 999 006 007 008 009', ;
                 .F., XOKGRD)
    XOKGRD = IIF(XTOZIP   $ '967 968 969 995 996 997 998 999 006 007 008 009', ;
                 .F., XOKGRD)

    IF .NOT. XOKGRD
      = gfDialog ("I","You cannot ship ground from/to Alaska, Hawaii or Puerto Rico !")
      RETURN
    ENDIF

  * 3 DAY SELECT
  CASE XUPSTYPE = '3'
    RATECODE = '3'+XTOZONE
    XOK3DAY = .T.
    XOK3DAY = IIF(XUPSFROM $ '004 005 006 007 008 009 967 968 969 995 996 997 998 999', ;
                 .F., XOK3DAY)
    XOK3DAY = IIF(XTOZIP   $ '004 005 006 007 008 009 967 968 969 995 996 997 998 999', ;
                 .F., XOK3DAY)

    IF BETWEEN(VAL(XTOZIP),100,149)
      XOK3DAY = .F.
    ENDIF

    IF .NOT. XOK3DAY
      = gfDialog ("I","You cannot ship 3 Day Select from/to this zipcode. !!!")
      RETURN
    ENDIF

  * 2ND DAY AIR
  CASE XUPSTYPE  = '2'
    RATECODE = '12'
    RATECODE = IIF(XUPSFROM $ '967 968 995 996 997 998 999', '14', RATECODE)
    RATECODE = IIF(XTOZIP   $ '967 968 995 996 997 998 999', '14', RATECODE)
    RATECODE = IIF(XUPSFROM $ '006 007 008 009', '15', RATECODE)
    RATECODE = IIF(XTOZIP   $ '006 007 008 009', '15', RATECODE)

  * NEXT DAY AIR
  CASE XUPSTYPE = 'N'
    RATECODE = '22'
    RATECODE = IIF(XUPSFROM $ '967 968 995 996 997 998 999', '24', RATECODE)
    RATECODE = IIF(XTOZIP   $ '967 968 995 996 997 998 999', '24', RATECODE)
    RATECODE = IIF(XUPSFROM $ '006 007 008 009', '25', RATECODE)
    RATECODE = IIF(XTOZIP   $ '006 007 008 009', '25', RATECODE)
ENDCASE

*----------------------------
* CALCULATE UPS CHARGES
*----------------------------
XFREIGHT = 0.00
XWEIGHT  = ROUND(XWEIGHT,0)

XWEIGHT  = IIF( XWEIGHT > 0 , XWEIGHT , 1 )
XCARTONS = IIF( XCARTONS <= 0 , 1 , XCARTONS )
XCARTONS = IIF( XCARTONS > ROUND(XCARTONS,0) , ROUND(XCARTONS+1,0) , ;
ROUND(XCARTONS,0) )

******
***Modified by ARH 02/02/94 to check for 150 records instead of 70 records
******
IF XWEIGHT/XCARTONS > 150
  X = XWEIGHT/150
  = gfDialog ("I","UPS cannot exceed 150 LBS/carton ! carton count has been adjusted..")
  XCARTONS = IIF ( X > ROUND(X,0) , ROUND(X+1 , 0 ) , ROUND(X,0) )
  RETURN
ENDIF
***END  ARH  02/02/94

*-----------------------------------------------------------------------------------
* check in UPSRATES file that rate field exists for this zone
* Added by FA on 1/30/92 to avoid variable not found error if invalid zone found.
*-----------------------------------------------------------------------------------
** SELE UPSRATES
** X=FCOUNT()
** XOKZONE=.F.
** FOR I=1 TO X
**   IF FIELD(I)='RATE&RATECODE'
**     XOKZONE=.T.
**     EXIT
**   ENDIF
** ENDFOR

** Following was commented out by FAR on 12/09/93 and changed to the code
** that follows which checks by TYPE() and is faster.
**
** IF .NOT. ((LEN(RATECODE)=1 .AND. (RATECODE $ '2 3 4 5 6 7 8')) .OR.  ;
**   (LEN(RATECODE)=2  .AND. (RATECODE $ '12 14 15 16 22 24 25')))
**   DO MSG22 WITH 'Invalid UPS zone found.  Cannot calculate UPS freight !!!!','$'
**   RETURN
** ENDIF
**
** Following code was added on 12/09/93 by FAR to check for valid zone
** The following SELECT was added by FAR on 12/09/93 for the TYPE command to
** work.

SELECT UPSRATES
IF TYPE('RATE&RATECODE') = 'U'
   = gfDialog ("!","Invalid UPS zone found.  Cannot calculate UPS freight !!!!")
   RETURN
ENDIF
*---------------------------------------------------------------------------------*

IF XCARTONS = 1
  **  SELECT UPSRATES    && commented out by FAR on 12/09/93 since already selected
  GOTO XWEIGHT
  XFREIGHT = RATE&RATECODE
ELSE
  **  SELECT UPSRATES    && commented out by FAR on 12/09/93 since already selected
  X = XWEIGHT/XCARTONS
  AVGLBS = IIF( X > ROUND(X, 0) , ROUND(X+1,0) , ROUND(X,0) )
  AVGLBS = IIF(AVGLBS<=0, 1, MIN(AVGLBS, 150))    && ARH 02/02/94
  GOTO AVGLBS
  XFREIGHT = XCARTONS * RATE&RATECODE
  NCARTONS = XCARTONS
ENDIF

XCODAMT = 0.00

IF XCODYN = 'Y'
   XCODAMT = XCODCHARGE * XCARTONS
ENDIF

**IF XTSHIPAMT >100 .AND. XINSURYN='Y'

IF XTSHIPAMT >=100 .AND. XINSURYN='Y'           && CHANGED 2/16/92 BY FA
   X         = IIF( (XTSHIPAMT/100) >= ROUND( (XTSHIPAMT/100) , 0 ) ,;
   ROUND( (XTSHIPAMT/100),0), ROUND( (XTSHIPAMT/100) - 1,0)   )
   XINSURAMT = X * XINSCHARGE
ENDIF

RETURN

**************************************************************************
****************** EOF GETUPS
**************************************************************************

***************************************************************************
* PROG: GETUPSIN()
* DESC: UDF THAT WILL RETURN THE UPS INSURANCE
* DATE: 04/25/90
* NOTE: USED BY INV111 & INV121 INVOICING PROGRAMS
* PARA: PARAMETER 1   => MERCHANDISE $$ AMOUNT
*
PROCEDURE GETUPSIN
***************************************************************************
PARAMETER XMER_AMT
PRIVATE XMER_AMT,XINS_AMT,X
X         = 0
XINS_AMT  = 0
XINS_RATE = 00.25

IF XMER_AMT>100
  X        = ROUND( ( XMER_AMT/100) , 0 )
  XINS_AMT =  X * XINS_RATE
ENDIF

RETURN(XINS_AMT)

*!*************************************************************
*! Name : lfToBatch.
*! Auth : MOHAMED FAHMY MOHAMED .MFM.
*! Date : 07/02/94.
*! 
*! Synopsis : Save a record for the currently printed report to the
*!            batch server file.
*! Modifications :
*!      ARH 07/27/94 :
*!          1) Added the computing of the time the job is put 
*!             in the batch server file and added two fields 
*!             (DINDATE,CINTIME).
*!*************************************************************
FUNCTION lfToBatch

lcOldAlias = ALIAS()
IF !USED('SYUBTSRV')
  SELECT 0
  DO NETUSE WITH 'SyuBtSrv', 'SyuBtSrv', 'SH'
ELSE
  SELECT SyuBtSrv
ENDIF

APPEND BLANK

*-- ARH 07/27/94 Added the computing of the time the job is put 
*-- in the batch server file and added two fields (DINDATE,CINTIME).
lcHour = IIF(VAL(TIME())-12=0,"12",IIF(VAL(TIME())-12 < 0,;
             ALLTRIM(STR(VAL(TIME()))),ALLTRIM(STR(VAL(TIME())-12))))
lcMode = IIF(VAL(TIME())<12," am"," pm")
lcTime = lcHour+SUBSTR(TIME(),3)+lcMode
REPLACE cProgId    WITH xReport,;
        cRepName   WITH qTopic,;
        cStatus    WITH 'O',;
        cPriority  WITH IIF( !EMPTY( qUserPrt ), qUserPrt, '1' ),;
        nCopies    WITH 1,;
        Net_Loc    WITH lcNetOrLoc ,;
        Net_PrtNo  WITH lnPrnNo    ,;
        Server     WITH lcServNme  ,;
        Queue      WITH lcQueNme   ,;
        Baner      WITH lcBanrNme  ,;
        PrtPort    WITH gcLoclPort ,;
        Paper_Type WITH lcPaprTyp  ,;
        PrMod      WITH lcPrtModl  ,;
        cUserId    WITH qUserId    ,;
        dInDate    WITH DATE()     ,;
        cInTime    WITH lcTime
*-- END  ARH  07/27/94

SAVE TO MEMO mRepoVars ALL EXCEPT lcPopRet

IF !EMPTY(lcOldAlias)
  SELECT &lcOldAlias
ENDIF
*-- EOF( lfToBatch )

*************************************************************************
* PROG: WA_COUNT       UDF()
* DESC: UDF THAT WILL RETURN THE NUMBER OF AVAILABLE WORK AREAS
* DATE: 05/16/90
*************************************************************************
PROCEDURE WA_COUNT

PRIVATE X,XOLD_WA,XCOUNT

XOLD_WA = ALIAS()
X       = 1
XCOUNT  = 0

DO WHILE  X <= 25

  IF LEN(TRIM(ALIAS(X))) = 0
    XCOUNT = XCOUNT + 1
  ENDIF

  X = X + 1

ENDDO

IF LEN(TRIM(XOLD_WA)) <> 0
  SELE &XOLD_WA
ELSE
  SELE 0
ENDIF

RETURN(XCOUNT)

************************************************************************
*! PROG : SEQUENCE
*! DESC : UDF THAT WILL RETURN A NUMBER FROM THE SEQUENCE CONTROL FILE
*! DATE : 05/29/90
*! PARA : THE FIELD NAME IS PASSED AS AN ARGUMENT
*! MODI : 
*!        OHR 09/92/92 
*!            1) MODIFIED THE LOCKING TO LOCK FILE AND RECORD
*!        FAR 10/27/93 
*!            1) Removed the file locking since it is not necessary. 
*!               The reason it was put in here was because we could 
*!               not find the real problem behind the two workstations 
*!               getting same sequence number for any transaction.  So 
*!               the real problem that I discovered was that under the 
*!               error handler, the RLOCK() or FLOCk() functions do not 
*!               generate an error which would force a RETRY and keep the 
*!               program at that line until it is able to lock. So the 
*!               best solution is to retry until it is able to lock.
*!        YMA 01/12/95 
*!            1) Added the facility to generate the sequence code according
*!               to the new added "Division Technique" which is :
*!               - Splitting the numeric fields in the sequence file into
*!                 five different divisions, each of them has it's own code
*!                 sequence. We will name these field by adding the main 
*!                 field name + the division group which will be validated
*!                 from the code file.
*!                 This new added facility will be available if the
*!                 value of the variable "M_Div_Seq" is "Y" otherwise the 
*!                 old technique will be used.
*!               - In order to add this facility to the "sequence" procedure
*!                 we added a new parameter called "lcDivision" which will
*!                 hold the nedded division number.
*!                 If this parameter is not defined we assume that the 
*!                 calling program is tring to deal with a numeric sequence 
*!                 field that have no division groups.
*!      TAK 02/16/95 
*!          1) Change the way of reading sequence numbers from sequence
*!             file and that by going to given division group.
*!      WAM 03/08/95
*!          1) Check that the generated number is not redundant.
*B800077,1 TAK 08/15/95 Fixed the duplication in codes.
************************************************************************
PROCEDURE SEQUENCE

PARAMETERS XField, lcDivision
PRIVATE lnAlias, lcDivNum, llUseCode, XNumber

lnAlias = SELECT()
lcDivNum = "01"               &&TAK 02/16/95 Default group.
*-- YMA 01/12/95 
IF !(TYPE("lcDivision") $ "UL")
  RESTORE FROM ADPARA&QSYSCODE ADDITIVE
  IF M_Div_Seq = "Y"
    IF !USED('Code')
      SELECT 0
      DO NetUse WITH '&qDD.Code','&qDD.Code','SH'
      llUseCode = .T.
    ELSE  
      llUseCode = .F.
    ENDIF
    *--Changed TAK 02/16/95  
    lcDivNum = IIF(SEEK("D"+lcDivision,"Code"),;
               IIF(!EMPTY(Code.DivGroup),Code.DivGroup,"01"),"01")
    IF llUseCode
      USE IN Code
    ENDIF
  ENDIF
  RELEASE ALL LIKE M_*
ENDIF
IF !USED('SEQUENCE')
  SELECT 0
  DO NETUSE WITH '&QDD.SEQUENCE',' ','SH'
ENDIF

*-- WAM 03/08/95
*-- Check that the generated number is not redundant.
STORE .F. TO llF1Found, llF2Found, llF1OpHere, llF2OpHere
STORE '' TO lcTag1Name, lcTag2Name
STORE 0 TO lnF1RecNo, lnF2RecNo

IF !USED('SETUPS')
  SELECT 0
  DO NETUSE WITH '&QDD.SETUPS','&QDD.SETUPS','SH'
ENDIF
SELECT SETUPS
SET ORDER TO TAG SETUPS
SEEK 'S'
LOCATE REST WHILE CODE = 'S' FOR MEMVARNAME = XField
IF !EMPTY(MPrompts)
  STORE MPrompts TO lcPrompts
  lcFileName = SUBSTR(lcPrompts,AT('',lcPrompts,1)+1,AT('\',lcPrompts,1)-AT('',lcPrompts,1)-1)
  lcCDXName  = SUBSTR(lcPrompts,AT('\',lcPrompts,1)+1,AT('',lcPrompts,2)-AT('\',lcPrompts,1)-1)
  lcSecFile  = SUBSTR(lcPrompts,AT('',lcPrompts,2)+1,AT('\',lcPrompts,2)-AT('',lcPrompts,2)-1)
  lcSecCDX   = SUBSTR(lcPrompts,AT('\',lcPrompts,2)+1,AT('',lcPrompts,3)-AT('\',lcPrompts,2)-1)
  IF FILE(QDD+lcFileName+'.DBF') .AND. FILE(QDD+lcCDXName+'.CDX')
    IF !USED(lcFileName)
      SELECT 0
      DO NETUSE WITH QDD+lcFileName,QDD+lcCDXName,'SH'
      llF1OpHere = .T.     
    ENDIF
    SELECT (lcFileName)
    lcTag1Name = SYS(22)
    lnF1RecNo  = RECNO()
    SET ORDER TO TAG (lcCDXName)
    llF1Found = .T.    
  ENDIF  
  IF FILE(QDD+lcSecFile+'.DBF') .AND. FILE(QDD+lcSecCDX+'.CDX')
    IF !USED(lcSecFile)
      SELECT 0
      DO NETUSE WITH QDD+lcSecFile,QDD+lcSecCDX,'SH'
      llF2OpHere = .T.
    ENDIF
    SELECT (lcSecFile)
    lcTag2Name = SYS(22)    
    lnF2RecNo  = RECNO()    
    SET ORDER TO TAG (lcSecCDX)
    llF2Found = .T.
  ENDIF  
ENDIF

SELECT SEQUENCE
GOTO VAL(lcDivNum)

*B800077,1 TAK 08/15/95 Changed to reduce the time between getting the code and replace the new one.
DO WHILE !RLOCK()               && Because with the error handler
ENDDO                           && Rlock was not generating an error.
lnGenNum = EVAL(XField)
XNumber  = PADL(lnGenNum,6,'0')
DO WHILE (llF1Found .AND. SEEK(XNumber,lcFileName)) .OR. ;
         (llF2Found .AND. SEEK(XNumber,lcSecFile))
  lnGenNum = lnGenNum + 1
  XNumber  = PADL(lnGenNum,6,'0')
ENDDO
REPLACE &XField WITH lnGenNum + 1
FLUSH
UNLOCK
*-- End WAM 03/08/95

*B800077,1 TAK 08/15/95 this code moved from up to the end of seq. function.
IF llF1Found 
  IF llF1OpHere
    USE IN (lcFileName)
  ELSE
    SET ORDER TO TAG lcTag1Name IN (lcFileName)
    IF BETWEEN(lnF1RecNo,1,RECCOUNT(lcFileName))
      GOTO lnF1RecNo IN (lcFileName)
    ENDIF  
  ENDIF  
ENDIF  
IF llF2Found
  IF llF2OpHere
    USE IN (lcSecFile)
  ELSE
    SET ORDER TO TAG lcTag2Name In (lcSecFile)
    IF BETWEEN(lnF2RecNo,1,RECCOUNT(lcSecFile))    
      GOTO lnF2RecNo IN (lcSecFile)
    ENDIF  
  ENDIF  
ENDIF  

SELECT (lnAlias)
RETURN (XNumber)

****************************************************************************
* PROG: CENTER()
* DATE: 07/28/90
* DESC: UDF() TO CENTER ANY TEXT
* PARA:                   PARA 1 =>    COL1
*                         PARA 2 =>    COL2
*                         PARA 3 =>    TEXT
****************************************************************************
PROCEDURE CENTER
PARAMETER XCOL1,XCOL2,XTEXT

PRIVATE ALL LIKE X*

X = ROUND( ((XCOL2 - XCOL1) - LEN(XTEXT)) / 2 ,0 )

XCOL_CNTR = XCOL1 + X

RETURN(XCOL_CNTR)

***
****** EOF() CENTER
***
****************************************************************************
* PROG: GETSCALE()
* DESC: FUNCTION THAT WILL RETURN A STRING WITH THE SIZE SCALE
* DATE: 09/17/90
* ARGU:   1 ==>  SIZE SCALE TO BE DISPLAYED
*         2 ==>  SPACING BETWEEN EACH SIZE
*
****************************************************************************
PROCEDURE GETSCALE

PARAMETERS XSC,XSPACE

PRIVATE XOLDALIAS,X,XSTRING,XSC,XSPACE,Z

XOLDALIAS= ALIAS()
*E300637,1 Use the new global variables names
*IF .NOT. OPENED('SCALE')
*  DO NETUSE WITH '&QDD.SCALE','&QDD.SCALE','SH'
*ENDIF
=gfOpenFile(gcDataDir+'SCALE',gcDataDir+'SCALE','SH')
*E300637,1 (End)  
SELE SCALE
SEEK 'S'+XSC
X       = 1
XSTRING = ''

DO WHILE FOUND() .AND. X<=CNT
  Z = STR(X,1)
  XSTRING = XSTRING + SZ&Z + IIF(X=CNT,'',XSPACE)
  X= X + 1
ENDDO

IF .NOT. FOUND()
  XSTRING ='* * * E R R O R * * *'
ENDIF

IF LEN(TRIM(XOLDALIAS)) > 0
  SELE &XOLDALIAS
ENDIF

RETURN(XSTRING)

*MFM Commeted out.
*****************************************************************************
* PROG: NOTREADY
* DESC: DISPLAY MESSAGE SAYING THAT THIS PROGRAM IS STILL UNDER DEVELOPMENT
* DATE: 11/11/90
*****************************************************************************
*PROCEDURE NOTREADY
*SAVE SCREEN TO NOTREADY
*?? CHR(7)
*= gfDialog ("I","This program is still under development, For Any further information please contact.."+SPACE(28)+"Aria Systems INC. AT (212) 714 - 1334")
*RESTORE SCREEN FROM NOTREADY
*RETURN
**EOF() NOTREADY

*****************************************************************************
* PROG: DEMOMSGG
* DESC: DISPLAY MESSAGE SAYING THAT THIS DEMO SYSTEM HAS EXPIRED
* DATE: 04/23/90
*****************************************************************************
PROCEDURE DEMOMSG
?? CHR(7)
?? CHR(7)
DEFINE WINDOW lwdemomsg ;
FROM INT((SROW()-8)/2), INT((SCOL()-45)/2) ;
TO INT((SROW()-8)/2)+7, INT((SCOL()-45)/2)+44  ;
FLOAT NOCLOSE SHADOW NOMINIMIZE DOUBLE COLOR SCHEME 7
ACTIVATE WINDOW lwdemomsg NOSHOW
@ 1,12 SAY "Demo System Expired" SIZE 1,19, 0
@ 2,5 SAY "Please contact Aria Systems Inc." SIZE 1,32, 0
@ 3,10 SAY "Phone# : (212) 714-1334" SIZE 1,23, 0
@ 5,16 GET pbOk PICTURE "@*HT \<Ok" SIZE 1,10,1 DEFAULT 1
ACTIVATE WINDOW lwdemomsg     
READ CYCLE MODAL
RELEASE WINDOW lwdemomsg
RETURN

*-----------------------------------------------------------------------------
* PROG: LCBROW
* DESC: UDF() PROGRAM TO BROWSE THE LC FOR A SPECIFIC ACCOUNT
* DATE: 08/02/90
* PARA: THE ACCOUNT # IS PASSED AS A PARAMETER
*! 
*! Modifications :
*!      MFM 07/12/94
*!          1) Incresed the vendor code to 8 characters for the AP link changes.
*!      TMI 07/27/94
*!          1) Added the ability to validate the vendor information
*!            from vendor file of the Aria Advantage series system 
*!            instead of our vendor file if the system was setup to
*!            link with the AP module.
*!      MFM 12/11/94
*!          1) Made modifications to cover the required modifications in the
*!             LC program(Sty660).
*!****************************************************************************
FUNCTION LCBROW
PARAMETER lcBnkLc,lcLcNo
*-- TMI 07/27/94 To hold the status of the AP link facility.
RESTORE FROM ADPARA&QSYSCODE ADDI
llApLink  = (M_ApLink = 'Y')   
lcApDir   = ALLTRIM (M_ApDataDir)
RELEASE ALL LIKE M_*

PRIVATE ROW

SAVE SCREEN TO LCBROW_1

*-- TMI 07/27/94 Open the vendor file of the Aria Advantage series
*-- system instead of our vendor file if the system was setup to
*-- link with the AP module.
IF llApLink
  IF !USED( 'ApVendor' )
    SELECT 0
    DO NetUse WITH '&lcApDir.ApVendor', 'VenCode', 'SH'
  ENDIF  
  lcVenFile = 'ApVendor'
  lcFldNme  = 'cVenComp'  
ELSE
  *E300637,1 Use the new global variables names
  *IF !USED( 'VENDOR' )
  *  SELECT 0
  *  DO NETUSE WITH '&QDD.VENDOR','&QDD.VENDOR','SH'
  *ENDIF
  =gfOpenFile(gcDataDir+'VENDOR',gcDataDir+'VENDOR','SH')
  *E300637,1 (End)
  lcVenFile = 'Vendor'
  lcFldNme  = 'Name' 
ENDIF  

*E300637,1 Use the new global variables names
*IF !USED('CODE')
*  SELECT 0
*  DO NETUSE WITH '&QDD.CODE','&QDD.CODE','SH'
*ENDIF
=gfOpenFile(gcDataDir+'CODE',gcDataDir+'CODE','SH')
*E300637,1 (End)
SELE LC
SET RELATION TO VENDOR INTO &lcVenFile
GOTO TOP

*-- MFM 07/12/94.
*!    ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....
*!.. 
*!..  LC#    BANK LC #  BANK ...NAME... VENDOR   .....NAME.... EXPIRE   US$ AMOUNT 
*!.. 
*!..          // . 
*!..  123456 1234567890 12   1234567890 12345678 1234567890123 12345678 1234567890 
*!.. 
*- END MFM 07/12/94.

IF EOF()
  = gfDialog ("I","There are no LCs on the file...!")
  lcLcNo  = SPACE(6)    && MFM 12/11/94.
  lcBnkLc = SPACE(10)
  RETURN
ENDIF

 GOTO TOP
 DO WHILE .T.
    ROW    = 4
    QRECNO = 0
    DO DRAWBOX WITH QCLRMAG,'',1,0,21,79
    SET COLOR TO &QCLRMAG
    @ 02,01 SAY ' LC#    BANK LC #  BANK ...NAME... VENDOR   .....NAME.... EXPIRE   US$ AMOUNT'
    @ 03,01 TO 03,78

    SET COLOR TO &QCLRSAY

    DO WHILE .NOT. EOF().AND.ROW<21
      SELE CODE
      SEEK 'H'+LC->BANK
      IF FOUND()
       BR_DES=SUBSTR(CDATA,1,10)
      ELSE
       BR_DES='**ERROR **'
      ENDIF
      SELE LC
      @ ROW,02 SAY cLcNo   && MFM 12/11/94.
      @ ROW,09 SAY LC
      @ ROW,20 SAY BANK
      @ ROW,25 SAY BR_DES
      @ ROW,36 SAY VENDOR
      *-- TMI 07/27/94
      @ ROW,45 SAY SUBSTR(&lcVenFile..&lcFldNme ,1,13)
      @ ROW,59 SAY EXPIRE
      @ ROW,68 SAY US_AMT PICTURE '9999999.99'

      QRECNO(ROW) = RECNO()
      SKIP
      ROW = ROW + 1
    ENDDO
    BP(1)  = 4
    BP(2)  = 1
    BP(3)  = ''
    BP(4)  = 22
    BP(5)  = 79
    BP(6)  = 'N'
    BP(7)  = 'N'

    BP(8)  = ''
    SET COLOR TO &QCLRMAG
    THISKEY = BROW()
    DO CASE
      CASE THISKEY = QESCKEY
        lcLcNo  = SPACE(6)   && MFM 12/11/94.
        lcBnkLc = SPACE(10)
        
      CASE THISKEY = QRETKEY
        lcLcNo  = cLcNo     && MFM 12/11/94.        
        lcBnkLc = LC
        
      OTHERWISE
        LOOP
    ENDCASE
    EXIT
  ENDDO

RESTORE SCREEN FROM LCBROW_1

*MFM Commeted out.
************************************************************
*                         PSW_CHK                          *
************************************************************
*-----------------------------------------------------------------------------
* PROG: PSW_CHK
* DESC: UDF() PROGRAM TO CHECK THE MENU SELECTION AGAINST THE QPW
* DATE: 02/19/91
*****************************************************************************
*PROCEDURE PSW_CHK
*PARAMETERS SUBCHOICE,MMCHOICE
*PSWOK=.F.
*IF LTRIM(STR(SUBCHOICE)) $ QPW(MMCHOICE)
*  PSWOK=.T.                    && MENU SELECTION AUTHORIZED
*  RETURN(PSWOK)
*ENDIF
*SAVE SCREEN TO PSW_CHK_1
*DO DRAWBOX WITH QCLRMSG,'',20,20,22,57
*SET COLOR TO &QCLRMSG
*?CHR(7)
*@ 21,26 SAY '***** Access denied *****'
*XX=0
*DO WHILE XX <= 1000
*  XX=XX+1
*ENDDO
*RESTORE SCREEN FROM PSW_CHK_1
*RETURN(PSWOK)
******************************************************************************
* EOF PSW_CHK
******************************************************************************


************************************************************
*                         LDOM                             *
************************************************************
PROCEDURE LDOM

PARAMETER XDATE
PRIVATE X                       && ADDED BY FAR ON 07/28/93

XNEXTM   = IIF( MONTH(XDATE) = 12 , 1, MONTH(XDATE) + 1 )

FOR X=1 TO 32
  XDATE = XDATE + 1
  IF MONTH(XDATE) = XNEXTM
    EXIT
  ENDIF

ENDFOR
XDATE = XDATE - 1

RETURN(XDATE)

**************************************************************************
*! PROG: SYSDATE
*! DESC: CHANGE THE SYSTEM DATE
*! DATE: 02/09/1991
*! 
*! Modifications :
*!        ARH 04/06/94:
*!            1) Rebuilded the menu again after changing the system date.
**************************************************************************
PROCEDURE SYSDATE
QTOPIC='SYSTEM DATE'
DO DRAWBOX WITH QCLRBLK,'',10,09,12,69
SET COLOR TO &QCLRBLK

*-- ARH 04/06/94 To save the old system date. This will indicate if
*-- the system date was changed after words.
@ 24,00 SAY gfMsgStr(' ') COLOR &gcMsgClr
ldTmpDate = DATE()

XSYSDATE = DATE()
@ 11,21 SAY 'CURRENT SYSTEM DATE..:' GET XSYSDATE
READ

Z= DTOC(XSYSDATE)

RUN DATE &Z

SUBCHOICE = 0

*-- ARH 04/06/94 To rebuild the menu if the date was changed
*-- NOTE: The procedure gpMnuBld lies in ARIA.
IF DATE() <> ldTmpDate
  RELEASE MENUS
  DO gpMnuBld
ENDIF

RETURN

**************************************************************************
* PROG: SCALBROW.PRG
* DESC: BROWSE SCREEN FOR SIZE SCALES
* DATE: 04/10/91
* Modifications:
*      TMI 11/27/94
*          1) Modified the coordinates of scale brows to be consistant with 
*             the increased scale desc. field from 3 chars. to 5 chars. and 
*             made all necessary modifications.        
***************************************************************************
PROCEDURE SCALBROW
PARAMETER XSCALE
SAVE SCREEN TO SCALBROW_1
PRIVATE ROW
*...*....1....*....2....*....3....*....4....*....5....*....6....*....7....*....
*        | ' SCALE DESCR.      CNT   SIZE1 SIZE2 SIZE3 SIZE4 SIZE5 SIZE6 SIZE7 SIZE8 |
*        |     A   XXXXXXXXXX   8    XXXXX XXXXX XXXXX XXXXX XXXXX XXXXX XXXXX XXXXX |
***
***MAIN LOOP***************************************
***
SELE SCALE
SEEK 'S'
DO WHILE .T.
  DO DRAWBOX WITH QCLRMAG,'',5,01,20,75   && TMI 11/27/94
  SET COLOR TO &QCLRMAG
  @ 06,02 SAY ' SCALE DESCR.      CNT   SIZE1 SIZE2 SIZE3 SIZE4 SIZE5 SIZE6 SIZE7 SIZE8 '      && TMI 11/27/94
  SET COLOR TO &QCLRNRM
  @ 07,02 TO 19,73 CLEAR    && TMI 11/27/94
  QRECNO = 0
  ROW   = 7
  SET COLOR TO &QCLRSAY
  DO WHILE .NOT. EOF() .AND. TYPE = 'S' .AND. ROW<20  &&DISPLAY THE SCALES
    *-- TMI 11/27/94
    @ ROW,05 SAY SCALE
    @ ROW,09 SAY DESC
    @ ROW,22 SAY CNT
    @ ROW,27 SAY SZ1
    *-- END TMI 11/27/94
    @ ROW,COL()+1 SAY SZ2
    @ ROW,COL()+1 SAY SZ3
    @ ROW,COL()+1 SAY SZ4
    @ ROW,COL()+1 SAY SZ5
    @ ROW,COL()+1 SAY SZ6
    @ ROW,COL()+1 SAY SZ7
    @ ROW,COL()+1 SAY SZ8
    QRECNO(ROW) = RECNO()
    ROW = ROW + 1
    SKIP
  ENDDO                        &&LOOP TO DISPLAY SCALES AND GET COUNT
  BP(1) = 7
  BP(2) = 2                    && TMI 11/27/94
  BP(3) = 'S'
  BP(5) = 70
  BP(8) = " TYPE = 'S' "
  SET COLOR TO &QCLRNRM
  THISKEY = BROW()
  DO CASE
    CASE THISKEY = QESCKEY       && PRESSED THE ESCAPE KEY
      XSCALE = SPACE(1)
      EXIT
    CASE THISKEY = QRETKEY
      XSCALE = SCALE
      EXIT
    OTHERWISE
      LOOP
  ENDCASE
ENDDO
RESTORE SCREEN FROM SCALBROW_1
RETURN(XSCALE)

********************************************************************
* PROG: CODETEST.PRG
* DESC: CHECK THE CODE FILE TO MAKE SURE THAT NECESSARY CODES ARE SETUP
*       FOR A SPECIFIC PROGRAM
* DATE: 04/20/91
* PARA: CODE TYPES
********************************************************************
PROCEDURE CODETEST
PARAMETER XCODES

PRIVATE ALL LIKE X*

XOLD_WA = ALIAS()
XLEN    = LEN(XCODES)
XALLOK  = .T.

SELE CODE

FOR X=1 TO XLEN
  SEEK SUBSTR(XCODES,X,1)
  IF .NOT. FOUND()
    XALLOK = .F.
    EXIT
  ENDIF
ENDFOR

IF .NOT. XALLOK
  = gfDialog ("I","One or more codes have not been setup ! Please setup and try again..")
ENDIF

IF .NOT. EMPTY(XOLD_WA)
  SELE &XOLD_WA
ENDIF

RETURN(XALLOK)
    
********************************************************************************
* PROG: CODE_VAL                                                               *
* DATE: 06/24/93                                                               *
* DESC: CODE VALIDATION FUNCTION                                               *
* AUTH: AMR ABDEL RAOUF HEGAZY                                                 *
* NOTE: FTYPE       = 'S' ---> SCALES                                          *
*                     'P' ---> PREPAKS                                         *
*                     'V' ---> VENDORS                                         *
*                     'F' ---> FABRICS                                         *
*                     'R' ---> SALES REPS                                      *
*                     'CX'---> CODES and X is the type of any different code   *
*                                                                              *
*       FCODE      = USER ENTERED CODE                                         *
*                                                                              *
*       FCOOR      = String delimeted with COMMA consisting of following:      *
*                      1) Starting ROW of the code DESCRIPTION                 *
*                      2) Starting COLUMN of the code DESCRIPTION              *
*                      3) Displayed LENGTH of the code DESCRIPTION             *
*                                                                              *
*       FOPT       = If the code is OPTIONAL or not ['.T.'or'.F.']             *
*       FOLD_VAR   = Name of the variable passed to change its value before    *
*                    returning back                                            * 
*       FCODE_DESC = Name of the variable holding code description  to be      *
*                    updated according to the latest changes (if there is any) *
*       FSPC_SEA   = This variable is set to 'Y' optionally to let the function*
*                    accept SEASON='Y' in some cases                           *
* NOTE: If you added new code in the CODE file and you want to validate this   *
*       code you have to do the following:                                     *
*         1) Add the indicator letter for that code at the end of FINDC        *
*            which is the var. that holds the indicator letters for different  *
*            codes in the CODE MAINTENANCE menu (EX: Z -> SEASONS)             *
*         2) Add the description of the new code at the end of FDESC           *
*            which holds the codes' descriptions (EX: 'SEASONS')               *
*            with a maximum characters of 17 CHARACTERS                        *
* MODI:                                                                        *
*!        TMI 07/27/94
*!         1) from vendor file of the Aria Advantage series system 
*!            instead of our vendor file if the system was setup to
*!            link with the AP module.
*!        11/27/94 TMI
*!         1) Modified the coordinates of Desplaying prepak desc. to be consistant with 
*!            the increased scale desc. field from 3 chars. to 5 chars. and 
*!            made all necessary modifications. 
********************************************************************************
FUNCTION CODE_VAL
PARAMETERS FTYPE,FCODE,FCOOR,FOPT,FOLD_VAR,FCODE_DESC,FSPC_SEA
*-- TMI 07/27/94 To hold the status of the AP link facility.
RESTORE FROM ADPARA&QSYSCODE ADDI
llApLink  = M_ApLink    = 'Y'
lcApDir   = ALLTRIM (M_ApDataDir)
RELEASE ALL LIKE M_*

PRIVATE ALL LIKE F*        && In order not to make any confusion with any 
                           && variables with the same name
FOLDALIAS=ALIAS()          && To hold the alias name before entering the function
FNEW_DESC=SPACE(0)         && To hold the code description

*****The following steps to divide the FCOOR variable into three values*****
**********representing starting row for description,starting col************
******************for the description and the displayed*********************
***************************description length*******************************
FDESC_ROW=VAL(SUBSTR(FCOOR,1,(ATC(',',FCOOR)-1)))
FDESC_COL=VAL(SUBSTR(FCOOR,(ATC(',',FCOOR,1)+1),((ATC(',',FCOOR,2)-1)-(ATC(',',FCOOR,1)))))
FDESC_LEN=VAL(SUBSTR(FCOOR,(ATC(',',FCOOR,2)+1)))
****************************************************************************

******Return .T. if the code was for PREPAK and OPTIONAL and the code****
*************contains 1 character or less because it contains**************
*****************SCALE+PREPAK so it should be 2 characters******************
IF FTYPE='P' .AND. LEN(ALLTRIM(FCODE)) <= 1
  IF LEN(ALLTRIM(FCODE_DESC)) > 0
    &FCODE_DESC = SPACE(0)
  ENDIF
  lcCurClr = SET('COLOR')
  SET COLOR TO &qClrSay
  @ FDESC_ROW,FDESC_COL TO FDESC_ROW,FDESC_COL+FDESC_LEN CLEAR
  SET COLOR TO &lcCurClr
  RETURN(.T.)
ENDIF
***************************************************************************

**********Return .T. if the code entered is empty and optional*********    
IF EMPTY(FCODE) .AND. FOPT
  IF LEN(ALLTRIM(FCODE_DESC)) > 0
    &FCODE_DESC=SPACE(0)
  ENDIF
  lcCurClr = SET('COLOR')
  SET COLOR TO &qClrSay
  @ FDESC_ROW,FDESC_COL TO FDESC_ROW,FDESC_COL+FDESC_LEN CLEAR
  SET COLOR TO &lcCurClr
  RETURN(.T.)
ENDIF
**********************************************************************

DO CASE
  *******************If the code entered is scale*********************
  CASE FTYPE='S'
    *E300637,1 Use the new global variables names
    *IF !USED('SCALE')
    *  SELE 0
    *  DO NETUSE WITH '&QDD.SCALE','&QDD.SCALE','SH'
    *ENDIF 
    =gfOpenFile(gcDataDir+'SCALE',gcDataDir+'SCALE','SH')
    *E300637,1 (End)
    SELE SCALE
    IF !SEEK('S'+FCODE)
      FCODE=SCALBROW(FCODE)
    ENDIF
    FNEW_DESC=SZ1+' '+SZ2+' '+SZ3+' '+SZ4+' '+SZ5+' '+SZ6+' '+SZ7+' '+SZ8
  ******************If the code entered is prepak*********************
  CASE FTYPE='P'
    FNEW_SCALE=SUBSTR(FCODE,1,1)
    FNEW_PREPAK=SUBSTR(FCODE,2)
    *E300637,1 Use the new global variables names
    *IF !USED('SCALE')
    *  SELE 0
    *  DO NETUSE WITH '&QDD.SCALE','&QDD.SCALE','SH'
    *ENDIF  
    =gfOpenFile(gcDataDir+'SCALE',gcDataDir+'SCALE','SH')
    *E300637,1 (End)
    SELE SCALE
    IF !SEEK('P'+FNEW_SCALE+FNEW_PREPAK)
      FNEW_PREPAK=PREPBROW(FNEW_SCALE)
    ENDIF
    FNEW_DESC=SPACE(2) + STR(PP1,3)+'   '+STR(PP2,3)+'   '+STR(PP3,3)+'   '+STR(PP4,3)+'   ';
              +STR(PP5,3)+'   '+STR(PP6,3)+'   '+STR(PP7,3)+'   '+STR(PP8,3)       && TMI 11/27/94
    FCODE=FNEW_PREPAK
  ******************If the code entered is vendor*********************
  CASE FTYPE='V'
    *-- TMI 07/27/94 Open the vendor file of the Aria Advantage series
    *-- system instead of our vendor file if the system was setup to
    *-- link with the AP module.
    IF llApLink
      IF !USED( 'ApVendor' )
        SELECT 0
        DO NetUse WITH '&lcApDir.ApVendor', 'VenCode', 'SH'
      ENDIF  
      lcVenFile = 'ApVendor'
      lcFldNme  = 'cVenComp'  
    ELSE
      *E300637,1 Use the new global variables names
      *IF !USED( 'VENDOR' )
      *  SELECT 0
      *  DO NETUSE WITH '&QDD.VENDOR','&QDD.VENDOR','SH'
      *ENDIF
      =gfOpenFile(gcDataDir+'VENDOR',gcDataDir+'VENDOR','SH')
      *E300637,1 (End)
      lcVenFile = 'Vendor'
      lcFldNme  = 'Vendor' 
    ENDIF  

    SELE &lcVenFile 
    IF !SEEK(FCODE)
      IF llApLink
        = gfApVnBrow (@FCODE)
      ELSE  
        DO VENBROW WITH FCODE
      ENDIF  
    ENDIF
    FNEW_DESC = &lcVenFile..&lcFldNme
  ******************If the code entered is sales rep*********************
  CASE FTYPE='R'
    *E300637,1 Use the new global variables names
    *IF !USED('SALESREP')
    *  SELE 0
    *  DO NETUSE WITH '&QDD.SALESREP','&QDD.SALESREP','SH'    
    *ENDIF
    =gfOpenFile(gcDataDir+'SALESREP',gcDataDir+'SALESREP','SH')
    *E300637,1 (End)
    SELE SALESREP
    IF !SEEK(FCODE)
      DO REPCHK WITH FCODE
    ENDIF
    FNEW_DESC=NAME    
  ******************If the code entered is fabric*********************
  CASE FTYPE='F'
    *E300637,1 Use the new global variables names
    *IF !USED('FABRIC')
    *  SELE 0
    *  DO NETUSE WITH '&QDD.FABRIC','&QDD.FABRIC','SH'
    *ENDIF  
    =gfOpenFile(gcDataDir+'FABRIC',gcDataDir+'FABRIC','SH')
    *E300637,1 (End)
    SELE FABRIC
    IF !SEEK(FCODE)
      DO FABROW WITH FCODE,'*'
    ENDIF
    FNEW_DESC=DESC
  ******************If the 'Y' entry is permitted in season**************
  CASE FCODE='Y '.AND.SUBSTR(ALLTRIM(FTYPE),2)='Z'.AND.FSPC_SEA='Y'
    FNEW_DESC= 'YEAR ROUND     '
  ******************If the code is none of the above*********************
  OTHERWISE
    *E300637,1 Use the new global variables names
    *IF !USED('CODE')
    *  SELE 0
    *  DO NETUSE WITH '&QDD.CODE','&QDD.CODE','SH'
    *ENDIF
    =gfOpenFile(gcDataDir+'CODE',gcDataDir+'CODE','SH')
    *E300637,1 (End)
    
    *******Putting the code description concatinated into variable*******
    FDESC='TERMS            CLASSIFICATIONS  SHIP VIA         REGIONS          ';
         +'SPC. INSTRUCTIONSSEASONS          DIVISIONS        STYLE GROUPS     ';
         +'STYLE COLORS     DEBIT ADJUSTMENTSCREDIT ADJUSTMENTRETURN REASONS   ';
         +'DECLINE REASONS  CURRENCY         BANKS            ';
         +'MFG. OPERATIONS  MATERIAL TYPES   '
    FINDC='TLVRSZDGCBEAIFHMJ'                 && To hold the codes' letters
    
    FSEARCH=SUBSTR(ALLTRIM(FTYPE),2)          && To determine the letter 
                                              && that we'll search its description
    FBEGIN=((ATC(FSEARCH,FINDC)-1)*17)+1      && To determine the starting 
                                              && position for desc search
    FTITLE=ALLTRIM(SUBSTR(FDESC,FBEGIN,17))
    
    DO CODECHK WITH FSEARCH,FCODE,FTITLE
    
    FNEW_DESC=CDATA
ENDCASE
***************************End code validation******************************

********Return .F. to the calling program if the code still empty***********
****************but it's required (user pressed ESCAPE)*********************
IF EMPTY(FCODE) .AND. !FOPT
  &FOLD_VAR=' '
  SELE &FOLDALIAS
  RETURN(.F.)
ENDIF

**********Return .T. to the calling program if the code still empty**********
***************after validation (user pressed ESCAPE) and optional***********
IF EMPTY(FCODE) .AND. FOPT
  &FOLD_VAR = FCODE 
  SELE &FOLDALIAS  
  IF LEN(ALLTRIM(FCODE_DESC)) > 0
    &FCODE_DESC=SPACE(0)
  ENDIF  
  @ FDESC_ROW,FDESC_COL TO FDESC_ROW,FDESC_COL+FDESC_LEN CLEAR
  RETURN(.T.)
ENDIF
*****************************************************************************

**************************Otherwise do the following*************************
SET COLOR TO &QCLRSAY

@ FDESC_ROW,FDESC_COL SAY SUBSTR(FNEW_DESC,1,FDESC_LEN)

&FOLD_VAR=FCODE         && To return to the calling prog with the new validated variable

IF LEN(ALLTRIM(FCODE_DESC)) > 0

  &FCODE_DESC=FNEW_DESC         && To update the original code description
                                && (if there is any) with the latest value
ENDIF
  
SELE &FOLDALIAS

RETURN(.T.)
****************************************************************************

********************************************************************************
* PROG: KEY_EXIST                                                              *
* DATE: 11/02/93                                                               *
* DESC: UDF() THAT CHECK IF THERE IS ANOTHER CODE ENTERED IN ADD OPERATION     *
* AUTH: TIMOUR ABDALLA                                                         *
* PARA: XTITLE     =Message disc.  and alias name                              *
*       XKEY       =Variable name wich hold the code                           *
*       XCOL       =The colom of field display location                        *
*                   (Row position is the same for all screens at 2)            *
* NOTE: The title name parameter must entered as form of first letter is       *
*       upper as ex. 'Vendor'                                                  *
*       RETURN WITH EMPTY FOR CANCEL CASE                                      *
*       Called by :
*         CUS100, STY100, MAT100, REP100, VEN100
* MODI:                                                                        *
********************************************************************************
PROCEDURE KEY_EXIST

PARAMETERS XTITLE,XKEY,XCOL

PRIVATE ALL LIKE X*        && In order not to make any confusion with any 
                           && variables with the same name

SELE &XTITLE
IF SEEK(IIF(XTITLE='Customer','M'+XKEY,XKEY))
  ?? CHR(7)
  ?? CHR(7)
  DO MSG22 WITH ' THIS '+UPPER(XTITLE)+' CODE HAS JUST BEEN USED BY ANOTHER USER. ','$'
  DO MSG22 WITH 'C<h>ange '+LOWER(XTITLE)+' code or <C>ancel ? ','HC'
  DO CASE
    CASE CHOICE = 'H'
      DO WHILE .T.
        @ 02,XCOL GET XKEY PICTURE '@!' VALID !EMPTY(XKEY)
        READ
        SET COLOR TO &QCLRSAY
        @ 02,XCOL SAY XKEY PICTURE '@!'
        IF SEEK(IIF(XTITLE='Customer','M'+XKEY,XKEY))
          = gfDialog ("I",ALLTRIM(XTITLE)+" "+ XKEY + " already exists !")
          LOOP
        ELSE
          EXIT
        ENDIF
      ENDDO

    CASE CHOICE = 'C'          && CASE OF CANCEL
      RETURN (SPACE(LEN(XKEY)))

  ENDCASE

ENDIF

RETURN (XKEY)
******************** END  KEY_EXIST *************************************
****************************************************************************
* PROG: GETFRGHT.PRG
* DESC: CALCULATE UPS FREIGHT, COD AND INSURANCE CHARGE THE NEW WAY.
* DATE: 02/17/94
* AUTH: TIMOUR ABDALLA
*   PROGRAM PARAMETERS
*    INPUT PARA
*        XUPSFROM  =     SHIPPER CODE
*        XTOZIP    =     SHIP TO ZIP OR POSTAL CODE
*        XUPSTYPE  =     'USUPSG '  U.S.A UPS Ground
*                  =     'USUPS2 '  U.S.A UPS 2ND Day
*                  =     'USUPSN '  U.S.A UPS Next Day
*                  =     'USUPST '  U.S.A UPS Ground trac
*                  =     'USUPS3 '  U.S.A UPS 3 Day Select
*                  =     'CAXPR  '  Canada Xpresspost Service
*                  =     'CACOM  '  Canada Commercial Parcel
*                  =     'CAEXPR '  Canada ...By MFM *E300362,1
*                  =     'CAEXPD '  Canada ...By MFM *E300362,1
*                  =     'CASTAN '  Canada ...By MFM *E300362,1
*                  =     'CAECON '  Canada ...By MFM *E300362,1
*           XCODYN     =     'Y'   YES COD
*                      =     'N'   NO  COD
*           XINSURYN   =     Y/N  INSURANCE
*           XCARTONS   =     # OF CARTONS
*           XWEIGHT    =     TOTAL WEIGHT
*E300325,4 The following parameters are optional :
*E300325,4 If not passed, calculations are done in base currency.
*E300325,4 lcCurrCode  =     Amounts are to be calculated in this currency.
*E300325,4 lnCurrUnit  =     Currency unit
*E300325,4 lnExRate    =     Exchange rate.
*
*    OUTPUT PARA
*           XFREIGHT   =     TOTAL FREIGHT CHARGE
*           XINSURAMT  =     TOTAL INSURANCE AMOUNT
*           XCODAMT    =     TOTAL COD CHARGE
*
*! 
*! Modifications :
*!      YMA 07/14/94 
*!          1) Added tow extra parameter called 'xCodCharge,xInsCharge' 
*!             to hold the COD & Insurance charge from the code
*!             file instead of the control file.
*E300325,4 RENEE 12/28/95. Add currency parameters, and calculate 
*E300325,4                 freight, insurance, and COD amounts in 
*E300325,4                 the passed currency.  
*****************************************************************************
PROCEDURE GETFRGHT

*-- YMA 07/14/94 Added the xCodCharge,xInsCharge parameters.
*E300325,4 Add parameters : lcCurrCode, lnCurrUnit, lnExRate 
*PARA  XUPSFROM,XTOZIP,XUPSTYPE,XCODYN,XINSURYN,XFREIGHT,XINSURAMT,;
*      XCODAMT,XCARTONS,XWEIGHT,xCodCharge,xInsCharge
PARA  XUPSFROM,XTOZIP,XUPSTYPE,XCODYN,XINSURYN,XFREIGHT,XINSURAMT,;
      XCODAMT,XCARTONS,XWEIGHT,xCodCharge,xInsCharge,;
      lcCurrCode, lnCurrUnit, lnExRate       

*E300325,4 Add private variables for currency conversion
*E300325,4 lcExRSin : exchange rate sign
*E300325,4 lcUntSin : currency unit sign
*PRIV X,XMAXWGHT,XOLDEXAC,XOLDNEAR,XZONE,XW
PRIV X,XMAXWGHT,XOLDEXAC,XOLDNEAR,XZONE,XW, lcExRSin, lcUntSin
*E300325,4 end.

*------ INITIALIZE OUTPUT PARA TO ZERO -----*
XFREIGHT = 0.00
XINSURAMT= 0.00
XCODAMT  = 0.00
*-------------------------------------------*

*C100553,1 TAK 02/25/96 (Start) Added 'UPS Consignee'. 
*C100553,1 TAK That Freight always be zero.
IF XUPSTYPE='USUPSC'   &&Ship type UPS Consignee.
  *-Calculate only the Insurance and COD charges.  
  IF XCODYN = 'Y'
     XCODAMT = XCODCHARGE * XCARTONS
  ENDIF
  IF XTSHIPAMT >=100 .AND. XINSURYN='Y'
    X  = IIF( (XTSHIPAMT/100) >= ROUND( (XTSHIPAMT/100) , 0 ) ,;
    ROUND( (XTSHIPAMT/100),0), ROUND( (XTSHIPAMT/100) - 1,0)   )
    XINSURAMT = X * XINSCHARGE
  ENDIF
  *E300325,4 Convert freight, insurance and COD amounts to the passed
  *E300325,4 currency if multi currency and the passed currency is 
  *E300325,4 not the base currency.
  IF !EMPTY(lcCurrCode) .AND. lcCurrCode = gcBaseCurr 
    IF lnExRate > 0 .AND. lnCurrUnit > 0
      lcUntSin  = ''
      lcExRSin  = gfGetExSin(@lcUntSin, lcCurrCode)
      lcExRSin  = IIF(lcExRSin = '*', '/', '*')
      lcUntSin  = IIF(lcUntSin = '*', '/', '*')
      xCODAmt   = ROUND(xCODAmt   &lcExRSin lnExRate ;
                                  &lcUntSin lnCurrUnit, 2)
      xInsurAmt = ROUND(xInsurAmt &lcExRSin lnExRate ;
                                  &lcUntSin lnCurrUnit, 2)     
    ELSE
      RETURN .F.
    ENDIF
  ENDIF
  *E300325,4 end.
  RETURN
ENDIF
*C100553,1 TAK 02/25/96 (End)

IF !USED('FRTZONES')
  SELE 0
  DO NETUSE WITH '&QLB.FRTZONES','&QLB.FRTZONES','SH'
ENDIF

IF !USED('FRTRATES')
  SELE 0
  DO NETUSE WITH '&QLB.FRTRATES','&QLB.FRTRATES','SH'
ENDIF

SELE FRTZONES
IF !SEEK(XUPSTYPE+XUPSFROM+XTOZIP)
  DO CASE

    CASE SUBSTR(XUPSTYPE,1,2)='CA'                         && CANADA
      IF !SEEK(XUPSTYPE+XUPSFROM+SUBSTR(XTOZIP,1,1))       && 1st CHAR OF POSTAL CODE
        = gfDialog ("!","Shipper postal zone or Shipto zone invalid! unable to calculate Freight...")
        RETURN
      ENDIF

    OTHERWISE
      = gfDialog ("!","Shipper postal zone or Shipto zone invalid! unable to calculate Freight...")
      RETURN

  ENDCASE
ENDIF

XZONE=ZONE   &&Get the zone
 
*---------------------------------------------------------------------*
* CALCULATE FREIGHT CHARGES
*----------------------------

*E300362,1 MFM 03/13/96 (Begin) In the new 4 types no max for the weight.
llNoMax = .F.
*E300362,1 MFM 03/13/96 (End).

DO CASE
  CASE  'USUPS'$XUPSTYPE     &&US UPS. WEIGHTS NOT DECIMAL 1,2,3,4,5,6,7
    XWEIGHT  = IIF( XWEIGHT > 0 , XWEIGHT , 1 )
    XMAXWGHT = 150           &&E300362,1 MFM 03/13/96 Added.    
  CASE  'CAX'$XUPSTYPE      &&CANADA XPRESSPOST 0.05,0.1,0.2,0.5,1,2,3,4,5,6,7
    XWEIGHT  = IIF( XWEIGHT > 0.05 , XWEIGHT , 0.05 )
    XMAXWGHT = 150           &&E300362,1 MFM 03/13/96 Added.
  CASE  'CAC'$XUPSTYPE      &&CANADA COMMERCIAL PARCEL 1.0,1.5,2.0,2.5,3
    XWEIGHT  = IIF( XWEIGHT > 0 , XWEIGHT , 1 )
    XMAXWGHT = 30            &&E300362,1 MFM 03/13/96 Added.
  *E300362,1 MFM 03/13/96 (Begin) Added this case to cover the new cases.
  OTHERWISE
    llNoMax = .T.
  *E300362,1 MFM 03/13/96 (End).
ENDCASE 

*E300362,1 MFM 03/13/96 (Begin) Commented.
*XMAXWGHT = IIF('USUPS'$XUPSTYPE ,150,30)   && 150 FOR USUPS and 30 FOR CANADIAN
*E300362,1 MFM 03/13/96 (End).

XCARTONS = IIF( XCARTONS <= 0 , 1 , XCARTONS )
XCARTONS = IIF( XCARTONS > ROUND(XCARTONS,0) , ROUND(XCARTONS+1,0) , ;
ROUND(XCARTONS,0) )

*E300362,1 MFM 03/13/96 (Begin) Added the 'IF !llNoMax' do not check for the
*E300362,1 MFM 03/13/96 max weight if ther is no max for checking.
IF !llNoMax
  IF XWEIGHT/XCARTONS > XMAXWGHT
    X = XWEIGHT/XMAXWGHT
    XMAXWGHT=ALLTRIM(STR(XMAXWGHT))
    *MAN
    = gfDialog ("!","Weight cannot exceed "+XMAXWGHT+" /carton! carton count has been adjusted..")
    XCARTONS = IIF ( X > ROUND(X,0) , ROUND(X+1 , 0 ) , ROUND(X,0) )
    RETURN
  ENDIF
ENDIF
*E300362,1 MFM 03/13/96 (End).
*---------------------------------------------------------------------*

* following is done in order to do a soft seek for the weight in case
* of decimal weights.
XOLDEXAC = SET('EXAC')
SET EXACT OFF
XOLDNEAR = SET('NEAR')
SET NEAR ON
*************************************************************************

** Now compute the weight per carton to get the rate.  In the case of
** where weights are in decimals we do not round but instead do a
** soft seek

XW = XWEIGHT / XCARTONS                 && WEIGHT PER CARTON
lnWight = 1        &&E300362,1 MFM 03/13/96 Added to say if the rate per kg.
llMulti = .F.      &&E300362,1 MFM 03/13/96 Added to say if this UPS type have
                   &&E300362,1 MFM 03/13/96 rates for multipl shipments.

DO CASE

  CASE  'USUPS'$XUPSTYPE    &&US UPS. WEIGHTS NOT DECIMAL 1,2,3,4,5,6,7
    XW = IIF( XW > ROUND(XW, 0) , ROUND(XW+1,0) , ROUND(XW,0) )
    XW = SPACE(6-LEN(ALLTRIM(STR(XW,6))))+ALLTRIM(STR(XW,6))

  *** Following was changed to make weights 2 decimals for all canada
  *** carriers. Before CACOM was one decimal but customer entered it
  *** with 2 decimals so we chagned it to be 2 decimals for both.
  *** Done on 03/06/94
  *E300362,1 MFM 03/13/96 (Begin) Changed the case.
  *CASE  'CA'$XUPSTYPE      &&CANADA THE WEIGHTS are with 2 decimals 0.05,0.1
  CASE XUPSTYPE = 'CACOM  ' .OR. XUPSTYPE = 'CAXPR  '
  *E300362,1 MFM 03/13/96 (End).
    XW = SPACE(6-LEN(ALLTRIM(STR(XW,6,2))))+ALLTRIM(STR(XW,6,2))

  **CASE  'CAC'$XUPSTYPE      &&CANADA THE WEIGHTS 1.0,1.5,2.0,2.5,3
  **  XW = SPACE(6-LEN(ALLTRIM(STR(XW,6,1))))+ALLTRIM(STR(XW,6,1))
  *E300362,1 MFM 03/13/96 (Begin) Added to handle the new added 4 types for canada.
  OTHERWISE
    IF XUPSTYPE = 'CASTAN ' .OR. XUPSTYPE = 'CAECON '
      llMulti = .T.
      XW = XW * XCARTONS
    ENDIF
    
    *** In this case wieght should be integer.
    XW      = IIF( XW > ROUND(XW,0), ROUND(XW+1,0), ROUND(XW,0) )
    lnWight = XW
    DO CASE
      CASE lnWight > 150 .AND. lnWight <= 500
        XW = 151
      CASE lnWight > 500
        XW = 501
    ENDCASE
    XW = SPACE(6-LEN(ALLTRIM(STR(XW,6))))+ALLTRIM(STR(XW,6))  
  *E300362,1 MFM 03/13/96 (End).

ENDCASE 

SELE FRTRATES
*E300362,1 MFM 03/13/96 (Begin) Added.
IF llMulti
  IF XCARTONS > 1
    *The chracter 'U' is for the multi shipments type.
    SEEK LEFT(XUPSTYPE,6)+'U'+XZONE+XW
  ELSE
    *The chracter 'S' is for the multi shipments type.
    SEEK LEFT(XUPSTYPE,6)+'S'+XZONE+XW
  ENDIF
ELSE
  SEEK XUPSTYPE+XZONE+XW
ENDIF

*SEEK XUPSTYPE+XZONE+XW
*E300362,1 MFM 03/13/96 (Begin) Added.

*E300362,1 MFM 03/13/96 (Begin) Changed.
*XFREIGHT = XCARTONS * RATE
IF llMulti
  XFREIGHT = RATE * lnWight
ELSE
  XFREIGHT = XCARTONS * RATE
ENDIF
*E300362,1 MFM 03/13/96 (End).
NCARTONS = XCARTONS

SET EXACT &XOLDEXAC
SET NEAR &XOLDNEAR
*---------------------------------------------------------------------*

IF 'USUPS'$XUPSTYPE     &&ONLY FOR US UPS.
  IF XCODYN = 'Y'
     XCODAMT = XCODCHARGE * XCARTONS
  ENDIF
  IF XTSHIPAMT >=100 .AND. XINSURYN='Y'
    X  = IIF( (XTSHIPAMT/100) >= ROUND( (XTSHIPAMT/100) , 0 ) ,;
    ROUND( (XTSHIPAMT/100),0), ROUND( (XTSHIPAMT/100) - 1,0)   )
    XINSURAMT = X * XINSCHARGE
  ENDIF
ENDIF

*E300325,4 Convert freight, insurance and COD amounts to the passed
*E300325,4 currency if multi currency and the passed currency is 
*E300325,4 not the base currency.
IF !EMPTY(lcCurrCode) .AND. lcCurrCode = gcBaseCurr 
  IF lnExRate > 0 .AND. lnCurrUnit > 0
    lcUntSin  = ''
    lcExRSin  = gfGetExSin(@lcUntSin, lcCurrCode)
    lcExRSin  = IIF(lcExRSin = '*', '/', '*')
    lcUntSin  = IIF(lcUntSin = '*', '/', '*')
    xCODAmt   = ROUND(xCODAmt   &lcExRSin lnExRate ;
                                &lcUntSin lnCurrUnit, 2)
    xFreight  = ROUND(xFreight  &lcExRSin lnExRate ;
                                &lcUntSin lnCurrUnit, 2)
    xInsurAmt = ROUND(xInsurAmt &lcExRSin lnExRate ;
                                &lcUntSin lnCurrUnit, 2)     

  ELSE
    RETURN .F.
  ENDIF
ENDIF
*E300325,4 end,

RETURN

*************************************************************
* PROC  : GLBROW
* DESC  : CHECK ENTERED G/L LINK CODE AND IF NOT FOUND
*       : BROWSE GENERAL LEDGER LINK CODE FROM GL_LINK FILE
* PARA  : XTYPE,YPOS,XPOS,XSUB
*         XTYPE = 'Y'  PRESSING ESC KEY MAY BE ACCEPTED
*         XTYPE = 'N'  DO NOT ALLOW PRESSING ESC KEY 
*         YPOS,XPOS    COORDINATES OF G/L LINK CODE DESCRIPTION TO BE DISPALYED
*         XSUB         NUMBER OF CHARACTERS TO BE DISPALYED AS SUBSTRING FROM
*                      G/L LINK DESCRIPTION.
* AUTH  : WAEL ALY MOHAMED
* DATE  : 02/10/94
* MODI  : NONE
*************************************************************
PROCEDURE GLBROW
PARAMETER XLINKTYPE,XTYPE,YPOS,XPOS,XSUB

PRIVATE lcAlias
lcAlias = ALIAS()
SELECT GL_LINK
SET ORDER TO TAG GL_LINK1
IF !SEEK(xLinkType+XLINK_CODE) .AND. IIF(EMPTY(xLinkType),SEEK('01'),SEEK(xLinkType))
  SAVE SCREEN TO SCR3
  lcCondit = IIF(!EMPTY(xLinkType), 'LinkType = xLinkType','.T.')
  DO DRAWBOX WITH QCLRMAG,'<GL LINK CODE>',4,15,20,74
  SET COLOR TO &QCLRMAG
  @ 05,17 SAY 'CODE DESCRIPTION                    TYPE'
  @ 06,16 TO 06,73
  DO WHILE .T.
    SET COLOR TO &QCLRMAG
    @ 07,16 CLEAR TO 19,73
    ROW1  = 7
    QRECNO= 0
    SET COLOR TO &QCLRSAY
    SCAN WHILE ROW1 < 20 .AND. &lcCondit 
      lcLinkType = LinkType
      lcTypeDesc = SPACE(20)
      = lfBrowType('lcLinkType','lcTypeDesc')
      @ ROW1,17 SAY LINK_CODE
      @ ROW1,22 SAY LINKDESC
      @ ROW1,53 SAY lcTypeDesc
      QRECNO(ROW1)=RECNO()
      ROW1=ROW1+1
    ENDSCAN
    BP(1)=7
    BP(2)=16
    BP(4)=21
    BP(5)=74
    BP(6)='N'
    BP(7)='N'
    BP(8)=lcCondit
    SET COLOR TO &QCLRMAG
    THISKEY=BROW()
    DO CASE
     CASE THISKEY = QESCKEY .AND. XTYPE='Y'
       XLINK_CODE = SPACE(3)
       EXIT
     CASE THISKEY = QRETKEY     
        XLINK_CODE = LINK_CODE
     OTHERWISE
        LOOP
    ENDCASE
    EXIT
  ENDDO  
  RESTORE SCREEN FROM SCR3
ENDIF
SET COLOR TO &QCLRSAY
SET ORDER TO TAG GL_LINK
SELECT (lcAlias)
IF TYPE('YPOS') $ 'UL' 
  RETURN(GL_LINK.LinkDesc)
ELSE
  @ YPOS,XPOS SAY SUBSTR(GL_LINK.LINKDESC,1,XSUB)
  RETURN .T.
ENDIF  

*************************************************************
*****************************************************************************
* PROC: GLDIST.PRG
* DESC: A GLOBAL PROCEDURE  THAT WILL BE  CALLED FROM  SEVERAL PLACES WITH
*       DIFFERENT PARAMETERS, DEPENDING ON THE  PARAMETERS THE PROGRAM WILL
*       UPDATE THE G/L DISTRIBUTION FILE WITH THE CORRESPONDING G/L ACCOUNT
*       AND AMOUNT. 
* DATE: 12/24/93
* AUTH: WAEL ALY MOHAMED
* NOTE: PARAMETERS USED:-
*       - _GLLINK  : GL LINK CODE -> THE LINK CODE USED FOR POSTING.
*
*       - _CATGKEY : CATEGORY KEY
*
*       - _AMOUNT  : AMOUNT       
*                    DEBITS ARE POSITIVE, CREDITS ARE NEGATIVE.
*
*       - _TRANTYP : TRANSACTION TYPE :-
*                    'IN' -> INVOICE
*                    'VI' -> VOID INVOICE
*                    'CR' -> CASH RECEIPT
*                    'CA' -> CREDIT ADJUSTMENT                         
*                    'DA' -> DEBIT ADJUSTMENT                         
*                    'RM' -> RETURN MERCHANDISE
*                    'VR' -> VOID RETURN
*                    'IP' -> INVENTORY PHYSICAL
*                    'MA' -> MATERIAL INVENTORY ADJUSTMENT
*                    'MP' -> MATERIAL INVENTORY PHYSICAL
*                    'IA' -> INVENTORY ADJUSTMENT
*                    'PO' -> P/O RECEIVING
*                    'MO' -> MATERIAL P/O RECEIVING
*                    'CT' -> C/T RECEIVING
*                    'ZE' -> ZERO OUT STOCK
*                    'NL' -> NON MAT. LIABILITY
*                    'JC' -> JOB COST CLOSING ADJ
*                    'RO' -> MATERIAL P/O RECEIVING
*                    'RS' -> C/T RECEIVING
*                    'MM' -> ZERO OUT STOCK
*                    'EX' -> EXCHANGE RATE DIFFERENCE  
*                    'KO' -> KEY OFF
*
*      - _TRANNO   : TRANSACTION NUMBER.
*
*      - _TRANDAT  : TRANSACTION DATE.
*
*      - _NFILE    : NAME OF FILE WILL BE USED. 
*      - _FYEAR    : TRANSACTION FISCAL YEAR.
*      - _PRDID    : PERIOD ID.
*E300325,1 If base currency, or, single currency setting,
*E300325,1 these parameters may not be passed.
*E300325,1 lcCurrCode : the current transaction currency code.
*E300325,1              (if not passed, defaults to the base currency)
*E300325,1 lnCurrUnit : the current transaction currency unit.
*E300325,1              (if lcCurrCode is not passed, defaults to 1)
*E300325,1 lnExRate   : the exchange rate used for the current transaction
*E300325,1              (if lcCurrCode is not passed, defaults to 1)
* MODI:
*    WAM 03/29/94 
*        1) Add a new field 'GlACNTTYPE' in 'GLDIST.MDL' file to hold
*           Type of account [ Control account or Distribution account].
*        2) Update the field 'GLACNTTYPE' with the account type depends
*           on the passed category key.
*        3) If the link code not found in 'GL_LINK' file (Zap the file 
*           for example), Default link code to 'DEF'.
*   WAM 04/20/94
*        1) Add thre category keyes '015', '016' and '017' for material
*           inventory control, inventory adjustment and P/O clearing.
*        2) Add three transaction types
*           'MP', 'MA' and 'MO' for material inventory physical, inventory 
*            adjustment and P/O receiving.
*   ARH 11/10/94
*       1) Added new transaction type for non material cost liability.
*!  WAM 03/05/95
*!      1) Add a new account '020' for Return Merchandise
*!      2) Do not add entry for zero amount.
*E100219,9 WAM 07/04/95 Add new type codes for receiving materials & styles
*N100219,4              from operation
*N000016,6 WAM 07/04/95 Add new type code for M.F.G. order receivin.
*E300325,1 RENEE 12/25/95 Update currency and equivalent amount fields
*E300325,1                in GLDIST.DBF 
*E300325,1                (cCurrCode, nCurrUnit. nExRate, nEqvAmnt) 
*E300344,2 WAM 02/14/96 Add new transaction type for Differences in Exchange rate
*E300592,1 WAM 02/25/97 Increase the link_Code field to be 6 characters
*B603504,1 ADEL 12/04/2000 Add a new transaction type for Closing material MFG and Closing Material PO.
*B603862,1 SSE 09/07/2000 Add new type for the Manufacturing closing cost sheet also modify 
*B603862,1                'JC' type to be on P/O Closing Cost sheet
*B603983,1 SSE 10/23/2000 Add new type for the Inventory Locking
*N000388,1 SSE 07/02/2002 Make a new description type in GLDIST for Material Invoice.
*N000391,1 SSE 07/02/2002 Make a new description type in GLDIST for Voiding Material Invoice.
*****************************************************************************
PROCEDURE GLDIST
*MAN
*PARAMETERS _GLLINK,_CATGKEY,_AMOUNT,_TRANTYP,_TRANNO,_TRANDAT,_FYEAR,_PRDID,_NFILE
*E300325,1 Add currency fields parameters:
*E300325,1 (lcCurrCode, lnCurrUnit, lnExRate, 
*PARAMETERS _GLLINK,_CATGKEY,_AMOUNT,_TRANTYP,_TRANNO,_TRANDAT,_FYEAR,_PRDID,_NFILE,lcGlAct
PARAMETERS _GLLINK,_CATGKEY,_AMOUNT,_TRANTYP,_TRANNO,_TRANDAT,_FYEAR,_PRDID,;
           _NFILE,lcGlAct, lcCurrCode, lnCurrUnit, lnExRate 

*E300325,1 Add private variables for equivalent amounts calculations
*PRIVATE XGLACNT,XTRANDESC,lcAcntType
PRIVATE XGLACNT, XTRANDESC, lcAcntType, lcExRSin, lcUntSin, lnEqvAmnt 
*E300325,1 end.

*B803032,1 BWA 14/02/2000 [START]
* Fix the bug of Period & year fields in GL distribution file are empty,So there is no way 
* to release those entries unless we are replace in those fields manually.
IF EMPTY(_FYEAR) OR EMPTY(_PRDID)
  =CheckPrd(_TRANDAT,"_FYEAR","_PRDID",'_TRANTYP' , .T.)
  IF EMPTY(_FYEAR) OR EMPTY(_PRDID)
    DO (gcapphome +'GL\GLDDATE.PRG')
  ENDIF
ENDIF
*B803032,1 BWA 14/02/2000 [END]


*E301210,1 ASH 04/27/99 (Begin) Don't create GL entries for some transactions 
*E301210,1                      due to the new parameter M_GL_COST.
llGlCost = ALLTRIM(gfGetMemVar('M_GL_COST',gcAct_Comp))='Y'

IF !llGlCost AND _CATGKEY $ '006,007,008,011,012,013,015,016,017,018,019,021,022,023,024,025,026,027'
  RETURN
ENDIF
*E301210,1 ASH 04/27/99 (End)
*** OPEN GL_LINK FILE TO GET G/L ACCOUNT FOR THIS CATEGORY/GL LINK CODE

IF _AMOUNT = 0
  RETURN
ENDIF  

*E300325,1 If the currency code is not passed, or
*E300325,1 If the currency code is the base currency, or
*E300325,1 If the category key of the transaction is either,
*E300325,1   '006' : 'FINISHED GOODS INVENTORY'
*E300325,1    or
*E300325,1   '008' : 'COST OF GOODS' 
*E300325,1 Default the currency fields to the base currency values.
IF EMPTY(lcCurrCode) .OR. INLIST(_CATGKEY, '006', '008');
  .OR. lcCurrCode = gcBaseCurr
  lcCurrCode = gcBaseCurr
  lnCurrUnit = 1
  lnExRate   = 1
  lnEqvAmnt  = _AMOUNT
ELSE
  *E300325,1 If either of the exchange rate or the currency unit
  *E300325,1 is not greater than 0, return .F., otherwise, calculate
  *E300325,1 as follows. 
  IF lnExRate > 0 .AND. lnCurrUnit > 0
    *E300325,1 Get the exchange rate sign for the curreny code
    lcUntSin = ''
    lcExRSin = gfGetExSin(@lcUntSin, lcCurrCode)
    *E300325,1 Get the currency unit sign for the curreny code
    lnEqvAmnt  = ROUND(_AMOUNT &lcExRSin lnExRate ;
                               &lcUntSin lnCurrUnit, 2)
  ELSE
    RETURN .F.
  ENDIF  
ENDIF
*E300325,1 end.

*E300637,1 Use the new global variables names
*IF !OPENED('GL_LINK')
*  DO NETUSE WITH '&QDD.GL_LINK','&QDD.GL_LINK','SH'
*ENDIF
=gfOpenFile(gcDataDir+'GL_LINK',gcDataDir+'GL_LINK','SH')
*E300637,1 (End)

SELE GL_LINK  
*-- 03/29/94 WAM 
*-- If the link code not found (Zap the file for example), default to 'DEF'

*E300592,1 Increase the link_Code field to be 6 characters
*IF !SEEK(_GLLINK+_CATGKEY)    
*  SEEK('DEF'+_CATGKEY)
*ENDIF   
IF !SEEK(PADR(_GLLINK,6)+_CATGKEY)    
  SEEK('DEFDEF'+_CATGKEY)
ENDIF   
*E300592,1 (End)

*MAN
*XGLACNT = GLACNT
XGLACNT = IIF(EMPTY(lcGlAct),GLACNT,lcGlAct)

*-- WAM 03/29/94
*-- Get Account Type

DO CASE
  CASE _CATGKEY = '001'   && Account Receivable
    *-- Control Account
    lcAcntType = 'C'
  
  CASE _CATGKEY = '002'   && Cash Receipts
    *-- Distribition Account
    lcAcntType = 'D'  
  
  CASE _CATGKEY = '003'   && Sales Revenue
    *-- Control Account
    lcAcntType = 'C'  
  
  CASE _CATGKEY = '004'   && Freight
    *-- Control Account
    lcAcntType = 'C'  
  
  CASE _CATGKEY = '005'   && Discount
    *-- Distribition Account
    lcAcntType = 'D'  
    
  *-- WAM 04/20/94  
  *-- Add category key for material inventory control  
  CASE _CATGKEY = '006' .OR. _CATGKEY = '015'  && Inventory Control
    *-- It is a Control account if the inventory decrease, 
    *-- and a distribution account if the inventory increase.
    lcAcntType = IIF(_AMOUNT < 0 , 'C', 'D')
    
  *-- WAM 04/20/94
  *-- Add category key for material inventory adjustment
  CASE _CATGKEY = '007' .OR. _CATGKEY = '016'  && Inventory Adjustments
    *-- It is a distribution account if the inventory decrease, 
    *-- and a Control account if the inventory increase. 
    lcAcntType = IIF(_AMOUNT < 0 , 'D', 'C')

  CASE _CATGKEY = '008'   && Cost of Goods
    *-- It is a distribution account if the inventory decrease, 
    *-- and a Control account if the inventory increase. 
    lcAcntType = IIF(_AMOUNT < 0 , 'D', 'C')

  CASE _CATGKEY = '009'   && Credit Adjustments
    *-- Distribition Account
    lcAcntType = 'D'  

  CASE _CATGKEY = '010'   && Debit Adjustments
    *-- Distribition Account
    lcAcntType = 'D'  

  CASE _CATGKEY = '011'   && Return Merchandise
    *-- Distribition Account
    lcAcntType = 'D'  
    
  *-- WAM 04/20/94  
  *-- Add category key for material P/O clearing

  CASE _CATGKEY = '012' .OR. _CATGKEY = '017'  && P/O Clearing
    *-- It is a distribution account if the inventory decrease, 
    *-- and a Control account if the inventory increase. 
    lcAcntType = IIF(_AMOUNT < 0 , 'D', 'C')

  CASE _CATGKEY = '013'   && C/T Clearing
    *-- It is a distribution account if the inventory decrease, 
    *-- and a Control account if the inventory increase. 
    lcAcntType = 'C'

  CASE _CATGKEY = '014'   && Sales Tax Liability
    *-- Control Account
    lcAcntType = 'C'
  
  CASE _CATGKEY = '018'   && Non material cost liability
    *-- Control Account
    lcAcntType = 'D'    
  CASE _CATGKEY = '019'   && Cost of goods variance
    *-- Distribution Account
    lcAcntType = 'D'    
  CASE _CATGKEY = '020'   && Return Merchandise
    *-- Distribution Account
    lcAcntType = 'C'    
  *E100219,9 WAM 07/04/95 Add new category key '021' in the GL_CATG for
  *E100219,9              Cost of Material Variance.
  CASE _CATGKEY = '021'   && Cost of material variance
    *-- Distribution Account
    lcAcntType = 'D'    

  CASE _CATGKEY = '022'   && Cost of goods variance 1
    *-- Distribution Account
    lcAcntType = 'D'    
  CASE _CATGKEY = '023'   && Cost of goods variance 2
    *-- Distribution Account
    lcAcntType = 'D'    
  CASE _CATGKEY = '024'   && Cost of goods variance 3
    *-- Distribution Account
    lcAcntType = 'D'    
  CASE _CATGKEY = '025'   && Cost of goods variance 4
    *-- Distribution Account
    lcAcntType = 'D'    
  *B603573,1 SSH 16/04/00 Add New Categ key in GlDist Procedure. [Begin]
  CASE _CATGKEY = '026'   && Cost of goods variance 5
    lcAcntType = 'D'
  *B603573,1 SSH 16/04/00 Add New Categ key in GlDist Procedure. [End]

  *E302472,1 MHM 11/18/2007  Multiple Taxes for Canada on Invoice [T20060709.0008] [Start]
  * add another 2 types to handle sales taxes in canada
  CASE _CATGKEY = '027'   && PST TAX LIABILITIY
    lcAcntType = 'C'
  CASE _CATGKEY = '028'   && HST TAX LIABILITIY
    lcAcntType = 'C'
  *E302472,1 MHM [End]


ENDCASE

*** GET DESCRIBTION OF THIS TRANSACTION TYPE

*-- WAM 04/20/94
*-- Add three transaction types
*-- 'MP', 'MA' and 'MO' for material inventory physical, inventory adjustment
*-- and P/O receiving.

DO CASE
  CASE _TRANTYP = 'IN' 
    XTRANDESC = 'INVOICE             '
  CASE _TRANTYP = 'VI' 
    XTRANDESC = 'VOID INVOICE        '
  CASE _TRANTYP = 'CR' 
    XTRANDESC = 'CASH RECEIPT        '
  CASE _TRANTYP = 'CA' 
    XTRANDESC = 'CREDIT ADJUSTMENT   '
  CASE _TRANTYP = 'DA' 
    XTRANDESC = 'DEBIT ADJUSTMENT    '                         
  CASE _TRANTYP = 'RM' 
    XTRANDESC = 'RETURN MERCHANDISE  '
  CASE _TRANTYP = 'VR' 
    XTRANDESC = 'VOID RETURN         '
  CASE _TRANTYP = 'IP' 
    XTRANDESC = 'INVENTORY PHYSICAL  '
  CASE _TRANTYP = 'IA' 
    XTRANDESC = 'INVENTORY ADJUSTMENT'
  CASE _TRANTYP = 'MP' 
    XTRANDESC = 'MATERIAL INV. PHYSI.'
  CASE _TRANTYP = 'MA' 
    XTRANDESC = 'MATERIAL INV. ADJUS.'
  CASE _TRANTYP = 'PO' 
    XTRANDESC = 'P/O RECEIVING       '
  CASE _TRANTYP = 'MO' 
    XTRANDESC = 'MATERIAL P/O RECEIV.'
  CASE _TRANTYP = 'CT' 
    XTRANDESC = 'C/T RECEIVING       '
  CASE _TRANTYP = 'ZE' 
    XTRANDESC = 'ZERO OUT STOCK      '

  *-- ARH 11/10/94
  CASE _TRANTYP = 'NL'
    XTRANDESC = 'NON MAT. LIABILITY  '
    
  *B603862,1 Modify 'JC' type description [Begin] 
  CASE _TRANTYP = 'JC'
    *XTRANDESC = 'JOB COST CLOSING ADJ'
    XTRANDESC = 'P/O JOB COST CLOSING'
  *B603862,1 Modify 'JC' type description [End] 
      
  *-- END  ARH  11/10/94
  *E100219,9 WAM 07/04/95 Add new type codes for receiving materials & styles
  *N100219,4              from operation
  *N000016,6 WAM 07/04/95 Add new type code for M.F.G. order receivin.
  CASE _TRANTYP = 'RO' 
    XTRANDESC = 'MATERIAL OP. RECEIVE'
  CASE _TRANTYP = 'RS' 
    XTRANDESC = 'STYLE OP. RECEIVE   '
  CASE _TRANTYP = 'MM' 
    XTRANDESC = 'RECEIVE M.F.G. ORDER'
  *E300344,2 Add new transaction type for Differences in Exchange rate
  CASE _TRANTYP = 'EX' 
    XTRANDESC = 'EX. RATE DIFFERENCES'
  CASE _TRANTYP = 'KO' 
    XTRANDESC = 'KEY OFF'
  *B603504,1 (Begin) Add a new transaction type for Closing material MFG and Closing Material PO.
  CASE _TRANTYP = 'MC' 
    XTRANDESC = 'MATERIAL JOB ClOSING'
  *B603504,1 (End)

  *B603862,1 Add new type for the Manufacturing closing cost sheet [Begin] 
  CASE _TRANTYP = 'JP'
    XTRANDESC = 'C/T JOB COST CLOSING'
  *B603862,1 Add new type for the Manufacturing closing cost sheet [End] 

  *B603983,1 Add new type for Inventory Locking [Begin] 
  CASE _TRANTYP = 'LK'
    XTRANDESC = 'INVENTORY LOCKING'
  *B603983,1 Add new type for Inventory Locking [End] 

  *N000388,1 Add a new type for Material Invoice. [Begin]
  CASE _TRANTYP = 'MI' 
    XTRANDESC = 'MATERIAL INVOICE'
  *N000388,1 Add a new type for Material Invoice. [End]

  *N000391,1 Add a new type for Voiding Material Invoice. [Begin]
  CASE _TRANTYP = 'VM'
    XTRANDESC = 'VOID MAT. INVOICE'
  *N000391,1 Add a new type for Voiding Material Invoice. [End]
  
ENDCASE

***
*-- WAM 03/29/94
*-- Update the field 'GLACNTTYPE' with the account type

SELE &_NFILE
APPEND BLANK
*E300325,1 Update currency fields and equivalent amount field
*E300325,1 in GLDIST (cCurrCode, nCurrUnit, nExRate, nEqvAmnt)
*REPLACE CATG_KEY   WITH _CATGKEY, ;
*        TRAN_TYPE  WITH _TRANTYP, ;
        TRAN_NO    WITH _TRANNO,  ;
*        AMOUNT     WITH _AMOUNT,  ;
*        TRAN_DATE  WITH _TRANDAT, ;
        GLACCOUNT  WITH XGLACNT,  ;
        ADD_DATE   WITH DATE(),   ;
        ADD_TIME   WITH TIME(),   ;
*        ADD_USERID WITH QUSERID,  ;
*        TRAN_DESC  WITH XTRANDESC, ;
*        GLPERIOD   WITH _PRDID, ;
*        GLFYEAR    WITH _FYEAR, ;
*        GLACNTTYPE WITH lcAcntType

*E300637,1 Use file new fields names
*REPLACE CATG_KEY   WITH _CATGKEY, ;
        TRAN_TYPE  WITH _TRANTYP, ;
        TRAN_NO    WITH _TRANNO,  ;
        AMOUNT     WITH _AMOUNT,  ;
        TRAN_DATE  WITH _TRANDAT, ;
        GLACCOUNT  WITH XGLACNT,  ;
        ADD_DATE   WITH DATE(),   ;
        ADD_TIME   WITH TIME(),   ;
        ADD_USERID WITH QUSERID,  ;
        TRAN_DESC  WITH XTRANDESC, ;
        GLPERIOD   WITH _PRDID, ;
        GLFYEAR    WITH _FYEAR, ;
        GLACNTTYPE WITH lcAcntType,;
        cCurrCode  WITH lcCurrCode,;
        nCurrUnit  WITH lnCurrUnit,;
        nExRate    WITH lnExRate,;
        nEqvAmnt   WITH lnEqvAmnt

* MAB 03/07/99 Remove updating odded fields [Begin
*REPLACE CATG_KEY   WITH _CATGKEY  ,;
        TRAN_TYPE  WITH _TRANTYP  ,;
        TRAN_NO    WITH _TRANNO   ,;
        nGlAmount  WITH _AMOUNT   ,;
        TRAN_DATE  WITH _TRANDAT  ,;
        GLACCOUNT  WITH XGLACNT   ,;
        ADD_DATE   WITH gdSysDate ,;
        ADD_TIME   WITH TIME()    ,;
        ADD_USERID WITH gcUser_Id ,;
        TRAN_DESC  WITH XTRANDESC ,;
        GLPERIOD   WITH _PRDID    ,;
        GLFYEAR    WITH _FYEAR    ,;
        GLACNTTYPE WITH lcAcntType,;
        cCurrCode  WITH lcCurrCode,;
        nCurrUnit  WITH lnCurrUnit,;
        nExRate    WITH lnExRate  ,;
        nEqvAmnt   WITH lnEqvAmnt

REPLACE CATG_KEY   WITH _CATGKEY  ,;
        TRAN_TYPE  WITH _TRANTYP  ,;
        TRAN_NO    WITH _TRANNO   ,;
        nGlAmount  WITH _AMOUNT   ,;
        TRAN_DATE  WITH _TRANDAT  ,;
        GLACCOUNT  WITH XGLACNT   ,;
        TRAN_DESC  WITH XTRANDESC ,;
        GLPERIOD   WITH _PRDID    ,;
        GLFYEAR    WITH _FYEAR    ,;
        GLACNTTYPE WITH lcAcntType,;
        cCurrCode  WITH lcCurrCode,;
        nCurrUnit  WITH lnCurrUnit,;
        nExRate    WITH lnExRate  ,;
        nEqvAmnt   WITH lnEqvAmnt
* MAB 03/07/99 Remove updating odded fields [End

*E300637,1 (End)
*E300325,1 end.
RETURN

********************
*** EOF of GLDIST
********************

****
*************************************************************************
*FUNCTION CheckPrd
*DESC: Function to validate transaction date
*NOTE: This function is called from evry transaction program.
*DATE: 02/28/1994
*AUTH: Wael Aly Mohamed 
*PARA: ldDate   : Transaction date to be check
*    : lcPeriod : Transaction Period
*    : lcFYear  : Transaction Fiscal Year 
*    : lcTranTyp: Type of transaction calls this function
*! MODI:  WAM 09/19/94
*!        1) Modified to call the function 'gfDialog' instead of the 
*!           function 'MsgCenter' to display messages when validate 
*!           transactions dates. Function'MsgCenter' has been deleted also.
*!B602317,1 WAM 12/06/98 Open SBT system company file with another name
*!B802236,1 AHM 08/05/1999 Allow voiding invoice in prior period
*************************************************************************
FUNCTION Checkprd
PARAMETERS ldDate,lcFYear,lcPeriod,lcTranTyp,llHideMsg

PRIVATE lcDType,lcAddMes1,lcAddMes2,lcSysDir,lcGlVers,lcGlComp, ;
        lcDate,llContinue,lcErrorM1,lcErrorM2, lnAlias
        
lnAlias = SELECT()
STORE '' TO M_POST_PPRD,M_SYS_DIR,M_GL_VERS,M_GL_CO

=gfGetMemVar('M_POST_PPRD,M_SYS_DIR,M_GL_VERS,M_GL_CO',gcAct_Comp)
lcSysDir   = ALLTRIM(M_SYS_DIR)
lcGlVers   = ALLTRIM(M_GL_VERS)
lcGlComp   = ALLTRIM(M_GL_CO)
STORE SPACE(1) TO lcDType,lcAddMes1,lcAddMes2

lcDate = DTOC(ldDate)      && Transaction date as a string used in messages
IF lcGlVers = 'S'            &&   <<<... SBT 2.5 ... >>>
  *B602317,1 Open SBT system company file with another name
  *=gfOpenFile(lcSysDir+'SYCCOMP',lcSysDir+'COMPID','SH')
  *=SEEK(lcGlComp,'SYCCOMP')

  USE lcSysDir+'SYCCOMP' ORDER TAG 'COMPID' IN 0 AGAIN ALIAS 'SBTCOMP'
  =SEEK(lcGlComp,'SBTCOMP')
  *B602317,1 (End)
  
  =gfOpenFile(lcSysDir+'SYCHFIS',lcSysDir+'COMPID1','SH')
  =gfOpenFile(lcSysDir+'SYCDFIS',lcSysDir+'COMPID1','SH')

  llContinue = .T.
  IF SEEK(lcGlComp)
    LOCATE REST FOR BETWEEN(ldDate,Bdate,Edate) ;
                WHILE (ldDate >= Bdate) .AND. (CompId = lcGlComp)
  ENDIF
  IF !FOUND()                && No period match checked date
    llContinue = .F.
    lcErrorM1 = ' does not fall within any period. '
    lcErrorM2 = ''
  ELSE
    &lcFYear  = SUBSTR(Yearprd,1,4)      && Transaction date year
    &lcPeriod = SUBSTR(Yearprd,5,2)      && Transaction date period     
  ENDIF  
  IF llContinue .AND. Permlck         && Permanently locked period
    llContinue = .F.
    lcErrorM1 = ' falls in a permanently locked period.'
    lcErrorM2 = ''
  ENDIF  
  IF llContinue .AND. Plocked         && Locked period
    llContinue = .F.
    lcErrorM1 = ' falls in a locked period.'
    lcErrorM2 = ''
  ENDIF  
  IF llContinue              && So far so good
    IF Pclosed               && Closed period
      IF !(lcTranTyp $ 'VI2VR2')  && Transaction is neither 
                                  && 'Void invoice' nor 'void return'.
        llDummy =  FErrInfo(lcTranTyp,'lcDType','lcAddMes1','lcAddMes2')
        lcErrorM1 = '&lcDType&lcDate belongs to prior period.'
        lcErrorM2 = ''
        =gfDialog( 'I',lcErrorM1+lcErrorM2)
      ELSE  
        llContinue = .F.
      ENDIF
    ELSE    && Period not closed. Check if it is a future period
      *B602317,1 Open SBT system company file with another name
      *IF Yearprd <>  SYCCOMP.CURYR+SYCCOMP.CURPRD .AND. !(lcTranTyp $ 'VI2VR2')
      IF Yearprd <>  SBTCOMP.CURYR+SBTCOMP.CURPRD .AND. !(lcTranTyp $ 'VI2VR2')
      *B602317,1 (End)

        llDummy   =  FErrInfo(lcTranTyp,'lcDType','lcAddMes1','lcAddMes2')
        lcErrorM1 = '&lcDType&lcDate belongs to a future period.'
        lcErrorM2 = ''
        =gfDialog( 'I',lcErrorM1+lcErrorM2)
      ENDIF
    ENDIF    
  ENDIF  
  *B602317,1 Open SBT system company file with another name
  USE IN SBTCOMP
  *B602317,1 (End)

ELSE
  =gfOpenFile(gcSysHome+'SYCCOMP',gcSysHome+'CCOMP_ID','SH')
  =SEEK(gcPrnt_Cmp,'SYCCOMP')
  IF 'GL' $ SYCCOMP.mModlset
    *=gfOpenFile(ALLTRIM(SYCCOMP.CCOM_DDIR)+'GLSETUP','','SH')
    *E301098,1 Hesham (Start)
    *USE (ALLTRIM(SYCCOMP.CCOM_DDIR)+'GLSETUP') SHARED AGAIN ALIAS TGLSETUP IN 0
    USE (gfGetDataDir(ALLTRIM(SYCCOMP.CCOM_DDIR))+'GLSETUP') SHARED AGAIN ALIAS TGLSETUP IN 0
    *E301098,1 Hesham (End)
    lDSETBBDAT=TGLSETUP.DSETBBDAT
    *-- Variable that hold the Allow posting before beginning balance (Start)
    *-- AAMER 11/12/98
    llAllPBB = TGLSETUP.LSETALBBE
    *-- Variable that showes the Allow posting before beginning balance (End)
    USE IN TGLSETUP 
  ELSE  
    lDSETBBDAT={}
    *-- Variable that showes the Allow posting before beginning balance (Start)
    *-- AAMER 11/12/98
    *-- .T. is assigend as default because we need not to check
    *-- if the GL module not installed or not linked
    llAllPBB = .T.
    *-- Variable that hold the Allow posting before beginning balance (End)
  ENDIF  
  *E300692,5 Use FISHD, FSPRD instead of SYCFISHD, SYCFSPRD
  *=gfOpenFile(gcSysHome+'SYCFISHD',gcSysHome+'COMPFYEAR','SH')
  *=gfOpenFile(gcSysHome+'SYCFSPRD',gcSysHome+'COMFYRPRDI','SH')
  =gfOpenFile(gcDataDir+'FISHD',gcDataDir+'COMPFYEAR','SH')
  =gfOpenFile(gcDataDir+'FSPRD',gcDataDir+'COMFYRPRDI','SH')
  *E300692,5 end
  llContinue = .T.
  *E300789,1 Hesham (Start)
  *IF SEEK(lcGlComp)
  LOCATE
  IF FOUND()
  *E300789,1 Hesham (End)
    *E300789,1 Remove cComp_ID
    *LOCATE REST FOR BETWEEN(ldDate,Dfsppbgdt,Dfsppendt) ;
                WHILE (ldDate >= Dfsppbgdt) .AND. (CComp_Id = lcGlComp) 
    LOCATE REST FOR BETWEEN(ldDate,Dfsppbgdt,Dfsppendt) ;
                WHILE (ldDate >= Dfsppbgdt)                 
    *E300789,1 end
  ENDIF
  IF !FOUND()                  && No period match checked date
    llContinue = .F.
    lcErrorM1 = ' does not fall within any period. '
    lcErrorM2 = ''
  ELSE
    &lcFYear  = Cfisfyear      && Transaction date year
    &lcPeriod = Cfspprdid      && Transaction date period     
  ENDIF  
  IF llHideMsg
    SELECT (lnAlias)
    RETURN(llContinue)
  ENDIF
  *** Check if transaction date falls in a history period.
  IF llContinue .AND. Cfisfyear < STR(VAL(SYCCOMP.CCURR_YER)-1)
    llContinue = .F.
    lcErrorM1 = ' belongs to a history fiscal year.'
    lcErrorM2 = ''
  ENDIF 
  IF llContinue         
    *** Check if the transaction date before the begining balance
    *** date, and if the user is allowed to post before the begining
    *** balance date

    *-- Check if the system is linked to GL And Allow posting before beginning Balance (Start)
    *-- AAMER 11/12/98
    *IF !EMPTY(lDSETBBDAT) .AND. ldDate < lDSETBBDAT
    IF lcGlVers='A' AND !llAllPBB AND !EMPTY(lDSETBBDAT) .AND. ldDate < lDSETBBDAT
    *-- Check if the system is linked to GL And Allow posting before beginning Balance (End) 
      llContinue = .F.
      lcErrorM1 = ' falls before the begining balance date.'
      lcErrorM2 = ' No posting allowed before the begining balance date. '
    ENDIF  
  ENDIF  
  IF llContinue .AND. Lfsplocks         && Locked period
    llContinue = .F.
    lcErrorM1 = ' falls in a locked period.'
    lcErrorM2 = ''
  ENDIF  
  IF llContinue 
    IF Lfspclsds               && Closed period
      IF !(lcTranTyp $ 'VI2VR2')
        llDummy =  FErrInfo(lcTranTyp,'lcDType','lcAddMes1','lcAddMes2')
        lcErrorM1 = '&lcDType&lcDate belongs to prior period.'
        lcErrorM2 = ''
        *E300420,1 Message : 00274
        *E300420,1 
        *E300420,1 Button : 00000 
        *E300420,1 Ok
        
        *B802236 (Start)
        IF lcTranTyp # 'VI1'
        *B802236 (End)
          =gfModalGen('INM00274B00000','ALERT',lcErrorM1+lcErrorM2)
        *B802236 (Start)
        ENDIF
        *B802236 (End)
          
        *=gfDialog( 'I',lcErrorM1+lcErrorM2)
      ELSE  

        *B802236 (Start)
        IF lcTranTyp # 'VI2'
        *B802236 (End)
          llContinue = .F.
        *B802236 (Start)
        ENDIF
        *B802236 (End)
          
      ENDIF
    ELSE      && Period not closed. Check if it is a future period.
      IF Cfisfyear+Cfspprdid <> SYCCOMP.CCURR_YER+SYCCOMP.CCURR_PRD .AND. !(lcTranTyp $ 'VI2VR2')
        llDummy =  FErrInfo(lcTranTyp,'lcDType','lcAddMes1','lcAddMes2')
        lcErrorM1 = '&lcDType&lcDate belongs to a future period.'
        lcErrorM2 = ''
        *E300420,1 Message : 00274
        *E300420,1 
        *E300420,1 Button : 00000 
        *E300420,1 Ok
        =gfModalGen('INM00274B00000','ALERT',lcErrorM1+lcErrorM2)
        *=gfDialog( 'I',lcErrorM1+lcErrorM2)
      ENDIF
    ENDIF    
  ENDIF  
ENDIF
IF !llContinue             && There is an error.
  IF lcTranTyp $ 'VI2VR2'       && Transaction is either 'Void invoice'
                                && or 'Void return'
    lcErrorM1  = ' not in the current period. '
    lcErrorM2 = ''
  ENDIF
  llDummy =  FErrInfo(lcTranTyp,'lcDType','lcAddMes1','lcAddMes2')
  lcErrorM1= lcDType + lcDate + lcErrorM1
  *E300420,1 Message : 00274
  *E300420,1 
  *E300420,1 Button : 00000 
  *E300420,1 Ok
  
  *B802236 (Start)
  IF lcTranTyp # 'VI2'
  *B802236 (End)
    =gfModalGen('INM00274B00000','ALERT',lcErrorM1+lcErrorM2+lcAddMes1+lcAddMes2)
  *B802236 (Start)
  ENDIF
  *B802236 (End)

  *=gfDialog( 'I',lcErrorM1+lcErrorM2+lcAddMes1+lcAddMes2)
  SELECT (lnAlias)
  RETURN(.F.)
ENDIF
SELECT (lnAlias)
RETURN(.T.)
*****
* End of Function CheckPrd
*****
*************************************************************************
*FUNCTION FErrInfo
*DESC: Function get error information, which depends on transaction type. 
*NOTE: Called from Function Checkprd
*DATE: 02/28/1994
*AUTH: Wael Aly Mohamed 
*PARA: lcType   : Transaction type.
*    : lcDKind  : Date kind
*    : lcErrMes1: Message line #1
*    : lcErrMes2: Message line #2
*MODI:
*E100219,9 WAM 07/04/95 Add new type codes for receiving materials & styles
*E100219,9              from operation
*N000016,6 WAM 07/04/95 Add new type code for M.F.G. order receivin.
*E300324,6 RENEE 12/28/95 function fErrInfo() : Change text of type 'IN'
*E300324,6                AND 'V1' from 'System date' to 'Invoice date',
*E300324,6                and remove the checking message.
*B603504,1 ADEL 12/04/2000 Add a new transaction type for Closing material MFG and Closing Material PO.
*************************************************************************
FUNCTION FErrInfo
PARAMETERS lcType,lcDKind,lcErrMes1,lcErrMes2

DO CASE
  CASE lcType = 'IN'                 && Invoice
    *E300324,6 Change message text.
    *&lcDKind   = 'System date '
    &lcDKind   = 'Invoice date '
    *E300324,6 end.
    
    &lcErrMes1 = 'Not allowed to create invoices for this date. '
    
    *E300324,6 Remove checking message text.
    *&lcErrMes2 = 'Please check the system date.'
    &lcErrMes2 = ''
    *E300324,6 end.  
    
  CASE lcType = 'VI1'                 && Void invoice 1st.
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to void invoices for this date. '
    &lcErrMes2 = 'Please check the system date.'
    
  CASE lcType = 'VI2'                 && Void Invoice 2nd.
    &lcDKind   = 'Invoice date '
    &lcErrMes1 = 'Not allowed to void invoices from prior periods.'
    &lcErrMes2 = ''
      
  CASE lcType = 'IA'                 && Inventory Adjustment
    &lcDKind   = 'Transaction date '
    &lcErrMes1 = 'Not allowed to enter inventory adjustment for this date.'
    &lcErrMes2 = ''
      
  CASE lcType = 'IP'                 && Inventory Physical
    &lcDKind   = 'Transaction date '
    &lcErrMes1 = 'Not allowed to enter physical inventory for this date.'
    &lcErrMes2 = ''
    
  CASE lcType = 'ZE'                 && Zero out Stock
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to zero out stock for this date. '
    &lcErrMes2 = 'Please check the system date.'
      
  CASE lcType = 'PO'                 && Receive P/Os
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to enter P/O receivings for this date. '
    &lcErrMes2 = 'Please check the system date.'
      
  CASE lcType = 'CT'                 && Receive C/Ts
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to enter C/T receivings for this date. '
    &lcErrMes2 = 'Please check the system date.'

  CASE lcType = 'RM'                 && Return merchandise
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to receive returns for this date. '
    &lcErrMes2 = 'Please check the system date.'
    
  CASE lcType = 'VR1'                 &&  Void Return 1st
    &lcDKind   = 'System date '
    &lcErrMes1 = 'Not allowed to void credit memo for this date. '
    &lcErrMes2 = 'Please check the system date.'
    
  CASE lcType = 'VR2'                 &&  Void Return 2nd
    &lcDKind   = 'Return date '
    &lcErrMes1 = 'Not allowed to void credit memo from prior periods.'
    &lcErrMes2 = ''
    
  CASE lcType = 'CR'                 &&  Customer Payment
    &lcDKind   = 'Batch date '
    &lcErrMes1 = 'Not allowed to enter payments for this batch date.'
    &lcErrMes2 = ''

  CASE lcType = 'AJ'                 &&  Adjustment
    &lcDKind   = 'Batch date '
    &lcErrMes1 = 'Not allowed to enter adjustments for this batch date.'
    &lcErrMes2 = ''
    
  CASE lcType = 'KO'                 &&  Key Off
    &lcDKind   = 'Key off date '
    &lcErrMes1 = 'Not allowed to make key off for this date.'
    &lcErrMes2 = ''

  CASE lcType = 'RO'                 &&  Receive from material operation
    &lcDKind   = 'Material operation receiving date '
    &lcErrMes1 = 'Not allowed to receive from material operation for this date.'
    &lcErrMes2 = ''

  CASE lcType = 'RS'                 &&  Receive from style operation
    &lcDKind   = 'Style operation receiving date '
    &lcErrMes1 = 'Not allowed to receive from style operation for this date.'
    &lcErrMes2 = ''

  CASE lcType = 'MM'                 &&  Receive M.F.G. order
    &lcDKind   = 'M.F.G. order receiving date '
    &lcErrMes1 = 'Not allowed to receive M.F.G. order for this date.'
    &lcErrMes2 = ''
  *B603504,1 (Begin) Add two new transaction type for Closing material MFG and Closing Material PO.
  CASE lcType = 'MC'               && ClOSE MATERIAL PO
    &lcDKind   = 'Material job closing date'
    &lcErrMes1 = 'Not allowed to close Material job for this date.'
  *B603504,1 (End)

  OTHERWISE
    &lcDKind   = 'Transaction date '
    &lcErrMes1 = ''
    &lcErrMes2 = ''
ENDCASE   

RETURN(.T.)

*****
* End of Function FErrInfo
*****
*************************************************************************
*PROCEDURE FLinkInfo
*DESC: Procedure to update the global variables current year, current year, 
*      and begin balance date 
*NOTE: Called from Function selecomp and set100.prg
*DATE: 03/29/94
*AUTH: Wael Aly Mohamed 
*PARA: XLINK    : Link to general ledger
*    : XVERS    : Version
*    : XSYS_DIR : System directory
*    : XGL_CO   : Company
*    : XCURR_YR : Current year
*    : XCURR_PRD: Current period
*MODI:
*************************************************************************
PROCEDURE FLinkInfo
PARAMETERS XLINK,XVERS,XSYS_DIR,XGL_CO,XCURR_PRD,XCURR_YR

PRIVATE XTEMPDIR

DO CASE

  CASE XLINK = 'Y' .AND. (XVERS = 'SBT2.5' )
    QPRDCNTRL='L'
    XTEMPDIR = ALLTRIM(XSYS_DIR)
    IF FILE('&XTEMPDIR.SYCCOMP.DBF')
      IF USED('SYCCOMP')
        SELECT SYCCOMP
      ELSE  
        SELECT 0
      ENDIF  
      
      DO NETUSE WITH '&XTEMPDIR.SYCCOMP','','SH'
      SET ORDER TO TAG COMPID
      
      SEEK XGL_CO
      QCURRPRD  = CURPRD                 && Current Period
      QCURRYEAR = CURYR                  && Current Year
      USE
    ELSE
      ??CHR(7)
      ??CHR(7)
      = gfDialog ("I","SBT Company file not found.  Please check linking info.")
      QCURRPRD  = SPACE(2)
      QCURRYEAR = SPACE(4)
    ENDIF
    
  CASE XLINK = 'Y' .AND. (XVERS = 'ARIAGL' )
    QPRDCNTRL='L'
    XTEMPDIR = ALLTRIM(XSYS_DIR)
    IF FILE('&XTEMPDIR.SYCCOMP.DBF')
      IF USED('SYCCOMP')
        SELECT SYCCOMP
      ELSE  
        SELECT 0
      ENDIF  
      
      DO NETUSE WITH '&XTEMPDIR.SYCCOMP','','SH'
      SET ORDER TO TAG CCOMP_ID
      
      SEEK XGL_CO
      QCURRPRD  = CCURR_PRD                 && Current Period
      QCURRYEAR = CCURR_YER                 && Current Year
      *E301098,1 Hesham (Start)
      *XTEMPDIR = ALLTRIM(CCOM_DDIR)         && Date directory
      XTEMPDIR = gfGetDataDir(ALLTRIM(CCOM_DDIR))         && Date directory
      *E301098,1 Hesham (End)
      USE
      IF FILE('&XTEMPDIR.GLSETUP.DBF')
        IF ! USED('GLSETUP')
          SELECT 0
          DO NETUSE WITH '&XTEMPDIR.GLSETUP','','SH'
        ENDIF
        SELECT GLSETUP
        QBegBalDt = DSETBBDAT
        USE
      ELSE
        ??CHR(7)
        ??CHR(7)
        = gfDialog ("I","Company setup file not found.  Please check linking info.")
        QBegBalDt = {}
      ENDIF

    ELSE
      ??CHR(7)
      ??CHR(7)
      = gfDialog ("I","ARIA Company file not found.  Please check linking info.")
      QCURRPRD  = SPACE(2)
      QCURRYEAR = SPACE(4)
    ENDIF

  OTHERWISE
     IF .NOT. EMPTY(XCURR_PRD+XCURR_YR)     && INTERNAL FISCAL CALENDER IS SETUP
        QPRDCNTRL = 'A'
        QCURRPRD  = XCURR_PRD
        QCURRYEAR = XCURR_YR
      ELSE
        QPRDCNTRL = 'N'                   && NO ACCTG/PERIOD CONTROL
        QCURRPRD  = SPACE(2)
        QCURRYEAR = SPACE(4)
      ENDIF

  ENDCASE
RETURN

*****
* End of procedure FLinkInfo
*****



*!**************************************************************************
*!Name: gfReadPswd
*!Auth: Timour Abdalla Khalil
*!Date: 03/26/94
*!
*!
*!Synopsis: Function to get password and convert it.
*!
*!Called from: SET800.prg
*!
*!Passed:
*!   Parameters: lnRow,lnColom,llChgPass
*!
*!Returned: lcUserPass  

FUNCTION gfReadPswd
PARAMETERS lnRow,lnColom,llChgPass
PRIVATE lnInkey,lnCnt,lnRow,lnColom,lnCol,laPass,llChgPass

DIME laPass(12)
STORE ' ' TO laPass
lnCnt     =1
lnCol     =lnColom 
lcUserPass=SPACE(12)

lcSay = IIF (llChgPass,'************',SPACE(12))
IF _WINDOWS
  @ lnRow,lnCol SAY lcSay COLOR gr+/n FONT "FOXFONT",9 
ELSE
  @ lnRow,lnCol SAY lcSay COLOR gr+/n 
ENDIF  

*-- Get the user password chracter by chracter.
DO WHILE .T.

  IF _WINDOWS
    @ lnRow,lnCol SAY SPACE(1) COLOR gr+/n FONT "FOXFONT",9 
  ELSE
    @ lnRow,lnCol SAY SPACE(1) COLOR gr+/n 
  ENDIF  

  @ lnRow,lnCol say ''
  lnInkey=INKEY(0)
  IF lnInkey>=0
    laPass(lnCnt)=UPPER(CHR(lnInkey))
  ELSE
    laPass(lnCnt)=' '
    lnInkey=27
  ENDIF
  DO CASE
    CASE lnInkey=27
      laPass(lnCnt)=' '
      EXIT
    CASE lnInkey=4 .OR.lnInkey=5 .OR.lnInkey=24
      laPass(lnCnt)=' '
      LOOP
    CASE lnInkey=19 .OR. lnInkey=127
      laPass(lnCnt)=' '
      lnCnt=lnCnt-1
      lnCol=lnCol-1
      IF lnCnt<>0
        IF _WINDOWS
          @ lnRow,lnCol SAY SPACE(1) COLOR gr+/n FONT "FOXFONT",9 
        ELSE
          @ lnRow,lnCol SAY SPACE(1) COLOR gr+/n 
        ENDIF  
        laPass(lnCnt)=' '
      ELSE
        ? CHR(7)
        lnCnt=1
        lnCol=lnColom
      ENDIF  
    CASE lnInkey=13 .OR. lnCnt=12
      IF lnCnt=12
        IF _WINDOWS
          @ lnRow,lnCol SAY '*' COLOR gr+/n FONT "FOXFONT",9 
        ELSE
          @ lnRow,lnCol SAY '*' COLOR gr+/n 
        ENDIF  
      ENDIF
      laPass(lnCnt)=' '
      EXIT
    OTHERWISE
      IF _WINDOWS
        @ lnRow,lnCol SAY '*' COLOR gr+/n FONT "FOXFONT",9 
      ELSE
        @ lnRow,lnCol SAY '*' COLOR gr+/n 
      ENDIF  
      lnCnt=lnCnt+1
      lnCol=lnCol+1
  ENDCASE
ENDDO

*-- Combine the contents of password.
lcUserPass=laPass(1)+laPass(2)+laPass(3)+laPass(4)+;
           laPass(5)+laPass(6)+laPass(7)+laPass(8)+;
           laPass(9)+laPass(10)+laPass(11)+laPass(12)

*-- Convert the user password
lcUserPass=SYS(2007,lcUserPass)

IF _WINDOWS
  @ lnRow,lnColom SAY '************' COLOR N+/W FONT "FOXFONT",9 
ELSE
  @ lnRow,lnColom SAY '************' COLOR N+/W
ENDIF  

RETURN(lcUserPass)

*!**************************************************************************
*! Name : Procedure gpAbotAria
*! Auth : Amr Abdel Raouf Hegazy
*! Date : 04/06/94
*!         
*! Synopsis : Display all the information about aria in a window.
*!  
*! Called from : 
*!         Procedures : Aria25.MPR
*! 
*! Calls : 
*!         Functions  : gfMsgStr(),lfDecode()
*! 
*! Passed :
*!        Variables  : qTopMsg,qLstKey
*! 
*E100230,1 HISH 04/19/95 Change about aria screen to work in windows.
PROCEDURE gpAbotAria

ON KEY LABEL ESC

lcMsg=gfMsgStr("Information about ARIA SYSTEMS, INC. and tech support numbers") 

DO CASE
  CASE _DOS OR _UNIX
    @ 24,00 SAY lcMsg COLOR &gcMsgClr  
  CASE _WINDOWS OR _MAC
    SET MESSAGE TO lcMsg
ENDCASE

*E300637,1 Use the new global variables names
*DO (qSd+'ABOTARIA.SPR')
DO (gcScrDir+'ABOTARIA.SPR')
*E300637,1 (End)

*E100230,1 HISH 04/19/95, Activate help popup after finishing ABOUT ARIA window.
KEYBOARD '{ALT+H}'
ON KEY LABEL ESC KEYBOARD '{ALT+X}'


*!**************************************************************************
*! Name : FUNCTION lfDecode()
*! Auth : Amr Abdel Raouf Hegazy
*! Date : 04/06/94
*!         
*! Synopsis : This function takes a string of characters and convert it
*!            into scrambelled group of numbers (decoding) and takes
*!            string of scrambelled numbers and convert it into
*!            the original string (encoding).
*!  
*! Called from : 
*!         Procedures : Init25.PRG,gpAbotAria
*! 
*! Passed :
*!        Parameters :
*!           1) lcString
*!                    --> String of characters to be decoded.
*!                    --> String of decoded numbers to be encoded.
*!           2) lcType
*!                    --> 'D' To decode the passed string.
*!                    --> 'E' To encode the passed string.
*! 
*! Returned : 
*!        Variables  :
*!           1) lcRetVal
*!                   --> String of decoded numbers if the passed string
*!                       is a string of characters.
*!                   --> String of characters if the passed string is
*!                       decoded numbers.
*! 
FUNCTION lfDecode
PARAMETERS lcString,lcType
PRIVATE lcString,lcType,lcRetVal

*- Put the length of the passed string in the returned value if we're
*- decoding the passed string because it's an element in the decoding
*- and encoding process.Otherwise initialize it with empty string.
lcRetVal = IIF(lcType='D',ALLTRIM(STR(LEN(lcString))),SPACE(0))

*-- Decode the string if lctype='D'.Otherwise encode it.
IF lcType = 'D'
  
  *- Decoding happens by :
  *-    1) Subtracting 5 from the string length
  *-       then add the result on the ascii value returned from changing
  *-       the current character into ascii value.
  *-    2) Putting the delemeter '~' then the result of operation # 1
  *-       in the lcRetVal as a character value and so on.
  FOR lnI=1 TO LEN(lcString)
    lcRetVal = lcRetVal+'~'+ALLTRIM(STR(ASC(SUBSTR(lcString,lnI,1))+;
                                      (LEN(lcString)-5)))
  ENDFOR
ELSE
  
  *- Encoding happens by :
  *-    1) Searching about the delemeter '~' then get the number that
  *-       follows the delemeter
  *-    2) Subtracting 5 from the string length that we put in the decoding
  *-       operation and subtract it from the number we got in step 1
  *-    3) Getting the CHR() for the result of step # 2 and put it in 
  *-       the lcRetVal and so on.
  FOR lnI=1 TO OCCURS('~',lcString)
    lcRetVal = lcRetVal +CHR(ROUND(VAL(SUBSTR(lcString,;
                            ATC('~',lcString,lnI)+1,IIF(lnI=OCCURS('~',;
                                lcString),(LEN(lcString)-(ATC('~',lcString,;
                                lnI-1)+1)),((ATC('~',lcString,lnI+1);
                                -ATC('~',lcString,lnI))-1))));
                                -(ROUND(VAL(SUBSTR(lcString,1,;
                                (ATC('~',lcString)-1)))-5,0)),0))
  ENDFOR
ENDIF

RETURN(lcRetVal)

*!**************************************************************************
*! Name      : FacChk
*! Developer : ARH
*! Date      : 08/26/1992
*! Purpose   : Validates factors. If passed a valid factor, displays
*!             factor name, otherwise browses factors.
*! Modified  : 04/09.1995 RENEE - Renee Ezzat
*!             This function replaces the old factor validation so as to 
*!             use more facilities provided by higher versions of FoxPro 
*!             (eg Browse in Windows)
*!**************************************************************************
*! Called From : 
*!             -Factors Setup program (SET600)
*!             -Customer Entry screen (CUS100)
*!**************************************************************************
*! Calls     : 
*!              None
*!**************************************************************************
*! Passed Parameters  : 
*!              xFactor Type C            : factor code
*!              xCRow   Type N (optional) : Row co-ordinate of factor code
*!              xCCol   Type N (optional) : Col co-ordinate of factor code
*!              xDRow   Type N (optional) : Row co-ordinate of factor name,
*!                                          0 if not required
*!              xDCol   Type N (optional) : Col co-ordinate of factor name,
*!                                          0 if not required                      
*!    Comments         :
*!              If called from a screen created by the screen generator,
*!              do not pass the last four parameters.
*!**************************************************************************
*! Returns            : 
*!              If called from a screen created by the screen generator :
*!                returns the factor name 
*!              Otherwise, returns .t.
*!*************************************************************
*! Example   :  If called from a screen created by the screen generator :
*!                lcFactName = FacChk(xFactor) 
*!              Otherwise
*!                -If factor name is required :
*!                  =FacChk(xFactor, xFactRow, xFactCol, xFNameRow, xFNAmeCol)
*!                -If factor name is not required :
*!                  =FacChk(xFactor, xFactRow, xFactCol, 0, 0)
*!*************************************************************
FUNCTION FacChk
PARAMETERS xFactor,xCRow,xCCol,xDRow,xDCol
PRIVATE lcBrFields, lcSetExact, lnOldAlias, lnCustTag, lnCustRecNo,;
        lnSoftSeek, llOpnCust, laData

DECLARE laData[2]  && array to get values from browse
STORE '' TO laData
xFactor = PADR(xFactor,5)
IF !EMPTY(xFactor)
  llBrowse   = IIF(TYPE('llBrowse') = 'U', .F., llBrowse)
  lnOldAlias = SELECT()
  lcSetExact = SET('EXACT')
  SET EXACT OFF

  *-- Open Customer file, tag Customer if not already in use, 
  *-- Otherwise set the correct tag
  IF !USED('CUSTOMER')
    *E300637,1 Use the new global variables names
    *SELECT 0
    *DO NETUSE WITH '&QDD.CUSTOMER','&QDD.CUSTOMER','SH'
    =gfOpenFile(gcDataDir+'CUSTOMER',gcDataDir+'CUSTOMER','SH')
    *E300637,1 (End)
    llOpnCust   = .T.
  ELSE
    SELECT CUSTOMER
    lnCustTag   = VAL(SYS(21))
    lnCustRecNo = IIF(EOF(), 0, RECNO())
    SET ORDER TO TAG CUSTOMER
    llOpnCust   = .F.
  ENDIF

  *-- Check if there are any factors in the file before validation
  IF SEEK('F') 
    *-- Look for the passed factor, 
    *-- If not found, browse factors setting the record pointer
    *-- on the closest match.
    IF !SEEK('F'+xFactor) .OR. llBrowse
      lnSoftSeek  = RECNO()
      *B600429,1 Add more fields to the browse fields variable.
      *lcBrFields  = [Account,BtName:H='Name']
      *B500772,1 HISH 07/02/96 Displayed field phone with its format.

      *E300637,1 Use the global phone template
      *IF _WINDOWS
      *  lcBrFields  = [Account:H='Account',BtName:H='Name',Buyer:H='Contact',Phone1 :P= "@R "+gcPhnFrmt :H='Phone']
      *ELSE
      *  lcBrFields  = [Account:H='Account',BtName:H='Name',Buyer:H='Contact',Phone1 :P= "@R "+gcPhnFrmt :H='Phone']
      *ENDIF
      IF _WINDOWS
        lcBrFields  = [Account:H='Account',BtName:H='Name',Buyer:H='Contact',Phone1 :P= gfPhoneTem() :H='Phone']
      ELSE
        lcBrFields  = [Account:H='Account',BtName:H='Name',Buyer:H='Contact',Phone1 :P= gfPhoneTem() :H='Phone']
      ENDIF
      *E300637,1 (End)
      
      IF BETWEEN(lnSoftSeek, 1, RECCOUNT())
        GO lnSoftSeek
      ELSE
        GO TOP
      ENDIF 
      IF ARIABROW(['F'],'Factors',;
                  gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2, '','',; 
                  'CUSTOMER.Account,CUSTOMER.BtName','laData')
        xFactor   = laData[1]
      ELSE
        xFactor   = SPACE(5)
        laData[2] = SPACE(30)
      ENDIF                  
    *-- If the passed factor code is valid, get factor name into laData[2]
    ELSE
      laData[2]   = CUSTOMER.BtName
    ENDIF
  
  *-- If there are no factors in the customers file, present the 
  *-- following message
  ELSE
    =gfDialog('I', 'There are no factors to browse.')
    xFactor   = SPACE(5)
    laData[2] = SPACE(30)
  ENDIF
  
  *-- Restore calling environment
  IF llOpnCust
    IF USED('CUSTOMER')
      USE IN CUSTOMER
    ENDIF
  ELSE
    SET ORDER TO lnCustTag IN CUSTOMER
    IF lnCustRecNo > 0
      GO lnCustRecNo
    ENDIF 
  ENDIF
  SELECT (lnOldAlias)
  SET EXACT &lcSetExact
ELSE
  laData[2] = SPACE(30)
ENDIF

*-- If coordinates are not passed, return the factor name,
*-- otherwise display the factor code and name (optional) and return .t.  
IF TYPE('XCROW') $ 'UL' 
  RETURN laData[2]
ELSE
  SET COLOR TO &QCLRSAY
  IF !EMPTY(XFACTOR)
    @ xCRow, XCCol SAY xFactor
  ELSE
    @ xCRow, XCCol TO xCRow, XCCol + 4 CLEAR
  ENDIF  
  IF xDRow <> 0 .OR. xDCol <> 0
    @ xDRow, XDCol SAY SUBSTR(laData[2],1,24)
  ENDIF
  RETURN .T.
ENDIF  
*-----------------------------------------------------------------------------
* PROG: POFBROW
* DESC: PROGRAM TO BROWSE THE FABRIC PURCHASE ORDER
* DATE: 08/02/90
* PARA: THE PO AND VENDOR IS PASSED AS A PARAMETER
* MODI: 13/03/95 HISH
*                1) Added 3 numerics to the feild POTOTAL
*! 
*! Modifications :
*!      MFM 07/12/94
*!          1) Incresed vendor code to 8 characters and fixed the 
*!             says of data in it's correct places.
*!          2) Validate the vendor from AP directory if link is yes.
*****************************************************************************
PROCEDURE OLDPOFBROW
PARAMETER XPO,XVEN,llRetAlias

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lcAlias,lcVenCode && Variable to hold browse fields
PRIVATE lcBrFields,lcAlias,lcVenCode,laData
*E300637,1 (End)

DECLARE laData[2] && array to get values from browse
laData=' '
llOpnApVen=.F.
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lcTitle  = 'Material Purchase Orders'
lcVenCode=IIF(!EMPTY(xVen),xVen,'')

*B600429,1 Change the browse fields variable width under windows.
IF _WINDOWS
  lcBrFields = "PO      :R :H='P/O #':8,"+;
	           "Status  :R :H='S':2,"+;	         	           	         
               "Vendor  :R :H='Vendor':10,"+;
	           "&lcVenFile..&lcFldNme  :R :H='Name':18,"+;
	           "Complete:R :H='Complete':8,"+;
  	           "Order   :R :H='Tot.Qty.':7,"+;	         
               "POTotal :R :H='Amount':10,"+;
               "Receive :R :H='Receive':7,"+;
               "Open    :R :H='Open':7"
ELSE
  *B800136,1 Reham On 08/29/95    *** Begin ***
  *B800136,1 Change _ the name width from 14 to 11
  *B800136,1        _ the open width from 7  to 10
  lcBrFields = "PO      :R :H='P/O #':6,"+;
	           "Status  :R :H='S':1,"+;	         	           	         
               "Vendor  :R :H='Vendor':8,"+;
	           "&lcVenFile..&lcFldNme  :R :H='Name':11,"+;
	           "Complete:R :H='Complete':8,"+;
  	           "Order   :R :H='Tot.Qty.':7,"+;	         
               "POTotal :R :H='Amount':10,"+;
               "Receive :R :H='Receive':7,"+;
               "Open    :R :H='Open':10"
  *B800136,1 Reham On 08/29/95    *** End ***
ENDIF

lcAlias = ALIAS()   && Save the current alias.

*-- TMI 07/27/94 To hold the status of the AP link facility.
RESTORE FROM ADPARA&QSYSCODE ADDI
llApLink  = IIF (M_ApLink    = 'Y', .T., .F.)   
lcApDir   = ALLTRIM (M_ApDataDir)
RELEASE ALL LIKE M_*

IF RECCOUNT()=0
  = gfDialog ("I","There are no Purchase orders on the file...!")
  XVEN = SPACE(8)
  xPo  = SPACE(6) 
  IF llRetAlias
    SELECT (lcAlias)
  ENDIF  
  RETURN
ENDIF

*-- TMI 07/27/94 Open the vendor file of the Aria Advantage series
*-- system instead of our vendor file if the system was setup to
*-- link with the AP module.
IF llApLink
  IF !USED( 'ApVendor' )
    SELECT 0
    DO NetUse WITH '&lcApDir.ApVendor', 'VenCode', 'SH'
    llOpnApVen=.T.
  ELSE  
    llOpnApVen=.F.
  ENDIF
  lcVenFile = 'ApVendor'
  lcFldNme  = 'cVenComp'  
ELSE
  *E300637,1 Use the new global variables names
  *IF !USED( 'VENDOR' )
  *  SELECT 0
  *  DO NETUSE WITH '&QDD.VENDOR','&QDD.VENDOR','SH'
  *ENDIF  
  =gfOpenFile(gcDataDir+'VENDOR',gcDataDir+'VENDOR','SH')
  *E300637,1 (End)
  lcVenFile = 'Vendor'
  lcFldNme  = 'Name' 
ENDIF  

SELE POFHDR
*-- MFM 07/12/94.
SET RELATION TO Vendor INTO &lcVenFile
*-- END MFM 07/12/94.
GOTO TOP

lcStyOrder = TAG()
IF !EMPTY(xVen)
  SET ORDER TO TAG POFHDRV
ELSE
  SET ORDER TO TAG POFHDR
ENDIF  

IF !SEEK (XVEN)
  = gfDialog ("I","There are no Purchase orders for this vendor on the file....!")
  XVEN = SPACE(8)
  xPo  = SPACE(6) 
  IF llRetAlias
    SELECT (lcAlias)
  ENDIF      
  RETURN .F.
ENDIF

llWasSel=ARIABROW('lcVenCode',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','',"Po,Vendor","laData")
IF llWasSel
  XPO  = laData[1]
  XVEN = laData[2]
ELSE
  XVEN = SPACE(8)
  xPo  = SPACE(6) 
ENDIF  

IF llOpnApVen
  SELECT ApVendor
  USE
ENDIF

SELE POFHDR

IF !EMPTY(lcStyOrder)
  SET ORDER TO TAG (lcStyOrder)
ELSE
  SET ORDER TO  
ENDIF  
IF llRetAlias
  SELECT (lcAlias)
ENDIF  
RETURN llWasSel


*:---------------------------------------------------------------------
*! Name      : POFBROW
*! Developer : Wael Aly Mohamed 
*! Date      : 05/04/97
*! Purpose   : Function to browse material POS
*: Job ID    : E300637,1
*:---------------------------------------------------------------------
*: Calls              : gfDialog,AriaBrow
*:---------------------------------------------------------------------
*: Passed Parameters  : lcPOType : PO Type
*:                      lcVendor : Vendor
*:                      lcPo     : PO#
*:---------------------------------------------------------------------
*: Example            : =POFBROW('P',@lcVendor,@lcPo)
*:---------------------------------------------------------------------
FUNCTION POFBROW
PARAMETER lcPOType,lcVendor,lcPo
PRIVATE lcBrFields,lcAlias,laData,llRetValue,lcPOOrder


lcAlias = ALIAS()
SELECT POFHDR
lcOldFilt = FILTER()
SET FILT TO
DO CASE
  CASE lcPOType= 'P'
    lcTitle  = 'Material Purchase Orders'
  CASE lcPOType= 'C'
    lcTitle  = 'Material Purchase Order Contracts'
  CASE lcPOType= 'R'
    lcTitle  = 'Material Purchase Order Returns'
ENDCASE
lcPOOrder = ORDER('POFHDR')
lcVendor  = IIF(TYPE('lcVendor')='C' .AND. !EMPTY(lcVendor),lcVendor,'')
lcPo      = IIF(TYPE('lcPo')='C',lcPo,SPACE(6))
SET ORDER TO TAG IIF(EMPTY(lcVendor),'POFHDR','POFHDRV') IN POFHDR
IF !SEEK(lcVendor+lcPOType,'POFHDR')
  =gfDialog ("I","No "+lcTitle+' found'+IIF(EMPTY(lcVendor),'',' for vendor '+lcVendor)+'.')
  lcVendor = SPACE(8)
  lcPo     = SPACE(6)
  SELECT POFHDR
  SET FILTER TO &lcOldFilt 
  SET ORDER TO TAG lcPoOrder IN POFHDR
  IF !EMPTY(lcAlias)
     SELECT (lcAlias)
  ENDIF  

  RETURN(.F.)
ENDIF
DECLARE laBrow[2]
laBrow=' '
lcBrFields = "POMAT   :R :H='P/O #':8,"+;
             "Status  :R :H='S':2,"+;	         	           	         
             "Vendor  :R :H='Vendor':10,"+;
	         "ApVendor.cVenComp :R :H='Name':18,"+;
	         "Complete:R :H='Complete':8,"+;
  	         "NFABORDER  :R :H='Tot.Qty.':7,"+;	         
             "POTotal :R :H='Amount':10,"+;
             "NFBRECEIVE :R :H='Receive':7,"+;
             "NPO_OPEN   :R :H='Open':7"
llOpnApVen = gfOpenFile(gcDataDir+'ApVendor',gcDataDir+'VenCode','SH')
CLEAR TYPEAHEAD
SELECT POFHDR
SET RELATION TO Vendor INTO ApVendor
=SEEK(lcVendor+lcPOType)
llRetValue = gfBrows('lcVendor+lcPOType',"PoMat,Vendor","laBrow",lcTitle)
IF llRetValue
  lcPo     = laBrow[1]
  lcVendor = laBrow[2]
ELSE
  lcPo     = SPACE(6)
  lcVendor = SPACE(8) 
ENDIF  
IF llOpnApVen
  USE IN ApVendor
ENDIF
SET FILTER TO &lcOldFilt 
SET ORDER TO TAG lcPoOrder IN POFHDR
IF !EMPTY(lcAlias)
  SELECT (lcAlias)
ENDIF  
RETURN llRetValue
**************************************************************


*!***************************************************************
* PROG: POSBROW
* DESC: PROGRAM TO BROWSE THE STYLE PURCHASE ORDER
* PARA: THE PO AND VENDOR IS PASSED AS A PARAMETER
*
*PARAMETER :lcAType='P' for p/o,
*                   'R' for return po
*                   'C' for contract
*--------------------------------------------------------------
*E300838,1 TAK 04/12/98 Added Inter Location P/o.
*                   'N' for Inter Location P/O. 
*  lcVen - >  will hold the source location insted of vendor.
*!***************************************************************
PROCEDURE POSBROW
PARAMETER lcPO,lcVEN,lcAType
PRIVATE lcBrFields,lcAlias,lcVenCode,laPData
DECLARE laPData[2] && array to get values from browse
laPData=' '
*E301291,4 AMM  Adjust title to fit adornment and dye order
*lcTitle  = IIF(lcAType='R','Return Purchase Orders',;
           IIF(lcAType='C','Contracts','Style Purchase Orders'))
lcTitle  = IIF(lcAType='R','Return Purchase Orders',;
           IIF(lcAType='C','Contracts',IIF(lcAType='D','Dye Purchase Order',;
           IIF(lcAType='A','Adornment Purchase Order','Style Purchase Orders'))))
*E301291,4 AMM end
*E300838,1 TAK 04/12/98
lcTitle  = IIF(lcAType='N','Inter Location Purchase Orders',lcTitle)

lcPOType = IIF(lcAType='R','Return P/O',IIF(lcAType='C','Contract','P/O '))
lcVenCode=IIF(!EMPTY(lcVen),PADR(lcVen,8)+lcAType,lcAType)

lcAlias  = ALIAS()   && Save the current alias.
*E301291,4 AMM Add new type "A" for adornment order
*IF lcAType <> 'N'
IF !(lcAType $ 'NA')
*E301291,4 AMM end
  *--Open the vendor file if not opened.
  =gfOpenFile(gcDataDir+'APVENDOR','Vencode','SH')
  llApLink = (gfGetMemVar('M_ApLink',gcAct_Comp)='Y')
  lcApDir  = ALLTRIM(gfGetMemVar('M_ApLink',gcAct_Comp))
ENDIF

*E300838,1 TAK 04/12/98 Browse location insted of vendor in Int.Comp P/O.
*E301291,4 AMM Adjust to fit adornment order as inter location PO
*B604526,1 AMH Adding the Enetered date field to the browse [Start]
*lcBrFields =   [PO        :R :H=lcPOType+' #':8,]+;
  	           [Status    :R :H='S':2,]+;
               [Vendor    :R :H=IIF(lcAType$'NA','Source Loc.','Vendor'):11,]+;
               [lcVnName = IIF(lcAType$'NA',WAREHOUS.cDesc,ApVendor.cVenComp) :R :H='Name':18,]+;
	           [Complete  :R :H='Complete':8,]+;
  	           [nStyOrder :R :H='Tot.Qty.':7,]+;
               [POTotal   :R :H='Amount':10,]+;
               [Receive   :R :H='Receive':7,]+;
               [Open      :R :H='Open':7]

lcBrFields =   [PO        :R :H=lcPOType+' #':8,]+;
  	           [Status    :R :H='S':2,]+;
               [Vendor    :R :H=IIF(lcAType$'NA','Source Loc.','Vendor'):11,]+;
               [lcVnName = IIF(lcAType$'NA',WAREHOUS.cDesc,ApVendor.cVenComp) :R :H='Name':18,]+;
	           [Entered   :R :H='Entered':10,]+;
	           [Complete  :R :H='Complete':10,]+;
  	           [nStyOrder :R :H='Tot.Qty.':7,]+;
               [POTotal   :R :H='Amount':10,]+;
               [Receive   :R :H='Receive':7,]+;
               [Open      :R :H='Open':7]
*B604526,1 AMH [End]


SELECT POSHDR
IF !EMPTY(lcVen)
  SET ORDER TO TAG POSHDRV
  IF !SEEK (lcVenCode)
    = gfDialog ("I","There are no "+lcPOType+"s for this "+IIF(lcAType='N','location','vendor')+" on the file....!")
    lcVEN = SPACE(8)
    lcPO  = SPACE(6) 
    GO TOP
    SET ORDER TO TAG POSHDR
    RETURN .F.
  ENDIF
ELSE
  SET ORDER TO TAG POSHDR
  IF !SEEK(lcAType)
    = gfDialog ("I","There are no "+lcPOType+"s on the file....!")
    lcVEN = SPACE(8)
    lcPO  = SPACE(6) 
    GO TOP
    RETURN .F.
  ENDIF
ENDIF  
SELECT POSHDR
lcPosRel = SET('RELATION')
*E301291,4 AMM Add the new type "A" for adornment order
*IF lcAType = 'N'
IF lcAType $ 'NA'
*E301291,4 AMM end
  SET RELATION TO PADR(Vendor,6) INTO WareHous
ELSE
  SET RELATION TO Vendor INTO APVendor
ENDIF
llWasSel=gfBrows([lcVenCode],"Po,Vendor","laPData",lcTitle)
SET RELATION TO &lcPosRel
IF llWasSel
  lcPO  = laPData[1]
  lcVEN = laPData[2]
ELSE
  lcVEN = SPACE(8)
  lcPO  = SPACE(6) 
ENDIF  

SELECT POSHDR
SET ORDER TO TAG POSHDR
RETURN llWasSel



********************************************************************************
* PROG: PRT_NOTE
* DESC: PRINT NOTEPADS
* DATE: 11/17/90
* PARA:              1=>    XTYPE   = A -> CUSTOMER
*                                     B -> ORDERS
*                    2=>    XKEY      EX: XACCOUNT, XORDER....
* VARIABLES THAT HAVE TO BE INITIALIZED
*                    1=>    XTITLE  = TITLE OF THE REPORT OR FORM
*                    2=>    XREPORT = PROGRAM NAME
*                    3=>    R_TITLE = STANDARD REPO NAME
*                    4=>    R_WIDTH = 'W'-> WIDE
*                                     'N'-> NARROW
*                    5=>    ROW     = CURRENT ROW POSITION
*                    6=>    PAGENO  = PAGE NUMBER
*
* CALL: RPT_HDR IF IT IS A REPORT
* MODI: 12/22/92  OHR - Add option to exit if there is a spacebar press
*                       because the program is now also called from the screen
*       04/17/93  FAR - Added the check to see if '*' is the first character
*                       then skip over this line i.e. do not print it.
******************************************************************************
PROCEDURE PRT_NOTE

PARAMETER XTYPE,XKEY
PRIVATE lnAlias, lnMemoWdth, lnMemoLnNo, lnMemolins
WAIT CLEAR
lnAlias = SELECT()
*E300637,1 Use the new global variables names
*IF !USED('NOTEPAD')
*  SELECT 0
*  DO NETUSE WITH '&QDD.NOTEPAD','&QDD.NOTEPAD','SH'
*ENDIF
=gfOpenFile(gcDataDir+'NOTEPAD',gcDataDir+'NOTEPAD','SH')
*E300637,1 (End)
SELECT NOTEPAD

IF SEEK (XTYPE+XKEY)
  lnMemoWdth = SET('MEMOWIDTH')
  SET MEMOWIDTH TO 75
  lnMemoLnNo = 0      
  lnMemolins = 0
  IF ROW > 55
    PAGENO = PAGENO + 1
    DO RPT_HDR WITH XREPORT,XTITLE,R_WIDTH
    ROW = 5
  ENDIF
  
  *@ ROW,00 SAY REPLICATE('|',80 )    &&B800184,1 MFM 09/26/95 Commeted out.
  *ROW = ROW + 1                      &&B800184,1 MFM 09/26/95 Commeted out.
  
  lnMemolins = MEMLINES(mNotes)
  IF lnMemolins > 0
    *B800184,1 MFM 09/26/95 (Begin) Moved to be printed under condition 
    *B800184,1 MFM 09/26/95 that thire is line in the notpad.
    @ ROW,00 SAY REPLICATE('|',80 )
    ROW = ROW + 1
    *B800184,1 MFM 09/26/95 (End).

    DO WHILE lnMemoLnNo <> lnMemolins .AND. INKEY() <> 32
      IF ROW > 55
        PAGENO = PAGENO + 1
        DO RPT_HDR WITH XREPORT,XTITLE,R_WIDTH
        ROW = 5
      ENDIF
      lnMemoLnNo = lnMemoLnNo + 1
      IF SUBSTR(MLINE(mNotes,lnMemoLnNo),1,1) = '*'
        LOOP
      ENDIF
      @ ROW,00 SAY '|'+MLINE(mNotes,lnMemoLnNo)
      ROW = ROW + 1
    ENDDO
    *B800184,1 MFM 09/26/95 (Begin) Moved to be printed under condition 
    *B800184,1 MFM 09/26/95 that thire is line in the notpad.
    @ ROW,00 SAY REPLICATE('|',80 )
    ROW = ROW + 1
    *B800184,1 MFM 09/26/95 (End).

  ENDIF
  *@ ROW,00 SAY REPLICATE('|',80 )    &&B800184,1 MFM 09/26/95 Commeted out.
  *ROW = ROW + 1                      &&B800184,1 MFM 09/26/95 Commeted out.
  SET MEMOWIDTH TO (lnMemoWdth)
ENDIF

SELECT (lnAlias)
RETURN
**************************************************************************
* PROG: VIEWNOTE
* DATE: 02/24/93
* DESC: PROGRAM TO VIEW A TEXT FILE ( EX: THE RELEASE NOTES)
**************************************************************************

XFILE = gpGetFile('DOC','Select the latest release file','Select')

IF EMPTY(XFILE)
  RETURN
ENDIF


DEFINE WINDOW WNOTES FROM 00,00 TO 24,79 ;
              TITLE 'Release notes, <Esc> to exit'

MODI FILE &XFILE  NOEDIT WINDOW WNOTES

RELE WINDOW WNOTES

RETURN

*!-----------------------------------------------------------------------------
*! PROG: CUTBROW               VERSION :  AAS 2.5        03/06/94 
*! DESC: PROGRAM TO BROWSE THE CUTTING TICKETS
*! DATE: 04/27/91
*! PARA: THE CUTTKT # AND THE STYLE ARE PASSED
*! MODI: 03/11/93 RAA
*!                1) CHANGE INDEX IF FOXPRO VERSION 2.0
*!----------------------------------------------------------------------
*!       MFM 03/06/94
*!       ARH 06/14/94 :
*!           1) Decreased the style # from 15 chrs. to 12 chrs.
*****************************************************************************
PROCEDURE CUTBROW
PARAMETER lcParaCuTkt, lcParaStyle, lcForExpr

lnOldAlias = SELECT()
SELECT CUTTKTH
SET ORDER TO CUTTKTH

IF RECCOUNT() = 0
  = gfDialog ("I","There are no cutting tickets on file.")
  lcParaCuTkt = SPACE(6 )
  lcParaStyle = SPACE(12)           
  XCUTTKT     = SPACE(6)
  XSTYLE      = SPACE(12)           
  RETURN
ENDIF

lcForExpr = IIF(TYPE('lcForExpr')='C',' FOR '+ lcForExpr,'')

IF EMPTY(lcParaStyle)
  IF !SEEK(TRIM(lcParaCuTkt),'CUTTKTH')
    IF RECNO(0)=0
      GO TOP
    ELSE
      GO RECNO(0)
    ENDIF
  ENDIF
ELSE
  SELECT CUTTKTH
  SET ORDER TO CUTTKTHS       && Index by style
  IF !SEEK(lcParaStyle,'CUTTKTH')
    =gfDialog('I','There are no cutting tickets for this style.')
    lcParaCuTkt = SPACE(6)
    lcParaStyle = SPACE(12)               
    XCUTTKT     = SPACE(6)
    XSTYLE      = SPACE(12)           
    RETURN
  ENDIF
ENDIF

DECLARE laValues[1]  && array to get values from browse
lcFile_Ttl = 'Cutting Tickets'
lcBrFields = "CutTkt  :H='Cutkt'   ,"+;
             "Style   :H='Style'   ,"+;
             "Status  :H='S'       ,"+;
             "Entered :H='Issue'   ,"+;
             "Complete:H='Complete',"+;
             "Season  :H='Se'      ,"+;
             "cDivision:H='Di'     ,"+;
             "Pcs_Bud :H='Budget':P='999999',"+;
             "Pcs_Rec :H='Recvd' :P='999999',"+;
             "Pcs_Dam :H='Damged':P='999999',"+;
             "Pcs_Opn :H='Open'  :P='999999' "

=ARIABROW(IIF(EMPTY(lcParaStyle),lcForExpr,'lcParaStyle '+ lcForExpr),lcFile_Ttl,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','','CutTkt','laValues')
lcParaCuTkt = IIF(EMPTY(laValues[1]),SPACE(6),laValues[1])
XCUTTKT     = lcParaCuTkt
SELECT (lnOldAlias)

*!*****************************************************************
*! Name : gfBrowWare.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 04/17/94.
*!*****************************************************************
*! Synopsis : Browse the warehouse file.
*!*****************************************************************
*! Passed :
*!        Parameters : 
*!         llIsEscape: If the escape is allowed.
*!
*!******************************************************************
*! Files      : WareHous.DBF should be opend.
*!******************************************************************
*! Returned : 
*!        VARIABLES : 
*!        lcWareCode : The warehouse code that will be selected
*!                     if it's empty it means that the user did
*!                     not select anything.
*!******************************************************************
*! Example :
*!        =gfBrowWare(.T.)
*!******************************************************************
*! Calls : lpSelOnEnt 
*!******************************************************************
*! Modifications :
*!   - RENEE 05/16/1995 Changed the function so as to have
*!     a browse in a window
*B600441,1 RENEE 06/15/95. Fix the problem of the browse window being
*B600441,1                 right shifted. 
*N16,5     RENEE 08/01/95  Updated gfBrowWare so as to browse the
*N16,5                     warehouses that contain a specific
*N16,5                     style(or fabric) color.
*E300511,4 Reham On 08/04/97
*E300511,4 Remove the color from the warehouse browse for styles.
*B603670,1 (Begin) Add a parameter to gfBrowWare to enable its caller to browse either 
*B603670,1         Finished goods inventroy or Material inventory or both.
*!******************************************************************
FUNCTION gfBrowWare
*N16,5 Add parameters and private variables.
*B603670,1 (Begin) Add the parameter. (S to browse Finished goods inventory, T to Material inventory,.F. for both)
*PARAMETERS llIsEscape, lcItem, lcColor, lcWareCode, lcSrcFile
PARAMETERS llIsEscape, lcItem, lcColor, lcWareCode, lcSrcFile,lcStyMatIn
*B603670,1 (End)
PRIVATE lcBrWinName, lcBrTtl, lcWareCode, lcItem, lcColor, lcForCond;
        lnCurAlias, lnCurTag, lnWinWidth, lnWinHight, llEntered
*N16,5 end.

GO TOP IN WareHous
IF EOF('WareHous')
  = gfDialog ('I','No locations found.')
  *N16,5 Return space(6), not .t.
  RETURN SPACE(6)
  *N16,5 end.
ENDIF

*-- Save the current alias.
lnCurAlias = SELECT()

SELECT WAREHOUS
lnCurTag    = VAL(SYS(21))
SET ORDER TO TAG WAREHOUS

*N16,5 If called from browsing the warehouses of a specific item/color
IF !EMPTY(lcSrcFile)
  lcColor     = IIF(EMPTY(lcColor), SPACE(6), lcColor)
  lcWareCode  = IIF(EMPTY(lcWareCode), SPACE(6), lcWareCode)
  IF UPPER(ALLTRIM(LEFT(lcSrcFile,1))) = 'S'
    lcSrcFile = 'STYDYE'
    lcItem    = IIF(EMPTY(lcItem), SPACE(12), PADR(lcItem,12))
    lcFld     = 'Style'
    *E300511,4 Reham On 08/04/97  ** Begin **
    *E300511,4 Remove the color from the warehouse browse for styles.
    *lcTMsg    = 'Style/Color '
    lcTMsg    = 'Style ' 
    llFound   = .F.
    *IF SEEK(lcItem + lcColor , lcSrcFile)
    IF SEEK(lcItem , lcSrcFile)
      SELECT (lcSrcFile)
      *LOCATE REST FOR EMPTY(Dyelot) WHILE &lcFld + Color = lcItem + lcColor
      LOCATE REST FOR EMPTY(Dyelot) WHILE &lcFld = lcItem 
      llFound = FOUND()
    ENDIF  
    IF !llFound
      =gfDialog ('I', lcTMsg + ALLTRIM(lcItem) + ' is not asssigned to any location.')
      SET ORDER TO lnCurTag IN WAREHOUS
      SELECT (lnCurAlias)
      RETURN SPACE(6)
    ENDIF
    SELECT WAREHOUS
    *SET RELATION TO lcItem + lcColor + cWareCode + SPACE(10) INTO (lcSrcFile) ADDITIVE
    SET RELATION TO lcItem + cWareCode + SPACE(10) INTO (lcSrcFile) ADDITIVE
    *E300511,4 Reham On 08/04/97  ** End   **
  ELSE
   lcSrcFile = 'FABDYE'
   lcItem    = IIF(EMPTY(lcItem), SPACE(7), PADR(lcItem,7))   
   lcFld     = 'Fabric'
   lcTMsg    = 'Item/Color ' 
   llFound   = .F.
   IF SEEK(lcItem + lcColor , lcSrcFile)
     SELECT (lcSrcFile)
     LOCATE REST FOR EMPTY(Dyelot) ;
            WHILE &lcFld + Color = lcItem + lcColor
     llFound = FOUND()
   ENDIF  
   IF !llFound
     =gfDialog ('I', lcTMsg + ALLTRIM(lcItem) + '/' + ALLTRIM(lcColor) + ;
                ' is not asssigned to any location.')
     SET ORDER TO lnCurTag IN WAREHOUS
     SELECT (lnCurAlias)
     RETURN SPACE(6)
   ENDIF
   SELECT WAREHOUS
   SET RELATION TO lcItem + lcColor + cWareCode + SPACE(10) ;
                INTO (lcSrcFile) ADDITIVE
  ENDIF   
  lcForCond   = 'FOR !EOF(lcSrcFile)'
ELSE
  lcWareCode = SPACE(6)  
  lcForCond  = ''
ENDIF  
*N16,5 end.

lcBrWinName = gfTempName()
lcBrTtl     = 'Locations'

IF _DOS .OR. _UNIX
  lnWinWidth = 41
  lnWinHight = 12
ELSE
  *E300825,1 Increase window width to be compatable with ms Sans Serif font.
  *lnWinWidth = 45
  lnWinWidth = 60
  *E300825,1 Increase window width to be compatable with ms Sans Serif font.
  lnWinHight = 20
ENDIF  

*B600441,1 Define window at the top left corner.
*DEFINE WINDOW (lcBrWinName);
       AT 0, 0 SIZE lnWinHight, lnWinWidth;
       FONT "FoxFont", 9 ;
       FLOAT ;
       NOCLOSE ;
       SHADOW ;
       NOMINIMIZE ;
       SYSTEM ;
       COLOR SCHEME 10  	   
*E300825,1 Redefine warehouse window to support arabic entries. [begin]
DEFINE WINDOW (lcBrWinName);
       AT 0, 0 SIZE lnWinHight, lnWinWidth;
       FONT "MS Sans Serif", 9 ;
       FLOAT ;
       NOCLOSE ;
       SHADOW ;
       NOMINIMIZE ;
       SYSTEM ;
       COLOR SCHEME 10  	   
*B300825,1 Redefine warehouse window to support arabic entries. [end]
MOVE WINDOW (lcBrWinName) CENTER
*B600441,1 end.
*B603670,1 (Begin) Add the parameter condition.
IF TYPE('lcStyMatIn')='C' AND lcStyMatIn $ 'SM'
  lcMatOrSty = IIF(UPPER(lcStyMatIn) = 'S','FOR lStyInv','FOR lMatInv')
  lcForCond  = lcForCond +IIF(EMPTY(lcForCond),'',' AND ') + lcMatOrSty
ENDIF
*B603670,1 (End)
llEntered = .F.
PUSH KEY
ON KEY
ON KEY LABEL ENTER DO lpSelOnEnt WITH lcBrTtl, llEntered
DO WHILE .T. 
  *N16,5 Added a for condition, if required. (lcForCond)
  BROWSE FIELDS cWareCode:H='Location',;
                cDesc    :H='Description';
         &lcForCond;       
         WINDOW (lcBrWinName);
         LOCK 0;
         NOMENU;         
         NOAPPEND;
         NOEDIT;
         NODELETE;
         TITLE lcBrTtl
  *N16,5 end.
         
  IF !llIsEscape .AND. !llEntered
    =gfDialog('I', 'You have to select a location.')
    SELECT WAREHOUS     
    LOOP
  ELSE
    EXIT
  ENDIF     
ENDDO
RELEASE WINDOW (lcBrWinName)
lcWareCode = IIF(llEntered, cWareCode, SPACE(6))

*N16,5 Reset relation, if any
IF !EMPTY(lcSrcFile)
  SET RELATION OFF INTO (lcSrcFile)
ENDIF  
*N16,5 end.

SET ORDER TO lnCurTag IN WAREHOUS
*SET ORDER TO lnCurTag
SELECT (lnCurAlias)
POP KEY
RETURN (lcWareCode)


*:************************************************************************
*: Program file  : lpSelOnEnt
*: Program desc. : Selects a code upon presssing ENTER in CodeChk browse
*: For screen    :
*:         System: 
*:         Module: Aria Apparel System
*:      Developer: Renee Ezzat
*:************************************************************************
*: Example :
*:        ON KEY LABEL ENTER DO lpSelOnEnt
*:*************************************************************
PROCEDURE lpSelOnEnt
PARAMETERS lcBrName, llExit

ON KEY

*B600480,1 YI on 06/20/95 save the selected record number
IF TYPE('lnSelRec')='N'
  lnSelRec = RECNO()
ENDIF

DEACTIVATE WINDOW  (lcBrName)
llExit = .T.

*!*************************************************************
*! Name : gpAdStyWar
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 05/03/94.
*!         
*! Synopsis : Add a new record to the StyDye file.
*! 
*! Passed :
*!        Parameters : 
*!          lcPStyle : The style.   
*!          lcPColor : The color.
*!          lcPDyelot: The Dyelot.
*!          lcPWare  : The Warehouse.
*!        Files      : The StyDye File should be opened.
*!                     The WareHouse File should be opened.
*! 
*! Returned : 
*!        Files      : The StyDye File after appending the new record.
*! 
*! Example :
*!        DO gpAdStyWar WITH lcStyle,lcColor,SPACE(10),lcWareCode
*! 
*! Modifications :
*!      YMA 09/07/94
*!          1) Added the saving of the cost field.
*B600331,1 YMA 05/30/95 Fixed a bug of saving the "Ave_Cost" field
*B600331,1 in case of adding a dyelot record using this procedure.
*E300511,4 Reham On 08/04/97
*E300511,4 Remove the color from the function.
*C102051,1 ABD 11/30/2000 Add new replace filed in procedure gpAdStyWar 
*C102051,1 ABD            when add new style on warehouse
*C102051,1 ABD            In stydye file.
*!*************************************************************

PROCEDURE gpAdStyWar

*E300511,4 Reham On 08/04/97  ** Begin **
*E300511,4 Remove the color from the function.
*PARAMETERS lcPStyle, lcPColor, lcPDyelot, lcPWare
PARAMETERS lcPStyle, lcPDyelot, lcPWare
*E300511,4 Reham On 08/04/97  ** End   **

*C102051,1 ABD add new variable hold cDiscCode. [Begin]
*PRIVATE lcDesc, lcAlias, lnCost
PRIVATE lcDesc, lcAlias, lnCost , lcDiscCods
*C102051,1 ABD [End]

*-- MFM 05/30/94.
lcAlias = ALIAS()

SELECT STYLE
*E300511,4 Reham On 08/04/97  ** Begin **
*E300511,4 Remove the color from the seek condition.
*IF SEEK (lcPStyle+lcPColor)
IF SEEK (lcPStyle)
*E300511,4 Reham On 08/04/97  ** End   **
  lcDesc = Desc
  lnCost = Ave_Cost                            && YMA 09/07/94
  *C102051,1 ABD add new variable hold cDiscCode. [Begin]  
  lcDiscCods  = cDiscCode
  *C102051,1 ABD [End]

  *B607113,1 KHM 06/23/2003 (Begin) Getting the gl link code from the style file.
  lcGlCode = Link_Code
  *B607113,1 KHM 06/23/2003 (End)
  
ELSE
  lcDesc = SPACE(20)
  lnCost = 0                                   && YMA 09/07/94
  *C102051,1 ABD add new variable hold cDiscCode. [Begin]
  lcDiscCods  = cDiscCode  
  *C102051,1 ABD [End]    

  *B607113,1 KHM 06/23/2003 (Begin) initializing lcGlCode with space
  lcGlCode = ""
  *B607113,1 KHM 06/23/2003 (End)

ENDIF

*B600289,1 YI we need a new relation into the warehouse file
*B600289,1 and the style journal
llSTYDYE   = .F.
llSTYINVJL = .F.

IF !USED('STYDYE')
  llSTYDYE   = .T.
  *E300637,1 Use the new global variables names.
  *=gfOpenFile(QDD+'STYDYE' ,QDD+'STYDYE' ,'SH')
  =gfOpenFile(gcDataDir+'STYDYE',gcDataDir+'STYDYE','SH')
  *E300637,1 (End)
ENDIF
 
IF !USED('STYINVJL')
  llSTYINVJL = .T.
  *E300637,1 Use the new global variables names.
  *=gfOpenFile(QDD+'STYINVJL' ,QDD+'STYINVJL' ,'SH')
  =gfOpenFile(gcDataDir+'STYINVJL',gcDataDir+'STYINVJL','SH')
  *E300637,1 (End)
ENDIF

SELECT STYDYE
SET RELATION TO

*E300511,4 Reham On 08/04/97  ** Begin **
*E300511,4 Remove the color from the relation.
*SET RELATION TO style+color+cwarecode INTO STYINVJL ADDITIVE
SET RELATION TO style+cwarecode INTO STYINVJL ADDITIVE
*E300511,4 Reham On 08/04/97  ** End  **

SELECT STYLE
SET RELATION TO

*E300511,4 Reham On 08/04/97  ** Begin **
*E300511,4 Remove the color from the relation.
*SET RELATION TO style+color INTO STYDYE ADDITIVE
SET RELATION TO style INTO STYDYE ADDITIVE
*E300511,4 Reham On 08/04/97  ** End   **


*--Added by TAK 12/07/94
*E300637,1 Use the new global variables names
*IF ! USED('WareHous')
*  SELECT 0
*  DO NETUSE WITH '&QDD.WareHous','&QDD.WareHous','SH'
*ENDIF
=gfOpenFile(gcDataDir+'WareHous',gcDataDir+'WareHous','SH')
*E300637,1 (End)
*--

SELECT WareHous
*E300637,1 Use the new default link code
*lcGlCode = IIF(SEEK(lcPWare),GL_LINK,'DEF')
*B607113,1 KHM 06/23/2003 (Begin) Check if there is no gl link code in the style file assing DEFDEF
*lcGlCode = IIF(SEEK(lcPWare),GL_LINK,'DEFDEF')
lcGlCode = IIF(EMPTY(lcGlCode),'DEFDEF',lcGlCode)
*B607113,1 KHM 06/23/2003 (End)
*E300637,1 (End)

*B601257,1 TAK 09/12/96 Start Added.

*E300637,1 Followinf lines are commented out
*RESTORE FROM AdPara&qSysCode ADDIT
*llGlLink = (M_LINK_GL = 'Y')
*RELEASE ALL LIKE M_*
*IF llGlLink
*  *-- Call the screen only if empty dyelot.
*  IF EMPTY(lcPDyelot)
*    *E300637,1 Use the new global variables names
*    *llOpnUsed = gfOpenFile(qDD+'GL_LINK', qDD + 'GL_LINK1','SH')
*    llOpnUsed  = gfOpenFile(gcDataDir+'GL_LINK',gcDataDir+'GL_LINK1','SH')
*    *E300637,1 (End)
*    lcGlCode = SPACE(3)
*    *E300637,1 Use the new global variables names
*    *DO (QSD+"GL_LINK.SPX") WITH '02', lcGlCode, '', .T.
*    DO (gcScrDir+"GL_LINK.SPX") WITH '02', lcGlCode, '', .T.
*    *E300637,1 (End)
*    IF llOpnUsed
*      USE IN GL_LINK
*    ENDIF
*  ENDIF
*ENDIF
*E300637,1 (End)

*B601257,1 TAK 09/12/96 End.

SELECT StyDye
APPEND BLANK
*E300511,4 Reham On 08/04/97  ** Begin **
*E300511,4 Remove the color from the replace command.
*E300511,4 REPLACE Color WITH lcPColor
*C102051,1 ABD 11/30/2000 Add new replace filed when add new style on warehouse
*C102051,1 ABD            when add new style on warehouse In stydye file. [Begin]
*REPLACE Style      WITH lcPStyle  ,;
        Desc       WITH lcDesc    ,;
        Dyelot     WITH lcPDyelot ,;
        cWareCode  WITH lcPWare   ,;
        Ave_Cost   WITH IIF(EMPTY(Dyelot),lnCost,0) ,;
        GL_Link    WITH lcGlCode  ,;
        dAdd_Date  WITH gdSysDate ,;
        cAdd_Time  WITH TIME()    ,;
        cAdd_User  WITH gcUser_ID

REPLACE Style      WITH lcPStyle  ,;
        Desc       WITH lcDesc    ,;
        cDiscCode  WITH lcDiscCods,;
        Dyelot     WITH lcPDyelot ,;
        cWareCode  WITH lcPWare   ,;
        Ave_Cost   WITH IIF(EMPTY(Dyelot),lnCost,0) ,;
        GL_Link    WITH lcGlCode  ,;
        dAdd_Date  WITH gdSysDate ,;
        cAdd_Time  WITH TIME()    ,;
        cAdd_User  WITH gcUser_ID
*C102051,1 ABD [End]        
*E300511,4 Reham On 08/04/97  ** End   **

= gfTraceKey("STYDYE",Style+cWareCode+Dyelot,"A")

*C200171 TMI [Start] Gen Upcs in EDICATGD
*-- Run if EDI installed
IF OCCURS('NC',gcCmpModules)<>0
  lcWhCode   = lcPWare
  lcSty      = lcPStyle
  llFrmAdWre = .T.
  =gfDoTriger('ICSTYLE','GNUPCWH   ')
ENDIF
*C200171 TMI [End  ] Gen Upcs in EDICATGD


*B600289,1 YI Update the warehouse records with the new cose

IF !EOF('STYDYE') .AND. EOF('STYINVJL')
  SELECT STYDYE
  *B601259,1 ASH 12/04/96 (Begin) Don't save the ave_cost in style dyelot record.
  *REPLACE REST WHILE STYLE = STYLE.STYLE .AND. ;
                     COLOR = STYLE.COLOR       ;
          AVE_COST WITH STYLE.AVE_COST
  *E300511,4 Reham On 08/04/97  ** Begin **
  *E300511,4 Remove the color condition from the replace command.
  *REPLACE REST WHILE STYLE = STYLE.STYLE .AND. ;
  *                   COLOR = STYLE.COLOR       ;
  *        AVE_COST WITH IIF(EMPTY(Dyelot),STYLE.AVE_COST,0)
  REPLACE REST WHILE STYLE = STYLE.STYLE ;
          FOR gfTraceKey("STYDYE",Style+cWareCode+Dyelot,"M") ;
          AVE_COST WITH IIF(EMPTY(Dyelot),STYLE.AVE_COST,0)
  *E300511,4 Reham On 08/04/97  ** End   **
*B601259,1 ASH 12/04/96 (End)
ENDIF                   

SELECT STYDYE
SET RELATION TO

SELE STYLE
SET RELATION TO

*-- Close files
IF llSTYDYE
  USE IN STYDYE
ENDIF

IF llSTYINVJL
  USE IN STYINVJL
ENDIF

*-- MFM 05/30/94.
IF !EMPTY(lcAlias)
  SELECT (lcAlias)
ENDIF


*!*************************************************************
*! Name : gpStDyBrow.
*!         
*! Synopsis : Browse the dyelots for a specific Style/Color at
*!            a specific warehouse. 
*!          
*! Passed :
*!        Parameters : 
*!           lcStyle : The active style.
*!           lcColor : The active color.
*!           lcWare  : The active warehouse.
*!           lcDyelot: The dyelot.
*!        Files      : StyDye,Style file should be opened.
*! 
*! Returned : 
*!        Parameters : 
*!          lcDyelot : The selected dyelot.
*! 
*! Example :
*!        DO gpStDyBrow WITH lcStyle,lcColor,lcFromWare,lcDyelot
*!*************************************************************
*E300433,1 TAK 07/20/96 Changed to work with screens in 2.7.
*B802448,1 AHM 07/20/99 Allow adding dyelot to warehouse
*B603236,1 SSH 20/10/99 Prevent Add new record for the warehouse
*B603236,1 SSH          unless this style not assigned on warehouse.
*!*************************************************************

PROCEDURE gpStDyBrow
*PARAMETER lcStyle,lcColor,lcWare,lcDyelot
PARAMETER lcStyle,lcWare,lcDyelot

llMultiWH  = gfGetMemVar('M_WareHouse')='Y'
lnAlias=SELECT()
SELECT STYLE
lnXSvRec=RECNO()
SELECT STYDYE
SEEK (PADR(lcStyle,19)+lcWare)
*B802448 (Start)
*LOCATE WHILE Style+cWareCode = PADR(lcStyle,19)+lcWare FOR !EMPTY(Dyelot)
= SEEK(PADR(lcStyle,19)+lcWare+lcDyelot)
*B802448 (End)
IF !FOUND()
  IF llMultiWH
    lcmesgx  = 'Style\Warehouse :'+ALLTRIM(lcStyle)+'\'+ALLTRIM(lcWare)
  ELSE
    lcmesgx  = 'Style :'+ALLTRIM(lcStyle)
  ENDIF
  
  *B802448 (Start)
  **--No Dyelots found for (lcmesgx).
  *=gfModalGen('TRM42053B42001','DIALOG',lcmesgx)
  *lcDyelot = SPACE(10)
  *RETURN

  lnChoice=gfModalGen('TRM42062B42003','DIALOG',ALLTRIM(lcStyle)+'|'+ALLTRIM(lcDyelot)+'|'+lcWare)
  IF lnChoice = 1
    *B603236,1 SSH 20/10/99 (BEGIN) Seek With the parameter.
    *IF !SEEK(PADR(lcStyle,19)+lcToWare+SPACE(10),'STYDYE')
    IF !SEEK(PADR(lcStyle,19)+lcWare+SPACE(10),'STYDYE')
    *B603236,1 SSH (END)
      DO gpAdStyWar WITH lcStyle,SPACE(10),lcWare
    ENDIF
    DO gpAdStyWar WITH lcStyle,lcDyelot,lcWare
    RETURN
  
  ELSE   
    IF lnChoice = 2
      *B603236,1 SSH 20/10/99 (BEGIN) Seek With the parameter.
      IF SEEK(PADR(lcStyle,19)+lcWare+SPACE(10),'STYDYE')
      *B603236,1 SSH (END)      
        LOCATE REST WHILE Style+cWareCode = PADR(lcStyle,19)+lcWare FOR !EMPTY(Dyelot)
        IF !FOUND()
          =gfModalGen('TRM42053B42001','DIALOG',lcmesgx)  
          lcDyelot = SPACE(10)
          RETURN
        ENDIF
      ENDIF
    ELSE
      lcDyelot = SPACE(10)
      _CUROBJ = _CUROBJ
      RETURN
    ENDIF
  ENDIF
  *B802448 (End)
ENDIF

IF STYLE.Style <> STYDYE.Style
  =SEEK(STYDYE.Style,'STYLE')
ENDIF
=SEEK('S'+STYLE.Scale,'SCALE')

lcBrfields = "Dyelot  :H='Dyelot#' ,"
FOR I=1 TO SCALE.Cnt
  Z=STR(I,1)
  lcString = "Stk"+Z+" :H='Stock&Z' ,"
  lcBrfields = lcBrfields + lcString
ENDFOR
lcBrfields = lcBrfields + "TotStk :H='TotStk',"

FOR I=1 TO SCALE.Cnt
  Z=STR(I,1)
  lcString = "Alo"+Z+" :H='Aloc.&Z',"
  lcBrfields = lcBrfields + lcString
ENDFOR
lcBrfields = lcBrfields + "TotAlo :H='TotAlo'"

lcDyelot = SPACE(10)
lcDyeKey = PADR(lcStyle,19)+lcWare
IF ARIABROW([lcDyeKey FOR !EMPTY(Dyelot) REST],' Style Dyelots ', gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2)
  lcDyelot = Dyelot
ENDIF

SELECT STYLE
GOTO lnXSvRec
SELECT(lnAlias)
RETURN

*!*************************************************************
*! Name : gfWareStls
*! Auth : Mohamed Fahmy Mohamed (MFM).
*! Date : 04/20/94.
*!          
*! Synopsis : Browse the style/clr for a certin warehouse.
*! 
*! Passed :
*!        Parameters : 
*!          lcWareHous : The Warehouse.
*!          lcStyle    : The style.   
*!          lcClr      : The color.
*! 
*! Returned : 
*!        Variables  : True if the user select or false if the user
*!                     ESC. from the browse.
*!                     The selected Style Color.
*! 
*! Example :
*!        =gfWareStls( lcWareHous, @lcStyle, @lcClr )
*! 
*! Screen layout :
*!    ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....
*!03  
*!04   STYLE        COLOR  DESCRIPTION      SI DI   PRICE   STOCK  ORDERS   O.T.S 
*!05  
*!06             
*!07             
*!08             
*!09             
*!..   123456789012 123456 123456789012345  12 12 1234567 1234567 1234567 1234567 
*!21  
*! 
*! Modifications :
*!      ARH 06/14/94 :
*!          1) Increased the color code to 6 chrs. instead of 3 chrs.
*!             and decreased the style # to be 12 chrs. instead of 15 chrs.
*!      YMA 07/04/94 :
*!          1) Changed the browse technique to use a temp. file instead
*!             of browsing the master StyDye file.
*!*************************************************************
FUNCTION gfWareStls

PARAMETERS lcWareHous, lcStyle, lcClr

*-- Save the current alias.
lcAlias = ALIAS()
SAVE SCREEN TO lsWareStls1

*-- Initialize the nedded variables.
llStatus   = .F.

*E300637,1 Use the new global variables names
*IF !USED( 'Style' )
*  SELECT 0
*  DO NetUse WITH '&qDD.Style', '&qDD.Style', 'SH'
*ENDIF
*IF !USED( 'StyDye' )
*  SELECT 0
*  DO NetUse WITH '&qDD.StyDye', '&qDD.StyDye', 'SH'
*ENDIF
=gfOpenFile(gcDataDir+'Style',gcDataDir+'Style','SH')
=gfOpenFile(gcDataDir+'StyDye',gcDataDir+'StyDye','SH')
*E300637,1 (End)

*-- YMA 07/04/94 Build the temp file.
tmpStDyBrw = TempName()
*E300637,1 Use the new global variables names
*SELECT * FROM     &qDD.StyDye                  ;
         WHERE    cWareCode = lcWareHous .AND. ;
                  Dyelot    = SPACE(10)        ;
         INTO DBF &qWD.&tmpStDyBrw
SELECT * FROM     &gcDataDir.StyDye            ;
         WHERE    cWareCode = lcWareHous .AND. ;
                  Dyelot    = SPACE(10)        ;
         INTO DBF &gcWorkDir.&tmpStDyBrw
*E300637,1 (End)
INDEX ON cWareCode+Style+Color+Dyelot TAG &tmpStDyBrw

*-- YMA 07/04/94 Check if there are no dyelots.
IF EOF()
  = gfDialog ('I', 'No style/colors are assigned to warehouse &lcWareHous')
  lcStyle  = SPACE (12)
  lcClr    = SPACE (06)
  SELECT (lcAlias)
  RESTORE SCREEN FROM lsWareStls1
  RETURN llStatus
ENDIF

*-- Draw the screen.
lcTitle = 'WAREHOUSE : ' + ALLTRIM( lcWareHous )
DO DrawBox WITH qClrMag, lcTitle, 03, 01, 21, 78
SET COLOR TO &qClrNrm
@ 22,00 CLEAR
SET COLOR TO &qClrMag
@ 04,03 SAY 'STYLE        COLOR  DESCRIPTION      SI DI   PRICE   STOCK  ORDERS   O.T.S'
@ 05,02 TO 05,77
*B800360,1 TMI 12/24/95 Added the next seek to indicate to the first
*B800360,1 TMI 12/24/95 color in the browse
IF !EMPTY(lcStyle) 
  IF !SEEK(lcWareHous+lcStyle)
    GO TOP
  ENDIF
ENDIF  
*B800360,1 TMI 12/24/95 (End)

DO WHILE .T.
  Row     = 06
  qRecNo  = 0
  SET COLOR TO &qClrMag
  @ 06,02 CLEAR TO 20,77
  SET COLOR TO &qClrSay

  *-- Put the information on the screen.
  SELECT &tmpStDyBrw               && YMA 07/04/94
  SCAN WHILE ROW < 21
    qRecNo[Row] = RECNO()
    @ ROW,03 SAY Style
    @ ROW,16 SAY Color
    IF SEEK(Style+Color, 'Style')
      @ ROW,23 SAY SUBSTR(Style.Desc ,1 ,15)
      @ ROW,40 SAY Style->Season
      @ ROW,43 SAY Style->cDivision
      @ ROW,46 SAY Style->PriceA    PICTURE '99999.9'
      @ ROW,54 SAY TotStk           PICTURE '9999999'
      @ ROW,62 SAY TotOrd           PICTURE '9999999'
      @ ROW,70 SAY TotStk - TotOrd  PICTURE '9999999'
    ENDIF  
    Row = Row + 1
  ENDSCAN

  *-- Setup the BP array.
  BP [1] = 06
  BP [2] = 02
  BP [3] = lcWareHous
  BP [4] = 23
  BP [5] = 79
  BP [6] = 'N'
  BP [7] = 'N'
  BP [9] = 'N'

  SET COLOR TO &qClrMag
  ThisKey = Brow()
  
  DO CASE 
    CASE ThisKey = qRetKey
      lcStyle  = Style
      lcClr    = Color
      llStatus = .T.
    CASE ThisKey = qEscKey  
      lcStyle  = SPACE(12)
      lcClr    = SPACE(06)
    OTHERWISE
      LOOP
  ENDCASE
  EXIT
ENDDO

SELECT (lcAlias)
RESTORE SCREEN FROM lsWareStls1

SELECT &tmpStDyBrw
ZAP
USE
*E300637,1 Use the new global variables names
*ERASE &qWd.&tmpFbDyBrw
ERASE &gcWorkDir.&tmpFbDyBrw
*E300637,1 (End)

RETURN llStatus

*-- EOF( gfWareStls )

*!*************************************************************
*! Name : gpClrBrow.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/12/94.
*! 
*! Synopsis : Browse the colors for the new entered Fabric/Style 
*!            or for the modified Fabric/Style.
*! 
*! Called from : 
*!         Procedures : Mat100.
*!                      Sty100.
*! 
*! Passed :
*!        Parameters : 
*!        lcFeldName : The master field name.
*!        lcMstrFile : The master file name.
*!        lcKey      : The key (Style\Fabric) in procces.
*!        lcTmpFile  : The color temp file name.
*!        llUseDel   : Flag to indecate either to use
*!                     the delete key or not.  
*! 
*! Returned : 
*!        Files      : The Color temp file is updated.
*! 
*! Screen layout :
*!...1....*....2....*....3....*....4....*....5....*....6....*..
*!03  
*!04   COLOR  DESCRIPTION     LONG DESCRIPTION               
*!05  
*!06      
*!..   123456 123456789*12345 123456789*123456789*123456789* 
*!..      
*!21    
*!...1....*....2....*....3....*....4....*....5....*....6....*..
*! 
*! Modification:
*!    TMI 09/18/94
*!        1) Made the screen in insert mode all the time until
*!           the user press "ESC" or "ENTER" to abort.
*!    YMA 01/22/95 
*!        1) Modified the color width according to the "cSyClr126"
*!           field in the control file.
*!    MFM 02/12/95
*!        1) Removed the '&qDD' FROM '&qDD.&lcMstrFile' to cover the style 
*!           copy feture.
*!    MFM 02/15/95
*!        1) Fixed bug of infinet traping in the browse when you exeed
*!           more than 1 page of entry.
*!*************************************************************
PROCEDURE gpClrBrow
PARAMETERS lcFeldName, lcMstrFile, lcKey, lcTmpFile, llUseDel

*-- YMA 01/22/95
RESTORE FROM ADPARA&QSYSCODE ADDIT
llColor6 = (M_Color6 ='Y')
RELEASE ALL LIKE M_*
*-- End YMA 01/22/95

IF !USED('&lcTmpFile')
  *-- MFM 02/12/95
  *-- Removed the '&qDD' FROM '&qDD.&lcMstrFile' to cover the style copy
  *-- feture.
  *E300637,1 Use the new global variables names
  *SELECT COLOR, 'S' AS cStatus         ;
         FROM     &lcMstrFile     ;
         WHERE    &lcFeldName = lcKey  ;
         INTO DBF &qWD.&lcTmpFile
  SELECT COLOR, 'S' AS cStatus         ;
         FROM     &lcMstrFile     ;
         WHERE    &lcFeldName = lcKey  ;
         INTO DBF &gcWorkDir.&lcTmpFile
  *E300637,1 (End)
  INDEX ON Color TAG &lcTmpFile
ENDIF  

Arrow      = 00
lnFirstRec = 00
llStayIns  = .F.
lnMaxRec   = 15
DO DRAWBOX WITH qClrBlk,'',03,11,21,67
SET COLOR TO &qClrBlk
@ 04,13 SAY 'COLOR  DESCRIPTION     LONG DESCRIPTION'
@ 05,12 TO 05,66

SELECT &lcTmpFile
GOTO TOP
llInsMode  = EOF('&lcTmpFile')

DO WHILE .T.
  SET COLOR TO &qClrBlk
  @ 06,12 TO 20,66 CLEAR
  Row     = 06
  lnTRow  = Row
  qRecNo  = 0

  SET COLOR TO &qClrSay
  SELECT &lcTmpFile
  SCAN WHILE Row <= 20
    qRecNo[Row] = RECNO()
    @ Row,13 SAY COLOR
    SELECT CODE
    SEEK 'C' + &lcTmpFile->COLOR
    @ Row,20 SAY IIF(Found(), cData   , '**** ERROR ****')
    @ Row,36 SAY IIF(Found(), ClrLName, '************ ERROR ***********')
    SELECT &lcTmpFile
    Row = Row + 1
  ENDSCAN

  BP[1] = 06
  BP[2] = 12
  BP[4] = 23
  BP[5] = 67
  BP[6] = 'Y'
  BP[7] = IIF (llUseDel, 'Y', 'N')
  lnFirstRec = qRecNo[lnTRow]
  SET COLOR TO &qClrBlk
  ThisKey = IIF(llInsMode .OR. llStayIns, qInsKey, Brow())

  DO CASE
    CASE ThisKey = qEscKey
      EXIT
    
    CASE ThisKey = qInsKey

      IF Arrow <> 0
        SET COLOR TO &qClrBlk
        @ Arrow,12 CLEAR TO Arrow,12
      ENDIF  
      IF Row >= 21
        @ 06,12 TO 20,66 CLEAR
        Row = 06
      ENDIF  
      SET COLOR TO &qClrSay
      lcColor = SPACE(06)    
      @ Row,13 GET lcColor SIZE 1,6 PICTURE REPLICATE("!",IIF(llColor6,6,3))  && YMA 01/22/95
      READ

      IF EMPTY(lcColor) .OR. READKEY() = 12 
        llStayIns = .F.
        llInsMode = .F.                && MFM 02/15/95.
        IF EOF('&lcTmpFile') 
          SET COLOR TO &qClrBlk
          @ ROW,13 TO 20,66 CLEAR    
          RETURN
        ENDIF
      ELSE
        SELECT CODE
        IF !SEEK('C'+lcColor)
          xColor     = lcColor
          lnOldArrow = Arrow
          lnOldRow   = Row
          lnOldFstRc = lnFirstRec
          DO CODECHK WITH 'C',XCOLOR,'COLOR'
          lnFirstRec = lnOldFstRc
          Row        = lnOldRow
          Arrow      = lnOldArrow
          lcColor    = xColor
        ENDIF
        IF !EMPTY(lcColor)
          llStayIns = .T.
          SELECT &lcTmpFile
          IF SEEK(lcColor)
            = gfDialog ('I','This color already exists !')
          ELSE
            @ Row,13 SAY lcColor
            @ Row,20 SAY Code->cData
            @ Row,36 SAY Code->ClrLName
            APPEND BLANK
            REPLACE COLOR   WITH lcColor ,;
                    cStatus WITH 'A'
          ENDIF  
        ELSE
          IF EOF('&lcTmpFile') 
            llStayIns = .F.
            RETURN
          ENDIF
        ENDIF
        
      ENDIF
      SELECT &lcTmpFile

      IF lnFirstRec <> 0
        GOTO IIF(RECCOUNT()>lnMaxRec, lnMaxRec*INT((RECCOUNT()/lnMaxRec)), lnFirstRec)  && MFM 02/15/95.
        BP[10] = Arrow
      ELSE 
        GOTO TOP
      ENDIF

    CASE ThisKey = qRetKey
      GOTO lnFirstRec                           
      BP[10] = Arrow                            

    CASE ThisKey = qDelKey
      lnChoice=gfDialog ('I','Are you sure you want to delete this color ?',;
                           '\<Yes;\<No')
      IF lnChoice = 1
        DELETE NEXT 1
        GOTO TOP
      ELSE
        GOTO lnFirstRec                           
        BP[10] = Arrow                            
      ENDIF
  ENDCASE
ENDDO

*-- EOF (gpClrBrow).


*!*************************************************************
*! Name : gpFbDyBrow.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/28/94.
*!          
*! Synopsis : Browse the Dyelot for a certin fabric/clr in a
*!            certin warehouse.
*! 
*! Passed :
*!        Parameters : 
*!           lcFab   : The Fabric.   
*!           lcClr   : The color.
*!           lcDyelot: The dyelot.   
*!           lcWare  : The Warehouse.
*! 
*! Returned : 
*!        Variables  : The selected Dyelot.
*! 
*! Screen layout :
*!00       .+....3....+....4....+....5....+
*!05       
*!06        ITEM:   COLOR:  
*!07       
*!08        DYELOT#      ONHAND    USAGE 
*!09           
*!10        123456789* 12345678 12345678 
*!19           
*!20       
*!*************************************************************

PROCEDURE gpFbDyO
PARAMETER lcFab,lcClr,lcDyelot,lcWare

SAVE SCREEN TO lsStDyBrow1

RESTORE FROM AdPara&qSysCode ADDIT
llMultiWH = IIF (M_WareHouse = 'Y', .T., .F.)   
RELEASE ALL LIKE M_*

*-- Save the current alias.
lcAlias = ALIAS()

*E300637,1 Use the new global variables names
*IF .NOT. OPENED('FabDye')
*  SELECT 0
*  DO NETUSE WITH '&QDD.FabDye','&QDD.FabDye','SH'
*ENDIF
=gfOpenFile(gcDataDir+'FabDye',gcDataDir+'FabDye','SH')
*E300637,1 (End)

SELECT FabDye
GOTO TOP

llFound = .F.
SEEK (lcFab+lcClr+lcWare)
SCAN WHILE Fabric+Color+cWareCode = lcFab+lcClr+lcWare ;
     FOR   !EMPTY(Dyelot)
  llFound = .T.  
  EXIT
ENDSCAN
IF !llFound
  = gfDialog('I','There are no Dyelots for Item\Color: '+;
              ALLTRIM(lcFab)+'\'+ALLTRIM(lcClr) +;
              IIF(llMultiWH, ' in warehouse: '+ ALLTRIM(lcWare)+'.'  ,;
              ' on the file.' ))
  lcDyelot = SPACE(10)
  RETURN
ENDIF

lcTitle = IIF (llMultiWH, '<ITEM\WAREHOUSE DYELOTS>', '<ITEM\DYELOTS>')
DO DRAWBOX WITH qClrBlk, lcTitle, 05,24 , 20,55

SET COLOR TO &qClrBlk
@ 06,26 SAY 'ITEM:          COLOR:       '
@ 07,25 TO 07,54
@ 08,26 SAY 'DYELOT#      ONHAND    USAGE'

SET COLOR TO &qClrSay
@ 06,32 SAY lcFab
@ 06,48 SAY lcClr 

DO WHILE .T.
  Row    = 09
  qRecNo = 00

  SET COLOR TO &qClrBlk
  @ 09,25 TO 19,54 CLEAR
  
  SET COLOR TO &qClrSay
  SCAN WHILE (Fabric+Color+cWareCode=lcFab+lcClr+lcWare).AND.(Row<20);
       FOR   !EMPTY(Dyelot)
     qRecNo[Row] = RECNO()
     @ Row,26 SAY Dyelot
     @ Row,37 SAY OnHand PICTURE '99999999'
     @ Row,46 SAY Usage  PICTURE '99999999'
     Row = ROW + 1
  ENDSCAN
  
  BP[1] = 09
  BP[2] = 25
  BP[3] = lcFab+lcClr+lcWare
  BP[4] = 22
  BP[5] = 55
  BP[6] = 'N'
  BP[7] = 'N'
  BP[8] = 'Fabric+Color+cWareCode=lcFab+lcClr+lcWare'
  BP[9] = 'N'

  SET COLOR TO &qClrBlk
  ThisKey = BRow()
  DO CASE
    CASE ThisKey = qEscKey
      lcDyelot = SPACE(10)
    CASE ThisKey = qRetKey
      lcDyelot = Dyelot
    OTHERWISE
      LOOP
  ENDCASE
  
  EXIT
ENDDO

*-- Select the previous work area.
SELECT &lcAlias

RESTORE SCREEN FROM lsStDyBrow1


*!*************************************************************
*! Name : gpAdFabWar
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/28/94.
*!         
*! Synopsis : Add a new record to the FabDye file.
*! 
*! Passed :
*!        Parameters : 
*!          lcFab  : The fabric.   
*!          lcClr  : The color.
*!          lcDye  : The Dyelot.
*!          lcWare : The Warehouse.
*!        Files    : The FabDye File should be opened.
*!                   The WareHouse File should be opened.
*! 
*! Returned : 
*!        Files      : The FabDye File after appending the new record.
*! 
*! Screen layout :
*!   ..*....3....*....4....*....5....*
*!11 
*!12  ENTER THE GL. LINK CODE :  
*!13 
*! 
*! Example :
*!        DO gpAdFabWar WITH lcfabric,lcColor,SPACE(10),lcWareCode
*! 
*! Modifications :
*!    YMA 11/01/94
*!        1) Get the GL. link code from the user instead of 
*!           defaulting it from the warehouse file.
*!*************************************************************
*E300261,1 Modified function to work under Fox26 and Windows
*E300261,1 Created a new global screen GL_LINK that accepts 
*E300261,1 and validates, or displays a GL link code according
*E300261,1 to passed parameters.
*B600667,1 WAM 09/03/95 Upon assigning a material to a new warehouse, Default
*B600667,1              warehouse average unit cost with fabric average unit 
*B600667,1              cost.
*!*************************************************************
PROCEDURE gpAdFabWar 
*E300955,1 MAB Add code to update Dye_Rel file, [add new parameter]
*PARAMETERS lcFab, lcClr, lcDyel, lcWare
PARAMETERS lcFab, lcClr, lcDyel, lcWare, lcTmpScope
*E300955,1 MAB Add code to update Dye_Rel file, [add new parameter]

PRIVATE lcDesc, lcAlias, llGlLink
lcAlias = ALIAS()

*-- YMA 11/01/94.
*E300421,1 get the gl_link from the setup file
*RESTORE FROM AdPara&qSysCode ADDIT
*llGlLink = IIF (M_LINK_GL = 'Y', .T., .F.)
*RELEASE ALL LIKE M_*
llGlLink   = ALLTRIM(gfGetMemVar('M_LINK_GL'))  = 'Y' 
*E300421,1 (End)
lcGlCode = SPACE(3)
IF llGlLink
  *E300261,1 Replaced file opening with a call to gfOpenFile
  *E300637,1 Use the new global variables names
  *llUsed = gfOpenFile(qDD+'GL_LINK', qDD + 'GL_LINK1','SH')
  llUsed = gfOpenFile(gcDataDir+'GL_LINK',gcDataDir+'GL_LINK1','SH')
  *E300637,1 (End)
  
  *IF !USED('GL_LINK')
    *SELECT 0
    *DO NetUse WITH '&qDD.GL_LINK','&qDD.GL_LINK1','SH'
    *llUsed = .T.
  *ELSE
    *llUsed = .F.
  *ENDIF
  *E300261,1 end. 
  
  *E300261,1 Removed the following lines and replaced with a call
  *E300261,1 to GL_LINK.SCX 

  *SAVE SCREEN TO lsAdFabWar1
  *DO DrawBox WITH qClrMag, '', 11,23,13,55
  *@ 12,25 SAY 'ENTER THE GL. LINK CODE :' COLOR &qClrMag
  *@ 12,51 GET lcGlCode PICTURE '@!'
  *READ
  *IF !EMPTY(lcGlCode) .AND. !SEEK(lcGlCode,'GL_LINK')
  *  XLINK_CODE = lcGlCode
  *  DO GLBROW WITH '03','Y',0,0,0
  *  lcGlCode = XLINK_CODE 
  *ENDIF
  *RESTORE SCREEN FROM lsAdFabWar1

*B601258,1 SWK 09/12/96 
*-- Call the screen only if empty dyelot
  IF EMPTY(lcDyel)
    *E300637,1 Use the new global variables names
    *DO (QSD+"GL_LINK.SPX") WITH '03', lcGlCode, '', .T.
    *E300421,1 delete the calling of GL_LINK screen
    *DO (gcScrDir+"GL_LINK.SPX") WITH '03', lcGlCode, '', .T.
    *E300421,1(End)
    *E300637,1 (End)
  ENDIF
  *E300261,1 end.
*B601258,1 SWK End
     
  IF llUsed
    USE IN GL_LINK
  ENDIF
ENDIF
*-- END YMA 11/01/94.

*B600667,1 WAM 09/03/95 Open fabric file if not used
*E300637,1 Use the new global variables names
*llUsed = gfOpenFile(qDD+'FABRIC', qDD + 'FABRIC','SH')
llUsed = gfOpenFile(gcDataDir+'FABRIC',gcDataDir+'FABRIC','SH')
*E300637,1 (End)
= SEEK(lcFab+lcClr,'FABRIC')

*B600667,1 WAM 09/03/95 Default warehouse average unit cost with fabric 
*B600667,1              average unit cost.
SELECT FabDye
APPEND BLANK
llLock = RLOCK()
*B601258,1 SWK 09/12/96 
*B601258,1 Update the Fabdye file with the average cost for empty dyelot records only
*REPLACE Fabric     WITH lcFab    ,;
        Color      WITH lcClr    ,;
        Dyelot     WITH lcDyel    ,;
        cWareCode  WITH lcWare   ,;
        GL_Link    WITH lcGlCode ,;
        Add_Date   WITH DATE()   ,;
        Add_Time   WITH TIME()   ,;
        Add_UserId WITH qUserId  ,;
        Ave_Cost   WITH IIF(EMPTY(lcDyel),Fabric.Ave_Cost,0) ,;
        nAveCstBuy WITH Fabric.nAveCstBuy
*REPLACE Fabric     WITH lcFab    ,;
        Color      WITH lcClr    ,;
        Dyelot     WITH lcDyel    ,;
        cWareCode  WITH lcWare   ,;
        GL_Link    WITH lcGlCode ,;
        Add_Date   WITH DATE()   ,;
        Add_Time   WITH TIME()   ,;
        Add_UserId WITH gcUser_Id  ,;
        nfAve_Cost   WITH IIF(EMPTY(lcDyel),Fabric.nfAve_Cost,0) ,;
        nAveCstBuy WITH Fabric.nAveCstBuy

*-- B602687 AHM update nAveCstBuy also like nfAve_Cost if EMPTY(lcDyel) only (Start)
*REPLACE Fabric     WITH lcFab    ,;
        Color      WITH lcClr    ,;
        Dyelot     WITH lcDyel    ,;
        cWareCode  WITH lcWare   ,;
        GL_Link    WITH lcGlCode ,;
        nfAve_Cost   WITH IIF(EMPTY(lcDyel),Fabric.nfAve_Cost,0) ,;
        nAveCstBuy WITH Fabric.nAveCstBuy

REPLACE Fabric     WITH lcFab    ,;
        Color      WITH lcClr    ,;
        Dyelot     WITH lcDyel    ,;
        cWareCode  WITH lcWare   ,;
        GL_Link    WITH lcGlCode ,;
        nfAve_Cost WITH IIF(EMPTY(lcDyel),Fabric.nfAve_Cost,0) ,;
        nAveCstBuy WITH IIF(EMPTY(lcDyel),Fabric.nAveCstBuy,0)
*-- B602687 AHM update nAveCstBuy also like nfAve_Cost if EMPTY(lcDyel) only (End)
=gfAdd_Info('FabDye')

UNLOCK        
*B601258,1 SWK End

*B600667,1 WAM 09/03/95 Close fabric file if opened here.
IF llUsed
  USE IN FABRIC
ENDIF

*E300955,1 MAB Update dye_Rel file with specific color [begin]
IF TYPE('lcTmpScope') $ 'UL'
  lcTmpScope = ''
ENDIF

*--E300955,1 MAB IF !EMPTY(lcTmpScope) AND !EMPTY(lcDyel)
IF !EMPTY(lcDyel)
  lcFab = PADR(lcFab,7)
  lcClr = PADR(lcClr,6)
  lcDyel= PADR(lcDyel,10)
  
  llDyeRel = gfOpenFile(gcDataDir+"Dye_Rel","Dye_Rel","SH")
  SELECT Dye_Rel
  SET ORDER TO Dye_Rel

  *-- if you did not find this fabric, color, dyelot record 
  IF !SEEK(lcFab + lcClr + lcDyel)
    PRIVATE lnNearest,lcDye_Seq

    lcDye_Seq = ''
    lnNearest = RECNO(0)
    
    *-- Add this block to adjust add records at top of file. [begin]
    IF (lnNearest # 0)
      GO lnNearest
      IF FABRIC + COLOR != lcFab + lcClr
        SET ORDER TO Dye_Rel DESCENDING
        = SEEK(lcFab + lcClr + lcDyel)
        lnNearest = RECNO(0)
        IF lnNearest # 0
          GO lnNearest
          IF (FABRIC + COLOR != lcFab + lcClr) OR (lcDyel > DYELOT)
            lnNearest = 0
          ENDIF
        ENDIF     
      ENDIF  
    ENDIF    
    *-- Add this block to adjust add records at top of file. [end]

    *-- if it is Last dyelot code.
    IF lnNearest = 0
      SET ORDER TO SEQUENCE DESCENDING
      = SEEK(lcFab + lcClr)
      lcDye_Seq = PADL(ALLTRIM(STR(VAL(cDye_Seq) + 1)),4,'0')
    ENDIF  

    SET ORDER TO
    IF lnNearest # 0
      GO lnNearest
      lcDye_Seq = cDye_Seq

      SCAN FOR FABRIC + COLOR + cDye_Seq = lcFab + lcClr ;
               AND cDye_Seq >= lcDye_Seq

        REPLACE cDye_Seq WITH PADL(ALLTRIM(STR(VAL(cDye_Seq) + 1)),4,'0')
        =gfTraceKey('DYE_REL', lcFab + lcClr + DYE_REL.DYELOT ,'M')
        =gfAdd_Info('DYE_REL')

      ENDSCAN 
    ENDIF
    
    *-- insert new dyelot line.
    INSERT INTO ('Dye_Rel')                                 ;
             (FABRIC, COLOR, DYELOT, cDye_Seq , cTmpScope ) ;
      VALUES (lcFab , lcClr, lcDyel, lcDye_Seq, lcTmpScope)     

    = gfTraceKey('DYE_REL', lcFab + lcClr + DYE_REL.DYELOT ,'A')
    =gfAdd_Info('DYE_REL')

  ENDIF
  
  IF llDyeRel
    USE IN DYE_REL
  ENDIF

ENDIF
*E300955,1 MAB Update dye_Rel file with specific color [end]

SELECT (lcAlias)

*!*************************************************************
*! Name : gfToPrn.
*! Auth : MOHAMED FAHMY MOHAMED .MFM.
*! Date : 07/02/94.
*! 
*! Synopsis : Initialize the printer according to the defrint inputs.
*!*************************************************************
FUNCTION gfToPrn

qRepo_Scr   = .F.
llErrFlg    = .F.

*-- If in batch mode then initialize the variables from the batch server file.
IF qBatchMod
  
  *B500826,1 MFM 07/12/95  (Begin).
  *llDefult = !SEEK( 'M'+lcPrnter, 'Printers' )
  llDefult = !SEEK( lcPrnter, 'Printers' )
  *B500826,1 MFM 07/12/95  (End).
  
  =gfIntVar( llDefult, llDefult, 'SyuBtSrv' )
ENDIF

*-- We get to build the set printer to ??? string 
*-- according to the variables entered.
*-- These variables are used to build the strin in case of network
*-  lnPrnNo Net work printer number.
*-  lcServNme Server name if it is empty it will not be used.
*-  lcQueNme  The printer queue name if it is empty it will not be used.
*-  lcBanrNme The Bannar page if it is empty it will not be used.
IF !_UNIX
  lcToPrinter = IIF( lcNetOrLoc = 'L', gcLoclPort,;
                     '\\SPOOLER\TI=5'+;
                     IIF( EMPTY( lcServNme ), '','\S='+ALLTRIM(lcServNme))+;
                     IIF( EMPTY( lcQueNme ) ,'','\Q='+ALLTRIM(lcQueNme))+;
                     '\P='+ALLTRIM(STR(lnPrnNo))+;
                     IIF( EMPTY( lcBanrNme ), '\NB', '\B='+STRTRAN( lcBanrNme, ' ', CHR(255) ) ) )
ELSE         
  lcToPrinter = IIF( lcNetOrLoc = 'L', gcLoclPort,'"'+ALLTRIM(lcQueNme)+'"')
ENDIF                   
*-- If the local printer is not ready.
*-- MFM 07/13/94.
DO WHILE SYS(13) = 'OFFLINE' .AND. lcNetOrLoc = 'L'
  IF qBatchMod
    lcMsg = 'Printer is not ready'
    RETURN .F.
  ELSE
    SET DEVICE TO SCREEN
*    RESTORE SCREEN FROM lsSelDev1
    IF gfDialog( 'I','Printer is not ready', '\<Retry;\<Cancel') = 2
      *-- Reinitialize the out put to the screen.
      S_Device = 'S'
      *B800149,1 If called from notepad and cancelling, fill xReport
      *B800149,1 variable with 'ABORT' to be checked from the calling 
      *B800149,1 program.
      IF TYPE('xReport') = 'C' .AND. xReport = 'NOTEPAD'
        xReport = 'ABORT'   
      ENDIF 
      *B800149,1 end.

      *B800149,1 Added an Else to fix the following : 
      *B800149,1 If llDontGoMast is passed as .t., the program will 
      *B800149,1 never exit this loop.
      *IF !llDontGoMast 
      *  RETURN TO gfDrv
      *ENDIF
      IF !llDontGoMast 
        RETURN TO gfDrv
      ELSE
        RETURN
      ENDIF
      *B800149,1 end.  
    ELSE
      LOOP
    ENDIF    
  ENDIF
ENDDO  

SET DEVICE TO PRINT

*-- Trap the error of 'invalid server name' ,'invalid queue name'
*-- and 'printer is not ready' = 'Invalid printer number' 
*-- by the local error handler.
lcOldError = ON( 'ERROR' )

ON ERROR =gfPrnErr()

SET PRINTER TO &lcToPrinter

*-- To cheak for the error 'printer not ready' because if wrong printer number
*-- and wrong server or queue or both it want generat an error in the set
*-- printer to so it will bumps when setting the escep sequance so 
*-- befor going an whare check for the erroe.
IF !llErrFlg
  @ PROW(),PCOL() SAY ' '
ENDIF

*-- Reset to the old error handler.
ON ERROR &lcOldError

*-- If ther is an error the return otherwise proceed.
IF llErrFlg
  *-- Return to the calling program.
  RETURN .F.
ENDIF

*-- The fallowing varabiles are used in som other programs
*-- do not comment them 6 variables they are qP10CPI, YP85PG_LEN,
*-- YPAPER_TYP, YDEVI, YP10CPI, YP17CPI....
STORE '' TO qP10CPI,YP85PG_LEN,YPAPER_TYP,;
            YP10CPI,YP17CPI,lcP10CPI,lcP85PG_LEN,lcPAPER_TYP,;
            lcP10CPI,lcP17CPI,lcP12CPI,lcP10CPI
  YDEVI      = 'P'
  lcyDEVI      = 'P'  

*B500826,1 MFM 07/12/95  (Begin).
*IF !EMPTY(lcprtModl) AND SEEK('M'+lcprtModl,'PRINTERS')
IF !EMPTY(lcprtModl) AND SEEK(lcprtModl,'PRINTERS')
*B500826,1 MFM 07/12/95  (End).

  qP10CPI    = Printers.P10CPI
  YP85PG_LEN = Printers.P85PG_LEN        && Y VARIABLE IS USED IN INVOICE PROG.
  YPAPER_TYP = lcPaprTyp                && Y VARIABLE IS USED IN MFG800
  YDEVI      = 'P'
  YP10CPI    = Printers.P10CPI
  YP17CPI    = Printers.P17CPI
  lcP17CPI   = Printers.P17CPI
  lcP12CPI   = Printers.P12CPI
  lcP10CPI   = Printers.P10CPI  
ENDIF  

*-- Set the escep sequance for the printing procees.
DO CASE
  CASE ( lcPaprTyp = 'N' .AND. R_Width = 'W'  ) .OR. R_Width = 'CPI17' .OR.;
       ( lcPaprTyp = 'W' .AND. R_Width = 'XW' )

    *-- MAC.Ver. MFM 02/19/95.
    IF _MAC
      SET PRINTER FONT 'FOXPRINT',7
    ELSE
      IF !EMPTY(lcP17CPI)
        @ PROW(),PCOL() SAY &lcP17CPI
      ENDIF  
    ENDIF  

  CASE ( lcPaprTyp = 'N' .AND. R_Width = '2W' ) .OR. R_Width = 'CPI12' .OR.;
       ( lcPaprTyp = 'W' .AND. R_Width = '2XW')
    *-- MAC.Ver. MFM 02/19/95.
    IF _MAC
      SET PRINTER FONT 'FOXPRINT',10
    ELSE
      IF !EMPTY(lcP12CPI)
        @ PROW(),PCOL() SAY &lcP12CPI
      ENDIF  
    ENDIF  

  CASE ( lcPaprTyp = 'N' .AND. R_Width = 'N'  ) .OR. R_Width = 'CPI10' .OR.;
       ( lcPaprTyp = 'W' .AND. R_Width = 'W'  )

    *-- MAC.Ver. MFM 02/19/95.
    IF _MAC
      SET PRINTER FONT 'FOXPRINT',14
    ELSE
      IF !EMPTY(lcP10CPI)
        @ PROW(),PCOL() SAY &lcP10CPI
      ENDIF  
    ENDIF  

ENDCASE

*-- EOF( gfToPrn )


*!*************************************************************
*! Name : gfIntVar.
*! Auth : MOHAMED FAHMY MOHAMED .MFM.
*! Date : 07/02/94.
*! 
*! Synopsis : Initiaalize local variables.
*!*************************************************************
FUNCTION gfIntVar
PARAMETERS llDefult, llModify, lcFrmFile

lcNetOrLoc = IIF( llDefult, IIF( S_Net, 'N', 'L' )  , IIF( llModify, lcNetOrLoc, &lcFrmFile..Net_Loc ) )
lnPrnNo    = IIF( llDefult, 0        , IIF( llModify, lnPrnNo   , &lcFrmFile..Net_PrtNo ) )
lcServNme  = IIF( llDefult, SPACE(15), IIF( llModify, lcServNme , &lcFrmFile..Server ) )
lcQueNme   = IIF( llDefult, SPACE(22), IIF( llModify, lcQueNme  , &lcFrmFile..Queue ) )
lcBanrNme  = IIF( llDefult, SPACE(12), IIF( llModify, lcBanrNme , &lcFrmFile..Baner ) )
gcLoclPort = IIF( llDefult, 'LPT1',    IIF( llModify, gcLoclPort, IIF( EMPTY( &lcFrmFile..PrtPort ), 'LPT1', &lcFrmFile..PrtPort ) ) )
lcPaprTyp  = IIF( llDefult, 'W'      , IIF( llModify, lcPaprTyp , &lcFrmFile..Paper_Type ) )
lcPrtModl  = IIF( llDefult, SPACE(06), IIF( llModify, lcPrtModl , &lcFrmFile..PrMod ) )

*-- EOF( gfIntVar )

*!*************************************************************
*! Name : gfPrnErr.
*! Auth : MOHAMED FAHMY MOHAMED .MFM.
*! Date : 07/02/94.
*! 
*! Synopsis : Trab errors of 'invalid server' or 'invalid queue'
*!            or 'printer not ready'.
*!*************************************************************
FUNCTION gfPrnErr

SET DEVICE TO SCREEN

llErrFlg = .T.

lcMsg = 'Error'

DO CASE 
  *-- The Printer number is invalid.
  CASE ERROR() = 125
    lcMsg = 'Invalid printer number.'
    
  *-- The Server name is wrong.
  CASE ERROR() = 1715
    lcMsg = 'Invalid server name, please reenter.'
    
  *-- The Queue name is wrong.
  CASE ERROR() = 1716
    lcMsg = 'Invalid queue name, please reenter.'
ENDCASE

IF !qBatchMod
  =gfDialog ( 'I', lcMsg )
ENDIF

RETURN(.T.)
*-- EOF( gfPrnErr )


*!*************************************************************************
*! Name : gfPrtBrow()
*! Auth : Timour abdalla Khalil.
*! Date : 07/05/94.
*! 
*! Synopsis : Browse the Printer Personality numbers and models.
*! 
*! Parameters : lcType
*!              "M"  for modeles browse.       
*!              "P"  for personalites no browse.       
*! Calling =gfPrtBro( 'M', @lcPrId, @lcPDesc )
*! 
FUNCTION gfPrtBro
PARAMETERS lcType, lcPrId, lcPDesc,llRetAlias

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcOldAlias,lcBrFields
PRIVATE lcOldAlias,lcBrFields,laData
*E300637,1 (End)

DECLARE laData[2]
STORE '' TO laData
lcBrFields = [PRID:H="ID",PDESC:H="Description"]
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
llWasSel = .T.
lcOldAlias = ALIAS()

*B500826,1 MFM 07/12/95  (Begin).
IF lcType = 'M'
  SELECT Printers
  SET ORDER TO TAG Printers
ELSE
  SELECT Prsonlty
  SET ORDER TO TAG Prsonlty
ENDIF
*B500826,1 MFM 07/12/95  (End).

lcTitle=IIF(lcType='M','Printer Models','Printer Personality Numbers')

*B500826,1 MFM 07/12/95  (Begin).
*IF llBrowse OR !SEEK(lctype+lcPrId)
IF llBrowse OR !SEEK(lcPrId)
*B500826,1 MFM 07/12/95  (End).

  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     
  
  *B500826,1 MFM 07/12/95  (Begin).
  *llWasSel= ARIABROW([lctype],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","PRID,PDESC","laData")
  llWasSel= ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","PRID,PDESC","laData")
  *B500826,1 MFM 07/12/95  (End).
  
  IF llWasSel
    lcPrId  = laData[1]
    lcPDesc = laData[2]  
  ELSE
    lcPrId  = SPACE(6)
  ENDIF  
ENDIF  
IF llRetAlias
  SELECT ( lcOldAlias )
ENDIF  
RETURN 

*!*************************************************************
*! Name : gfAPVnBrow.
*! Auth : Hisham Ramsis Philips (HISH).
*! Date : 13/03/95.
*!          
*! Synopsis : Browse vendors from the AP files if system is seted to
*!            use AP link.
*! 
*! Passed :
*!        Parameters : Vendor code.
*! 
*! Returned : 
*!        Variables  : True if the user select or false if the user
*!                     ESC. from the browse.
*! 
*! Example :
*!        =gfAPVnBrow( @lcVenCode )
*! 
*! Screen layout :
*!    ....+....1....+....2....+....3....+....4....+....5....+....6....+....7....+....
*!03  
*!04   VENDOR    .............NAME.............  .....PHONE......  OUR ACCOUNT     
*!05  
*!06          
*!..   12345678  123456789012345678901234567890  1234567890123456  123456789012345 
*!22  
*! 
*! Modifications :
*B500763,1 YMA 06/05/95 Added the soft seek part.
*!*************************************************************
FUNCTION gfAPVnBrow

*E301268,1 [Start] Add new parameter to enable filtering the supplier type
*PARAMETERS lcVenCode,llRetAlias
PARAMETERS lcVenCode,llRetAlias , lcSubType
*E301268,1 [End]

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcBrFields,lcAlias && Variable to hold browse fields

*E301268,1 [Start] filtering the supplier type
*PRIVATE lcBrFields,lcAlias,laData
PRIVATE lcBrFields,lcAlias,laData , lcForExpr
*E301268,1 [End]

*E300637,1 (End)

DECLARE laData[1] && array to get values from browse
laData=' '
llOpnApVen=.F.
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
lcTitle  = 'A/P Vendors'

*B600429,1 Change the browse fields variable (to change fields width) under windows.
*B500772,1 HISH 07/02/96 Displayed field phone with its format.
*E300637 SWK add the next line
gcPhnFrmt  =gfPhoneTem()
IF _WINDOWS
  *B602172,1 '@R' is already included in variable gcPhnFrmt, so, remove
  *B602172,1 it from the browse fields
  *lcBrFields = "cVendCode :R :H='Vendor':11,"+;
               "cVenComp  :R :H='Name':35,"+;
	           "cPhoneNo  :R :P= '@R '+gcPhnFrmt  :H='Phone':18,"+;
               "cVenOurAc :R :H='Our Account':18"
  lcBrFields = "cVendCode :R :H='Vendor':11,"+;
               "cVenComp  :R :H='Name':35,"+;
	           "cPhoneNo  :R :P= gcPhnFrmt  :H='Phone':18,"+;
               "cVenOurAc :R :H='Our Account':18"               
  *B602172,1 end                              
ELSE
  *B602172,1 '@R' is already included in variable gcPhnFrmt, so, remove
  *B602172,1 it from the browse fields
  *lcBrFields = "cVendCode :R :H='Vendor':8,"+;
               "cVenComp  :R :H='Name':30,"+;
	           "cPhoneNo  :R :P= '@R '+gcPhnFrmt :H='Phone':16,"+;
               "cVenOurAc :R :H='Our Account':15"
  lcBrFields = "cVendCode :R :H='Vendor':8,"+;
               "cVenComp  :R :H='Name':30,"+;
	           "cPhoneNo  :R :P= gcPhnFrmt :H='Phone':16,"+;
               "cVenOurAc :R :H='Our Account':15"               
  *B602172,1 end                                             
ENDIF

lcAlias = ALIAS()   && Save the current alias.

*E300637 SWK Comment the next lines
*RESTORE FROM AdPara&qSysCode ADDIT
*lcApDir   = ALLTRIM(M_APDataDir)
*RELEASE ALL LIKE M_*
*E300637(End)

IF !USED( 'APVendor' )
  SELECT 0
  *E300637 SWK Replace netuse with gfOpenFile
  *DO NetUse WITH '&lcApDir.APVendor', 'VenCode', 'SH'
  =gfOpenFile(gcDataDir+'ApVendor',gcDataDir+'VenCode','SH')
  *E300637 (End)
  llOpnApVen=.T.
ELSE  
  llOpnApVen=.F.
ENDIF
SELECT APVendor
GO TOP
IF EOF()
  = gfDialog('I', 'Vendor file is empty' )
  lcVenCode  = SPACE(08)
  IF llOpnApVen
    USE
  ENDIF
  IF llRetAlias
    SELECT (lcAlias)
  ENDIF  
  RETURN 
ELSE
  *B500763,1 YMA 06/05/95 Added the soft seek part.
  IF !SEEK (lcVenCode)
    IF RECNO(0)=0
      GO TOP
    ELSE
      GO RECNO(0)
    ENDIF
  ENDIF
  *B500763,1 YMA 06/05/95 End.
ENDIF
*E301268,1 [Start] build for exp to filter sup. type
IF TYPE('lcSubType') <> 'C'
  lcSubType = ''
ENDIF
STORE '' TO lcForExpr
IF !EMPTY(lcSubType)
  FOR lnForLoop = 1 TO LEN(ALLTRIM(lcSubType))
    IF lnForLoop > 1
      lcForExpr = lcForExpr + ' OR '
    ENDIF
    lcForExpr = lcForExpr + "'" + SUBSTR(ALLTRIM(lcSubType),lnForLoop,1) +;
                "'" + ' $ ' + 'cVenSupTyp'
  ENDFOR
ENDIF
*llWasSel  =ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','',"cVendCode","laData")
IF EMPTY(lcForExpr)
  llWasSel  =ARIABROW('',lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','',"cVendCode","laData")
ELSE
  llWasSel  =ARIABROW([FOR &lcForExpr],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','',"cVendCode","laData")
ENDIF
*E301268,1 [End]


lcVenCode =IIF(llWasSel,laData[1],SPACE(8))
IF  llOpnApVen
  USE
ENDIF
IF llRetAlias
  SELECT (lcAlias)
ENDIF  
RETURN llWasSel
*-- EOF( gfAPVnBrow )

*!*************************************************************
*! Name : gpApLnkMsg.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 07/25/94.
*! 
*! Synopsis : Dialog message that will be called to prevent the
*!            user from running the calling program if the 
*!            system is setup to be linked with the A/P module.
*! 
*! Called from : 
*!         Procedures : Ven100.
*!                      Ven200.
*!                      Ven300.
*!*************************************************************
PROCEDURE gpApLnkMsg

= gfDialog ('I', 'The system has been setup to link with the Accounts '+;
                 'Payable module of Aria Advantage series. Please use '+;
                 'this option from the A/P module.')

*-- End gpApLnkMsg

*!*************************************************************
*! Name : gfVenAdr.
*! Auth : Mohamed Fahmy Mohamed (MFM).
*! Date : 07/12/94.
*!          
*! Synopsis : Get the order of the address if link with ap.
*!            use AP link.
*! 
*! Example :
*!       DECLARE laAddOrd [ 3, 2 ]  && This line should be befor the call.
*!       =gfVenAdr( )
*! 
*! Modifications :
*!    MFM 09/14/94
*!        1) Changed the file from 'Codes' to be 'SycInt' to get
*!           the correct address order.
*!    ARH 10/19/94
*!        1) Changed the AP VENDOR file field (cAdrCode) to be 
*!           cCont_Code and the AP SYCINT tag name (cAdrCode)
*!           to be cContCode.
*!*************************************************************
FUNCTION gfVenAdr

RESTORE FROM ADPARA&QSYSCODE ADDIT
lcSysDir  = ALLTRIM( M_APSysDir )
RELEASE ALL LIKE M_*

lcAlias = ALIAS()

*-- MFM 09/14/94.
*-- Changed the file from 'Codes' to be 'SycInt' according to the
*-- changes in the ap.
IF !USED( 'SycInt' )
  SELECT 0
  DO NetUse WITH '&lcSysDir.SycInt', '', 'SH'
ENDIF  

SELECT SycInt

*-- ARH 10/19/94 Changed the tag name from cAdrCode to cCont_Code.
SET ORDER TO TAG cContCode
*-- END  ARH  10/19/94

laAddOrd[ 1, 1 ] = 3
laAddOrd[ 2, 1 ] = 4
laAddOrd[ 3, 1 ] = 5

*-- ARH 10/19/94 Changed the APVENDOR field name from cAdrCode
*-- to cCont_Code.
IF SEEK( APVendor.cCont_Code )
  laAddOrd[ 1, 2 ] = SycInt.nPaRt3Ord
  laAddOrd[ 2, 2 ] = SycInt.nPaRt4Ord
  laAddOrd[ 3, 2 ] = SycInt.nPaRt5Ord
ENDIF

=ASORT( laAddOrd,2 )

USE

SELECT &lcAlias

*-- EOF( gfVenAdr )



*:********************************************************************
*! Name : GpCrtBom
*! Auth : Timour Abdalla Khalil.
*:********************************************************************
*! Synopsis : Create new records in BOMLINE file with type '2'
*!            if it is not found.
*:********************************************************************
*: Parameter Types              Call as
*:  'M' C/T           ('C',Cuttkt,Style,'',lcGlSession)          
*:  'I' P/O           ('P',Po+STR(LineNo,6),Style,'',lcGlSession)
*:  'S' Shipment      ('S',Po+STR(LineNo,6),Style,ShipNo,lcGlSession)
*:  'T' Material Mfg. ('T',cMfgOrdNo,cFabric,Color,lcGlSession)
*:********************************************************************
*! Modifications :
*E300746,1 TAK 11/14/97 Comment all old code in gpCrtBom and renamed
*E300746,1              the function to XGpCrtBom.
*:********************************************************************
PROCEDURE GpCrtBom
PARAMETERS lcTrType,lcTket,lcItem,lcColor,lcSess,lcStyQlt

tktlntp1 = gfTempName()

SELECT BOMLINE
*B605543,1 KHM 02/13/2002 (Begin) changing the order in case of shipment.
*SET ORDER TO TAG BomLine
IF lcTrType = 'S'
  SET ORDER TO TAG BomLnShp
ELSE
  SET ORDER TO TAG BomLine
ENDIF
*B605543,1 KHM 02/13/2002 (End)

*E#301235,1
* Walid Abou El-Magd (wam) Adjust the length of lcItem to 19 charachter [START]
IF lcTrType='T'
  lcItem=PADR(lcItem,19)
ENDIF
* Adjust the lenth of lcItem to 19 charachter [END]

*B605543,1 KHM 02/13/2002 (Begin) Taking the shipment into our consideration
*lcSeekKey = IIF(lcTrType='S','I',lcTrType)+'2'+lcTket
*lcWhleCnd = "cIMTyp+cType+cTktNo+IIF(lcTrType $ 'IS',STR(LineNo,6),'')=lcSeekKey"
*khm1
*lcSeekKey = IIF(lcTrType='S','I',lcTrType)+'2'+IIF(lcTrType='S',lcShpCode,'')+lcTket
lcSeekKey = IIF(lcTrType='S',IIF(lcTrType='D','D','I'),lcTrType)+'2'+IIF(lcTrType='S',lcShpCode,'')+lcTket
*khm1
IF lcTrType = 'S'
  lcWhleCnd = "cImTyp+cType+ShipNo+cTktNo+STR(LineNo,6)+cBomTyp+Style+sClr+Item+iclr+mfgcode=lcSeekKey"
ELSE
  *khm1
  *lcWhleCnd = "cIMTyp+cType+cTktNo+IIF(lcTrType $ 'IS',STR(LineNo,6),'')=lcSeekKey"
  lcWhleCnd = "cIMTyp+cType+cTktNo+IIF(lcTrType $ 'ISD',STR(LineNo,6),'')=lcSeekKey"
  *khm1
ENDIF
*B605543,1 KHM 02/13/2002 (End)

lcForCond = "Style+IIF(lcTrType='T',SClr,'')=lcItem+IIF(lcTrType='T',lcColor,'') AND ( EMPTY(cRSession) OR cRSession=lcSess )"
lcQltFltr = IIF(TYPE('lcStyQlt') $ 'UL' ,".T.","cStyGrade = lcStyQlt")

=SEEK(lcSeekKey)
LOCATE REST WHILE &lcWhleCnd FOR &lcForCond AND &lcQltFltr

*--If not found type '2' Create type '2' records.
IF !FOUND()
  *B605543,1 KHM 02/13/2002 (Begin) 
  SET ORDER TO TAG BomLine
  *khm1
  *lcWhleCnd = "cIMTyp+cType+cTktNo+IIF(lcTrType $ 'IS',STR(LineNo,6),'')=lcSeekKey"
  lcWhleCnd = "cIMTyp+cType+cTktNo+IIF(lcTrType $ 'ISD',STR(LineNo,6),'')=lcSeekKey"
  *khm1
  
  *B605543,1 KHM 02/13/2002 (End)
  
  *--Chech for type '1'.
  
  *khm1
  *lcSeekKey=IIF(lcTrType='S','I',lcTrType)+'1'+lcTket
  lcSeekKey=IIF(lcTrType='S',IIF(lcTrType='D','D','I'),lcTrType)+'1'+lcTket
  *khm1  
  lcForCond="Style+IIF(lcTrType='T',SClr,'')=lcItem+IIF(lcTrType='T',lcColor,'') AND !lVoid "
  =SEEK(lcSeekKey)
  LOCATE REST WHILE &lcWhleCnd FOR &lcForCond
  *--Create '2' from '1'. 
  IF FOUND()   
    COPY REST WHILE &lcWhleCnd FOR &lcForCond TO (gcWorkDir+TktLnTp1)
    =gfOpenFile(gcWorkDir+TktLnTp1,'','EX')
    SELECT (TktLnTp1)
    REPLACE ALL cType     WITH '2',;
                ShipNo    WITH IIF(lcTrType='S',lcColor,''),;
                cStyGrade WITH IIF(lcQltFltr<>".T.",lcStyQlt,''),;
                StyQty  WITH  0,;
                ItemQty WITH  0,;
                ItemAmt WITH  0
    USE
    SELECT BOMLINE
    APPEND FROM (gcWorkDir+TktLnTp1)
    ERASE (gcWorkDir+TktLnTp1+'.DBF')
  ENDIF
ENDIF
RETURN

*!*************************************************************
*! Name : GpCrtBom
*! Auth : Timour Abdalla Khalil.
*! Date : 11/03/94.
*!          
*! Synopsis : Create new records in BOMLINE file with type '2'
*!            if it is not found.
*!          
*! Calling from :  STY650.prg    Receive P/Os or Shipment.
*!                 MFG500.prg    Receive Cutting tickets.
*! 
*! Parameters  :  lcTrType :
*!                           'C'=> for Cutting tickets.
*!                           'P'=> for Purchase orders.
*!                           'S'=> for Shipments.
*!                lcTmpFile : Temp file alias name.
*!                            POSLTEMP  for 'P' or 'S'
*!                            TKTLTEMP  for 'C'
*! 
*! Note : The temp files names must exist like TEMPNAME().
*!        TktLnTp1  in all cases.
*!        TktLnTp2  in case of shipment only. 
*! 
*! Modifications :
*N000016,6 WAM 07/04/95 Create records type 2 while receiving MFG order
*! 
PROCEDURE XGpCrtBom

PARAMETERS lcTrType,lcTmpFile
PRIVATE lpType

lcSess = IIF(TYPE('XGLSESSION')='C',XGLSESSION,SPACE(6))
TktLnTp1 = gfTempName()
SELECT &lcTmpFile
*N000016,6 WAM 07/04/95 Create records type 2 while receiving MFG order
*lcStyle=Style  
lcStyle = IIF(lcTrType='T',PADR(cFabric,12,' '),Style)
lcSclr =Color
*N000016,6 WAM 07/04/95 Following lines are commented out by WAM
*IF lcTrType='C'
*  lcKey  = Cuttkt+SPACE(4)
*ELSE
*  lcShipNo=ShipNo 
*  lcLnNo  = LTRIM(STR(LineNo,4))+SPACE(4 -LEN(LTRIM(STR(LineNo,4))))
*  lcKey   = IIF(lcTrType='S',ShipNo,'')+Po+lcLnNo
*ENDIF
*N000016,6 WAM 07/04/95 Include the case of MFG order receive
DO CASE
  CASE lcTrType='C'
    lcKey  = Cuttkt+SPACE(4)
    lcType = 'M'
  CASE lcTrType $ 'PS'
   lcShipNo=ShipNo 
   lcLnNo  = LTRIM(STR(LineNo,4))+SPACE(4 -LEN(LTRIM(STR(LineNo,4))))
   lcKey   = IIF(lcTrType='S',ShipNo,'')+Po+lcLnNo
    lcType = 'I'   
  CASE lcTrType='T'   
    lcKey  = cMfgOrdNo+SPACE(4)  
    lcType = 'T' 
ENDCASE
*N000016,6 WAM 07/04/95 (End)

SELECT BomLine
IF lcTrType='S'
  SET ORDER TO TAG BomLnShp
ELSE
  SET ORDER TO TAG BomLine
ENDIF

*N000016,6 WAM 07/04/95 Hold the BOM type in a variable lcType
*N000016,6              'I' for Style POs or Shipments
*N000016,6              'C' Cutting tickets
*N000016,6              'T' MFG order
*IF SEEK('2'+lcKey) 
*B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
*B600507,1              manf. style.
*IF IIF(lcTrType $ 'PS',SEEK('I2'+lcKey),SEEK('M2'+lcKey))
IF SEEK(lcType+'2'+lcKey)
  *--Added TAK 12/18/94 Must check the RSession no too.
  DO CASE
    CASE lcTrType='S'     &&Shipment case
      LOCATE REST WHILE cIMTYP+cType+ShipNo+cTktNo+LineNo = 'I2'+lcKey FOR EMPTY(cRSession) 
    CASE lcTrType='P'
      LOCATE REST WHILE cIMTYP+cType+cTktNo+LineNo='I2'+lcKey FOR EMPTY(cRSession)
    CASE lcTrType='C'
      LOCATE REST WHILE cIMTYP+cType+cTktNo+LineNo='M2'+lcKey FOR EMPTY(cRSession) .OR. cRSession = lcSess
    *N000016,6 WAM 07/04/95 Include the case of MFG order receive      
    CASE lcTrType='T'
      LOCATE REST WHILE cIMTYP+cType+cTktNo+LineNo='T2'+lcKey FOR EMPTY(cRSession) .OR. cRSession = lcSess
  ENDCASE
  *B600507,1 TMI 06/28/95 (End)
  *--End TAK
ENDIF

IF !FOUND()
  IF lcTrType='S'     &&Shipment case
    COPY STRU TO &qWD.&TktLnTp1
    SELECT 0
    DO NetUse WITH '&qWD.&TktLnTp1',' ','EX'
    SELECT POSLN
    SET ORDER TO TAG PosLnSh
    IF SEEK(lcShipNo)
      llCrtRec=.F.
      SCAN WHILE ShipNo=lcShipNo
        lcPLnNo=LTRIM(STR(LineNo,4))+SPACE(4 -LEN(LTRIM(STR(LineNo,4))))
        lcPoKey=PO+lcPLnNo
        SELECT BomLine  
        SET ORDER TO TAG BomLine
        *B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
        *B600507,1              manf. style.
        *IF SEEK('2'+lcPoKey)
         IF IIF(lcTrType $ 'PS',SEEK('I2'+lcKey),SEEK('M2'+lcKey))
         *B600507,1 TMI 06/28/95 (End)
          REPLACE REST ShipNo  WITH lcShipNo,;
                       StyQty  WITH 0,;
                       ItemQty WITH 0,;
                       ItemAmt WITH 0 ; 
                  WHILE cIMTYP+cType+cTktNo+LineNo=IIF(lcTrType $ 'PS','I','M')+'2'+lcPoKey ;
                  FOR Style+SClr=lcStyle+lcSclr
          *B600507,1 TMI 06/28/95 (End)
         ELSE
          *B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
          *B600507,1              manf. style.
          SEEK IIF(lcTrType $ 'PS','I1'+lcPoKey,'M1'+lcPoKey)
         *SEEK '1'+lcPoKey   
          *B600507,1 TMI 06/28/95 (End)
          *-- WAM 01/03/95
          *-- Do not create records type '2' from records type '1' for
          *-- voided items
          COPY REST WHILE cType+cTktNo+LineNo='1'+lcPoKey ;
               FOR Style+SClr=lcStyle+lcSclr .AND. !LVOID TO &qWD.&TktLnTp2
               
          *MAN
          SELECT 0
          USE &QWD.&TktLnTp2
          REPLACE ALL SHIPNO WITH lcShipNo   
          USE
     
          SELECT &TktLnTp1
          APPEND FROM &qWD.&TktLnTp2
          llCrtRec=.T.
        ENDIF
      ENDSCAN
      IF llCrtRec
        SELECT &TktLnTp1
        *B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
        *B600507,1              manf. style.
        REPLACE ALL cIMTyp  WITH IIF(lcTrType $ 'PS','I','M') ;
                    cType   WITH '2',;
                    ShipNo  WITH lcShipNo,;
                    StyQty  WITH 0,;
                    ItemQty WITH 0,;
                    ItemAmt WITH 0
        *B600507,1 TMI 06/28/95 (End)
        USE
        SELECT BomLine
        APPEND FROM &qWD.&TktLnTp1
      ENDIF
      IF USED(TktLnTp1)
        SELECT &TktLnTp1
        USE 
      ENDIF
    ENDIF  
  *-------------------------------------------------------
  ELSE             &&PO or CUTTKT cases
    *N000016,6 WAM 07/04/95 Hold the BOM type in a variable lcType  
    *SEEK IIF(lcTrType $ 'PS','I1','M1')+lcKey
    *SEEK '1'+lcKey
    SEEK lcType+'1'+lcKey
    *-- WAM 01/03/95
    *-- Do not create records type '2' from records type '1' for voided items
    *N000016,6 WAM 07/04/95 Include the case of MFG order receive    
    *IF lcTrType='C'
     IF lcTrType $ 'CT'
      COPY REST WHILE cType+cTktNo+LineNo='1'+lcKey ;
           FOR Style=lcStyle .AND. !LVOID TO &qWD.&TktLnTp1
    ELSE
      COPY REST WHILE cType+cTktNo+LineNo='1'+lcKey ;
           FOR Style+SClr=lcStyle+lcSclr .AND. !LVOID TO &qWD.&TktLnTp1
    ENDIF
    SELECT 0
    DO NetUse WITH '&qWD.&TktLnTp1',' ','EX'
    *B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
    *B600507,1              manf. style.
    *N000016,6 WAM 07/04/95 Hold the BOM type in a variable lcType      
    *REPLACE ALL cIMTyp  WITH IIF(lcTrType $ 'PS','I','M')
    REPLACE ALL cIMTyp  WITH lcType ,;
                cType   WITH '2',;
                StyQty  WITH 0,;
                ItemQty WITH 0,;
                ItemAmt WITH 0
    *B600507,1 TMI 06/28/95 (End)
    USE
    SELECT BomLine
    APPEND FROM &qWD.&TktLnTp1
  ENDIF

ENDIF

SELECT BomLine

RETURN
*-End...



*-------------------------------------------------------
FUNCTION lfBrowType
PARAMETER lcType, lcDesc, llExitFlg
*-------------------------------------------------------
PRIVATE lnChoice, lsBrowScr
IF !INLIST(&lcType,'01','02','03','04')
  SAVE SCREEN TO lsBrowScr
  DO DRAWBOX WITH qClrBlk,'',02,33,07,60 
  SET COLOR TO &qClrBlk
  lnChoice = 0
  DO WHILE .T.
    @ 03,35 PROMPT '01 => SALES             '
    @ 04,35 PROMPT '02 => STYLE INVENTORY   '
    @ 05,35 PROMPT '03 => MATERIAL INVENTORY'
    @ 06,35 PROMPT '04 => WORK IN PROCESS   '
    MENU TO lnChoice
    IF lnChoice = 0 .AND. !llExitFlg
      LOOP
    ENDIF
    EXIT
  ENDDO  
  RESTORE SCREEN FROM lsBrowScr
  DO CASE
    CASE lnChoice = 0
      &lcType = SPACE(2)
    CASE lnChoice = 1
      &lcType = '01'
    CASE lnChoice = 2  
      &lcType = '02'
    CASE lnChoice = 3
      &lcType = '03'
    CASE lnChoice = 4
      &lcType = '04'
  ENDCASE    
ENDIF  
DO CASE
  CASE &lcType = '  '
    &lcDesc = '                  '
  CASE &lcType = '01'
    &lcDesc = 'SALES             '
  CASE &lcType = '02'
    &lcDesc = 'STYLE INVENTORY   '
  CASE &lcType = '03'
    &lcDesc = 'MATERIAL INVENTORY'
  CASE &lcType = '04'
    &lcDesc = 'WORK IN PROCESS   '
ENDCASE      
SET COLOR TO &qClrSay  
RETURN(.T.)

*!*************************************************************************
*! Name : gpApdBom
*! Auth : Timour Abdalla Khalil
*! Date : 11/24/94.
*!         
*! Synopsis : To create records in cuttkt bom and bom line files
*!            with type '1' only if we add a new line on PO or CUTTKT
*!            with status 'O' and has a Bom information.
*! 
*! Calls from : STY630.prg,STY650.prg,MFG200.prg .
*! 
*! Modifications :
*N000016,4 WAM 05/07/95 Modify the procedure to include the case of MFG order
*! 

PROCEDURE gpApdBom

PARA lcMIFlg,lcTkt,lcStyle,xStyClr,lcWareCode,lcLinkCode,lcWokALn,llCrtT2

*N000016,4 WAM 05/07/95 Empty the flag field for the Ticket being modified
SELECT CTktBom
IF SEEK(lcMiFlg+lcTkt)
  REPLACE REST FLAG WITH SPACE(1) WHILE cIMTyp+CutTkt=lcMIFlg+lcTkt
ENDIF

SELECT BOM
SEEK lcStyle
SCAN WHILE Style = lcStyle FOR IIF(lcMIFlg= 'T',lMaterial,!lMaterial)

  *N000016,4 WAM 05/07/95 Include the case of MFG order
  *IF !(cCatGTyp$'MDP') .AND. (SCLR <> xStyClr) .AND. (SCLR <> '******')
  *  LOOP
  *ENDIF
  IF (lcMIFlg = 'I' .OR. (lcMIFlg $ 'MT' .AND. cCatGTyp <> 'M'));
    .AND. (SCLR <> xStyClr) .AND. (SCLR <> '******')
    LOOP
  ENDIF

  xItem = Item
  xIClr= IIF(cCatGTyp $ 'MDP',SPACE(6),IIF(BOM.IClr='******',xStyClr,IClr))
  xDyelot1=IIF(lcMIFlg $ 'MT',&lcWokALn..Dyelot,SPACE(10))        

  SELECT CTKTBOM

  IF lcMIFlg $ 'MT' .AND. xDyelot_S .AND. BOM.cCatGTyp = 'S' .AND. ;
      SEEK(xItem+xIClr,'Style') .AND. Style.Dyelot = 'N'
    xDyelot1 = SPACE(10)
  ENDIF      
  IF lcMIFlg $ 'MT' .AND. xDyelot_S .AND.  ;
     ( BOM.cCatGTyp = 'F' .OR. (BOM.cCatGTyp='T' .AND. BOM.Trim_Invt)) .AND. ;
      SEEK(SUBSTR(xItem,1,7)+xIClr,'Fabric') .AND. Fabric.Dyelot = 'N'
    xDyelot1 = SPACE(10)
  ENDIF      

  *N000016,4 WAM 05/07/95 In case of cutting tickets and MFG orders and,
  *N000016,4 WAM 05/07/95 dyelot system, Check existence of the Style/Color/
  *N000016,4 WAM 05/07/95 Dyelot in the CtktBom file.
  *XKEY = lcMIFlg+lcTkt+BOM.TYP+IIF(!(BOM->cCatGTyp$'MDP'),BOM->ITEM,;
  *      BOM->MFGCODE)+XICLR
  IF lcMIFlg $ 'MT' .AND. xDyelot_S .AND. (BOM.cCatGTyp$'FS' ;
    .OR. (BOM.cCatGTyp='T' .AND. BOM.Trim_Invt))
    XKEY = lcMIFlg+lcTkt+BOM.TYP+IIF(!(BOM.cCatGTyp$'MDP'),BOM.ITEM,;
           BOM.MFGCODE)+XICLR+XDYELOT1
  ELSE
    XKEY = lcMIFlg+lcTkt+BOM.TYP+IIF(!(BOM.cCatGTyp$'MDP'),BOM.ITEM,;
                 BOM.MFGCODE)+XICLR
  ENDIF
  IF !SEEK(XKEY)
    APPEND BLANK
    REPLACE CUTTKT    WITH lcTkt,;
            CIMTYP    WITH lcMIFlg,;
            cCatGTyp  WITH BOM.cCatGTyp,;
            cWareCode WITH lcWareCode,;
            TYP       WITH BOM.TYP,;
            ITEM      WITH BOM.ITEM,;
            ICLR      WITH XICLR,;
            DESC      WITH BOM->DESC
          * Link_Code WITH lcLinkCode
    *N000016,4 WAM 05/07/95 Update the dyelot field.
    IF (cCatGTyp$'FS' .OR. (cCatGTyp='T' .AND. BOM.Trim_Invt))
      REPLACE DYELOT WITH XDYELOT1
    ENDIF

    *N000016,4 WAM 05/07/95 Include the case of MFG order
    *IF lcMIFlg = 'M' .OR. (lcMIFlg = 'I' .AND. cCatGTyp $ 'FS')
    IF lcMIFlg $ 'MT' .OR. (lcMIFlg = 'I' .AND. cCatGTyp $ 'FS')    
      REPLACE UntCost   WITH BOM.UntCost

      *N000016,4 WAM 05/07/95 Include Maintained Inventory trims
      *IF cCatGTyp = 'F' .AND. SEEK(SUBSTR(ITEM,1,7)+ICLR,'Fabric')
      IF (cCatGTyp = 'F' .OR. (cCatGTyp='T' .AND. BOM.Trim_Invt)) ;      
              .AND. SEEK(SUBSTR(ITEM,1,7)+ICLR,'Fabric')                

        *N000016,4 WAM 05/07/95 Use the fabric standard code
        *REPLACE UntCost WITH IIF(XAVG_COST,Fabric->Ave_Cost,Fabric->CostUse)
        REPLACE UntCost WITH Fabric.CostBuy/Fabric.Conv ,;
                WIDTH   WITH FABRIC->Width
      ENDIF
      IF cCatGTyp = 'S' .AND. SEEK(ITEM+ICLR,'Style')
        *N000016,4 WAM 05/07/95 Use the style standard cost
        *REPLACE UntCost WITH IIF(XAVG_COST,Style.Ave_Cost,Style.TotCost)
        REPLACE UntCost WITH Style.TotCost        
      ENDIF
    ENDIF
    IF cCatGTyp $ 'MDP'
      REPLACE MFGCODE WITH BOM->MFGCode
    ENDIF
    REPLACE UOM WITH BOM->UOM,;
            DATE WITH DATE(),;
            TRIM_INVT WITH IIF((BOM->cCatGTyp='T';
                                .AND. BOM->TRIM_INVT),.T.,.F.)  
  ENDIF

  *-- HAS NOT BEEN ADDED ALREADY FOR THIS COLOR
  IF FLAG <> 'Y'
    REPLACE PIECES WITH PIECES + &lcWokALn->TOTQTY,;
            FLAG   WITH 'Y'
  ENDIF
  REPLACE REQ_QTY   WITH REQ_QTY + &lcWokALn->TOTQTY * BOM->TOTQTY ,;
          UNTQTY    WITH IIF(PIECES<>0,REQ_QTY/PIECES,0)

  *N000016,4 WAM 05/07/95 Include the case of MFG order
  *IF lcMIFlg = 'M' .OR. (lcMIFlg = 'I' .AND. cCatGTyp $ 'FS')
  IF lcMIFlg $ 'MT' .OR. (lcMIFlg = 'I' .AND. cCatGTyp $ 'FS')
    *REPLACE Est_Cost  WITH Est_Cost + ROUND(Req_Qty * UntCost,2)

    *B605900,1 AMH Rounding with 3 [Start] Also fixed bug# B605857
    *REPLACE Est_Cost  WITH Est_Cost + ;
          ROUND( (EVAL(lcWokALn+'.TOTQTY')* BOM.TOTQTY)* UntCost,2)
    REPLACE Est_Cost  WITH Est_Cost + ;
          ROUND( (EVAL(lcWokALn+'.TOTQTY')* BOM.TOTQTY)* UntCost,3)
    *B605900,1 AMH [End]

  ELSE
    DO CASE
      CASE cCatGTyp = 'P'
        lnTotCost = ROUND(PosLn.Price * PosLn.TotQty,2)
      CASE BOM.nPercent = 0
        lnTotCost = ROUND(BOM.TotCost * PosLn.TotQty,2)
      CASE BOM.nPercent > 0
        lnTotCost = ROUND(((PosLn.Price * BOM.nPercent)/100);
                    * PosLn.TotQty,2)
    ENDCASE

    REPLACE Est_Cost WITH Est_Cost + lnTotCost,;
            UntCost  WITH IIF(Pieces<>0,Est_Cost/Pieces,0)
  ENDIF

  IF BOM.cCatGTyp = 'S'
    REPLACE REQ_QTY1 WITH REQ_QTY1 + ((&lcWokALn->QTY1)*UNTQTY),;
            REQ_QTY2 WITH REQ_QTY2 + ((&lcWokALn->QTY2)*UNTQTY),;
            REQ_QTY3 WITH REQ_QTY3 + ((&lcWokALn->QTY3)*UNTQTY),;
            REQ_QTY4 WITH REQ_QTY4 + ((&lcWokALn->QTY4)*UNTQTY),;
            REQ_QTY5 WITH REQ_QTY5 + ((&lcWokALn->QTY5)*UNTQTY),;
            REQ_QTY6 WITH REQ_QTY6 + ((&lcWokALn->QTY6)*UNTQTY),;
            REQ_QTY7 WITH REQ_QTY7 + ((&lcWokALn->QTY7)*UNTQTY),;
            REQ_QTY8 WITH REQ_QTY8 + ((&lcWokALn->QTY8)*UNTQTY)
  ENDIF
  *B602658,4 [BEGIN] Replace fields ADD_DATE , ADD_TIME , ADD_USERID 
  *                  and its values with calling gfAdd_Info('<File Name>')

  *REPLACE ADD_DATE WITH DATE(),;
          ADD_TIME WITH TIME(),;
          ADD_USERID WITH QUSERID
  =gfAdd_Info('CTKTBOM')
  *B602658,4 [END..] Replace fields ADD_DATE , ADD_TIME , ADD_USERID 
  *                  and its values with calling gfAdd_Info('<File Name>')

  SELECT BOM
  
  =lfApnLn(@lcTkt) 

ENDSCAN           && end scan on bom file

RETURN

*!*************************************************************
*! Name : FUNCTION lfApnLn
*! Auth : Timour A.K.
*! Date : 11/24/94.
*!         
*! Synopsis : To append records in Bom detail file.
*!          
*! Calls from : PROCEDURE  gpApdBom.
*!          
FUNCTION lfApnLn
PARAMETER lcTkt
PRIVATE lcSess

*G000000,1 06/25/95 MFM (Begin) Save the line number to used in the seek.
DO CASE
  CASE lcMIFlg = 'I'
    *SELECT POSLN
    lcLine = PADR(ALLTRIM(STR(PosLn.LineNo)),4,' ')
  *CASE lcMIFlg = 'M'
    *SELECT CUTTKTL
  CASE lcMIFlg $ 'MT'
    lcLine = SPACE(4)
ENDCASE
*G000000,1 06/25/95 MFM (End).
  
SELECT BomLine
lcOldTag = SYS(22)              &&G000000,1 06/25/95 MFM Save the old order.
SET ORDER TO TAG BOMLINE        &&G000000,1 06/25/95 MFM Switch to the req. order.

*G000000,1 06/25/95 MFM (Begin) Added the seek.
*B600507,1 TMI 06/28/95 Changed the index to contain "CIMTYP"->'M'for
*B600507,1              manf. style and  "I" for imported style.

*IF SEEK('1'+lcTkt+lcLine+BOM.Typ+lcStyle+xStyClr+IIF(.NOT.(BOM.cCatGTyp$"MDP"),BOM.Item,BOM.MfgCode)+CTKTBOM->IClr)
IF SEEK(lcMIFlg+'1'+lcTkt+lcLine+BOM.Typ+lcStyle+xStyClr+IIF(.NOT.(BOM.cCatGTyp$"MDP"),BOM.Item,BOM.MfgCode)+CTKTBOM->IClr)
  *G000000,1 06/25/95 MFM (Begin) If found then add to the record the new qty.
  REPLACE StyQty   WITH StyQty+ &lcWokALn..TOTQTY,;
          ItemQty  WITH StyQty * UnitQty,;
          ItemAmt  WITH ItemQty * UnitCost

ELSE
  APPEND BLANK
  REPLACE cIMTyp   WITH lcMIFlg ,;
          cTktNo   WITH lcTkt,;
          LineNo   WITH IIF(lcMIFlg = 'I',ALLTRIM(STR(PosLn.LineNo)),SPACE(0)),;
          Style    WITH lcStyle,;
          SClr     WITH xStyClr,;
          cBomTyp  WITH BOM.Typ,;
          cType    WITH '1',;
          cCatGTyp WITH BOM.cCatGTyp,;
          UnitQty  WITH BOM.TotQty,;
          UnitCost WITH IIF(cCatGTyp $ 'MPD',BOM.UntCost,CTKTBOM->UntCost),;
          StyQty   WITH (&lcWokALn->TOTQTY),;
          ItemQty  WITH (StyQty * UnitQty),;
          ItemAmt  WITH (ItemQty * UnitCost)
  *B600507,1 TMI 06/28/95 (End)  
  IF cCatGTyp $ 'MPD'
    REPLACE MfgCode WITH BOM.MfgCode
  ELSE
    REPLACE Item WITH BOM.Item,;
            IClr WITH CTKTBOM->IClr
  ENDIF


ENDIF

SCATTER TO laFields    &&G000000,1 06/25/95 MFM Save BomLine Information to array.

IF llCrtT2
  *G000000,1 06/25/95 MFM (Begin) Added.
  IF SEEK(lcMIFlg+'2'+lcTkt+lcLine+BOM.Typ+lcStyle+xStyClr+IIF(.NOT.(BOM.cCatGTyp$"MDP"),BOM.Item,BOM.MfgCode)+CTKTBOM->IClr)
    LOCATE REST ;
         WHILE CIMTYP+CTYPE+CTKTNO+LINENO+CBOMTYP+STYLE+SCLR+IIF(.NOT.(CCATGTYP$"MDP"),ITEM,MFGCODE)+ICLR+STR(RECNO(),7)=;
               lcMIFlg+'2'+lcTkt+lcLine+BOM.Typ+lcStyle+xStyClr+IIF(.NOT.(BOM.cCatGTyp$"MDP"),BOM.Item,BOM.MfgCode)+CTKTBOM->IClr;
         FOR EMPTY(CRSESSION)
  ENDIF          
  IF FOUND()
    *G000000,1 06/25/95 MFM (Begin) Either from the seek or the locate.
    REPLACE StyQty   WITH StyQty +(&lcWokALn->TOTQTY),;  
            ItemQty  WITH ItemQty+(StyQty  * UnitQty),;
            ItemAmt  WITH ItemAmt+(ItemQty* UnitCost)
  ELSE
    *-- To create type '2' records.
    APPEND BLANK
    GATHER FROM laFields
    REPLACE cIMTyp   WITH lcMIFlg ,;
            cType    WITH '2',;
            StyQty   WITH 0,;
            ItemQty  WITH 0,;
            ItemAmt  WITH 0
  ENDIF
  *G000000,1 06/25/95 MFM (End).
ENDIF

SET ORDER TO TAG (lcOldTag)  &&G000000,1 06/25/95 MFM Restore the old order.

*!*************************************************************
*! Name : Install.
*! Auth : Mohamed Fahmy Mohamed (MFM).
*! Date : 01/02/95.
*! 
*! Synopsis : If there is a 'CONTROL.NEW' then update file structre, 
*!            reindex files, update system files and execute all fix 
*!            programs if nedded.
*!*************************************************************
PROCEDURE Install
PRIVATE lcUpdtFile, lcIndxFile, lcSysFiles, lnChoice, lsUpdtAll1, Choice

*-- Initiliaze the required variables.
DIMENSION laPrgToRun[ 3 ,2 ]
DIMENSION laPrgDsc  [ 3 ]
laPrgDsc[ 1 ] = 'UPDATE FILE STRUCTURE'
laPrgDsc[ 2 ] = 'REINDEX FILES'
laPrgDsc[ 3 ] = 'UPDATE SYSTEM FILES DEFAULTS'
STORE 'Y' TO laPrgToRun[ 1 ,2 ], laPrgToRun[ 2 ,2 ], laPrgToRun[ 3 ,2 ]
llClear  = .T.
lnGrid   = 3

SAVE SCREEN TO lsUpdtAll1

DO WHILE .T.
  =lfPutGet( llClear, lnGrid , lnGrid , 01, 'INSTALLATION' )

  Choice = ' '
  DO Msg22 WITH '<P>roceed <M>odify <C>ancel ?', 'PMC'
  
  DO CASE 
    CASE Choice = 'P'
    
      llFixAll  = .T.
      Choice    = ' '
      llNoSpace = .F.
      lcChoice  = 'A'

      FOR lnI = 1 TO 3
        IF laPrgToRun[ lnI, 2 ] = 'Y'
          FOR lnY = 1 TO IIF( lnI = 3, 1, 2 )
            Choice   = IIF( Choice = 'S' , 'C', 'S' )
            lcOldCh  = Choice
            MECHOICE = IIF( lnI = 1, 4, IIF( lnI = 2, 1, 14) )
            IF lnY = 1 .OR. FILE('&qLB.CustCatg.DBF')
              DO FileUtl WITH MECHOICE
            ENDIF
            Choice = lcOldCh
          ENDFOR
        ENDIF
      ENDFOR
      
      IF llNoSpace
        =gfDialog('I', 'Disk space problem has occured during to the update of file structure.',;
                       'We recommend not to use the system at this point.',;
                       'Please create more disk space and then run the update file structure',;
                       'program from the file utilties under the system mangmnet.')
      ENDIF

    CASE Choice = 'M'
      llClear = .F.
      LOOP
  ENDCASE  
  
  EXIT
ENDDO

*-- Run all fix program if nedded.
RELEASE laPrgToRun
RELEASE laPrgDsc
=lfFixPrg()

RESTOR SCREEN FROM lsUpdtAll1
RETURN

*!*************************************************************
*! Name : lfFixPrg.
*! Auth : Mohamed Fahmy Mohamed (MFM).
*! Date : 01/02/95.
*! 
*! Synopsis : Run All fix program (stored in the fixprg file) if nedded.
*!*************************************************************
FUNCTION lfFixPrg
PRIVATE lcPrompt, lnNoOfLn, laPrgToRun, laPrgDsc, lcCond, lnRelNo, lcFile,;
        llOkToRun, lnI, lcRun, lnRelsNo, lnNoPrg, lcDir

*-- Get the relase number from the control file.
RESTORE FROM AdPara&qSysCode ADDITIVE
lnRelsNo = M_ReleNo
RELEASE ALL LIKE M_*

*-- Open the control file and initialize the release number.
SELECT 0
DO NetUse WITH 'Control', '', 'EX'

lnNoCmp  = RECCOUNT()
lnNoCmp  = IIF( lnNoCmp = 0 , 1 , lnNoCmp )
DIMENSION laDd  [ lnNoCmp ]
lnI = 1
DO WHILE !EOF()
  *E300284,1 MAN 08/30/95  Data Dir depends on either a defined enviromental Var. 
  *                        that holds a Remote path or depends on the defaul path
  *laDd[ lnI ] = Dd
  *E301109,1 Change ARIADATA to DATA27
  *laDd[ lnI ] = ALLTRIM(GETENV("ARIADATA"))
  laDd[ lnI ] = ALLTRIM(GETENV("DATA27"))
  *E301109,1 end
  laDd[ lnI ] = IIF(EMPTY(laDd[ lnI ]),FULLPATH(""),laDd[ lnI ]) + ALLTRIM(Dd)
  *E300284,1 MAN End
  lnI         = lnI + 1
  SKIP
ENDDO

*-- Open the fix programs file.
SELECT 0
DO NetUse WITH '&qLB.FixPrg', '', 'EX'

lnNoPrg  = RECCOUNT()
lnNoPrg  = IIF( lnNoPrg  = 0 , 1 , lnNoPrg )
lnNoOfLn = 0
DIMENSION laPrgToRun[ lnNoPrg ,2 ]
DIMENSION laPrgDsc  [ lnNoPrg ]

DO WHILE !EOF()
  lcCond   = cProgCond
  lcFile   = ALLTRIM( cFile )
  
  *B500826,1 MFM 07/12/95 (Begin) Added a field in the file to hold the
  *B500826,1 MFM          file data directory.
  *E300637,1 Use the new global variables names
  *lcDir    = IIF(EMPTY(cDir),qDD,ALLTRIM(cDir))
  lcDir    = IIF(EMPTY(cDir),gcDataDir,ALLTRIM(cDir))
  *E300637,1 (End)
  
  *B500826,1 MFM 07/12/95 (End).
  *-- YMA 08/07/95
  lcDir    = IIF(SUBSTR(lcDir,LEN(lcDir)-1,1)="\",lcDir,lcDir+"\")
  *-- YMA 08/07/95
  
  llOkToGo = .T.
  
  DO CASE
    CASE !EMPTY( lcCond )
  
      IF !EMPTY( lcFile ) .AND. !USED( '&lcFile' )
        *B500826,1 MFM 07/12/95 (Begin) Added a field in the file to hold the
        *SELECT 0
        *DO NetUse WITH '&qDD.&lcFile', ' ', 'SH'
        =gfOpenFile(lcDir+lcFile,'','SH')
        *B500826,1 MFM 07/12/95 (Begin) Added a field in the file to hold the
      ENDIF

      &lcCond
      llOkToGo = FOUND()
      *-- Close the file.
      USE
    CASE FixPrg.nRelease <> 0

      *-- 'lnRelsNo' Initialized from the control file.
      llOkToGo = IIF( lnRelsNo < FixPrg.nRelease, .T., .F. )

    CASE EMPTY( lcCond ) .AND. FixPrg.nRelease = 0
    
      llOkToGo = .T.
  ENDCASE
  
  IF llOkToGo
    lnNoOfLn = lnNoOfLn + 1
    laPrgDsc  [ lnNoOfLn ]    = ALLTRIM( FixPrg.cProgDesc )
    laPrgToRun[ lnNoOfLn ,1 ] = ALLTRIM( FixPrg.cProgId )
    laPrgToRun[ lnNoOfLn ,2 ] = 'Y'
  ENDIF
  
  SELECT FixPrg
  SKIP
ENDDO

*-- Update the control file with the new release number.
SELECT Control
REPLACE ALL nReleaseNo WITH lnRelsNo
GO TOP

IF lnNoOfLn = 0
  RETURN
ENDIF

llClear = .T.

DO WHILE .T.
  =lfPutGet( llClear, lnNoOfLn , lnNoOfLn , 01, 'FIX PROGRAMS')

  Choice = ' '
  DO Msg22 WITH '<P>roceed <M>odify <C>ancel ?', 'PMC'
  
  DO CASE 
    CASE Choice = 'P'
      FOR lnI = 1 TO lnNoOfLn
        *E300637,1 Use the new global variables names
        *lcQDd = qDd
        lcQDd = gcDataDir
        *E300637,1 (End)
        FOR lnY = 1 TO lnNoCmp
          lnRecNo = RECNO()
          *E300637,1 Use the new global variables names
          *qDD = ALLTRIM( laDd[ lnY ] )
          gcDataDir = ALLTRIM( laDd[ lnY ] )
          *E300637,1 (End)
          IF laPrgToRun[ lnI ,2 ] = 'Y'
            lcRun = laPrgToRun[ lnI ,1 ]
            DO &lcRun
          ENDIF
        ENDFOR 
      ENDFOR
      *E300637,1 Use the new global variables names
      *qDd = lcQDd
      gcDataDir = lcQDd
      *E300637,1 (End)
    CASE Choice = 'M'
      llClear = IIF( lnNoOfLn > 10 , .T. , .F. )
      LOOP
  ENDCASE  
  
  EXIT
ENDDO

RETURN .T.

*!*************************************************************
*! Name : lfPutGet.
*! Auth : Mohamed Fahmy Mohamed (MFM).
*! Date : 01/02/95.
*! 
*! Synopsis : Dispalay the grid and read the inputs for the execution.
*!*************************************************************
FUNCTION lfPutGet
PARAMETERS llClear, lnOrgGrd, lnNewGrd, lnPrmtNo, lcHder

PRIVATE lnPlusLn, lnFrm, lnTo, lnI

lnPlusLn = 00
lnTo     = 49
lnFrm    = 05
lnNewGrd = IIF( lnNewGrd > 10, 10 , lnNewGrd )

SET COLOR TO &qClrNrm

IF llClear
  *-- Clear the screen and put the sselection grid.
  CLEAR
  DO Header WITH 'Install', lcHder
  DO GRID WITH lnNewGrd, 'N'
  FOR lnI = lnPrmtNo TO lnNewGrd + lnPrmtNo - 1
    @ 03 + lnPlusLn ,lnFrm SAY PADR( laPrgDsc[lnI], lnTo , '.' ) + ':'
    lnPlusLn = lnPlusLn + 2
  ENDFOR
ENDIF

lnPlusLn = 0
FOR lnI = lnPrmtNo TO lnNewGrd + lnPrmtNo - 1
  @ 03 + lnPlusLn ,lnFrm + lnTo + 02 GET laPrgToRun[ lnI ,2 ] PICTURE 'Y'
  lnPlusLn = lnPlusLn + 2
ENDFOR
READ

IF lnOrgGrd > 10 .AND. lnNewGrd = 10 .AND. lnPrmtNo <> lnOrgGrd
  =lfPutGet( .T., lnOrgGrd, lnOrgGrd - lnI + 1, lnI , lcHder)
ENDIF

RETURN .T.





*!*************************************************************
*! Name : gfActPop.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/03/95
*! 
*! Synopsis : Dispalay a popup.
*!*************************************************************
FUNCTION gfActPop
PARAMETERS lnRow1,lnCol1,lnRow2,lnCol2,lcContNam,;
           lcReturn,lcDisplay,lcSayVar,lcPopWindo

lnDefBar   = 1
lcCode     = ''  
lnFound    = 0

IF TYPE("lcReturn") = 'C'
  *-- If the popup from field in a file
  lcOldFile = ALIAS()
  SELECT (lcContNam)  
  LOCATE
  IF !FOUND()
    = gfDialog ("I","File is empty.")
    SELECT (lcOldFile)
    RETURN " "
  ENDIF

  *-- Define popup from field.
  IF TYPE('lcPopWindo') = 'C'
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           PROMPT FIELD &lcDisplay;
           MARGIN ;
           MARK "" ;
           SCROLL;
           SHADOW ;
           IN WINDOW(lcPopWindo)
  ELSE
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           PROMPT FIELD &lcDisplay;
           MARGIN ;
           MARK "" ;
           SHADOW;
           SCROLL           
  ENDIF
  *-- Deactivate the popup on selection any bar.
  ON SELECTION POPUP lcList DEACTIVATE POPUP lcList

  lnFound = 0
  GO TOP
  COUNT WHILE UPPER(ALLTRIM(EVALUATE(lcDisplay)))<> ;
              UPPER(ALLTRIM(lcSayVar)) TO lnFound
  IF lnFound > 0
    lcCode   = &lcReturn
    lnDefBar = _TALLY + 1
  ENDIF
  ACTIVATE POPUP lcList BAR lnDefBar
  IF LASTKEY() = 13
    lcSayVar = &lcDisplay
    lcCode   = &lcReturn
  ENDIF
  RELEASE POPUP lcList  
  SELECT (lcOldFile)
  RETURN (lcCode)
ELSE
  *-- If the popup from array.
  IF TYPE('lcPopWindo') ='C'
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           MARGIN ;
           MARK "" ;
           SCROLL;
           SHADOW ;
           IN WINDOW (lcPopWindo)
  ELSE
    DEFINE POPUP lcList ;
           FROM lnRow1+1,lnCol1 TO lnRow2,lnCol2;
           MARGIN ;
           SCROLL;
           MARK "" ;
           SHADOW
  ENDIF
  *-- Fill the popup with the element of the array.
  lcArrElm=lcContNam+'[lnI,lcDisplay]'
  FOR lnI = 1 TO ALEN(&lcContNam,1)
    DEFINE BAR lnI OF lcList PROMPT &lcArrElm
  ENDFOR

  *-- Deactivate the popup on selection any bar.
  ON SELECTION POPUP lcList DEACTIVATE POPUP lcList
  lnFound = ASCAN(&lcContNam,ALLTRIM(lcSayVar))
  IF lnFound > 0
    lnDefBar = ASUBSCRIPT(&lcContNam,lnFound,1)
    lcCode   = &lcContNam[lnDefBar,lcReturn] 
  ENDIF 
  ACTIVATE POPUP lcList BAR lnDefBar
  RELEASE POPUP lcList
  IF LASTKEY() = 13
    lcSayVar = &lcContNam[IIF(BAR()=0 .OR. BAR()>ALEN(&lcContNam,1),1,BAR()),lcDisplay]
    lcCode   = (&lcContNam[IIF(BAR()=0 .OR. BAR()>ALEN(&lcContNam,1),1,BAR()),lcReturn])
  ENDIF  
  RETURN lcCode
ENDIF


*!*************************************************************
*! Name : gfFillPop.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/03/95
*! 
*! Synopsis : To fill a popup from an array.
*!*************************************************************
FUNCTION gfFillPop
PARAMETERS lcPopNam,laPopAray,lnColNum

lnColNum =IIF(TYPE('lnColNum')<>'N',1,lnColNum)

RELEASE BAR ALL OF &lcPopNam


FOR lnCount = 1 to ALEN(&laPopAray,1)
  DEFINE BAR lnCount OF &lcPopNam ;
         PROMPT (ALLTRIM(&laPopAray[lnCount,lnColNum]))
ENDFOR



*!*************************************************************
*! Name : gpSetReso.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 06/03/95
*! 
*! Synopsis : To create a temp. resource file and set the 
*!            resource to this tyemp file.
*!*************************************************************
PROCEDURE gpSetReso
PARAMETERS lcFileName
PRIVATE lnAlias

lnAlias = SELECT()
*B600822,1 Hesham El-Sheltawi (Start)
*B600822,1 Remark the activation of the resource file so the system
*B600822,1 use the ADV. resource file
*SELECT 0
*USE (qRd + "ARIARESO.DBF") SHARED
*SELECT * FROM ARIARESO ;
         INTO DBF (qRd+lcFileName)
*USE IN ARIARESO
*USE IN (lcFileName)
*SET RESOURCE TO (qRd+lcFileName)
*SET RESOURCE ON
*B600822,1 Hesham El-Sheltawi (Start)
IF _DOS OR _UNIX
   *B600822,1 Hesham El-Sheltawi (Start)
   *B600822,1 replace setting of color set with global function
*  SET COLOR SET TO APPARELSET
   =gfSetClrSet() && Set the Color set of the screen
   *B600822,1 Hesham El-Sheltawi (End)
ENDIF  

*E300244,1 YI color for selected objects
PUBLIC gcReadColr
IF _DOS .OR. _MAC
  gcReadColr = ","+SCHEME(13,2)
ELSE
  gcReadColr = ",RG+/N" 
ENDIF  

SELECT(lnAlias) 

**************************************************************
* FUNC  : gfBrowLink
* DESC  : Browse all availabe link code
* AUTH  : Wael Aly Mohamed
* DATE  : 02/20/95
**************************************************************
FUNCTION gfBrowLink
PARAMETERS lcLink
PRIVATE lcAlias, tmpFile, lsBrowLink, lnRow

lcAlias = ALIAS()
*E300637,1 Use the new global variables names
*IF !USED('Gl_Link')
*  SELECT 0
*  DO NETUSE WITH '&QDD.GL_LINK','&QDD.GL_LINK','SH'
*ENDIF
=gfOpenFile(gcDataDir+'GL_LINK',gcDataDir+'GL_LINK','SH')
*E300637,1 (End)
SELECT GL_LINK
SET ORDER TO TAG GL_LINK
IF SEEK(&lcLink)
  SELECT (lcAlias)
  RETURN(.T.)
ENDIF
tmpFile = TEMPNAME()
SELECT * FROM GL_LINK WHERE LINKTYPE = '00' INTO DBF (qWD+tmpFile)
SAVE SCREEN TO lsBrowLink
DO DRAWBOX WITH QCLRMAG,'<GL LINK CODE>',4,15,20,60
SET COLOR TO &QCLRMAG
@ 05,17 SAY 'CODE DESCRIPTION                '
@ 06,16 TO 06,59
DO WHILE .T.
  SET COLOR TO &QCLRMAG
  @ 07,16 CLEAR TO 19,59
  SET COLOR TO &QCLRSAY
  lnRow  = 7
  QRECNO= 0
  SCAN WHILE lnRow < 19
    @ lnRow,17 SAY LINK_CODE
    @ lnRow,22 SAY LINKDESC
    QRECNO(lnRow)=RECNO()
    lnRow=lnRow+1
  ENDSCAN
  BP(1)=7
  BP(2)=16
  BP(4)=21
  BP(5)=60
  BP(6)='N'
  BP(7)='N'
  SET COLOR TO &QCLRMAG
  THISKEY=BROW()
  DO CASE
    CASE THISKEY = QESCKEY
      &lcLink = SPACE(3)
      EXIT
    CASE THISKEY = QRETKEY
      &lcLink = LINK_CODE
    OTHERWISE
      LOOP
  ENDCASE
  EXIT
ENDDO  
RESTORE SCREEN FROM lsBrowLink
SELECT (lcAlias)
RETURN(.T.)


*!*************************************************************************
*! Name : gpUdtSJl
*! Auth : Timour Abdalla Khalil
*! Date : 03/30/95.     
*!         
*! Synopsis : Procedure to update the style inventory journal.
*!          
*! Called from : 
*!     Programs  : STY400 ,INV100 ,INV500 ,INV300 ,MFG500 ,
*!                 STY650 ,RA400 ,RA600 ,STY700 .
*! 
*! Parameters :
*!      lcTrType   =>  Transaction type.
*!                   1 for Inventory Adjustments 
*!                   2 for Physical Inventorys   
*!                   3 for Invoices              
*!                   4 for Void Invoices         
*!                   5 for Recive Cutting Tickets
*!                   6 for Recive Purchase Orders
*!                   7 for Recive Returns        
*!                   8 for Void Credit Memos     
*!                   9 for Inventory Markdown
*!     lcStyle    =>  Style code.  
*!     lcColor    =>  Color code. 
*!     lcWareCode =>  Warehouse code.
*!     ldTrDate   =>  Transaction date.
*!     lcTrCode   =>  Transaction code as ex.invoice no.
*!     lnCost     =>  New style cost. 
*!     lnStk1 to 8=>  Size transaction qty. 
*!     lnTotStk   =>  Transaction total qty. 
*!     llMltSesn  =>  .T. for defferent session number for each record
*!                    .F. same session number for all lines.
*!     lcWAlias   =>  Work aria to replace the record.
*!                    'StyInvJL' or 'TmpStyJL'in case of consol. invoice .
*! Modifications:
*B800647,1 ARH 06/20/96 Fixed the bug File does not exist in the invoicing 
*B800647,1              program when trying to issue more then one
*B800647,1              consolidated invoice in the same session
*E300620,4 Reham On 08/06/97
*E300620,4 Remove the color field from the function.
*B601808,1 TAK 08/03/97 Added the reference field in style journal.
*! 
PROCEDURE gpUdtSJl

*B800905,4 SWK 12/25/96 Add new passed parameters with old quanties and old cost
*PARAMETERS lcTrType,lcStyle,lcColor,lcWareCode,ldTrDate,lcTrCode,lnCost,;
           lnStk1,lnStk2,lnStk3,lnStk4,lnStk5,lnStk6,lnStk7,lnStk8,;
           lnTotStk,llMltSesn,lcWAlias
*E300620,4 Reham On 08/06/97  ** Begin **
*PARAMETERS lcTrType,lcStyle,lcColor,lcWareCode,ldTrDate,lcTrCode,lnCost,;
           lnStk1,lnStk2,lnStk3,lnStk4,lnStk5,lnStk6,lnStk7,lnStk8,;
           lnTotStk,llMltSesn,lcWAlias,lnOStk1,lnOStk2,lnOStk3,lnOStk4,;
           lnOStk5,lnOStk6,lnOStk7,lnOStk8,lnOTotSk,lnOCost
*E300746,1 TAK (Start) Added new parameter to update Dyelot field.
*PARAMETERS lcTrType,lcStyle,lcWareCode,ldTrDate,lcTrCode,lnCost,;
           lnStk1,lnStk2,lnStk3,lnStk4,lnStk5,lnStk6,lnStk7,lnStk8,;
           lnTotStk,llMltSesn,lcWAlias,lnOStk1,lnOStk2,lnOStk3,lnOStk4,;
           lnOStk5,lnOStk6,lnOStk7,lnOStk8,lnOTotSk,lnOCost,lcRefer
*E300620,4 Reham On 08/06/97  ** End  **
PARAMETERS lcTrType,lcStyle,lcWareCode,ldTrDate,lcTrCode,lnCost,;
           lnStk1,lnStk2,lnStk3,lnStk4,lnStk5,lnStk6,lnStk7,lnStk8,;
           lnTotStk,llMltSesn,lcWAlias,lnOStk1,lnOStk2,lnOStk3,lnOStk4,;
           lnOStk5,lnOStk6,lnOStk7,lnOStk8,lnOTotSk,lnOCost,lcRefer,lcDyelot
*E300746,1 TAK (End).


lcOldWAr = ALIAS()
lcClrSet = SET('COLOR')
lcFlUsed = IIF(lcWAlias='StyInvJL',lcWAlias,&lcWAlias)
*B601808,1 Added.
lcRefer  = IIF(TYPE('lcRefer')$'UL','',lcRefer)
lcDyelot = IIF(TYPE('lcDyelot')$'UL','',lcDyelot)

*--Open the master style inventory journal file.
IF !USED(lcFlUsed)
  *E300637,1 Use the new global variables names
  *IF !USED('StyInvJL')
  *  SELECT 0
  *  DO NetUse WITH '&qDD.StyInvJL', '&qDD.StyInvJL', 'SH'
  *ENDIF
  =gfOpenFile(gcDataDir+'StyInvJL',gcDataDir+'StyInvJL','SH')
  *E300637,1 (End)
  SELECT StyInvJL

  IF lcWAlias='TmpStyJL' 
    *B800647,1 ARH 06/20/96 (Begin) Created Temp. database instead of
    *B800647,1              cursor to be able to open it after it gets
    *B800647,1              closed not to have the error File does not
    *B800647,1              exist in the invoicing program when trying
    *B800647,1              to open the temp style inventory journal file
    IF FILE(qWd+lcFlUsed)
      ERASE (qWd+lcFlUsed+'.DBF')
      ERASE (qWd+lcFlUsed+'.CDX')
    ENDIF
    =AFIELDS(laSJrFle)
    CREATE DBF (qWd+TmpStyJL) FROM ARRAY laSJrFle
    *B800647,1 ARH 06/20/96 (End)
    *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
    =lfCrFox2x()
    *E303074,1 TMI 02/20/2012 [End  ] 
  ENDIF

  lcSession = SPACE(6)
ELSE
  SELECT &lcFlUsed
  IF lcTrType<>'9'
    lcSession = cSession
  ENDIF

ENDIF

*--Read session no.
*E300637,1 Use the new sequence function
*IF llMltSesn
*  lcSession = Sequence('GLSESSION')
*ELSE
*  lcSession =IIF(EMPTY(lcSession),Sequence('GLSESSION'),lcSession)
*ENDIF
IF llMltSesn
  lcSession = gfSequence('GLSESSION')
ELSE
  lcSession =IIF(EMPTY(lcSession),gfSequence('GLSESSION'),lcSession)
ENDIF
*E300637,1 (End)

*--lcIRType => Transaction kind if it Issue or Receive 'I' or 'R'.
*E300746,1 TAK (Start) Added receive P/o to be Isue if it is Return P/o.
*IF ( lcTrType $ '38' .OR. (lcTrType = '1' .AND. lnTotStk<0 ) )
IF ( lcTrType $ '38' OR (lnTotStk<0 AND lcTrType $ '16') )
  lcIRType='I'
ELSE
*E300746,1 TAK (End).
  lcIRType='R'
ENDIF
SELECT &lcFlUsed
*B800905,4 SWK 12/25/96 Check if the transtype is physical or unlock append 
*B800905,4              new issueing record with old values and old cost
IF lcTrType $ '29'
  lnOStk1  = IIF(TYPE('lnOStk1') = 'U',0,lnOStk1)
  lnOStk2  = IIF(TYPE('lnOStk2') = 'U',0,lnOStk2)
  lnOStk3  = IIF(TYPE('lnOStk3') = 'U',0,lnOStk3)
  lnOStk4  = IIF(TYPE('lnOStk4') = 'U',0,lnOStk4)
  lnOStk5  = IIF(TYPE('lnOStk5') = 'U',0,lnOStk5)
  lnOStk6  = IIF(TYPE('lnOStk6') = 'U',0,lnOStk6)
  lnOStk7  = IIF(TYPE('lnOStk7') = 'U',0,lnOStk7)
  lnOStk8  = IIF(TYPE('lnOStk8') = 'U',0,lnOStk8)
  lnOStk8  = IIF(TYPE('lnOStk8') = 'U',0,lnOStk8)          
  lnOTotSk = IIF(TYPE('lnOTotSk')= 'U',0,lnOTotSk)
  lnOCost  = IIF(TYPE('lnOCost') = 'U',0,lnOCost)
  APPEND BLANK
  *E300620,4 Reham On 08/06/97  ** Begin **
  *E300620,4 Remove the color from the replacement command.
  *E300620,4 "REPLACE Color     WITH lcColor"
  REPLACE cSession  WITH lcSession,;
          Style     WITH lcStyle,;
          cWareCode WITH lcWareCode,;
          dTrDate   WITH ldTrDate,;
          cTrType   WITH lcTrType,;
          cTrCode   WITH lcTrCode,;
          nCost     WITH lnOCost ,;
          cIRType   WITH "I"     ,;
          nStk1     WITH lnOStk1 ,;
          nStk2     WITH lnOStk2 ,;
          nStk3     WITH lnOStk3 ,;
          nStk4     WITH lnOStk4 ,;
          nStk5     WITH lnOStk5 ,;
          nStk6     WITH lnOStk6 ,;
          nStk7     WITH lnOStk7 ,;
          nStk8     WITH lnOStk8 ,;
          nTotStk   WITH lnOTotSk,;
          cDyelot   WITH lcDyelot,;
          lLockFlg  WITH IIF(lcTrType='9',.T.,lLockFlg)
  *E300620,4 Reham On 08/06/97  ** End   **
ENDIF
*B800905,4 (End)

APPEND BLANK
*E300620,4 Reham On 08/06/97  ** Begin **
*E300620,4 Remove the color from the replacement command.
*E300620,4 "REPLACE Color     WITH lcColor"
*E300746,1 TAK (Start) Added new parameter to update Dyelot field.
REPLACE cSession  WITH lcSession,;
        Style     WITH lcStyle,;
        cWareCode WITH lcWareCode,;
        dTrDate   WITH ldTrDate,;
        cTrType   WITH lcTrType,;
        cTrCode   WITH lcTrCode,;
        nCost     WITH lnCost,;
        cIRType   WITH lcIRType,;
        nStk1     WITH lnStk1,;
        nStk2     WITH lnStk2,;
        nStk3     WITH lnStk3,;
        nStk4     WITH lnStk4,;
        nStk5     WITH lnStk5,;
        nStk6     WITH lnStk6,;
        nStk7     WITH lnStk7,;
        nStk8     WITH lnStk8,;
        nTotStk   WITH lnTotStk,;
        Reference WITH lcRefer,;
        cDyelot   WITH lcDyelot,;
        lLockFlg  WITH IIF(lcTrType='9',.T.,lLockFlg)
*E300620,4 Reham On 08/06/97  ** End   **
SET COLOR TO &lcClrSet
SELECT &lcOldWAr
RETURN
****


*!*************************************************************************
*! Name      : GPGETFILE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : To display reports or text files to screen
*!*************************************************************************
*: Calls       :
*:            FUNCTION : lfvOkPrint
*:            FUNCTION : lfActObj
*:            FUNCTION : lpRepTrap
*!*************************************************************************      
*: Passed parameters  : lcprogram  && file name to display
*:                      lctitle    && Title for the screen
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
PROCEDURE gpGetFile
PARAMETERS lcProgram,lcTitle
PRIVATE llTerminate,lcToProc
llTerminate = .F.  && variable used for terminating the read and releasing windows
lcToProc = ''      && variable used for proceding function after terminating the read
                   && to control the read level
lcTempCur =TempName()        && temprory cursor name
lnTypeAhead=SET('TYPEAHEAD') &&variable to hold the typeahead setting
SET TYPEAHEAD TO 128
lcTitle=IIF(TYPE('lcTitle')='C' AND !EMPTY(ALLTRIM(lcTitle)),ALLTRIM(lcTitle),'Report')
lcTitle=ALLTRIM(lcTitle)
lcConS=SET('CONSOLE')         && variable to hold the console setting
lcTop=qbd+'top.bmp'           && top bit map file for push button top
lcprior=qbd+"prior.bmp"       && prior bit map file for push button prior
lcNext=qbd+"next.bmp"         && next bit map file for push button next
lcbottom=qbd+"bottom.bmp"     && bottom bit map file for push button bottom
lcprinter1=qbd+"printer1.bmp" && print bit map file for push button print
lcclose=qbd+"close.bmp"       && close bit map file for push button close
SET CONSOLE ON
SET SHADOWS OFF
PUSH KEY
CLEAR TYPEAHEAD
*-- initializing traping needed for controling the program
ON KEY LABEL Ctrl+W DO lfvOkPrint
ON KEY LABEL ESCAPE DO lfvOkPrint
ON KEY LABEL Ctrl+Q DO lfvOkPrint
ON KEY LABEL O DO lfActObj WITH "PBOK"
ON KEY LABEL P DO lfActObj WITH "PBOUT"
ON KEY LABEL CTRL+ENTER DO lfvOkPrint
ON KEY LABEL TAB DO lpRepTrap WITH 1
ON KEY LABEL BACKTAB DO lpRepTrap WITH 2
*-- loop till the user select terminating
DO WHILE !llTerminate
  *-- MAN Changed the SPR Name from MODIFIL to MODFILE to void Calling
  *-- the existing one in AAS_DOS APP
  *E300637,1 Use the new global variables names
  *DO (qsd+'MODFILE.SPR')
  DO (gcScrDir+'MODFILE.SPR')
  *E300637,1 (End)
  *-- if we terminated the read just to validate or call another screen
  *-- the Purpose of terminating the read to use only one read level
  IF !EMPTY(lcToProc)
    &lcToProc
    lcToProc=''
  ENDIF
ENDDO
POP KEY
SET SHADOWS ON
SET CONSOLE &lcConS
SET TYPEAHEAD TO lnTypeAhead
IF USED(lcTempCur)
  USE IN (lcTempCur)
ENDIF

*!*************************************************************************
*! Name      : LFMODIPRG
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : Read level when function & to display file in previous 
*!             defined window
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfModiPrg
MODI COMM (lcProgram)  WINDOW AWDOUTfl IN WINDOW MODFILHST  NOEDIT  NOWAIT SAVE



	
*!*************************************************************************
*! Name      : LFVMODFILE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : Read level valid function
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvModFile
RETURN !WEXIST('AWDOUTFL') AND !WEXIST('OPM_BTNS') AND !WEXIST(lcTitle) AND !WEXIST('MODFILHST')

*!*************************************************************************
*! Name      : LFVOKPRINT
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : valid function for push button close
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvOkPrint
RELEASE WINDOW MODFILHST,awdoutfl, Opm_Btns
llTerminate = .T.
IF WEXIST((lcTitle))
  RELEASE WINDOW (lcTitle)
ENDIF
CLEAR READ
RETURN TO gpGetFile



*!*************************************************************************
*! Name      : LFKEBOARD
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   :
*!*************************************************************************
*: Passed parameters  : lnkeypres
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION LFKEBOARD
PARAMETER lnKeyPres
IF WONTOP()='OPM_BTNS'
  ACTIVATE WINDOW (lcTitle) TOP
ELSE
  ACTIVATE WINDOW  TOP Opm_Btns
ENDIF


*!*************************************************************************
*! Name      : LFVOUTPUT
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : valid function for push button print
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvoutput
*--initialize the next function to proceed variable & terminate the read
lcToProc = [DO lfSelDev]
CLEAR READ

*!*************************************************************************
*! Name      : LFSELDEV
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : call the sel_dev program to send output to device
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfSelDev
PRIVATE  lcOldAlias,lcToFile,llOvrWrite,lcP17Cpi,lcP10Cpi,lcP12Cpi,;
        lcNetOrLoc,lcServNme,lcQueNme,lnPrnNo,lcBanrNme

*- lcOldAlias    && variable to hold the current alias
*- lcToFile      && variable to hold the file name to output to
*- llOvrWrite    && variable to hold if the file will be overwrited
*- lcP17Cpi      && variable to hold the 17 charter per inch esc. seq.
*- lcP10Cpi      && variable to hold the 12 charter per inch esc. seq.
*- lcP12Cpi      && variable to hold the 10 charter per inch esc. seq.
*- lcNetOrLoc    && variable to hold if sending to local report or network
*- lcServNme     && variable to hold the server name 
*- lcQueNme      && variable to hold the queue name
*- lnPrnNo       && variable to hold the printer #
*- lcBanrNme     && variable to hold the banner
        
        
        
        
STORE '' TO lcOldAlias,lcToFile,llOvrWrite,lcP17Cpi,lcP10Cpi,lcP12Cpi,;
        lcNetOrLoc,lcServNme,lcQueNme,lnPrnNo,lcBanrNme
PUSH KEY
ON KEY
S_DEVICE = 'P'
*-- if user selected to print from the device screen
IF SEL_DEV(.T.,.F.,.T.,.F.,.T.)
  lcOldAlias = SELECT()
  RELEASE WINDOW (lcTitle)
  *--if the cursor is not created
  IF !USED(lcTempCur)
    CREATE CURSOR &lcTempCur (MToPrint M,MTOFILE M)
    APPEND BLANK
    *-- append the report temp. file to the memo mtofile to be used
    *-- to print to file
    APPEND MEMO MToFILE FROM (lcProgram) 
    *--memo mtoprint replaced with the report with escape sequences needed
    REPLACE MTOPRINT WITH IIF(!EMPTY(lcP17Cpi),EVAL(lcP17Cpi),'')+MToFILE+IIF(!EMPTY(lcP10Cpi),EVAL(lcP10Cpi),'')+CHR(12)
  ELSE
    *--memo mtoprint replaced with the report with escape sequences needed
    SELECT (lcTempCur)
    REPLACE MTOPRINT WITH IIF(!EMPTY(lcP17Cpi),EVAL(lcP17Cpi),'')+MToFILE+IIF(!EMPTY(lcP10Cpi),EVAL(lcP10Cpi),'')+CHR(12)
  ENDIF
  *-- selected device case
  DO CASE
    *-- case output device printer
    CASE GCDEVICE='P'
      *-- if any other platform than Unix
      IF !_UNIX
         *-- initialize the  printer "local or net"
         lcToPrinter = IIF( lcNetOrLoc = 'L', gcLoclPort,;
                        '\\SPOOLER\TI=5'+;
                        IIF( EMPTY( lcServNme ), '','\S='+ALLTRIM(lcServNme))+;
                        IIF( EMPTY( lcQueNme ) ,'','\Q='+ALLTRIM(lcQueNme))+;
                        '\P='+ALLTRIM(STR(lnPrnNo))+;
                        IIF( EMPTY( lcBanrNme ), '\NB', '\B='+STRTRAN( lcBanrNme, ' ', CHR(255) ) ) )
      ELSE
        lcToPrinter = IIF( lcNetOrLoc = 'L', gcLoclPort,'"'+ALLTRIM(lcQueNme)+'"')
      ENDIF
      *-- Set printer to selected output port or queue
      SET PRINTER TO &lcToPrinter
      *-- test if printer is not ready so display message
      DO WHILE SYS(13) = 'OFFLINE' .AND. lcNetOrLoc = 'L'
        SET DEVICE TO SCREEN
        IF gfDialog( 'I','Printer is not ready', '\<Retry;\<Cancel') = 2
          *-- Reinitialize the out put to the screen.
          RETURN
        ELSE
          LOOP
        ENDIF
      ENDDO
      llError=.F.
      lcOnErr=ON('ERROR')
      ON ERROR llError=.T.
      lcSetSafe=SET('SAFE')
      SET SAFE OFF
      *-- copy temprory file to local port to print it
      IF _WINDOWS
        COPY MEMO MTOPRINT TO (gcLoclPort)
      ELSE
        COPY MEMO MTOPRINT TO PRN
      ENDIF
      ON ERROR &lcOnErr
      SET SAFE &lcSetSafe
    *-- case output device file
    CASE GCDEVICE='F'
      *-- if file "exist and the user selected to overwrite" or new file 
      IF llOvrWrite
        COPY MEMO MTOFILE TO (lcToFile)
      ELSE
      *-- else if file exist and the user selected to append to it
        COPY MEMO MTOFILE TO (lcToFile) ADDI
      ENDIF
  ENDCASE
  =lfModiPrg()
ENDIF
S_DEVICE = 'S'
POP KEY

*!*************************************************************************
*! Name      : LFGOFIRST
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : valid function for push button to top
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfGoFirst
_CUROBJ=6
lcNOPage=IIF(WONTOP()='OPM_BTNS',["{TAB}"+],'')+["{CTRL+HOME}"]
keyboard &lcNoPage

*!*************************************************************************
*! Name      : LFVGOLAST
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : valid function for push button Bottom
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvGoLast
_CUROBJ=6
lcNOPage=IIF(WONTOP()='OPM_BTNS',["{TAB}"+],'')+["{CTRL+END}"+"{PGUP}"]
keyboard &lcNoPage


*!*************************************************************************
*! Name      : LFNEXTPAGE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : vaid function for push button next
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfNextPage
lcNOPage=IIF(WONTOP()='OPM_BTNS',["{TAB}"+],'')+["{PGDN}"]
_CUROBJ=6
keyboard &lcNoPage

*!*************************************************************************
*! Name      : LFVPREVPAGE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : valid function for push button previous
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvPrevPage
_CUROBJ=6
lcNOPage=IIF(WONTOP()='OPM_BTNS',["{TAB}"+],'')+["{PGUP}"]
keyboard &lcNoPage


*!*************************************************************************
*! Name      : LPREPTRAP
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : traping function for the display report screen
*!*************************************************************************
*: Passed parameters  : lncaseswicth
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lpRepTrap
PARAMETERS lnCaseSwicth
lcVarNam = VARREAD()
*-- case 1 Tab pressed,2 shift+tab pressed
DO CASE
  CASE lnCaseSwich = 1
    DO CASE
      *-- case called from inside the display report window
      CASE WONTOP() = lcTitle
        ACTIV WINDOW Opm_Btns
      _CUROBJ = 1
     *-- case called from the control window      
     CASE !EMPTY(lcVarNam) AND OBJNUM(&lcVarNam) = 6
       IF WEXIST(lcTitle)
         ACTIV WINDOW (lcTitle)
       ENDIF
     OTHERWISE
       KEYBOARD "{TAB}" PLAIN CLEAR
     ENDCASE
  CASE lnCaseSwich = 2
    DO CASE
      *-- case called from inside the display report window
      CASE WONTOP() = lcTitle
        ACTIV WINDOW Opm_Btns
      _CUROBJ = 6
     *-- case called from the control window       
     CASE !EMPTY(lcVarNam) AND OBJNUM(&lcVarNam) = 1
       IF WEXIST(lcTitle)
         ACTIV WINDOW (lcTitle)
       ENDIF
     OTHERWISE
       KEYBOARD "{BACKTAB}" PLAIN CLEAR
     ENDCASE
ENDCASE


*!*************************************************************************
*! Name      : LFACTOBJ
*! Developer : Hesham El-Sheltawi
*! Date      : 04/12/95    
*! Purpose   : function used for hot key simulation from inside the report
*!             displaying window
*!*************************************************************************
*: Passed parameters  : lcobjtoact
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfActObj
PARAMETERS lcObjToAct
ACTIV WINDOW Opm_Btns
_CUROBJ=OBJNUM(&lcObjToAct)
KEYBOARD "{SPACEBAR}"


*!*************************************************************************
*! Name      : AGETEXPR
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : use insted of the fox getexp command to display the logical
*!             names  of fields and variables 
*!*************************************************************************
*: Calls       :
*:            FUNCTION : lfAryBuld
*:            FUNCTION : lfGetFileFld
*!*************************************************************************      
*: Passed parameters  : lcexp        Default expression
*:                      lcfile       Intially file name to use its fields
*:                      lcexpprmpt   prompt to be displayed at the top of window
*:                      la_field     array hold fields logical names
*:                      lafield      array hold fields phisical names
*:                      lladdalias   if true expression will hold the alias names
*:                      lctype       expression type(s) to be return
*:                      lafiles      array hold the files to be use in building Exp.
*:                      la_var       array hold variable names to be use in Exp.
*:*************************************************************************
*! Returns   :  character value which is valid Expression of specific type(s)
*:*************************************************************************     
PROCEDURE AGETEXPR
PARAMETER lcExp,lcFile,lcExpPrmpt,la_Field,laField,llAddAlias,lcType,laFiles,la_Var
EXTERNAL ARRAY laScrMode,LAFILES,LA_VAR
lcMesage=IIF(EMPTY(lcExpPrmpt),"",lcExpPrmpt)
lcType=IIF(TYPE('lcType')<>'C','NLCD',lcType)
llCanVald = .T.
*IF TYPE('laScrMode')='L'
*  llCanVald = laScrMode[3] OR laScrMode[4]
*ENDIF
lcEdit = IIF(llCanVald,""," NOMODIFY")
DECLARE laFile[1,1],laVar[1,1],laMath[32,1],laDate[18,1],;
        laStr[35,1],lalogic[19,1]

=lfAryBuld()  && initialize arrays of fox functions
lnRow = 4 + IIF(EMPTY(lcExp),0,INT(LEN(ALLTRIM(lcExp))/58))
lnCol = 2 + IIF(EMPTY(lcExp),0,MOD(LEN(ALLTRIM(lcExp)),58))
lsField=0
***** build arrays holding fields and fields logical names
IF !(TYPE('laFiles') $ 'UL')
  DECLARE laFld_H[1,2],laField[1,2]
ENDIF
 =lfGetFileFld(lcFile,IIF(TYPE('laFiles') $ 'UL',.F.,.T.))


IF TYPE('lcExpPrmpt') $ "UL"
  lcExpPrmpt = ''
ENDIF

IF TYPE('lcFile')="U"
  laFile = ALIAS()
  IF !EMPTY(laFile)
    DIMENSION laField[FCOUNT()]
    FOR lnCount = 1 TO FCOUNT()
      laField[lnCount] = FIELD(lnCount)
    ENDFOR
  ENDIF
ENDIF

*B600335,1 MAN 05/25/95 (Begin) Fixed the bug when you enter the filter
*B600335,1              option in the standard browse from any browse in
*B600335,1              the system.
* Removed by MAN The default values have been moved to the ARIABROW.PRG
*IF !EMPTY(laField) AND !('U' $ lcType)
*  FOR lnCount = 1 TO ALEN(laField)
*    DO CASE
*      CASE LEFT(laField[lnCount],1)="M" OR LEFT(laField[lnCount],1)="C"
*        &laField[lnCount] = " "
*      CASE LEFT(laField[lnCount],1)="N"
*        &laField[lnCount] = 1
*      CASE LEFT(laField[lnCount],1)="D"
*        &laField[lnCount] = DATE()
*      OTHERWISE
*        &laField[lnCount] = .F.
*    ENDCASE
*  ENDFOR
*ELSE
   IF TYPE('laFiles') $ 'UL' AND EMPTY(laField)
     laField = " "
   ENDIF
*ENDIF
*B600335,1 MAN 05/25/95 (End)

mvExp = IIF(EMPTY(lcExp),"",ALLTRIM(lcExp))
IF _DOS OR _UNIX
  laFile = SPACE(INT(31-LEN(ALLTRIM(laFile)))/2)+ALLTRIM(laFile)+;
           SPACE(INT(31-LEN(ALLTRIM(laFile)))/2)
ENDIF
*B600455,1 MAN          Changed the name of GETEXPR to be AGETEXPR
*E300637,1 Use the new global variables names
*DO (qsd+'AGETEXPR.SPR')
DO (gcScrDir+'AGETEXPR.SPR')
*E300637,1 (End)

lcExp = IIF(EMPTY(lcExp),"",lcExp)
RETURN lcExp

*!*************************************************************************
*! Name      : LFSHOWEXP
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : show function for getexp screen
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfShowExp
IF !llCanVald
  SHOW GET pbVerfy DISABLE
  SHOW GET pbCancel DISABLE
ENDIF


*!*************************************************************************
*! Name      : LFVMATH
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for math fox functions popup
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvMath
IF llCanVald
  IF puMath <> 1
    DO lpWriteExp WITH laMath[puMath]
    puMath = 1
    SHOW GET puMath
  ENDIF
ELSE
  puMath = 1
  SHOW GET puMath
ENDIF

*!*************************************************************************
*! Name      : LFVSTRING
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for strin manipulation fox functions popup
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvString
IF llCanVald
  IF puStr <> 1
    DO lpWriteExp WITH laStr[puStr]
    puStr = 1
    SHOW GET puStr
  ENDIF
ELSE
  puStr = 1
  SHOW GET puStr
ENDIF

*!*************************************************************************
*! Name      : LFVLOGIC
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for logical fox functions popup
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvLogic
IF llCanVald
  IF puLogic <> 1
    DO lpWriteExp WITH laLogic[puLogic]
    puLogic = 1
    SHOW GET puLogic
  ENDIF
ELSE
  puLogic = 1
  SHOW GET puLogic
ENDIF


*!*************************************************************************
*! Name      : LFVDATE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for date fox functions popup
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvDate
IF llCanVald
  IF puDate <> 1
    DO lpWriteExp WITH laDate[puDate]
    puDate = 1
    SHOW GET puDate
  ENDIF
ELSE
  puDate = 1
  SHOW GET puDate
ENDIF


*!*************************************************************************
*! Name      : LFVFILES
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for the file popup
*!*************************************************************************
*: Calls       :
*:            FUNCTION : lfGetFileFld
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvfiles
lcFile = laFiles[puFile,2]
=lfGetFileFld(lcFile,.T.)  && get the selected file fields
lcFile = laFiles[puFile,1]
SHOW GETS


*!*************************************************************************
*! Name      : LFVVARIABE
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for the variables popup
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvVariabe
IF lsVariable > 0
  DO lpWriteExp WITH (la_Var[lsVariable,2])
ENDIF

*!*************************************************************************
*! Name      : LFVMVEXP
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   :
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvMvExp
ON KEY LABEL ENTER
lnRow = ROW()
lnCol = COL()

*!*************************************************************************
*! Name      : LFVCTRL
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : valid function for push button "cancel,ok,verify"
*!*************************************************************************
*: Passed parameters  : lnctrl
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfvCtrl
PARAMETERS lnCtrl

DO CASE
  *-- cancel
  CASE lnCtrl = 3
    CLEAR READ
  *--ok or verify  
  CASE lnCtrl = 1
    WAIT IIF(!(TYPE(mvExp) $ lcType), "Not a valid expression",;
             "Valid expression ") WINDOW NOWAIT
   OTHERWISE
     IF !EMPTY(mvExp)
       IF !(TYPE(mvExp) $ lcType)
         WAIT  "Not a valid expression" WINDOW NOWAIT
       ELSE
         lcExp = mvExp         && Added by RAM on 06/14/94
         CLEAR READ
       ENDIF
     ELSE
       lcExp = " "             && Added by RAM on 06/14/94
       CLEAR READ
     ENDIF
*     lcExp = mvExp            && Remarked by RAM on 06/14/94
ENDCASE

*!*************************************************************************
*! Name      : LFVFIELD
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : fields popup valid function
*!*************************************************************************
*: Calls       :
*:            PROCEDURE : lpWriteExp
*:*************************************************************************     
FUNCTION lfvField

IF lsField > 0
  DO lpWriteExp WITH (IIF(llAddAlias,ALLTRIM(lcFile)+'.','')+laField[lsField])
ENDIF

*!*************************************************************************
*! Name      : LPWRITEEXP
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : insert string to the expression
*!*************************************************************************
*: Passed parameters  : lcexpelm
*:*************************************************************************     
PROCEDURE lpWriteExp
PARAMETER lcExpElm
*mvExp = STUFF(mvExp,(lnRow-4)*58+lnCol-1, 0,ALLTRIM(lcExpElm)+" ")
lnHiglight=ATC('(exp',lcExpElm) && if the passed expr. has parameter
lnHiglight=IIF(lnHiglight>0,lnHiglight+4,0) 
lnRight = LEN(lcExpElm)-lnHiglight
lcCntrol = ''
IF lnHiglight>0
  FOR lnCount= 1 TO lnRight
    lcCntrol=lcCntrol+[+"{leftarrow}"]  && to control the highlight of <expr>
  ENDFOR
  FOR lnCount= 1 TO 4
    lcCntrol=lcCntrol+[+"{SHIFT+leftarrow}"] && to control the highlight of <expr>
  ENDFOR
ENDIF
*-- if the passed expr has parameter then highlight
IF !EMPTY(lcCntrol)
  KEYBOARD lcExpElm +&lcCntrol CLEAR
ELSE
  KEYBOARD lcExpElm  CLEAR
ENDIF
SHOW GET mvExp
_CUROBJ = OBJNUM(mvExp)
*KEYBOARD "{CTRL+RIGHTARROW}"


*!*************************************************************************
*! Name      : LFARYBULD
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*:*************************************************************************     
FUNCTION lfAryBuld
*-- defining the math functions array
laMath[1] = 'Math'
laMath[2] = '*'
laMath[3] = '/'
laMath[4] = '+'
laMath[5] = '-'
laMath[6] = 'ABS(expN)'
laMath[7] = 'MAX(,)'
laMath[8] = '^'
laMath[9] = 'MIN(,)'
laMath[10] = 'MOD(,)'
laMath[11] = 'PAYMENT(,,)'
laMath[12] = 'PI()'
laMath[13] = 'PV(,,)'
laMath[14] = 'RAND()'
laMath[15] = 'ACOS(expN)'
laMath[16] = 'ASIN(expN)'
laMath[17] = 'ATAN(expN)'
laMath[18] = 'ATN2(expN)'
laMath[19] = 'CEILING(expN)'
laMath[20] = 'EXP(expN)'
laMath[21] = 'FLOOR(expN)'
laMath[22] = 'FV(,,)'
laMath[23] = 'INT(expN)'
laMath[24] = 'LOG(expN)'
laMath[25] = 'LOG10(expN)'
laMath[26] = 'ROUND(expN)'
laMath[27] = 'RTOD(expN)'
laMath[28] = 'SIGN(expN)'
laMath[29] = 'SIN(expN)'
laMath[30] = 'SQRT(expN)'
laMath[31] = 'TAN(expN)'
laMath[32] = 'VAL(expC)'

*-- defining the string functions array
laStr[1] = 'String'
laStr[2] = '-'
laStr[3] = '""'
laStr[4] = '+'
laStr[5] = '-'
laStr[6] = 'ASC(expC)'
laStr[7] = 'ALLTRIM(expC)'
laStr[8] = 'LEFT(expC,)'
laStr[9] = 'LEN(expC)'
laStr[10] = 'LOWER(expC)'
laStr[11] = 'UPPER(expC)'
laStr[12] = 'LTRIM(expC)'
laStr[13] = 'RTRIM(expC)'
laStr[14] = 'PADC(expC,)'
laStr[15] = 'PADL(expC,)'
laStr[16] = 'PADR(expC,)'
laStr[17] = 'RIGHT(expC,)'
laStr[18] = 'TYPE(expC)'
laStr[19] = 'PROPER(expC)'
laStr[20] = 'SOUNDEX(expC)'
laStr[21] = 'CHR(expN)'
laStr[22] = 'SPACE(expN)'
laStr[23] = 'STR(expN,,)'
laStr[24] = 'AT(,,)'
laStr[25] = 'ATC(,,)'
laStr[26] = 'MAX(,)'
laStr[27] = 'MIN(,)'
laStr[28] = 'OCCURS(,)'
laStr[29] = 'RAT(,,)'
laStr[30] = 'REPLICATE(,)'
laStr[31] = 'CHRTRAN(,,)'
laStr[32] = 'STRTRAN(,,)'
laStr[33] = 'STUFF()'
laStr[34] = 'SUBSTR()'
laStr[35] = 'TRANSFORM(,)'

*-- defining the logical functions array
lalogic[1] = 'Logical'
lalogic[2] = '=='
lalogic[3] = '()'
lalogic[4] = '<'
lalogic[5] = '>'
lalogic[6] = '='
lalogic[7] = '<>'
lalogic[8] = '<='
lalogic[9] = '>='
lalogic[10] = '.T.'
lalogic[11] = '.F.'
lalogic[12] = 'NOT'
lalogic[13] = 'AND'
lalogic[14] = 'OR'
lalogic[15] = 'BETWEEN(,,)'
lalogic[16] = 'EMPTY(expR)'
lalogic[17] = 'IIF(,,)'
lalogic[18] = 'INLIST(,,)'

*-- defining the date functions array
laDate[1] = 'Date'
laDate[2] = 'CDOW(expD)'
laDate[3] = 'CMONTH(expD)'
laDate[4] = 'CTOD(expC)'
laDate[5] = 'DATE(expD)'
laDate[6] = 'DAY(expD)'
laDate[7] = 'DMY(expD)'
laDate[8] = 'DOW(expD)'
laDate[9] = 'DTOS(expD)'
laDate[10] = 'GOMONTH(expD)'
laDate[11] = 'MDY(expD)'
laDate[12] = 'MONTH(expD)'
laDate[13] = 'YEAR(expD)'
laDate[14] = 'MAX(,)'
laDate[15] = 'MIN(,)'
laDate[16] = 'SECONDS()'
laDate[17] = 'TIME()'



*!*************************************************************************
*! Name      : LFGETFILEFLD
*! Developer : Hesham El-Sheltawi
*! Date      : 04/15/95    
*! Purpose   : function to get the file fields "Logical and phisical names"
*!*************************************************************************
*: Passed parameters  : lcfile    file name to get it's fields
*:                      llhavetobld to force building the array
*:*************************************************************************
FUNCTION lfGetFileFld
PARAMETERS lcFile,llHaveToBld
IF TYPE('la_Field') $ "UL"  OR llHaveToBld
  la_Field = "laFld_H"
  laField  = "laField"
  DECLARE laFld_H[1,2],laField[1,2]
  *E301077,78 Hesham (Start)
  llflfld = gfSysOpen(gcSysHome+'sydflfld')
  llfield = gfSysOpen(gcSysHome+'sydfield')
  llfiles = gfSysOpen(gcSysHome+'sydfiles')  
  *E301077,78 Hesham (End)
 
  SELECT  DISTINCT IIF(EMPTY(sydField.cFld_Head),sydField.cFld_Name,;
          sydField.cFld_Head),sydFlFld.nFld_Pos ;
          FROM &gcSysHome.sydField,&gcSysHome.sydFlFld;
          WHERE sydField.cFld_Name=sydFlFld.cFld_Name .AND.;
          sydFlFld.cFile_Nam = lcFile ;
          ORDER BY nFld_Pos;
          INTO ARRAY laFld_H

  SELECT DISTINCT sydField.cFld_Name,sydFlFld.nFld_Pos ;
         FROM &gcSysHome.sydField,&gcSysHome.sydFlFld;
         WHERE sydField.cFld_Name=sydFlFld.cFld_Name .AND.;
         sydFlFld.cFile_Nam = lcFile ;
         ORDER BY nFld_Pos;
         INTO ARRAY laField
         
    =gfADel(@laFld_H,2,2)
    =gfADel(@laField,2,2)
  lcTit= LOOKUP(sydFiles.cFile_ttl,lcFile,;
                  sydFiles.cFile_Nam,'cFile_Nam')
  laFile = ALLTRIM(IIF(EMPTY(lcTit),lcFile,lcTit))
  *E301077,78 Hesham (Start)
  USE IN IIF(llflfld,'sydflfld',0)
  USE IN IIF(llfield,'sydfield',0)
  USE IN IIF(llfiles,'sydfiles',0)
  *E301077,78 Hesham (End)
  
ELSE
  laFile = ALIAS()
ENDIF


*!*************************************************************************
*!
*!              Function: gfMover
*!
*!*************************************************************************
*
FUNCTION gfMover1
*E300321,1 Add a parameter that, if passed, should contain
*E300321,1 the name of a function to be executed upon selecting
*E300321,1 the current element from the source list. The result of 
*E300321,1 this function should return a .T., if selection is permitted,
*E300321,1 .F. otherwise.
*E300321,1 Parameter : lcVldFncName
*E300321,1 example 1 : lcVldPrd = 'lfVldPrd(laSource[lnCount],;
*E300321,1                          _CUROBJ = OBJNUM(pbAll))'
*E300321,1             =gfMover(@laPredOprs,@laPredecsrs,;
*E300321,1                     "Select Preceeding Operations",.T.,;
*E300321,1                     @lcVldPrd)
*E300321,1 example 2 : gfMover(@laPredOprs, @laPredecsrs,;
*E300321,1                     "Select Preceeding Operations", .T.,;
*E300321,1                     'lfVldPrd()')
*E300321,1 Specifications of the validation function that is passed
*E300321,1 to the mover :
*E300321,1 It should return the following if Move single element :
*E300321,1       Condition                             Return Value
*E300321,1 1. Valid element                                 1
*E300321,1 2. Invalid element                               0
*E300321,1 
*E300321,1 It should return the following if Move All  :
*E300321,1       Condition                              Return Value
*E300321,1 1. Valid element                                 1
*E300321,1 2. Invalid element, continue with the others     0
*E300321,1 2. Invalid element, Stop moving.                -1
*PARAMETERS laSource,laTarget,lcMovTitle,llOpenAll
PARAMETERS laSource,laTarget,lcMovTitle,llOpenAll, lcVldFncName
*E300321,1 end.

*E300321,1 If a function name is not passed, default the variable with
*E300321,1 '1' .Evaluate of this string is 1 (valid)
lcVldFncName = IIF(EMPTY(lcVldFncName), '1', lcVldFncName)
*E300321,1 end.

*** This for the mover title. ***
lcMovTitle = IIF(TYPE("lcMovTitle") $ "UL" , "Mover" , lcMovTitle)

lnWidTit  = IIF(LEN(ALLTRIM(lcMovTitle)) > 74,74,LEN(ALLTRIM(lcMovTitle)))
lnWidTit  = IIF(lnWidTit = 0 , 1 , lnWidTit )
llOpenAll = IIF(TYPE("llOpenAll")="U",.T.,llOpenAll)

IF llOpenAll
  llCanVald = .T.
ELSE
  llCanVald = .F.
ENDIF  


lnMaxList = 1

FOR lnCount = 1 TO ALEN(laSource,1)
  IF LEN(laSource[lnCount]) > lnMaxList
    lnMaxList = LEN(laSource[lnCount])
  ENDIF
ENDFOR

lnMaxList = IIF(_DOS OR _UNIX,IIF(lnMaxList+4 > 31 , 31 , lnMaxList+4 ),;
                     IIF(lnMaxList+4 > 27 , 27 , lnMaxList+4 ))

lnMaxScrn = IIF(_DOS OR _UNIX,MAX(lnWidTit,(lnMaxList * 2) + 16),(lnMaxList*2)+23)
lnColPos = IIF(LEN(ALLTRIM(lcMovTitle)) > lnMaxScrn,0,;
           INT((lnMaxScrn - LEN(ALLTRIM(lcMovTitle)))/2))


EXTERNAL ARRAY laSource,laTarget
lnOldDim =ALEN(laTarget,1)
DECLARE laOldTarg[lnOldDim]

=ACOPY(laTarget,laOldTarg)

IF ALEN(laTarget,1) = 1 .AND. TYPE('laTarget[1]')="L"
  laTarget =' '
ENDIF  

DEFINE POPUP puSource  MARGIN RELATIVE SCROLL MARK CHR(16)
lcOldEx = SET("EXACT")
SET EXACT ON
FOR lnCount = 1 TO ALEN('laSource',1)
  DEFINE BAR lnCount OF puSource PROMPT (ALLTRIM(laSource[lnCount]))
  IF ASCAN('laTarget',ALLTRIM(laSource[lnCount])) > 0
    SET SKIP OF BAR lnCount OF puSource .T.
  ENDIF
ENDFOR
SET EXACT &lcOldEx

STORE 1  TO lsSource,lsTarget

PUSH KEY
ON KEY

*DO SYMover.SPR
*B600695,1 MFM 09/19/95 (Begin) Changed the screen name to privent errors 
*B600695,1 MFM          if running under prox.
*DO (qSd+"SYMover.SPX")
*E300637,1 Use the new global variables names
*DO (qSd+"AriaMovr.SPX")
DO (gcScrDir+"AriaMovr.SPX")
*E300637,1 (End)
*B600695,1 MFM 09/19/95 (End).

POP KEY

*!*************************************************************************
*!
*!              Function: lfMShow
*!
*!*************************************************************************
*
FUNCTION lfMShow

IF llCanVald 
  IF ALEN('laTarget',1) = ALEN('laSource',1)  AND !EMPTY(laTarget[1]);
    OR EMPTY(laSource[1])
    SHOW GET lsSource     DISABLE
    SHOW GET pbMove       DISABLE
    SHOW GET pbAll        DISABLE
  ELSE
    SHOW GET lsSource     ENABLE
    SHOW GET pbMove       ENABLE
    SHOW GET pbAll        ENABLE
  ENDIF  
  
  IF EMPTY(laTarget[1])
    SHOW GET lsTarget    DISABLE
    SHOW GET pbRemove    DISABLE
    SHOW GET pbRAll      DISABLE
  ELSE
    SHOW GET lsTarget    ENABLE
    SHOW GET pbRemove    ENABLE
    SHOW GET pbRAll      ENABLE
  ENDIF  
ELSE
    SHOW GET pbRemove    DISABLE
    SHOW GET pbRAll      DISABLE    
    SHOW GET pbMove      DISABLE
    SHOW GET pbAll       DISABLE    
    SHOW GET pbCancel    DISABLE
ENDIF  

*!*************************************************************************
*!
*!              Function: lfvMSource
*!
*!*************************************************************************
*
FUNCTION lfvMSource

IF lsSource <= ALEN('laSource',1) AND lsSource <> 0
  
  *E300321,1 Call the function whose name is passed as a parameter to
  *E300321,1 gfMover(). If its result is true, continue with the 
  *E300321,1 selection, otherwise, do not select the current element.
  *E300321,1 Use lnCount variable to hold the currenct index of the
  *E300321,1 source array. laSource[lnCount] is always the current
  *E300321,1 element and may be passed tp functions.
  lnCount = lsSource
  IF EVALUATE(lcVldFncName) <> 0
  *E300321,1 end.
    SET SKIP OF BAR lsSource OF puSource .T.  
    IF !EMPTY(laTarget[1]) 
      DIMENSION laTarget[ALEN(laTarget)+1]
    ENDIF
    laTarget[ALEN(laTarget)]= ALLTRIM(laSource[lsSource])
  *E300321,1 Add an ENDIF for the above condition  
  ENDIF  
  *E300321,1 end.
ENDIF  

lnStart  = lsSource
lsSource = 0

FOR lnCount = lnStart TO CNTBAR('puSource')
  IF !SKPBAR('puSource',lnCount)
    lsSource = lnCount 
    EXIT
  ENDIF  
ENDFOR

IF lsSource = 0
  FOR lnCount = 1 TO CNTBAR('puSource')
    IF !SKPBAR('puSource',lnCount)
      lsSource = lnCount 
      EXIT
    ENDIF  
  ENDFOR
ENDIF  

_CUROBJ = OBJNUM(lsSource)
SHOW GETS

*!*************************************************************************
*!
*!              Function: lfvMTarget
*!
*!*************************************************************************
*
FUNCTION lfvMTarget

lcExactSav = SET("EXACT")
SET EXACT ON

IF lsTarget <= ALEN('laTarget',1) .AND.;
   lsTarget <> 0 .AND.;
   ASCAN('laSource',laTarget[lsTarget]) > 0

  lsSource  = ASUBSCRIPT('laSource',;
                   ASCAN('laSource',laTarget[lsTarget]),1)
  SET MARK OF POPUP puSource .F.
  SET SKIP OF BAR lsSource OF puSource .F.

  =ADEL(laTarget,lsTarget)
  IF ALEN(laTarget,1) > 1
    DIMENSION laTarget[ALEN(laTarget)-1]
  ELSE
    laTarget[1] =' '
  ENDIF  
ENDIF

_CUROBJ = OBJNUM(lsTarget)
SHOW GETS

SET EXACT &lcExactSav

*!*************************************************************************
*!
*!              Function: lfvMMovmnts
*!
*!*************************************************************************
*
FUNCTION lfvMMovmnts
PARAMETERS lnMovmnts
PRIVATE lnEvalVal
*E300321,1 lnEvalVal : holds the evaluation of the passed valid function.

DO CASE
  CASE lnMovmnts = 1
    _CUROBJ = OBJNUM(lsSource)
    KEYBOARD "{ENTER}"
  CASE lnMovmnts = 2
    *E300321,1 If the valid function parameter does not contain
    *E300321,1 a function name, default ite evaluation to 1 (valid)
    *E300321,1 In this case, copy all the source array to the target
    *E300321,1 array as before.
    IF lcVldFncName = '1'
    *E300321,1 end.
      DECLARE laTarget[ALEN('laSource',1)]
      =ACOPY(laSource,laTarget)
      SET SKIP OF POPUP puSource .T.
    *E300321,1 If a valid function parameter exists, validate the
    *E300321,1 source array (the unselected elements only) one by
    *E300321,1 one before copying it into the target array.
    ELSE
      *E300321,1 Go through all the elements of the source list
      *E300321,1 Default evaluation of the valid function to valid (1)
      lnEvalVal = 1
      *E300321,1 If the function evaluates to -1, cancel the move all
      *E300321,1 operation.
      lnCount = 0 
      DO WHILE lnCount < CNTBAR('puSource') .AND. lnEvalVal <> 0
        lnCount = lnCount + 1  
        *E300321,1 If an element is not already selected,
        *E300321,1 proceed with the validation.
        IF !SKPBAR('puSource',lnCount)
          *E300321,1 If the function evaluates to 1, copy the element.
          *E300321,1 to the target array.
          lnEvalVal = EVALUATE(lcVldFncName)
          IF lnEvalVal = 1
            SET SKIP OF BAR lnCount OF puSource .T.
            IF !EMPTY(laTarget[1]) 
              DIMENSION laTarget[ALEN(laTarget)+1]
            ENDIF      && ENDIF !EMPTY(laTarget[1]) 
            laTarget[ALEN(laTarget)]= ALLTRIM(laSource[lnCount])
          ENDIF      && ENDIF lnEvalVal = 1
        ENDIF       && ENDIF !SKPBAR('puSource',lnCount)
      ENDDO       && ENDDO WHILE lnCount <= CNTBAR('puSource')...
    ENDIF       && ENDIF lcVldFncName = '1'
    *E300321,1 end.
    SHOW GETS
  CASE lnMovmnts = 3
    _CUROBJ = OBJNUM(lsTarget)
    KEYBOARD "{ENTER}"
  CASE lnMovmnts = 4
    DECLARE laTarget[1]
    laTarget =' '
    SET SKIP OF POPUP puSource .F.
    SHOW GETS
ENDCASE

*!*************************************************************************
*!
*!              Function: lfvMCancel
*!
*!*************************************************************************
*
FUNCTION lfvMCancel

DECLARE laTarget[lnOldDim]
=ACOPY(laOldTarg,laTarget)


*!*************************************************************
*! Name      : gfOpenFile
*! Developer : MALAK - Malak Hanna
*! Date      : 04/18/1995
*! Purpose   : To open database needed by the program.
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  : File Name, Index Tag, 
*!                          Open Mode "EX" ----> "EXCLUSIVE"
*!                                    "SH" ----> "SHARED"
*!*************************************************************
*! Returns            :  True  ----> If passed file is open by this function
*!                       False ----> If passed file is already open.
*!*************************************************************
*! Example            : =gfOpenFile(QDD+'ORDHDR',QDD+'ORDHDR','SH')
*!*************************************************************
*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
*B602015,1 AHM 05/07/98 using alias name to use the file by this alias
*!*************************************************************

FUNCTION gfOpenFile

*B602015,1 AHM 05/07/98
*PARAMETERS NFILE,lcIndex,MODE
PARAMETERS NFILE,lcIndex,MODE,lcAliasNam,llForceOp
*MAN Added lcSetExact to the following statement
PRIVATE MODE,lcFileName,lcPath,llReturnVal,lcMsg,lcSetExact

*E301316,1 [Start]
PRIVATE lcMacroSub
lcMacroSub=""
*E301316,1 [End..]

*lcPath     = IIF(ATC('\',nfile)<>0,SUBSTR(NFILE,1,RAT('\',nfile)),'')
lcFileName  = IIF(ATC('\',nfile)<>0,SUBSTR(NFILE,RAT('\',nfile)+1),NFILE)
lcOpenMode  = IIF(TYPE('MODE')='C' AND MODE='EX', "EXCLUSIVE", "SHARED")
lcOrderTag  = IIF(TYPE('lcIndex')='C',SUBSTR(lcIndex,IIF('\' $ lcIndex,ATC('\',lcIndex,OCCURS('\',lcIndex)),0) +1),'')



*-- MAN Commented out the following block .... to the end of the function and changed the code
*E301077,1 Hesham (Start)
*E301077,1 IF the file we are trying to open is not assigned to the 
*E301077,1 program files then add it to the program files
*E301077,1 so we can close it in the global cleanup
*B602513,1 Hesham (Start)
*B602513,1 if the file we are opening is a temproray file then do not
*B602513,1  add it to the files array

**MAN-- IF LEFT(ALLT(lcFileName),1)<>'X'
PRIVATE llOpen 
llOpen = .F.
*B602513,1 Hesham (End)
**MAN--   lcErrOn = ON('ERROR')
**MAN--   llError = .F.
**MAN--   ON ERROR llError = .T.
**MAN--   IF TYPE('laFileName')<>'U'
**MAN--     lcSetExact = SET('Exact')
**MAN--     SET EXACT ON
**MAN--     lnFilePos = ASCAN(laFileName,lcFileName)
**MAN--     IF lnFilePos = 0
**MAN--       IF !EMPTY(laFileName[1,1])
**MAN--         DIMEN laFileName[ALEN(laFileName,1)+1,ALEN(laFileName,2)]
**MAN--       ENDIF
**MAN--       laFileName[ALEN(laFileName,1),1] = lcFileName
**MAN--       laFileName[ALEN(laFileName,1),2] = lcOrderTag
**MAN--       lnFileElm = ASCAN(gaMnu_Fl,lcFileName)
**MAN--       IF lnFileElm > 0 
**MAN--          lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
**MAN--          gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
**MAN--       ELSE
**MAN--          DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
**MAN--          =AINS(gaMnu_Fl,1)
**MAN--          gaMnu_Fl[1,1] = lcFileName
**MAN--          gaMnu_Fl[1,2] = lcOrderTag
**MAN--          gaMnu_Fl[1,3] = SELECT(0)
**MAN--          *gaMnu_Fl[1,4] = IIF(USED(lcFileName),2,1)
**MAN--          *gaMnu_Fl[1,5] = "P"
**MAN--          gaMnu_Fl[1,4] = 1
**MAN--          gaMnu_Fl[1,5] = IIF(USED(lcFileName),'S','P')
**MAN--          gaMnu_Fl[1,6] = " "
**MAN--       ENDIF
**MAN--     ENDIF
**MAN--     SET EXACT &lcSetExact
**MAN--   ENDIF
**MAN--   ON ERROR &lcErrOn
*B602513,1 Hesham (Start)  
**MAN-- ENDIF  
*B602513,1 Hesham (End)
*E301077,1 Hesham (End)
*-- MAN End
*B602015,1 lcAliasNam parameter that holds the name of the alias that file
*B602015,1                           will be used with.
*B602015,1 llForceOp parameter that showes if the function used want to 
*B602015,1                          open the file with another alias name
*B602015,1                          regardless it is rather opened or opened
*B602015,1                          from the same directory or not opened
IF TYPE('lcAliasNam') <> 'C'
  lcAliasNam = lcFilename
ENDIF

*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
lcMsg = 'Opening '+NFILE+IIF(EMPTY(lcIndex),'', ' Index Tag '+lcOrderTag)+'....'
lcMsg = PROPER(lcMsg)
lnCurRow = ROW()
lnCurCol = COL()
IF 'SCREEN' $ SYS(101)
  DO CASE
    CASE _DOS OR _UNIX
      lcActWin = WONTOP()
      ACTIVATE SCREEN
      @ 24,00 SAY gfMsgStr(lcMsg) COLOR &gcMsgClr
      IF !EMPTY(lcActWin)
        ACTIVATE WINDOW (lcActWin) 
      ENDIF  
    CASE _WINDOWS OR _MAC
      SET MESSAGE TO lcMsg
  ENDCASE
ENDIF
*E300247,1 YMA 06/13/95 End.

*B602015,1 AHM 05/07/98 using alias name to use the file by this alias

*IF USED(lcFilename)
*  SELECT (lcFilename)
*  IF !EMPTY(lcIndex) 
*    SET ORDER TO TAG lcOrderTag
*  ENDIF
*ELSE
*  SELECT 0
*  IF EMPTY(lcIndex) 
*    USE (NFILE) &lcOpenMode
*  ELSE
*    USE (NFILE) ORDER TAG lcOrderTag &lcOpenMode 
*  ENDIF  
*  llReturnVal = .T.
*ENDIF 

llReturnVal = .T.
*B602015,1 saving the FULLPATH Status
lcFPathSt   = SET('FULLPATH')
SET FULLPATH ON
IF USED(lcFilename)
  lcOpenMode = "SHARED"
  *-- if the file is used and it is from the same data directory
  IF DBF(lcFilename) == ALLTRIM(STRTRAN(UPPER(nFile), ".DBF") + ".DBF")
    *-- if forced open is desired
    IF llForceOp
      lcAliasNam  = gfTempName()
      *E301316,1 [Start]
      *USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode
      lcMacroSub="USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode"
      &lcMacroSub
      *E301316,1 [End..]
   
      *--MAN
      llOpen = .T.
      IF !EMPTY(lcOrderTag)
        SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
      ENDIF    &&IF !EMPTY(lcOrderTag)
    ELSE
      *-- if forced open is not desired
      llReturnVal = .F.
      lcAliasNam  = IIF(TYPE('lcAliasNam')#'C' OR EMPTY(lcAliasNam),ALLTRIM(STRTRAN(UPPER(lcFileName),".DBF")),lcAliasNam)
      *-- if there is no tag is desired to set order to
      IF EMPTY(lcOrderTag)
        SET ORDER TO 0 IN (lcAliasNam)
      ELSE
        SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
      ENDIF   &&IF EMPTY(lcOrderTag)
    ENDIF     &&IF llForceOp
  ELSE
    *-- if the file is used but not from the same data directory
    lcAliasNam  = IIF(TYPE('lcAliasNam')#'C' OR EMPTY(lcAliasNam),gfTempName(),lcAliasNam)
    *E301316,1 [Start]
    *USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode
    lcMacroSub="USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode"
    &lcMacroSub
    *E301316,1 [End..]

    *-- MAN
    llOpen = .T.
    IF !EMPTY(lcOrderTag)
      SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
    ENDIF  &&IF !EMPTY(lcOrderTag)
  ENDIF   &&IF DBF(lcFilename) == .......
ELSE
  *-- if the file is not used
  lcAliasNam  = IIF(TYPE('lcAliasNam')#'C' OR EMPTY(lcAliasNam),ALLTRIM(STRTRAN(UPPER(lcFileName),".DBF")),lcAliasNam)
  *E301316,1 [Start]
  *USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode
  lcMacroSub="USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode"
  &lcMacroSub
  *E301316,1 [End..]

  *-- MAN
  llOpen = .T.
  IF !EMPTY(lcOrderTag)
    SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
  ENDIF    &&IF !EMPTY(lcOrderTag)
ENDIF    &&IF IF USED(lcFilename)
SELECT (lcAliasNam)
SET FULLPATH &lcFPathSt
*B602015,1 AHM 05/07/98 End.

*-- MAN Start
*-- MAN Commented out the following block .... to the end of the function and changed the code
*E301077,1 Hesham (Start)
*E301077,1 IF the file we are trying to open is not assigned to the 
*E301077,1 program files then add it to the program files
*E301077,1 so we can close it in the global cleanup
*B602513,1 Hesham (Start)
*B602513,1 if the file we are opening is a temproray file then do not
*B602513,1  add it to the files array


IF !UPPER(gcWorkDir) $ UPPER(NFILE)

*B602513,1 Hesham (End)
  lcErrOn = ON('ERROR')
  llError = .F.
  ON ERROR llError = .T.
  IF TYPE('laFileName')<>'U'
    lcSetExact = SET('Exact')
    SET EXACT ON
    *-- YMA MAN
    *lnFilePos = ASCAN(laFileName,lcAliasNam)
    FOR lnFilePos = 1 TO ALEN(laFileName,1)
      IF ALLTRIM(laFileName[lnFilePos,1]) == ALLTRIM(lcAliasNam)
        EXIT
      ENDIF
    ENDFOR
    IF lnFilePos > ALEN(laFileName,1)
      lnFilePos = 0
    ENDIF
    *-- YMA MAN
    
    IF lnFilePos = 0
      IF !EMPTY(laFileName[1,1])
        DIMEN laFileName[ALEN(laFileName,1)+1,ALEN(laFileName,2)]
      *-- MAN Added ELSE Cond.  
      ELSE
        *B802826,1 RAMY Add more columns [start]
        *DIME laFileName[1,1] 
        DIME laFileName[1,4] 
        *B802826,1 RAMY [end]
      ENDIF
      laFileName[ALEN(laFileName,1),1] = lcAliasNam
      laFileName[ALEN(laFileName,1),2] = lcOrderTag
      *E000001,1 Hesham (Start)
      laFileName[ALEN(laFileName,1),3] = NFILE
      laFileName[ALEN(laFileName,1),4] = lcFilename
      *E000001,1 Hesham (End)
      *-- YMA MAN
      *lnFileElm = ASCAN(gaMnu_Fl,lcAliasNam)
      FOR lnFileElm = 1 TO ALEN(gaMnu_Fl,1)
        IF ALLTRIM(gaMnu_Fl[lnFileElm,1]) == ALLTRIM(lcAliasNam)
          EXIT
        ENDIF
      ENDFOR
      IF lnFileElm > ALEN(gaMnu_Fl,1)
        lnFileElm = 0
      ENDIF
      *-- YMA MAN
      IF lnFileElm > 0 
         *-- YMA MAN 
         *lnRowNo = ASUBSCRIPT(gaMnu_Fl,lnFileElm,1)
         lnRowNo = lnFileElm 
         *-- YMA MAN
         gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] + 1
      ELSE
         DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1)+1,ALEN(gaMnu_Fl,2)]
         =AINS(gaMnu_Fl,1)
         gaMnu_Fl[1,1] = lcAliasNam
         gaMnu_Fl[1,2] = lcOrderTag
         gaMnu_Fl[1,3] = SELECT(0)
         *gaMnu_Fl[1,4] = IIF(USED(lcFileName),2,1)
         *gaMnu_Fl[1,5] = "P"
         gaMnu_Fl[1,4] = 1
         gaMnu_Fl[1,5] = IIF(!llOpen ,'S','P')
         gaMnu_Fl[1,6] = " "
      ENDIF
    ENDIF
    SET EXACT &lcSetExact
  ENDIF
  ON ERROR &lcErrOn
*B602513,1 Hesham (Start)  
ENDIF  
*B602513,1 Hesham (End)
*E301077,1 Hesham (End)

*-- MAN END

*E300247,1 YMA 06/13/95 Changed the displaying of the file
*E300247,1 name to be in the status message.
IF 'SCREEN' $ SYS(101)
  DO CASE
    CASE _DOS OR _UNIX
      lcActWin = WONTOP()
      ACTIVATE SCREEN
      @ 24,00 SAY gfMsgStr("") COLOR &gcMsgClr
      IF !EMPTY(lcActWin)
        ACTIVATE WINDOW (lcActWin)
      ENDIF  
      @ lnCurRow,lnCurCol SAY ""
    CASE _WINDOWS OR _MAC
      SET MESSAGE TO ""
  ENDCASE
ENDIF
*E300247,1 YMA 06/13/95 End.

RETURN llReturnVal

*!*************************************************************
*! Name      : gfvActBrow
*! Developer : MALAK - Malak Hanna
*! Date      : 05/02/1995
*! Purpose   : Function to activate browse function.
*!*************************************************************
*! Passed Parameters  :  Object Name
*!*************************************************************
*! Example            :  gfvActBrow(m.Scale)
*!*************************************************************
FUNCTION gfvActBrow
PARAMETERS lcObjName

llBrowse = .T.
_CUROBJ  = OBJNUM(&lcObjName)
KEYBOARD "{ENTER}"

*!*************************************************************
*! Name      : gfScalBrow
*! Developer : MALAK - Malak Hanna
*! Date      : 05/02/1995
*! Purpose   : Function to validate entered scale size value.
*!*************************************************************
*! Calls     : ARIABROW()
*!*************************************************************
*! Passed Parameters  :  Entered Scale
*!                       Multi scale 
*!*************************************************************
*! Returns            :  .T. --> Valid scale 
*!                       .F. --> Invalid scale
*!*************************************************************
*! Example            :  gfScalBrow(@m.Scale)
*!*************************************************************
FUNCTION gfScalBrow
PARAMETER lcParaScale,llMltScle
PRIVATE lcBrFields
*E300703,4 Added new parameter for multiple scale future.

lnOldAlias = SELECT()
lcFile_Ttl = 'Scales'

*--If Extended size scale was used.
IF llMltScle
  *--Browse from Scale Header file.
  llOpndSHd = gfOpenFile(gcDataDir+'scalehd','Extscale','SH')

  IF llBrowse OR EMPTY(lcParaScale) OR !SEEK(lcParaScale)
    DECLARE laValues[1]  && array to get values from browse
    lcBrFields = "cExtScale :H='Scale' ,"+;
                 "cScaleDes :H='Description'"
   
    =ARIABROW('',lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','','cExtScale','laValues')
    lcParaScale = IIF(EMPTY(laValues[1]),SPACE(1),laValues[1])
  ENDIF  

  IF llOpndSHd
    USE IN SCALEHD
  ENDIF

*--NO extended scales.
ELSE
  SELECT SCALE
  IF llBrowse OR EMPTY(lcParaScale) OR !SEEK('S'+lcParaScale)
    DECLARE laValues[1]  && array to get values from browse
 
    *B600429,1 Change the fields width under windows.
    *E300703,4 Show only first scale char if multi scale used.
     lcBrFields = "Scale:1:H='Scale' ,"+;
                  "cScl_DESC :14:H='Description',"+;
                  "CNT  :H='Cnt'  ,"+;
                  "SZ1  :8:H='Size 1',"+;
                  "SZ2  :8:H='Size 2',"+;
                  "SZ3  :8:H='Size 3',"+;
                  "SZ4  :8:H='Size 4',"+;
                  "SZ5  :8:H='Size 5',"+;
                  "SZ6  :8:H='Size 6',"+;
                  "SZ7  :8:H='Size 7',"+;
                  "SZ8  :8:H='Size 8'"
   
    =ARIABROW(['S'],lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','','SCALE','laValues')
    lcParaScale = IIF(EMPTY(laValues[1]),SPACE(1),laValues[1])
  ENDIF  
ENDIF

SELECT (lnOldAlias)
RETURN !EMPTY(lcParaScale)



*!*************************************************************
*! Name      : gfPrePBrow
*! Developer : MALAK - Malak Hanna
*! Date      : 05/02/1995
*! Purpose   : Function to validate entered prepack value for a 
*!             specific size scale.
*!*************************************************************
*! Calls     : ARIABROW()
*!*************************************************************
*! Passed Parameters  :  Entered prepack
*!*************************************************************
*! Returns            :  .T. --> Valid scale 
*!                       .F. --> Invalid scale
*!*************************************************************
*! Example            :  gfPrePBrow(m.Scale,@m.Prpak)
*!*************************************************************
FUNCTION gfPrePBrow
PARAMETER lcScale,lcPrePack

IF llBrowse OR (!EMPTY(lcPrePack) AND !SEEK('P'+lcScale+lcPrePack,'SCALE'))
  IF SEEK('P'+lcScale,'SCALE')
    lnOldAlias = SELECT()
    SELECT SCALE
    DECLARE laValues[1]  && array to get values from browse
    lcFile_Ttl = 'Prepacks'
    *B600429,1 Change the sizes fileds width under windows.
    lcBrFields = "Prepak :H='Prepack'"
    *B600430,1 Malak 06/19/95 {Begin}
    *B600430,1 Adjusting the browse fields string according to scale.
    IF SEEK('S'+lcScale,'SCALE') 
      FOR lnCounter = 1 TO SCALE.Cnt
        lcPos = STR(lnCounter,1)
        lcBrFields =lcBrFields+",PP&lcPos:H='"+Scale.Sz&lcPos+"'"+IIF(_WINDOWS,':6','')
      ENDFOR 
    ENDIF
 
    lcBrFields = lcBrFields + ",ppTot:H='Total'"+IIF(_WINDOWS,':8','')
    *B600430,1 Malak 06/19/95 {End}
    *B800831,1 TMI 11/11/96 
    =SEEK("P"+lcScale,'Scale')
    *B800831,1 TMI 11/11/96 (End)
    =ARIABROW(["P"+lcScale],lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','','PREPAK','laValues')
    lcPrePack = IIF(EMPTY(laValues[1]),SPACE(1),laValues[1])
    SELECT (lnOldAlias)
  ELSE
    =gfDialog("I",'There is no prepak for scale '+ lcScale)
    lcPrePack = SPACE(1)
  ENDIF  
ENDIF  

RETURN !EMPTY(lcPrePack)


*!*************************************************************
*! Name      : gfGLBrowse
*! Developer : MALAK - Malak Hanna
*! Date      : 05/18/1995
*! Purpose   : To check and browse the gl link codes from gl_Link file .
*!*************************************************************
*! Calls     : ARIABROW()
*!*************************************************************
*! Passed Parameters  : lcLinkType --> '01' for 'Sales' type
*!                                 --> '02' for 'Style Invertory' type
*!                                 --> '03' for 'Material Inverntory' type
*!                                 --> '04' for 'Work in Process' type
*!                                 --> '00' for main types
*!                                 --> ''   for all types except '00'
*!                      lcLinkCode --> Variables that holds entered link code
*!                      lcLinkDesc --> Variables that holds link descrption 
*!                      lnSalesPart--> 0 Browse the whole sales types
*!                                     1 Browse Customer sales
*!                                     2 Browse Style sales
*!*************************************************************
*! Returns            :  .T. or .F.
*!*************************************************************
*! Example            : =gfGLBrowse('02',@m.LinkCode,@lcLinkDesc)
*!*************************************************************
*! Modifications :
*!
*E300592,1 WAM 02/25/97 Recategorize link types
*E300592,1 WAM 02/25/97 Add new parameter lnSalesPart
*E300788,1 AHM 02/08/98 Updated the lclinkType variable.
*!*************************************************************
*E301077,8 MAB 03/10/1999 Open GL_Link file if not oppened.
FUNCTION gfGLBrowse
PARAMETER lcLinkType, lcLinkCode, lcLinkDesc,lnSalesPart
PRIVATE   lcLinkType, lcLinkCode, lcLinkDesc,laData,lcBrFields

lnOldAlias = SELECT()

*E300592,1 Commented out
*SELECT GL_LINK
*lnOldTag = VAL(SYS(21))
*SET ORDER TO TAG GL_LINK1
*lcFilter = IIF(EMPTY(lcLinkType),'LinkType<>"00"','LinkType=lcLinkType')
*SET FILTER TO &lcFilter
*LOCATE

*E301077,8 MAB Open GL_Link file if not oppened [Begin]

*lnOldTag = ORDER('GL_LINK')
llOpnGlLnk = .F.
IF USED('GL_LINK')
  lnOldTag = ORDER('GL_LINK')
ELSE
  llOpnGlLnk = gfOpenFile(gcDataDir+'GL_LINK','','SH')
ENDIF

*E301077,8 MAB Open GL_Link file if not oppened [End  ]

IF lcLinkType='02' .AND. lnSalesPart=2
  SET ORDER TO TAG SALES IN GL_LINK
ELSE
  SET ORDER TO TAG GL_LINK1 IN GL_LINK
ENDIF
*E300592,1 (End)

llBrowse = IIF(TYPE('llBrowse') = 'U' ,;
                .F., llBrowse .OR. '?' $ lcLinkCode)

IF llBrowse OR ! SEEK(lcLinkType+lcLinkCode,'GL_LINK')

  *E300592,1 Add new parameter lnSalesPart
  lnPos    = IIF(lcLinkType='02' .AND. lnSalesPart=2,4,1)
  lnLength = IIF(lcLinkType='02' .AND. INLIST(lnSalesPart,1,2),3,6)
  SELECT LinkType,SUBSTR(Link_Code,lnPos,lnLength) AS LinkCode,LinkDesc FROM GL_LINK ;
  GROUP BY LinkType,LinkCode ;
  HAVING (LinkType = lcLinkType);
  INTO CURSOR lcCodesCurs
  *E300592,1 (End)
  
  DECLARE laValues[2]     && array to get values from browse

  *E300592,1 Recategorize link types
  *DECLARE laLinkType[4] 
  *laLinkType[1] = 'Sales              '
  *laLinkType[2] = 'Style Invertory    '
  *laLinkType[3] = 'Material Inverntory'    
  *laLinkType[4] = 'Work in Process    '
  
  DECLARE laLinkType[5] 
  laLinkType[1] = 'Customer           '
  laLinkType[2] = 'Sales              '
  laLinkType[3] = 'Style Invertory    '
  laLinkType[4] = 'Material Inverntory'    
  laLinkType[5] = 'Work in Process    '
  *E300592,1 (End)
    
  lcFile_Ttl    = 'GL Link Codes' + IIF(EMPTY(lcLinkType) OR lcLinkType='00' ;
                  ,'',' for '+ALLTRIM(laLinkType[VAL(lcLinkType)]))

  *E300592,1 Browse from the cusrsor
  *lcBrFields    = "Link_Code :H='Code',"        +;
                  "LinkDesc  :H='Description'"  +;
                  IIF(EMPTY(lcLinkType),",lcDummy=laLinkType[VAL(LinkType)]:H='Type'",'')
  *=ARIABROW([lcLinkType],lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','','Link_Code,LinkDesc','laValues')
                  
  lcBrFields    = "LinkCode :H='Code',"        +;
                  "LinkDesc  :H='Description'"  +;
                  IIF(EMPTY(lcLinkType),",lcDummy=laLinkType[VAL(LinkType)]:H='Type'",'')


  =ARIABROW('',lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2,'','','LinkCode,LinkDesc','laValues')
                  
  *E300592,1 (End)
                    
  lcLinkCode = IIF(EMPTY(laValues[1]),SPACE(3 ),laValues[1])
  lcLinkDesc = IIF(EMPTY(laValues[2]),SPACE(30),laValues[2])

  *E300788,1 AHM 02/08/98 (Begin) Updated the lclinkType variable.
  lcLinkType = IIF(EMPTY(laValues[1]),lcLinkType,LinkType)
  *E300788,1 AHM 02/08/98 (End)
  
  *E300592,1 Close the cursor
  USE IN lcCodesCurs
  *E300592,1 (End)
  
ELSE
  lcLinkDesc = GL_LINK.LinkDesc
ENDIF

*E300592,1 Commented out
*SET FILTER TO 
*E300592,1 (End)

*E301077,8 MAB Close GL_Link file if not oppened [Begin]

IF llOpnGlLnk
  = gfCloseFile('GL_LINK')
ELSE  
  SET ORDER TO TAG lnOldTag IN GL_LINK
ENDIF  

*E301077,8 MAB Close GL_Link file if not oppened [End  ]

SELECT (lnOldAlias)
llBrowse = .F.

RETURN !EMPTY(lcLinkCode)


*!*************************************************************
*! Name      : gfKeyExist
*! Developer : MALAK - Malak Hanna
*! Date      : 05/16/1995
*! Purpose   : To check if there is another user use the enterd key field.
*!*************************************************************
*! Calls     : gfDialog()
*!             lfvChngKey()
*!*************************************************************
*! Passed Parameters  :  lcFileTit  : --> File Name
*!                       lcCheckKey : --> Key Field
*!                       lnKeyWidth : --> Key Width
*!                       lcCompKey  : --> In case of compound key
*!*************************************************************
*! Returns            :  .T. in case valid key
*!                       .F. in case invalid key
*!*************************************************************
*! Called by          :  CUS100, STY100, MAT100, REP100, VEN100
*!*************************************************************
*! Example            : =gfKeyExist('Vendor',@m.VendorCod ,8)
*!                      =gfKeyExist('Customer',@m.Customer,5,'M')  
*!                      =gfKeyExist('Customer',@m.Store   ,8,'S'+m.Customer)  
*!*************************************************************
FUNCTION gfKeyExist
PARAMETERS lcFileTit,lcCheckKey,lnKeyWidth,lcCompKey

lcCompKey  = IIF(TYPE('lcCompKey') = 'C',lcCompKey,'')
llValidKey = .T.
lcSetExact = SET('EXACT')
SET EXACT ON

IF SEEK(lcCompKey+lcCheckKey,lcFileTit)
  llValidKey = .F.
  lcNewKey   = SPACE(lnKeyWidth)
  IF gfDialog('!','This code has just been used by another user.','\!C\<hange;\?\<Cancel') = 1
    *E300637,1 Use the new global variables names
    *DO (qSd+"ChangKey.SPX")
    DO (gcScrDir+"ChangKey.SPX") 
    *E300637,1 (End)
  ENDIF 
ENDIF

SET EXACT &lcSetExact
RETURN llValidKey


*!*************************************************************
*! Name      : lfvChngKey
*! Developer : MALAK - Malak Hanna
*! Date      : 05/16/1995
*! Purpose   : Valid function to check new enterd key.
*!*************************************************************
*! Calls     : gfDialog()
*!*************************************************************
*! Passed Parameters  :  None
*!*************************************************************
*! Returns            :  None
*!*************************************************************
*! Called by          :  gfKeyExist
*!*************************************************************
*! Example            : lfvChngKey()
*!*************************************************************
FUNCTION lfvChngKey

IF EMPTY(lcNewKey)
  =gfDialog('?','Code cannot be empty.')
  RETURN
ENDIF

IF SEEK(lcCompKey+lcNewKey,lcFileTit)
  =gfDialog('!',ALLTRIM(lcNewKey) + ' code already exists.')
  lcNewKey = SPACE(lnKeyWidth)
  _CUROBJ  = OBJNUM(lcNewKey)
ELSE  
  llValidKey = .T.
  lcCheckKey = lcNewKey
  CLEAR READ
ENDIF  

*!*************************************************************
*! Name      : gfMFGOrdBr
*! Developer : RENEE - Renee Ezzat
*! Date      : 05/02/1995
*! Purpose   : Global browse for material maunufacturing orders
*!             If a match is found, returns, otherwise, browses
*!             Positions the file pointer of MMFGORDH on the 
*!             selected or matching record.
*!             Does not require the file to be opened.
*!*************************************************************
*! Parameters: - lcMFGOrdNo : (optional)
*!                            MFG Order number to be validated.
*!                            Browses all orders if not passed.
*!             - lcFabric   : (optional)
*!                            Use this parameter with a fabric
*!                            to select (or validate) a fabric, 
*!                            then browse only the orders that
*!                            use this fabric. 
*!             - lcForCond  : Allows further scoping of the 
*!                            dislayed records. (optional)                          
*!                            A condition that is to be browsed
*!                            for.
*!*************************************************************
*! Calls     : AriaBrow()
*!*************************************************************
*! Returns            :  .t. if a record is found or selected,
*!                       .f. otherwise
*!*************************************************************
*! Example            :   If only validating MFG Order number, 
*!                          llFound = gfMFGOrdBr(@lcMFGOrder)
*!                        Or if browsing orders using a fabric 
*!                          llFound = gfMFGOrdBr(@lcMFGOrder, 'COTTON')
*!                        If a condition is required :
*!                          (eg browse only open and complete orders)
*!                          llFound = gfMFGOrdBr(@lcMFGOrder,;
*!                                               'COTTON',;
*!                                               'Status $ 'OC')       
*!*************************************************************
FUNCTION gfMFGOrdBr
PARAMETERS lcMFGOrdNo, lcFabric, lcForCond

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lcMFGOrdNo, lcFabric, lcForCond, lcBrFields, lnCurAlias, ;
        lnCurTag, llFound, llOpenFile 
PRIVATE lcMFGOrdNo, lcFabric, lcForCond, lcBrFields, lnCurAlias, ;
        lnCurTag, llFound, llOpenFile, laData
*E300637,1 (End)

DECLARE laData[1]  && array to get values from browse
STORE '' TO laData

llBrowse   = IIF(TYPE('llBrowse')   = 'U', .F., llBrowse) 
lcMFGOrdNo = IIF(TYPE('lcMFGOrdNo') $ 'UL', SPACE(6), lcMFGOrdNo)
lcFabric   = IIF(TYPE('lcFabric')   $ 'UL' , SPACE(7), lcFabric)
lcForCond  = IIF(EMPTY(lcForCond), '', ' FOR ' +lcForCond)
*E#301235,1 WALID (WAM)
*RESTORE FROM AdPara&qSysCode ADDITIVE    
lcWareHouse  = gfGetMemVar('M_WareHouse')
lcBrFields   = [cMFGOrdNo:H='Order#',]+;
               [cFabric  :H='Fabric',]+;
               IIF(lcWareHouse = 'Y',;
                   [cWareCode:H='Warehouse',],[])+;
               [Status   :H='S',]+;
               [Entered  :H='Entered',]+;
               [Complete :H='Complete']
RELEASE ALL LIKE  M_*

lnCurAlias   = SELECT()
IF USED('MMFGORDH')
  llOpenFile = .F.
  SELECT MMFGORDH
ELSE  
  *E300637,1 Use the new global variables names
  *llOpenFile = gfOpenFile(QDD+'MMFGORDH', ' ', 'SH')
  llOpenFile = gfOpenFile(gcDataDir+'MMFGORDH',gcDataDir+'MMFGORDD','SH')
  *E300637,1 (End)
ENDIF  
lnCurTag     = VAL(SYS(21))
SET ORDER TO TAG MMFGORDD

llFound = .F.
IF !EMPTY(lcFabric) .AND. SEEK(lcFabric) ;
   .OR. EMPTY(lcFabric) .AND. SEEK('')
  SET ORDER TO TAG MMFGORDH  
  IF !(SEEK(lcMFGOrdNo)  ;
    .AND. (EMPTY(lcForCond) .OR. EVALUATE(STRTRAN(lcForCond, 'FOR')))) ;
    .OR. llBrowse 

    IF BETWEEN(RECNO(0), 1, RECCOUNT())
      GO RECNO(0)
    ELSE
      GO TOP
    ENDIF  
    IF EMPTY(lcFabric)
      llFound = ARIABROW(lcForCond,;
                "Material Manufacturing Orders",;
                gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","",;
                "MMFGORDH.cMFGOrdNo","laData")
    ELSE             
      SET ORDER TO TAG MMFGORDD
      llFound = ARIABROW([lcFabric] + lcForCond,;
                "Material Manufacturing Orders",;
                gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","",;
                "MMFGORDH.cMFGOrdNo","laData")
    ENDIF  
    IF llFound
      lcMFGOrdNo = laData[1]
    ELSE
      lcMFGOrdNo = SPACE(6)
    ENDIF  
  ELSE
    llFound  = .T.
  ENDIF  
ELSE
  llFound = .F.
  lcMFGOrdNo = SPACE(6)
  IF EMPTY(lcFabric)
    =gfDialog('I','There are no material manufacturing orders on the file.')
  ELSE
    =gfDialog('I','There are no material manufacturing orders for item '+ALLTRIM(lcFabric) +'.')  
  ENDIF  
ENDIF

IF llOpenFile
  USE IN MMFGORDH
ELSE
  SET ORDER TO (lnCurTag)
ENDIF
SELECT (lnCurAlias)

RETURN llFound

*!*************************************************************
*! Name      : gfUpdated
*! Developer : MALAK - Malak Hanna
*! Date      : 05/22/1995
*! Purpose   : Check if you changed any data during the most 
*!             recent read.
*!*************************************************************
*! Example            : gfUpdated()
*!*************************************************************
FUNCTION gfUpdated

glUpdated = glUpdated OR UPDATED()

*!*************************************************************
*! Name      : gfClearKey
*! Developer : RENEE - Renee Ezzat
*! Date      : 05/25/1995
*! Purpose   : Resets any keys then sets global key traps.
*!*************************************************************
*! Example            :  =gfClearKey()
*!*************************************************************
FUNCTION gfClearKey
ON KEY
ON KEY LABEL F4 KEYBOARD '?'+'{ENTER}'
ON KEY LABEL F1 DO lpPressF1

*!*************************************************************
*! Name      : gfCkNotEst
*! Developer : MALAK - Malak Hanna
*! Date      : 06/12/1995
*! Purpose   : This function is called from any add/change program
*!             to check in the add mode if there is a notes record
*!             added in the NOTEPAD file before saving the new entry,
*!             If one exists, delete this record from NOTEPAD file.
*!             This function is called only if the user wants to lose
*!             the added record.  
*!*************************************************************
*! Example            : =gfCkNotEst('F' + m.Style)
*!*************************************************************
FUNCTION gfCkNotEst
PARAMETERS lcNotesKey

lnOldAlias = SELECT()
*E300637,1 Use the new global variables names
*llNoteOpend =gfOpenFile(qdd+'NOTEPAD',qdd+'NOTEPAD','SH')
llNoteOpend =gfOpenFile(gcDataDir+'NOTEPAD',gcDataDir+'NOTEPAD','SH')
*E300637,1 (End)

IF SEEK(lcNotesKey,'NOTEPAD')
  DELETE
ENDIF

IF llNoteOpend 
  USE IN ('NOTEPAD')
ENDIF

SELECT (lnOldAlias)

*!*************************************************************
*! Name      : gfvDyelots
*! Developer : RENEE - Renee Ezzat
*! Date      : 07/11/1995
*! Purpose   : Global dyelots validation.
*!             Looks for a dyelot entry, if not found in the
*!             corresponding dyefile, may browse, add, or reenter.
*!             If multi warehouses, uses the passed warehouse,
*!             otherwise, uses the default warehouse 'DEFWHE'
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  :  lcDyeSrc   : 'S' if validating style dyelots,
*!                                    'M' if validating fabric dyelots
*!                       lcItem     : Fabric or Style
*!                       lcColor    : Color
*!                       lcWareCode : warehouse code, 
*!                                    or empty for default.
*!                       lcDyelot   : dyelot to be validated and returned.
*!                       lcOldVal   : old value of the dyelot,
*!                                    (optional)
*!                                    If not passed, the dyelot is filled
*!                                    with spaces instead of the old value
*!                                    of the field.
*!*************************************************************
*! Returns            :  .T. if a dyelot is valid, or selected,
*!                       .F. otherwise
*!*************************************************************
*! Example            :  If called for style dyelots,
*!                         =gfvDyelots('S', lcStyle, lcColor, lcWareCode,;
*!                                      @lcDyelot, lcOldVal)  
*!                       If called for fabric dyelots,
*!                         =gfvDyelots('M', lcFabric, lcColor, lcWareCode,;
*!                                      @lcDyelot, lcOldVal)  
*!
*!*************************************************************
FUNCTION gfvDyelots
PARAMETERS lcDyeSrc, lcItem, lcColor, lcWareCode, lcDyelot, lcOldVal
PRIVATE lcDyeFile , lnCurAlias, lnOption, llFromStyle, llOpenFile,;
        llSelected, llMultiWare
*N16,5 lcDyeFile   : Source dye file ('STYDYE' or 'FABDYE')
*N16,5 lnCurAlias  : Current work area
*N16,5 lnOption    : holds the option of a dialog
*N16,5 llFromStyle : .T. if called for style dyelots validations, 
*N16,5               .F. otherwise
*N16,5 llOpenFile  : .T. if Dye file is opened in this function,
*N16,5               .F. otherwise
*N16,5 llSelected  : .T. if a dyelot is selected, .F. otherwise. 
*N16,5 llMultiWare : .T. if the system uses multi warehouses, .F. otherwise. 
lcDyelot   = PADR(ALLTRIM(lcDyelot)  , 10) 
lcOldVal   = IIF(TYPE('lcOldVal') $ 'UL', SPACE(10), lcOldVal)
llBrowse   = IIF(TYPE('llBrowse') = 'U' ,;
                .F., llBrowse .OR. '?' $ lcDyelot)
llSelected = .T.
 
*N16,5 Validate dyelot if called from a browsing button, or if
*N16,5 its value is changed and it is not empty.
IF llBrowse .OR. !EMPTY(lcDyelot)
  RESTORE FROM AdPara&qSysCode ADDITIVE    
  llMultiWare = M_WareHouse = 'Y'
  RELEASE ALL LIKE  M_*  
  
  *N16,5 If the system is setup to use multi warehouse, check if 
  *N16,5 a warehouse code is entered. If not, present a message
  *N16,5 and return .F. 
  IF llMultiWare .AND. EMPTY(lcWareCode)
    =gfDialog('I','You have to select a warehouse ' + ;
                  'before you may enter a dyelot.')
    lcDyelot   = lcOldVal                  
    llSelected = .F.
  ELSE
    *N16,5 Check if called for Style/Color or Fabric/Color dyelots
    IF UPPER(LEFT(ALLTRIM(lcDyeSrc),1)) = 'S'
      llFromStyle = .T.
      lcDyeFile   = 'STYDYE'
      lcItem      = PADR(ALLTRIM(lcItem),12)
    ELSE
      llFromStyle = .F.
      lcDyeFile   = 'FABDYE'
      lcItem      = PADR(ALLTRIM(lcItem), 7)
    ENDIF  
  
    *N16,5 Use the default warehouse if it is empty
    *N16,5 (that is in the case of single warehouse, checked above).
    lcWareCode    = IIF(EMPTY(lcWareCode), 'DEFWHE',;
                        PADR(ALLTRIM(lcWareCode),6))
    lcColor       = PADR(ALLTRIM(lcColor), 6)
  
    lnCurAlias    = SELECT()
    
    *E300637,1 Use the new global variables names 
    *llOpenFile    = gfOpenFile(qDD + lcDyeFile, lcDyeFile, 'SH')
    llOpenFile =gfOpenFile(gcDataDir+lcDyeFile,gcDataDir+lcDyeFile,'SH')
    *E300637,1 (End)

    *N16,5 If browsing, do not present an inquiry message.
    IF llBrowse 
      *N16,5 Call the appropriate dyelots browsing function
      *N16,5 whether called for style/color or fabric/color dyelots
      *E300511,4 Reham On 08/04/97  ** Begin **
      *E300511,4 Remove the color from the calling of dyelots browse.
      *IF llFromStyle .AND. ;
      *   !SDYEBROW(lcItem, lcColor, @lcDyelot, .T., lcWareCode);
      *   .OR.;
      *   !llFromStyle .AND. ;
      *   !FDYEBROW(lcItem, lcColor, @lcDyelot, .T., lcWareCode)
      IF llFromStyle .AND. !SDYEBROW(lcItem, @lcDyelot, .T., lcWareCode);
         .OR. !llFromStyle .AND. ;
         !FDYEBROW(lcItem, lcColor, @lcDyelot, .T., lcWareCode)
      *E300511,4 Reham On 08/04/97  ** End   **
         lcDyelot = lcOldVal
         llSelected = .F.         
       ENDIF  
    ELSE 
      *N16,5 If a dyelot is not found for the item/color/warehouse
      *N16,5 present an inquiry message whether to add, browse, or reenter.
      IF !SEEK(lcItem + lcColor + lcWareCode + lcDyelot, lcDyeFile)
        *N16,5 If from style, call style dyelots validation functions
        IF llFromStyle 
          lnOption =  gfDialog ('I',;
                      'Style/Color/Dyelot ' + ALLTRIM(lcItem) + ;
                      '/' + ALLTRIM(lcColor) + ;
                      '/' + ALLTRIM(lcDyelot) + ;
                      IIF(llMultiWare,;
                      ' is not assigned to warehouse ' + ;
                      ALLTRIM(lcWareCode)+'.',;
                      ' is not found.'),;
                      '\<Add;\<Browse;\<Reenter')
          DO CASE
            *N16,5 Case 'Add'ing the dyelot to the file,
            CASE lnOption = 1           
              *E300511,4 Reham On 08/04/97  ** Begin **
              *E300511,4 Remove the color from the calling of the function.
              *DO gpAdStyWar WITH lcItem, lcColor, lcDyelot, lcWareCode 
              DO gpAdStyWar WITH lcItem, lcDyelot, lcWareCode
              *E300511,4 Reham On 08/04/97  ** End   **
              
            *N16,5 Case 'Brows'ing existing dyelot for the current
            *N16,5 warehouse
            CASE lnOption = 2              
              *E300511,4 Reham On 08/04/97  ** Begin **
              *E300511,4 Remove the color from the calling of dyelots browse.
              *IF !SDYEBROW(lcItem, lcColor, @lcDyelot, .T., lcWareCode)
              IF !SDYEBROW(lcItem, @lcDyelot, .T., lcWareCode)
              *E300511,4 Reham On 08/04/97  ** End   **
                lcDyelot   = lcOldVal
                llSelected = .F.
              ENDIF  
            *N16,5 Case "Reenter'ing  
            OTHERWISE
              lcDyelot   = SPACE(10)
              llSelected = .F.
          ENDCASE
        
        *N16,5 If from fabric, call fabric dyelots validation functions
        ELSE
          lnOption =  gfDialog ('I',;
                     'Item/Color/Dyelot ' + ALLTRIM(lcItem) + ;
                     '/' + ALLTRIM(lcColor) + ;
                     '/' + ALLTRIM(lcDyelot) + ;  
                     IIF(llMultiWare, ;                     
                     ' is not assigned to warehouse ' + ;
                     ALLTRIM(lcWareCode)+'.',;
                      ' is not found.'),;
                     '\<Add;\<Browse;\<Reenter')
                     
          DO CASE
            *N16,5 Case 'Add'ing the dyelot to the file,
            CASE lnOption = 1           
              DO gpAdFabWar WITH lcItem, lcColor, lcDyelot, lcWareCode 

            *N16,5 Case 'Brows'ing existing dyelot for the current
            *N16,5 warehouse
            CASE lnOption = 2              
              IF !FDYEBROW(lcItem, lcColor, @lcDyelot, .T., lcWareCode)
                lcDyelot   = lcOldVal
                llSelected = .F.
              ENDIF  

            *N16,5 Case "Reenter'ing  
            OTHERWISE
              lcDyelot = SPACE(10)
              llSelected = .F.
          ENDCASE
        ENDIF              && End IF llFromStyle
      ENDIF              && End IF !SEEK(dyelot) 
    ENDIF             && End IF llBrowse
    SELECT (lnCurAlias)
  ENDIF             && End IF M_WareHouse = 'Y' .AND. EMPTY(lcWareCode)
  llBrowse = .F.  
ENDIF  
RETURN llSelected


*!*************************************************************
*! Name      : gfGLAcctBr
*! Developer : MALAK - Malak Hanna
*! Date      : 17/07/1995
*! Purpose   : Browse general ledger account from linked company.
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  : lcFileName  : Chart of account file name.
*!                    : lcAcctField : Account field name. 
*!                    : lcDescField : Account description field name.
*!                    : lcAccount   : Account object.
*!*************************************************************
*! Returns            :  True  --> If valid account.
*!                       False --> If inValid account.
*!*************************************************************
*! Example            : gfGLAcctBr(lcFName,lcAField,lcDField,@xGL_Accnt)
*!*************************************************************
FUNCTION gfGLAcctBr
PARAMETERS lcFileName, lcAcctField, lcDescField, lcAccount
PRIVATE    lnCurAlias, llReturnVal, lnSoftSeek , lcAccount

lnCurAlias = SELECT()
SELECT &lcFileName
llReturnVal = .T.
llBrowse    = IIF(TYPE('llBrowse')='U',.F.,llBrowse) && variable to determine forcing browse or not

IF llBrowse .OR. !SEEK(lcAccount)   
  lnSoftSeek = RECNO(0)
  IF lnSoftSeek<>0 
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF     

  lcFile_Ttl = 'G/L Accounts'
  lcBrFields = "&lcAcctField :H='General Leadger Account' ,"+;
               "&lcDescField :H='Description':35"

  llReturnVal=ARIABROW('',lcFile_Ttl,gnBrHSRow1, gnBrHSCol1, gnBrHSRow2, gnBrHSCol2)
  lcAccount = IIF(llReturnVal,&lcAcctField,lcAccount)
ENDIF

llBrowse = .F.
SELECT (lnCurAlias)
RETURN llReturnVal


*!*************************************************************
*! Name      : gfvWareHs
*! Developer : RENEE - Renee Ezzat
*! Date      : 07/11/1995
*! Purpose   : Global warehouse validation.
*!             Validates a warehouse entry. If valid, checks its
*!             assignment to the passed style or fabric color. 
*!             If not found in the corresponding dyefile, 
*!             may browse, add, or reenter.
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  :  lcDyeSrc   : 'S' if validating styles,
*!                                    'M' if validating fabric
*!                       lcItem     : Fabric or Style
*!                       lcColor    : Color
*!                       lcWareCode : warehouse code, 
*!                                    or empty for default.
*!                       lcOldVal   : old value of the warehouse,
*!                                    (optional)
*!                                    If not passed, the warehouse is filled
*!                                    with spaces instead of the old value
*!                                    of the field.
*!*************************************************************
*! Returns            :  .T. if a warehouse is valid, or selected,
*!                       .F. otherwise
*!*************************************************************
*! Example            :  If called for style validation,
*!                         =gfvWareHs('S', lcStyle, lcColor, @lcWareCode,;
*!                                      lcOldVal)  
*!                       If called for fabric validation,
*!                         =gfvWareHs('M', lcFabric, lcColor, @lcWareCode,;
*!                                      lcOldVal)  
*!
*!***************************************************************
*N16,5     RENEE 08/01/95 
*!***************************************************************
FUNCTION gfvWareHs
PARAMETERS lcDyeSrc, lcItem, lcColor, lcWareCode, lcOldVal
PRIVATE lcDyeFile, lnCurAlias, lnOption, llFromStyle, llOpenDyeF, llOpenWareF, llSelected
*N16,5 lcDyeFile   : Source dye file ('STYDYE' or 'FABDYE')
*N16,5 lnCurAlias  : Current work area
*N16,5 lnOption    : holds the option of a dialog
*N16,5 llFromStyle : .T. if called for style validations, 
*N16,5               .F. otherwise
*N16,5 llOpenDyeF  : .T. if Dye file is opened in this function,
*N16,5               .F. otherwise
*N16,5 llOpenWarF  : .T. if WAREHOUS file is opened in this function,
*N16,5               .F. otherwise

*N16,5 llSelected  : .T. if a warehouse is selected, .F. otherwise. 

lcWareCode  = PADR(ALLTRIM(lcWareCode), 6) 
lcOldVal    = IIF(TYPE('lcOldVal') $ 'UL', SPACE(6), lcOldVal)
llBrowse    = IIF(TYPE('llBrowse') = 'U' ,;
                .F., llBrowse .OR. '?' $ lcWareCode)
llSelected = .T.
 
*N16,5 Validate warehouse if called from a browsing button, or if
*N16,5 its value is changed and it is not empty.
IF llBrowse .OR. !EMPTY(lcWareCode)
  *N16,5 Check if called for Style/Color or Fabric/Color 
  IF UPPER(LEFT(ALLTRIM(lcDyeSrc),1)) = 'S'
    llFromStyle = .T.
    lcDyeFile   = 'STYDYE'
    lcItem      = PADR(ALLTRIM(lcItem),12)
  ELSE
    llFromStyle = .F.
    lcDyeFile   = 'FABDYE'
    lcItem      = PADR(ALLTRIM(lcItem), 7)
  ENDIF  
  lcColor       = PADR(ALLTRIM(lcColor), 6)
  
  lnCurAlias    = SELECT()
   
  *E300637,1 Use the new global variables names 
  *llOpenDyeF    = gfOpenFile(qDD + lcDyeFile , lcDyeFile ,'SH')
  *llOpenWarF    = gfOpenFile(qDD + 'WAREHOUS', 'WAREHOUS', 'SH')
  llOpenDyeF     =gfOpenFile(gcDataDir+lcDyeFile,gcDataDir+lcDyeFile,'SH')
  llOpenWarF     =gfOpenFile(gcDataDir+'WAREHOUS',gcDataDir+'WAREHOUS','SH')
  *E300637,1 (End)
     
  *N16,5 If browsing, do not present an inquiry message.
  SELECT WAREHOUS
  *N16,5 If not found in the WAREHOUS file, or, called from a 
  *N16,5 browsing button, or if it has a '?'  
  IF !SEEK(lcWareCode) .OR. llBrowse
    IF !('?' $ lcWareCode .OR. llBrowse) .AND. BETWEEN(RECNO(0), 1, RECCOUNT())
      GO RECNO(0)
    ELSE
      GO TOP
    ENDIF  
    *N16,5 Call the global warehouse validation 
    lcWareCode = gfBrowWare(.T.) 
  ENDIF
  *N16,5 If a warehouse code is selected, check that there is a record
  *N16,5 for the current item/color/warehouse in the dye file.
  IF !EMPTY(lcWareCode) 
    *N16,5 If item/color/warehouse is not found in the dye file
    IF !SEEK(lcItem + lcColor + lcWareCode + SPACE(10), lcDyeFile)
      *N16,5 If from style, call style validation functions
      IF llFromStyle 
        lnOption =  gfDialog ('I',;
                    'Style/Color ' + ALLTRIM(lcItem) + ;
                    '/' + ALLTRIM(lcColor) + ;
                    ' is not assigned to warehouse ' + ;
                    ALLTRIM(lcWareCode)+'.',;
                    '\<Add;\<Browse;\<Reenter')
        DO CASE
          *N16,5 Case 'Add'ing the warehouse to the file,
          CASE lnOption = 1           
            *E300511,4 Reham On 08/04/97  ** Begin **
            *E300511,4 Remove the color from the calling of the function.
            *DO gpAdStyWar WITH lcItem, lcColor, SPACE(10), lcWareCode 
            DO gpAdStyWar WITH lcItem, SPACE(10), lcWareCode 
            *E300511,4 Reham On 08/04/97  ** End    **
            
          *N16,5 Case 'Brows'ing existing warehouses for the current
          *N16,5 item/color
          CASE lnOption = 2              
            *E300511,4 Reham On 08/04/97   ** Begin **
            *E300511,4 Remove the color from the calling of the warehouse browse.
            *lcWareCode = gfBrowWare(.T., lcItem, lcColor,lcWareCode, lcDyeFile) 
            lcWareCode = gfBrowWare(.T., lcItem,SPACE(6),lcWareCode, lcDyeFile)
            *E300511,4 Reham On 08/04/97   ** End   **
            IF EMPTY(lcWareCode)
              lcWareCode = lcOldVal
              llSelected = .F.
            ENDIF  
          *N16,5 Case "Reenter'ing  
          OTHERWISE
            lcWareCode = SPACE(6)
            llSelected = .F.
        ENDCASE
        
      *N16,5 If from fabric, call fabric validation functions
      ELSE
        lnOption = gfDialog ('I',;
                   'Item/Color ' + ALLTRIM(lcItem) + ;
                   '/' + ALLTRIM(lcColor) + ;
                   ' is not assigned to warehouse ' + ;
                   ALLTRIM(lcWareCode)+'.',;
                   '\<Add;\<Browse;\<Reenter')
        DO CASE
          *N16,5 Case 'Add'ing the warehouse to the file,
          CASE lnOption = 1           
            DO gpAdFabWar WITH lcItem, lcColor, SPACE(10), lcWareCode 

          *N16,5 Case 'Brows'ing existing warehouses for the current
          *N16,5 item/color
          CASE lnOption = 2              
            lcWareCode = gfBrowWare(.T., lcItem, lcColor,;
                                    lcWareCode, lcDyeFile) 
            IF EMPTY(lcWareCode)
              lcWareCode = lcOldVal
              llSelected = .F.
            ENDIF  

          *N16,5 Case "Reenter'ing  
          OTHERWISE
            lcWareCode = SPACE(6)
            llSelected = .F.
        ENDCASE
      ENDIF              && End IF llFromStyle
    ENDIF              && End IF !SEEK(..) 
  ELSE
    lcWareCode = lcOldVal
    llSelected = .F.
  ENDIF              && End IF !EMPTY(..)  
  SELECT (lnCurAlias)
  llBrowse  = .F.
ENDIF
RETURN llSelected

*!*************************************************************
*! Name      : gfClsData
*! Developer : MAN
*! Date      : 09/04/1995
*! Purpose   : To open database needed by the program.
*!*************************************************************
*! Calls              : None
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example            : =gfClsData()
*!*************************************************************
*E300285,1 MAN 09/04/1995 Added the function to replace 
*E300285,1 MAN CLOSE DATABASES

FUNCTION gfClsData

CLOSE DATABASES
IF TYPE('llAct_Key') = 'L' AND llAct_Key  && Check if User count is implemented
  SELECT 100
  USE (gcSysHome+"syustatc")  ORDER TAG CUSER_ID
  IF SEEK('INI'+'OLDVARS'+gcUser_ID+gcStation)
   =RLOCK()   
  ENDIF
ENDIF  

*!*************************************************************
*! Name      : gfStr2Ar
*! Developer : RENEE - Renee Ezzat
*! Date      : 10/09/1995
*! Purpose   : Cuts string containing elements separated by
*!             delimeter (passed as a parameter) into a one
*!             or two dimensional array.
*!             Adapted from ARIA ADVANTAGE gfSubStr() function
*!*************************************************************
*! Calls              :  None
*!*************************************************************
*! Passed Parameters  :  - lcString   : String to be cut into array 
*!                                      elements
*!                       - lnAryOrPos : Pointer to an array
*!                       - lcSepta    : Separator pattern(s).
*!*************************************************************
*! Returns            :  None
*!*************************************************************
*! Example            :  - One dim. array : 
*!                          =gfStr2Ar(m.mNotify, @laArrName, '|')
*! Example            :  - Two dim. array : 
*!                          =gfStr2Ar('P|S~Purchase|Sales', 
*!                                    @laArrName, '|~')
*!*************************************************************
FUNCTION gfStr2Ar
PARAMETERS lcString,lnAryOrPos,lcSepta
** lcSepta : separator.

lcSubstr  =' '
lnAryDim  = 1
lnAryRows = 1
lnAryCols = 1
lcSepta   = IIF(TYPE('lcSepta')='C',lcSepta,',') 

IF LEN(ALLTRIM(lcSepta))>1
  lcColSep  = SUBSTR(lcSepta,2,1)
  lcSepta   = LEFT(lcSepta,1)
  lnAryDim  = IIF(OCCURS(lcSepta,lcString)>0,;
              OCCURS(lcSepta,lcString)+;
              IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
              lnAryDim)
  lnAryCols = IIF(OCCURS(lcColSep,lcString)>0,;
              OCCURS(lcColSep,lcString)+;
              IIF(RIGHT(lcString,1)<>lcColSep,1,0),;
              lnAryDim)
  lnAryRows = (lnAryDim+(lnAryCols-1)) / lnAryCols
  lnAryDim  = lnAryDim +(lnAryCols-1)     
  lcString  = STRTRAN(lcString,lcColSep,lcSepta)
ELSE
  lnAryDim = IIF(OCCURS(lcSepta,lcString)>0,;
             OCCURS(lcSepta,lcString)+;
             IIF(RIGHT(lcString,1)<>lcSepta,1,0),;
             lnAryDim)
ENDIF

*** Chek if second parameter array or numeric
DO CASE
  *** If no parameter found assume firest part of string
  CASE TYPE ('lnAryOrPos')='U'
    lnAryOrPos = 1

  *** If array strich it to hold all string parts
  CASE TYPE ('lnAryOrPos') $ 'C,L'    
    IF lnAryCols > 1
      DIMENSION lnAryOrPos[lnAryRows,lnAryCols]
    ELSE
      IF ALEN(lnAryOrPos,2) > 0
        DIMENSION lnAryOrPos[lnAryDim,ALEN(lnAryOrPos,2)]
      ELSE
        DIMENSION lnAryOrPos[lnAryDim]
      ENDIF  

    ENDIF
    lnAryOrPos  = ' '

ENDCASE

FOR lnArElem  = 1 TO lnAryDim
  IF TYPE ('lnAryOrPos')='N'
    lnArElem = lnAryOrPos
  ENDIF  

  DO CASE
    *** In case of firest string part
    CASE lnArElem = 1
      lcSubstr = SUBSTR(lcString,1,;
      IIF(lcSepta $ lcString,AT(lcSepta,lcString)-1,LEN(lcString)))

    *** In case of last string part
    CASE lnArElem = lnAryDim
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1)
      lcSubstr = IIF(RIGHT(lcSubstr,1)=lcSepta,;
                 SUBSTR(lcSubstr,1,LEN(lcSubstr)-1),lcSubstr)
    *** In case of any string part from the meddel
    CASE lnArElem > 1
      lcSubstr = SUBSTR(lcString,AT(lcSepta,lcString,lnArElem-1)+1,;
                 AT(lcSepta,lcString,lnArElem)-;
                 AT(lcSepta,lcString,lnArElem-1)-1)
  ENDCASE

  IF TYPE ('lnAryOrPos')='N'
    RETURN lcSubstr
  ENDIF  
  
  IF lnAryCols > 1
    lnAryOrPos[((lnArElem-1)%lnAryRows)+1,INT((lnArElem-1)/lnAryRows)+1] = lcSubstr
  ELSE
    lnAryOrPos[lnArElem] = lcSubstr
  ENDIF
ENDFOR

*!**************************************************************************
*!
*!      Function: lfCondUpper
*!         
*!**************************************************************************
*
FUNCTION lfCondUpper
PARAMETERS lcOGCriteria
llToUp=.T.
lcOGUpCrit=''
FOR lnOGCount = 1 TO LEN(lcOGCriteria)
 IF SUBSTR(lcOGCriteria,lnOGCount,1) $ ['"]
   llToUp=!llToUp 
 ENDIF
   lcOGUpCrit=lcOGUpCrit+IIF(llToUp,UPPER(SUBSTR(lcOGCriteria,lnOGCount,1)),;
                            SUBSTR(lcOGCriteria,lnOGCount,1))
ENDFOR
RETURN lcOGupCrit



*!**************************************************************************
*!
*!      Function: lfGetScope
*!         
*!**************************************************************************
*
FUNCTION lfGetScope
PARAMETERS lcOGCriteria
PRIVATE lcOGExact
lcOGExact=SET('EXACT')
SET EXACT ON
lcOGScope = ''
&lcOGCriteria=lfCondUpper(&lcOGCriteria)
&lcOGCriteria = IIF(LEFT(&lcOGCriteria,1)=' ','',' ')+&lcOGCriteria+IIF(RIGHT(&lcOGCriteria,1)=' ','',' ')
lcCriteria = &lcOGCriteria
lcOGScope = lcOGScope + IIF(&lcOGCriteria<>STRTRAN(&lcOGCriteria,' ALL '),'ALL ','')
&lcOGCriteria = STRTRAN(&lcOGCriteria,'ALL ')
&lcOGCriteria = IIF(LEFT(&lcOGCriteria,1)=' ','',' ')+&lcOGCriteria+IIF(RIGHT(&lcOGCriteria,1)=' ','',' ')
lcOGScope = lcOGScope + IIF(&lcOGCriteria<>STRTRAN(&lcOGCriteria,' REST '),'REST ','')
&lcOGCriteria = STRTRAN(&lcOGCriteria,'REST ')
&lcOGCriteria = IIF(LEFT(&lcOGCriteria,1)=' ','',' ')+&lcOGCriteria+IIF(RIGHT(&lcOGCriteria,1)=' ','',' ')
IF ATC(' RECORD ',&lcOGCriteria)>0
  lcOGRec = ALLTRIM(SUBSTR(&lcOGCriteria,ATC(' RECORD ',&lcOGCriteria)+8))
  lcOGRec = lcOGRec+' '
  lcOGRcCont = SUBSTR(lcOGRec,1,ATC(' ',lcOGRec)-1)
  lcOGScope = lcOGScope + 'RECORD '+lcOGRcCont+' '
  lcOGRec = SUBSTR(&lcOGCriteria,ATC(' RECORD ',&lcOGCriteria),(ATC(' RECORD ',&lcOGCriteria)+LEN(lcOGrcCont)+8)-ATC(' RECORD ',&lcOGCriteria))
  &lcOGCriteria = STRTRAN(&lcOGCriteria,lcOGRec)  
ENDIF  
&lcOGCriteria = IIF(LEFT(&lcOGCriteria,1)=' ','',' ')+&lcOGCriteria+IIF(RIGHT(&lcOGCriteria,1)=' ','',' ')
IF ATC(' NEXT ',&lcOGCriteria)>0
  lcOGRec = ALLTRIM(SUBSTR(&lcOGCriteria,ATC(' NEXT ',&lcOGCriteria)+6))
  lcOGRec = lcOGRec+' '
  lcOGRcCont = SUBSTR(lcOGRec,1,ATC(' ',lcOGRec)-1)
  lcOGScope = lcOGScope + IIF(!EMPTY(lcOGRec),'NEXT '+lcOGRcCont,'')
  lcOGRec = SUBSTR(&lcOGCriteria,ATC(' NEXT ',&lcOGCriteria),(ATC(' NEXT ',&lcOGCriteria)+LEN(lcOGrcCont)+6)-ATC(' NEXT ',&lcOGCriteria))
  &lcOGCriteria = STRTRAN(&lcOGCriteria,lcOGRec)  
ENDIF  
SET EXACT &lcOGExact
RETURN lcOGScope



*!**************************************************************************
*!
*!      Function: lfGetcope1
*!       
*!**************************************************************************
*
FUNCTION lfGetcope1
PARAMETERS lcOGCriteria
PRIVATE lcOGExact
lcOGExact=SET('EXACT')
SET EXACT ON
lcOGScope = ''
lcCriteria=lfCondUpper(lcOGCriteria)
lcOGScope = lcOGScope + IIF(lcOGCriteria<>STRTRAN(lcOGCriteria,'ALL'),'ALL ','')
lcOGScope = lcOGScope + IIF(lcOGCriteria<>STRTRAN(lcOGCriteria,'REST'),'REST ','')

IF ATC('RECORD ',lcOGCriteria)>0
  lcOGRec = ALLTRIM(SUBSTR(lcOGCriteria,ATC('RECORD ',lcOGCriteria)+7))
  lcOGRcCont = SUBSTR(lcOGRec,1,ATC(' ',lcOGRec)-1)
  lcOGScope = lcOGScope + 'RECORD '+lcOGRcCont+' '
ENDIF  

IF ATC('NEXT ',lcOGCriteria)>0
  lcOGRec = ALLTRIM(SUBSTR(lcOGCriteria,ATC('NEXT ',lcOGCriteria)+5))
  lcOGRcCont = SUBSTR(lcOGRec,1,ATC(' ',lcOGRec)-1)
  lcOGScope = lcOGScope + IIF(!EMPTY(lcOGRec),'NEXT '+lcOGRcCont,'')
ENDIF  

SET EXACT &lcOGExact
RETURN lcOGScope


FUNCTION lfRpThermo
PARAMETERS lnRpTotal,lnRpCount,lcMessage 

WAIT SUBSTR(SPACE(LEN(lcMessage))+lcMessage+SPACE(LEN(lcMessage)),MOD(&lnRpCount,LEN(lcMessage)*2),LEN(lcMessage));
     WINDOW NOWAIT 
&lnRpCount=&lnRpCount+1      
RETURN .T.


FUNCTION lfQuitReport
PARAMETERS lnMRow,lnMcol

RETURN IIF(LASTKEY()=27,.F.,!(BETWEEN(lnMRow,2,2) AND BETWEEN(lnMCol,2,12)))


FUNCTION lfDispPage
PRIVATE lcOutWin

lcOutWin=WONTOP()
ACTIVATE WINDOW (lcTempWin) SAME

@ IIF(_DOS,0,3),IIF(_DOS,2,8) SAY 'Printing Page '+ALLTRIM(STR(_PAGENO)) SIZE 1,20

lnPPage=_PAGENO

IF !EMPTY(lcOutWin)
  ACTIVATE WINDOW (lcOutWin)
ENDIF

*!*************************************************************
*! Name      : gfStyPrice
*! Developer : Renee Ezzat
*! Date      : 12/20/95
*! Purpose   : Return the style/color price in a given currency.
*!*************************************************************
*! Parameters: lcStyle    : Style
*!             lcColor    : color
*!             lcStyCur   : Style currency code
*!             lcPriceLvl : price level ('A', 'B', or 'C')
*!             llNoAdd    : .T. if adding prices on the fly
*!                          is not to be allowed despite the company
*!                          setup.
*!*************************************************************
*! Calls     : gfGetMemVar
*!             STYPRICE.SPR     
*!*************************************************************
*! Returns                : Price level in passed currncy for
*!                          the passed style/color, or
*!                          -1 if it is not found and/or not
*!                          added.
*!*************************************************************
*! Example   : lnPrice = gfStyPrice(lcStyle, lcColor, lcCurrCode, 'A')
*!*************************************************************
*E300328,1 RENEE 12/21/95. 
*E300620,4 Reham On 08/05/97
*E300620,4 Remove color from the function.
*B602290,1 HSS 11/29/98 1) Get the price from STYLE file in the case of base
*B602290,1                 currency.
*B602290,1              2) Use gfModalgen()
*:*************************************************************************
FUNCTION gfStyPrice
*E300620,4 Reham On 08/05/97  ** Begin **
*E300620,4 Remove th color parameter.
*PARAMETERS lcStyle, lcColor, lcPriceLvl, lcStyCur, llNoAdd 
PARAMETERS lcStyle, lcPriceLvl, lcStyCur, llNoAdd 
*E300620,4 Reham On 08/05/97  ** End   **
PRIVATE lcFilter, lnOldVal, lnCurAlias, lnRetVal, lnCurTag, lnCurRec, llOpenFile   

*E300328,1 Called only if multi currency
*E300637,1 Use the new global setups function
*IF !gfGetMemVar('LLMULCURR', qSysCode)
IF !gfGetMemVar('LLMULCURR',gcAct_Comp)
*E300637,1 (End)
  RETURN -1
ENDIF

*E300620,4 Reham On 08/05/97  ** Begin **
*E300620,4 Remove the color from the if condition.
*E300328,1 Check parameters
*E300328,1 Return if no parameters are passed
*IF EMPTY(lcStyle) .OR. EMPTY(lcColor) .OR.;
   EMPTY(lcPriceLvl) .OR. ATC(lcPriceLvl, 'ABC') = 0)

*B602290,1 Change this line to remove the extra ')' [Begin]
*IF EMPTY(lcStyle) .OR. EMPTY(lcPriceLvl) .OR. ATC(lcPriceLvl, 'ABC') = 0)
IF EMPTY(lcStyle) .OR. EMPTY(lcPriceLvl) .OR. ATC(lcPriceLvl, 'ABC') = 0
*B602290,1 Change this line to remove the extra ')' [End]

*E300620,4 Reham On 08/05/97  ** End   **
  RETURN -1
ENDIF  

*E300328,1 If there is no currency code parameter, default with
*E300328,1 the base currency.
IF EMPTY(lcStyCur)
  lcStyCur = gcBaseCurr
ENDIF  

*E300328,1 Check if STYPRICE is open,
*E300328,1 If the file is used, store current environment
lnCurAlias = SELECT()
lnOldVal   = 0
IF USED('STYPRICE')
  llOpenFile = .F.
  SELECT STYPRICE
  *E300328,1 Get current tag
  lnCurTag   = VAL(SYS(21))
  *E300328,1 Get current record
  lnCurRec   = IIF(!EOF(), RECNO(), 0)
  *E300328,1 Get current filter
  lcFilter   = FILTER() 
  SET FILTER TO
  SET ORDER TO TAG STYPRICE  
ELSE
  *E300637,1 Use the new global variables names
  *llOpenFile = gfOpenFile(qDD+'STYPRICE', 'STYPRICE' , 'SH')
  llOpenFile =gfOpenFile(gcDataDir+'STYPRICE',gcDataDir+'STYPRICE','SH')
  *E300637,1 (End)
  lnCurAlias = 0
ENDIF

*E300328,1 Adjust Customer level parameter.
lcPriceLvl = LEFT(ALLTRIM(lcPriceLvl), 1) 

*B602290,1 Add these lines to get the style price from the STYLE file in the
*B602290,1 case of base currency [Begin]

*B602290,1 If base currency
IF ALLTRIM(lcStyCur) == ALLTRIM(gcBaseCurr)
  PRIVATE llCloseSty , lcStyOrder , lnStyRecNo
  
  IF !USED('STYLE')
    llCloseSty = .T.
    SELECT 0
    =gfOpenFile(gcDataDir + 'STYLE' , gcDataDir + 'STYLE' , 'SH')
    SELECT STYLE
  ELSE
    llCloseSty = .F.
    SELECT STYLE
    lnStyRecNo = IIF(EOF() , 0 , RECNO())
    lcStyOrder = ORDER()
    SET ORDER TO TAG STYLE
  ENDIF
  
  lcStyle = PADR(lcStyle , LEN(Style))
  IF SEEK(lcStyle)
    lnRetVal = Price&lcPriceLvl
  ELSE
    lnRetVal = -1
  ENDIF
  
  IF llCloseSty
    USE IN STYLE
  ELSE
    SELECT STYLE
    SET ORDER TO (lcStyOrder) IN STYLE
    IF lnStyRecNo <> 0
      GO lnStyRecNo IN STYLE
    ELSE
       GO BOTTOM IN STYLE
       SKIP IN STYLE
    ENDIF
  ENDIF
ELSE    && If not base currency
*B602290,1 Add these lines to get the style price from the STYLE file [End]

  *E300620,4 Reham On 08/05/97  ** Begin **
  *E300620,4 Remove the color from the seek condition.
  *E300328,1 If a record exists, get the price that corresponds to the
  *E300328,1 passed level.
  *IF SEEK(lcStyle + lcColor + lcStyCur, 'STYPRICE')
  IF SEEK(lcStyle + lcStyCur, 'STYPRICE')
  *E300620,4 Reham On 08/05/97  ** End   **
    lnRetVal = STYPRICE.Price&lcPriceLvl
  *E300328,1 Otherwise,   
  ELSE
    lnRetVal = -1
    *E300637,1 Use the new global setups function
    *IF !llNoAdd .AND. gfGetMemVar('LLSTYPRICE', qSysCode)
    IF !llNoAdd .AND. gfGetMemVar('LLSTYPRICE', gcAct_Comp)
    *E300637,1 (End)
      STORE 0 TO lnPriceA, lnPriceB, lnPriceC
      *E300637,1 Use the new global variables names
      *DO (qSD + 'STYPRICE.SPR')
      DO STYPRICE.SPR
      *E300637,1 (End)
    ELSE
      *E300620,4 Reham On 08/05/97  ** Begin **
      *E300620,4 Remove the color from the message.
      *=gfDialog('I', 'No prices are defined for style/color '  +;
                     ALLTRIM(lcStyle) + '/' + ALLTRIM(lcColor) +;
                     ' in ' + ALLTRIM(lcStyCur)) 
      *B602290,1 Change this line to use gfModalGen() [Begin]
      *=gfDialog('I', 'No prices are defined for style ' + ;
      *               ALLTRIM(lcStyle) + ' in ' + ALLTRIM(lcStyCur)) 
      
      =gfModalGen("TRM00344B00000" , "DIALOG" , ALLTRIM(gfItemMask('HI')) +;
                    " " + ALLTRIM(lcStyle) + "|" + ALLTRIM(lcStyCur))
      *B602290,1 Change this line to use gfModalGen() [End]
    
      *E300620,4 Reham On 08/05/97  ** End   **
    ENDIF  
  ENDIF  
*B602290,1 Add these lines to get the style price from the STYLE file in the
*B602290,1 case of base currency [Begin]
ENDIF    && End of IF ALLTRIM(lcStyCur) == ALLTRIM(gcBaseCurr)
*B602290,1 Add these lines to get the style price from the STYLE file [End]


*E300328,1 Restore environment
IF !llOpenfile
  SELECT STYPRICE
  SET ORDER TO (lnCurTag)
  IF !EMPTY(lcFilter)
    SET FILTER TO (lcFilter)
  ENDIF
  IF lnCurRec > 0
    GO lnCurRec
  ENDIF  
ENDIF
SELECT (lnCurAlias)

*E300328,1 Return price
RETURN lnRetVal

*!*************************************************************
*! Name      : lfvStyPrOk
*! Developer : Renee Ezzat
*! Date      : 12/20/95
*! Purpose   : VALID function for push button OK in STYPRICE.SCX
*!*************************************************************
*! Passed Parameters: None
*!*************************************************************
*! Called From      : STYPRICE.SPR
*!*************************************************************
*! Calls            : None
*!*************************************************************
*! Returns          : None.
*!*************************************************************
*! Example          : =lfvStyPrOk()
*!*************************************************************
*E300328,1 RENEE 12/21/95. . 
*:*************************************************************************
FUNCTION lfvStyPrOk

*E300637,1 WAM 04/08/97 Use the global variables names
*INSERT INTO STYPRICE;
       (  Style,   Color, cCurrCode,   PriceA,   PriceB,   PriceC,;
          Add_UserID, Add_Date, Add_Time);
 VALUES(lcStyle, lcColor, lcStyCur , lnPriceA, lnPriceB, lnPriceC,;
          qUserID, DATE(), TIME())
*B602658,4 [BEGIN] Replace fields ADD_DATE , ADD_TIME , ADD_USERID 
*                  and its values with calling gfAdd_Info('<File Name>')
*INSERT INTO STYPRICE;
       (  Style,   cCurrCode,   PriceA,   PriceB,   PriceC,;
          Add_UserID, Add_Date, Add_Time);
* VALUES(lcStyle, lcStyCur , lnPriceA, lnPriceB, lnPriceC,;
          gcUser_ID, gdSysDate, TIME())
INSERT INTO STYPRICE (Style,cCurrCode,PriceA,PriceB,PriceC );          
VALUES(lcStyle, lcStyCur , lnPriceA, lnPriceB, lnPriceC)

 =gfAdd_Info('STYPRICE')         

*B602658,4 [END..]
*E300637,1 (End)

lnRetVal = lnPrice&lcPriceLvl

*!*************************************************************
*! Name      : lfwStyPrice
*! Developer : Renee Ezzat
*! Date      : 12/20/95
*! Purpose   : WHEN function for style price field in STYPRICE.SCX
*!*************************************************************
*! Passed Parameters: None
*!*************************************************************
*! Called From      : STYPRICE.SPR
*!*************************************************************
*! Calls            : None
*!*************************************************************
*! Returns          : None.
*!*************************************************************
*! Example          : =lfwStyPrice()
*!*************************************************************
*E300328,1 RENEE 12/21/95. . 
*:*************************************************************************
FUNCTION lfwStyPrice
lnOldVal = EVALUATE(SYS(18))

*!*************************************************************
*! Name      : lfvStyPrice
*! Developer : Renee Ezzat
*! Date      : 12/20/95
*! Purpose   : VALID function for style price field in STYPRICE.SCX
*!*************************************************************
*! Passed Parameters: None
*!*************************************************************
*! Called From      : STYPRICE.SPR
*!*************************************************************
*! Calls            : None
*!*************************************************************
*! Returns          : None.
*!*************************************************************
*! Example          : =lfvStyPrice()
*!*************************************************************
*E300328,1 RENEE 12/21/95. . 
*B602290,1 HSS 11/29/98 Use gfModalgen()
*:*************************************************************************
FUNCTION lfvStyPrice
IF EVALUATE(SYS(18)) < 0
  *B602290,1 Change this line to use gfModalGen() [Begin]
  *=gfDialog('I', 'Style price cannot be negative.')
  =gfModalGen("TRM00343B00000" , "DIALOG")
  *B602290,1 Change this line to use gfModalGen() [End]
  lcStyObj  = SYS(18)
  &lcStyObj = lnOldVal
ENDIF   


*!*************************************************************
*! Name      : gfCurrBrow
*! Developer : RENEE - Renee Ezzat
*! Date      : 12/27/1995
*! Purpose   : Global currency code fields validation
*!*************************************************************
*! Calls     : gfBrow()
*!*************************************************************
*! Passed Parameters  : lcCurrCode : pointer to currency code field
*!                      lcCurrDesc : pointer to currency description
*!                                   variable (optional) 
*!*************************************************************
*! Returns            :  .T. If a valid currency code is selected,
*!                       .F. otherwise
*!*************************************************************
*! Example            :  =gfCurrBrow(@lcCurrCode, @lcCurrDesc)
*!*************************************************************
*E300324,5 Global currency codes validation
FUNCTION gfCurrBrow
PARAMETERS lcCurrCode, lcCurrDesc

lcCurrCode = PADR(ALLTRIM(lcCurrCode), 5)
DECLARE laTmpVal[2]
laTmpVal[1] = 'cCurrCode'
laTmpVal[2] = 'cCurrDesc'
*E300324,5 If a valid currency code is selected, 
*E300324,5 fill parameter variables,

IF gfBrow('SYCCURR', 'CCURRCODE', lcCurrCode, @laTmpVal,;
          [cCurrCode:8:H='Currency',cCurrDesc:30:H='Description',;
           nCurrUnit:5:H='Units',cCurrSmbl:7:H='Symbol'],;
           'Currencies', IIF(_DOS .OR. _UNIX, 54, 56))  

  lcCurrCode = laTmpVal[1]
  lcCurrDesc = laTmpVal[2]    
*E300324,5 Else, clear parameter variables
ELSE
  lcCurrCode = SPACE(5)
  lcCurrDesc = SPACE(30)
ENDIF    
RETURN !EMPTY(lcCurrCode)

*!*************************************************************
*! Name      : gfBrow
*! Developer : RENEE - Renee Ezzat
*! Date      : 12/27/1995
*! Purpose   : No button global browse
*!*************************************************************
*! Calls     : lcCurrCode
*!*************************************************************
*! Passed Parameters  :  None
*!*************************************************************
*! Returns            :  None
*!*************************************************************
*! Example            :  IF gfBrow('SYCCURR', 'CCURRCODE',;
*!                                  lcCurrCode, @laTmpVal,;
*!                                  lcBrFlds, lcBrTtl, 15, 54)  
*!*************************************************************
FUNCTION gfBrow
PARAMETERS lcSeekfile, lcSeekTag, lcSeekExp, laRetVal, lcBrFields, lcBrTitle,;
           lnBrCols            
PRIVATE lcCurFlt, lcBrWinName, lnCurAlias, lnCurTag, lnCurRec, llRetVal,;
        llEntered, lcExpToSeek, laKeyExp 

*E300329,1 Save environmet
*E300329,1 Save current alias
lnCurAlias = SELECT()
SELECT (lcSeekFile)
*E300329,1 Store current tag, filter, and record number
lcCurFlt = FILTER()
lnCurTag = VAL(SYS(21))
IF DELETED()
  SKIP 
ENDIF  
lnCurRec = IIF(EOF() .OR. BOF(), 0, RECNO())

*E300329,1 Reset filter
SET FILTER TO
*E300329,1 Set order to required tag
SET ORDER TO TAG (lcSeekTag)

*E300329,1 If not browsing from a browsing button, or,
*E300329,1 calling browse by a question mark, seek the given expression.
llBrowse =  IIF(TYPE('llBrowse') = 'U', .F., llBrowse) .OR. '?' $ lcSeekExp
GO TOP
llEntered = .F.
IF EOF()
  =gfDialog('I', 'There are no records to browse.')
ELSE
  IF !llBrowse 
    *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
    *IF !SEEK(lcSeekExp))
    IF !SEEK(lcSeekExp)
    *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
      IF BETWEEN(RECNO(0), 1, RECCOUNT())
        GO RECNO(0)
      ELSE
        GO TOP
      ENDIF    
      llBrowse = .T.
    ELSE
      llEntered = .T.
    ENDIF  
  ENDIF
  *E300329,1 If browsing, 
  IF llBrowse 
    *E300329,1 Store and clear current key settings
    PUSH KEY
    =gfClearKey()
    *CLEAR TYPEAHEAD

    *E300329,1 Add incremental search and mouse trap   
    
    DIMENSION laKeyExp[1]
    STORE 0 TO lnX,lnY,lnCurR,lnTimelimt,lnSeeklimt,lnSelRec
    STORE .F. TO llClick
    STORE [""] TO laKeyExp
    
    lcBrTitle   = IIF(EMPTY(lcBrTitle), PROPER(ALIAS()), lcBrTitle)
    lcBrWinName = gfTempName()
    DEFINE WINDOW (lcBrWinName);
           AT 0,0 SIZE 2*SROW()/3, lnBrCols;
           FONT "FoxFont", 9 ;
           FLOAT ;
           NOCLOSE ;
           SHADOW ;
           NOMINIMIZE ;
           SYSTEM ;
           COLOR SCHEME 10  	            

    MOVE WINDOW (lcBrWinName) CENTER   
  
    *E300329,1  Traps
    ON KEY LABEL ENTER DO lpSelOnEnt  WITH lcBrTitle, llEntered    
    ON KEY LABEL LEFTMOUSE  DO lfCdChkDcl WITH lcBrTitle, llEntered   
    lcExpToSeek="" 
    lcOrdExpr   = SYS(14, EVAL(SYS(21)))
    IF TYPE(lcOrdExpr) = 'N'
      lnStartTrap = 48
      lnEndTrap   = 57
    ELSE
      lnStartTrap = 32
      lnEndTrap   = 126
    ENDIF  
    FOR lnChrToTrap = lnStartTrap TO lnEndTrap
      ON KEY LABEL (CHR(lnChrToTrap)) DO lfcdchIncS
    ENDFOR
    
    BROWSE FIELDS &lcBrFields;
           WINDOW (lcBrWinName);
           LOCK 0;
           NOMENU;         
           NOAPPEND;
           NOEDIT;
           NODELETE;
           TITLE lcBrTitle
    POP KEY

    IF llEntered .AND. BETWEEN(lnSelRec, 1, RECCOUNT())
      GO lnSelRec
    ENDIF
    WAIT CLEAR
    RELEASE WINDOW (lcBrWinName)
  ENDIF
ENDIF

*E300329,1 If the browse is called from the last field before a menu
*E300329,1 created by MENU TO command, and a selection is done using
*E300329,1 a double mouse click, an extra mouse click needs to be 
*E300329,1 consumed so that the cursor waits for a menu selection
=inkey(0.001)

*E300329,1 If selected,
IF llEntered
  FOR lnCount = 1 TO ALEN(laRetVal)
    laRetVal[lnCount] = EVALUATE(lcSeekFile + '.' + laRetVal[lnCount])
  ENDFOR  
ENDIF
llBrowse = .F.
*E300329,1 Restore environmet
SET ORDER TO TAG (lnCurTag)
IF !EMPTY(lcCurFlt)
  SET FILTER TO
ENDIF
IF lnCurRec <> 0
  GO lnCurRec
ELSE
  GO TOP
ENDIF  
SELECT (lnCurAlias)
RETURN llEntered



*B600822,1 Hesham El-Sheltawi (Start)
*B600822,1 function to get the programm than called the browse
*B600822,1 to create the prefrence of the browse
FUNCTION gfGetPrefName
PARAMETERS lcAliasName
lcAliasName = IIF(TYPE('lcAliasName')='C',lcAliasName,'')
lcAliasName = IIF(EMPTY(lcAliasName),IIF(UPPER(qwd) $ FULL(DBF()) AND LEFT(ALIAS(),1)='T','',ALIAS()),lcAliasName)
lcProgName=IIF(LEFT(PROG(1),2)='ON','',PROG(1))
lnCount = 1
DO WHILE !('ARIABROW' $ SYS(16,lnCount)) AND !EMPTY(SYS(16,lnCount))
 lcProgName = IIF(LEFT(PROG(lnCount),2)='ON',lcProgName,PROG(lnCount))
 lnCount = lnCount +1
ENDDO
RETURN IIF(EMPTY(lcAliasName),'','B'+SYS(2007,PADR(lcProgName+lcAliasName,20)))
*B600822,1 Hesham El-Sheltawi (End)

*!*************************************************************
*! Name      : gfTherm
*! Developer : Yasser Saad Ibrahime
*! Date      : 1993-1995 
*! Purpose   : To display a thermometer for any running action
*!*************************************************************
*! Passed Parameters  : Total count
*!                      Current action
*!                      Fixed messag on top
*!                      variable messag with each count
*!*************************************************************
FUNCTION gfTherm
PARAMETERS lnToBeDone,lnDone,lcMessage,lcVariable

lcMessage   =IIF(TYPE('lcMessage')='C' ,lcMessage ,' ')
lcVariable  =IIF(TYPE('lcVariable')='C',lcVariable,' ')
IF _DOS
  IF ! WEXIST("gwdThermo")
	DEFINE WINDOW gwdThermo ;
           FROM INT((SROW()-7)/2),INT((SCOL()-58)/2) ;
           TO INT((SROW()-7)/2)+6,INT((SCOL()-58)/2)+57 ;
           NOCLOSE DOUBLE SHADOW COLOR SCHEME 5
    ACTIVATE WINDOW gwdThermo
    @ 0,2 SAY lcMessage
    @ 2,1 TO 5,54 
    @ 3,3 SAY CHR(219)
  ENDIF  
  lnPersent = INT((lnDone /lnToBeDone )*100)
  @ 1,3 SAY SPACE(54)
  @ 1,3 SAY lcVariable
  @ 3,3 SAY REPLICATE(CHR(219),lnPersent*50/100)
  IF lnToBeDone <= lnDone
    RELEASE WINDOW gwdThermo
  ENDIF
ELSE
  gcFontFace  = "MS Sans Serif"
  gcFontSize  = 8.000
  gcFontStyle = "B"
  gntherwidth = 57
  IF NOT WEXIST("gwdThermo")
    DEFINE WINDOW gwdThermo ;
      AT  INT((SROW() - (( 5.615 * ;
      FONTMETRIC(1, gcFontFace, gcFontSize, gcFontStyle )) / ;
      FONTMETRIC(1, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2), ;
      INT((SCOL() - (( 63.833 * ;
      FONTMETRIC(6, gcFontFace, gcFontSize, gcFontStyle )) / ;
      FONTMETRIC(6, WFONT(1,""), WFONT( 2,""), WFONT(3,"")))) / 2) ;
      SIZE 5.615,63.833 ;
      FONT gcFontFace, gcFontSize ;
      STYLE gcFontStyle ;
      NOFLOAT ;
      NOCLOSE ;
      NONE ;
      COLOR RGB(0, 0, 0, 192, 192, 192)
    MOVE WINDOW gwdThermo CENTER
    ACTIVATE WINDOW gwdThermo NOSHOW
    @ 0.5,3 SAY lcMessage FONT gcFontFace, gcFontSize STYLE gcFontStyle
    @ 0.000,0.000 TO 0.000,63.833 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    @ 0.000,0.000 TO 5.615,0.000 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    @ 0.385,0.667 TO 5.231,0.667 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 0.308,0.667 TO 0.308,63.167 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 0.385,63.000 TO 5.308,63.000 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    @ 5.231,0.667 TO 5.231,63.167 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    @ 5.538,0.000 TO 5.538,63.833 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 0.000,63.667 TO 5.615,63.667 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 3.000,3.333 TO 4.300,3.333 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 3.000,60.333 TO 4.308,60.333 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    @ 3.000,3.333 TO 3.000,60.333 ;
      COLOR RGB(128, 128, 128, 128, 128, 128)
    @ 4.300,3.333 TO 4.300,60.500 ;
      COLOR RGB(255, 255, 255, 255, 255, 255)
    SHOW WINDOW gwdThermo TOP
  ENDIF
  lnPersent = INT((lnDone /lnToBeDone )*100)
  lnblocks  = lnPersent*gntherwidth/100
  @ 1.7,3 SAY lcVariable+SPACE(gntherwidth-LEN(lcVariable)) FONT gcFontFace, gcFontSize STYLE gcFontStyle
  @ 3.039,gntherwidth/2 SAY ALLTRIM(STR(lnPersent))+"%" FONT "SYSTEM",8 ;
    COLOR RGB(0,0,0,192, 192, 192)
  @ 3.000,3.333 FILL TO 4.300,lnblocks + 3.333 ;
    COLOR RGB(255,255,255,128,128,128)
  IF lnToBeDone <= lnDone
    RELEASE WINDOW gwdThermo
  ENDIF
ENDIF   

*B600822,1 Hesham El-Sheltawi (Start)
*B600822,1 New function to set the reso file to on
*B600822,1 then set the color setting
FUNCTION gfSetClrSet
lcSetRes=SET('RESO')
SET RESO ON
SET COLOR SET TO APPARELSET
SET RESO &lcSetRes
*B600822,1 Hesham El-Sheltawi (End)

*!*************************************************************
*! Name      : gpWareFabs E300421,1
*! Developer : Samah Wilson Kirollos (SWK)
*! Date      : 08/30/96.
*! Purpose   : Browse the fabric/clr for a certain warehouse.
*!*************************************************************
*! Calls     : 
*!             Functions  : ARIABROW
*!*************************************************************
*! Passed :
*!        Parameters : 
*!            lcWare : The Warehouse.
*!            lcFab  : The Fabric.   
*!            lcClr  : The color.
*!*************************************************************
*! Returns            : Fabric + Color
*!*************************************************************
PROCEDURE gpWareFabs 
PARAMETERS lcWareHous, lcFab, lcClr

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
*PRIVATE lnAlias
PRIVATE lnAlias,laData
*E300637,1 (End)

*-- Array to get values from browse
DECLARE laData[2]
laData = SPACE(1)

*-- Title for the browse
lcTitle  = "ITEM/COLORS IN WAREHOUSE " + ALLTRIM( lcWareHous ) 
llWasSel = .T.

lnAlias = SELECT()
*E300637,1 Use the new global variables names and get the oldtag in avariable
*llOpenFac = gfOpenFile(qDD+"Fabric", "Fabric", "SH")
  
IF USED('Fabric')
  SELECT Fabric
  lcOldTFac = TAG()
ENDIF  
llOpenFac =gfOpenFile(gcDataDir+'Fabric',gcDataDir+'Fabric','SH')
*lcOldTFac = TAG()
*E300637,1 (End)

SET ORDER TO TAG Fabric IN Fabric

*E300637,1 Use the new global variables names and get the oldtag in avariable
*llOpenFad = gfOpenFile(qDD+"FabDye", " "     , "SH")
IF USED('FabDye')
  SELECT FabDye
  lcOldTFad = TAG()
ENDIF  
llOpenFad =gfOpenFile(gcDataDir+'FabDye',gcDataDir+'FABDYEW','SH')
*lcOldTFad = TAG()
*E300637,1 (End)

SET ORDER TO TAG FABDYEW IN FabDye

*-- Check if there is any Fabric assingned to the WareHouse
SELECT FabDye
IF !SEEK(lcWareHous)
  = gfDialog('I', 'No Item/Colors are assigned to warehouse &lcWareHous' )
  lcFab = SPACE(7)
  lcClr = SPACE(6)
ELSE
  *-- Browse all Fabric/Color combination found in the WareHouse
  SET RELATION TO FABRIC + COLOR INTO FABRIC ADDITIVE
  IF _WINDOWS OR _MAC
    lcBrFields = [FabDye.Fabric:10:h="Item",FabDye.Color:8,Fabric.Desc:h="Description":18,]+;
                 [Fabric.item_Type:h="Type",Fabric.loc:8:h="Location",Fabric.Vendor:11:H="Ven.",]+;
                 [Fabric.Pattern:10:H="Pattern",FabDye.Onhand:8:h="On Hand"]  
  ELSE
    lcBrFields = [Fabric:h="Item",Fabric.Color,Fabric.Desc:7:h="Desc.",]+;
                 [Fabric.item_Type:h="Type",Fabric.loc:h="Location",Fabric.Vendor:H="Ven.",]+;
                 [Fabric.Pattern:H="Pattern",FabDye.Onhand:h="On Hand"]  
  ENDIF
  llWasSel = ARIABROW('lcWareHous'+ [FOR EMPTY(DYELOT)],lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2," "," ","FABRIC,COLOR","laData")
  lcFab    = IIF(llWasSel, laData[1], SPACE(7)) 
  lcClr    = IIF(llWasSel, laData[2], SPACE(6))
  SET RELATION OFF INTO FABRIC
ENDIF

*E300637,1 check if the file is open out of the function ,return the old tag
*SET ORDER TO TAG (lcOldTFac) IN Fabric
*SET ORDER TO TAG (lcOldTFad) IN FabDye
IF !llOpenFac
  SET ORDER TO TAG (lcOldTFac) IN Fabric
ENDIF
IF !llOpenFad
  SET ORDER TO TAG (lcOldTFad) IN FabDye
ENDIF  
*E300637,1 (End)
USE IN IIF(llOpenFac, "Fabric", 0)
USE IN IIF(llOpenFad, "FabDye", 0)

SELECT(lnAlias)
*E300421,1*************************************************************
*!*************************************************************
*! Name      : gpFbDyBrow E300421,1
*! Developer : Samah Wilson Kirollos (SWK)
*! Date      : 09/01/96.
*! Purpose   : Browse the Dyelots for a certain Fabric/Clr 
*!             in a warehouse.
*!*************************************************************
*! Calls     : 
*!             Functions  : ARIABROW
*!*************************************************************
*! Passed :
*!        Parameters : 
*!            lcWare   : The Warehouse.
*!            lcFab    : The Fabric.   
*!            lcClr    : The color.
*!            lcDyelot : The Dyelot
*!*************************************************************
*! Returns             : Dyelot
*!***********************************************************************
* Modifications:
*B603423,1 ADEL 05/17/2000 Add Yard field in Dyelots browse.
*!************************************************************************
PROCEDURE gpFbDyBrow
PARAMETER lcFab,lcClr,lcDye,lcWare

*E300637,1 Use the array 'laData' as a private variable to prevent conflect
*E300637,1 with the global objects array
PRIVATE laData,lcBrFields
*E300637,1 (End)

lnAlias = SELECT()

*-- Array to get values from browse
DECLARE laData[3]
laData = SPACE(1)

*--Variable to check if there is any dyelot
llFound = .F.

*--Check if the system setup is Multi or Single WareHouse
*RESTORE FROM AdPara&qSysCode ADDIT
*llMultiWH = (M_WareHouse = 'Y')   
llMultiWH = ALLTRIM(gfGetMemVar('M_WareHouse'))= 'Y'
*RELEASE ALL LIKE M_*

*-- Title for the browse
lcTitle = IIF (llMultiWH, 'ITEM\WAREHOUSE DYELOTS', 'ITEM\DYELOTS')

*-- Variable to check if we select from the browse or not
llWasSel = .T.

lcKey = "lcFab+lcClr+lcWare"

*E300637,1 Use the new global variables names
*llOpenFad = gfOpenFile(qDD+"FabDye", " ", "SH")
*E300421,1 Get the old tag name if the file is already open
IF USED ('FabDye')
  SELECT FabDye 
  lcOldTFad = TAG() 
ENDIF
llOpenFad =gfOpenFile(gcDataDir+'FabDye',gcDataDir+'FABDYE','SH')
*E300637,1 (End)
*lcOldTFad = TAG()
*E300421,1 (End)
SET ORDER TO TAG FABDYE IN FabDye

IF SEEK (lcFab+lcClr+lcWare)
  SCAN WHILE Fabric+Color+cWareCode = lcFab+lcClr+lcWare FOR !EMPTY(Dyelot)
    llFound = .T.
    EXIT
  ENDSCAN
ENDIF
IF llFound 
  IF _WINDOWS OR _MAC
    lcBrFields = [FabDye.Fabric:10:h="Item",FabDye.Color:8:H="Color",FabDye.Dyelot:h="Dyelot":10]
  ELSE
    lcBrFields = [FabDye.Fabric:h="Item",FabDye.Color:H="Color",FabDye.Dyelot:h="Dyelot"]
  ENDIF
  *B603423,1 (Begin) Add onhand filed to the browse.
  lcBrFields = lcBrFields+IIF(_WINDOWS OR _MAC,[,FabDye.OnHand:h="OnHand":12],[,FabDye.OnHand:h="OnHand"])
  *B603423,1 (End)
  llWasSel = ARIABROW(lcKey+[FOR !EMPTY(DYELOT)],;
             lcTitle,gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"","","Fabric,Color,Dyelot","laData")
  lcFab    = IIF(llWasSel, laData[1], SPACE(7)) 
  lcClr    = IIF(llWasSel, laData[2], SPACE(6))
  lcDye    = IIF(llWasSel, laData[3], SPACE(10))
ELSE
  *E300421,1 Change the gfDialog with gfModalGen
  =gfModalGen('TRM36045B36000','ALERT',ALLTRIM(lcFab)+'\'+ALLTRIM(lcClr) +;
              IIF(llMultiWH, ' in warehouse: '+ ALLTRIM(lcWare)+'.'  ,;
              ' on the file.' ))
  *= gfDialog('I','There are no Dyelots for Item\Color: '+;
              ALLTRIM(lcFab)+'\'+ALLTRIM(lcClr) +;
              IIF(llMultiWH, ' in warehouse: '+ ALLTRIM(lcWare)+'.'  ,;
              ' on the file.' ))
  lcDye = SPACE(10)            
  *E300421 (End)
ENDIF
*E300421,1 set the old tag
IF llOpenFad
  SET ORDER TO TAG (lcOldTFad) IN FabDye
ENDIF  
*SET ORDER TO TAG (lcOldTFad) IN FabDye
*E300421,1 (End)
USE IN IIF(llOpenFad, "FabDye", 0)
SELECT(lnAlias)

*E300421,1*************************************************************

*E300399,1 Hesham El-Sheltawi (Start)
*E300399,1 new function to run the option grid for specified report
*E300399,1 and run the report program if called from the option grid
FUNCTION gfRepRun
PARAMETERS lcRpPrg,llDoReport
IF llDoReport
  lcRepAlias = SELECT()
  IF !USED('SYDREPRT')
    SELECT 0
    USE &gcSysHome.SYDREPRT 
  ELSE
    SELECT SYDREPRT 
  ENDIF
  SET ORDER TO TAG CREP_ID
  lcSetRpPrg = lcRpPrg

  *E038033,1 HMA 04/03/2004 Select only Records belong to ARIA27 [BEGIN]
  
  *IF SEEK(PADR(lcRpPrg,8))
  *  lcSetRpPrg=ALLTRIM(IIF(!EMPTY(CMAINREPID),PADR(ALLTRIM(CMAINREPID),8),PADR(ALLTRIM(lcRpPrg),8)))    
  *ENDIF  
  =SEEK(PADR(lcRpPrg,8))	
  LOCATE WHILE cRep_id= PADR(lcRpPrg,8) FOR cVer<>"A40"
  lcSetRpPrg=ALLTRIM(IIF(!EMPTY(CMAINREPID),PADR(ALLTRIM(CMAINREPID),8),PADR(ALLTRIM(lcRpPrg),8)))		

  *E038033,1 HMA [END]    
  
  SELECT (lcRepAlias)
  =gfRunRpPrg(lcSetRpPrg)
ELSE
  DECLARE laField_H[1,1],laField_N[1,1],laOpenFile[10,3]

  STORE " " TO lcRpForm ,lcRpFiles,lcRpExpr,lcRpTargt,lcRpOrder,lcRpFields,lcRpExp
  STORE " " TO lcBrFields,lcBaseFile,laField_H,laField_N,lcFile_Ttl,lcSetProcd

  llOGFltCh  = .T.

  IF !USED('SYDREPRT')
    SELECT 0
    USE &gcSysHome.SYDREPRT 
  ELSE
    SELECT SYDREPRT 
  ENDIF  
  SET ORDER TO TAG CREP_ID  
  lcSetRpPrg = lcRpPrg

  *E038033,1 HMA 04/03/2004 Select only Records belong to ARIA27 [BEGIN]
  
  *IF SEEK(PADR(lcRpPrg,8))
  *  lcSetRpPrg=ALLTRIM(IIF(!EMPTY(CMAINREPID),PADR(ALLTRIM(CMAINREPID),8),PADR(ALLTRIM(lcRpPrg),8)))    
  *ENDIF 
  =SEEK(PADR(lcRpPrg,8))
  LOCATE WHILE cRep_id= PADR(lcRpPrg,8) FOR cVer<>"A40"
  lcSetRpPrg=ALLTRIM(IIF(!EMPTY(CMAINREPID),PADR(ALLTRIM(CMAINREPID),8),PADR(ALLTRIM(lcRpPrg),8)))

  *E038033,1 HMA [END]
  
 
  lcSetProcd=SET('PROCEDURE')
  lcOldErr=ON('ERROR')
  ON ERROR llDumErr = .T.
  SET PROCEDURE TO (ALLTRIM(lcSetRpPrg))
  ON ERROR &lcOldErr
  R_WIDTH = 'N'
  =gfOpGrid(lcRpPrg)
  SET PROCEDURE TO (lcSetProcd)
ENDIF
RETURN


FUNCTION gfRunRpPrg
PARAMETERS lcSetRpPrg
IF EMPTY(lcOGFormV)
  PRIVATE lcDevSelect
  lcDevSelect = gcDevice
  gcDevice=LEFT(gcDevice,1)
  qRepo_Scr = .F.  
  DO CASE
   CASE gcDevice = 'P'
     IF _WINDOWS
       qRepoTXT  = gfTempName()   &&temprory file to use in printing
       SET DEVICE TO PRINT
       SET PRINTER TO &qWD.&qRepoTXT..TXT
       lnRepWidth = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))
       lcPrtEscSet = PRDdocst(66,lnRepWidth)
       IF !EMPTY(lcPrtEscSet)
         @0,0 SAY lcPrtEscSet
       ENDIF
       *-- Set the escep sequance for the printing procees.
     ELSE   
       lcPaprTyp= IIF(gnPrint_Wd=240,'XW',IIF(gnPrint_Wd=132,'W','N'))
       lcPrintset  = ""
       IF glPrnt_Lan                && if it is a lan option
         lcPrintSet = '\\SPOOLER\P='+ALLTRIM(STR(gnPrnt_No))+'\S='+ALLTRIM(gcServ_Nam);
                         +'\Q='+ALLTRIM(gcQueu_nam);
                         +IIF(glBaner,'\B='+gcBaner_H,'\N');
                         +IIF(_pCopies>1,"\C="+ALLTRIM(STR(_PCOPIES)),"")
       ELSE
         lcPrintSet = gcPrnt_Port               
       ENDIF       
       SET PRINTER TO &lcPrintSet
       SET DEVICE TO PRINTER
       lnRepWidth = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))
       lcPrtEscSet = PRDdocst(66,lnRepWidth)
       IF !EMPTY(lcPrtEscSet)
         @0,0 SAY lcPrtEscSet
       ENDIF
       SET DEVICE TO SCREEN
     ENDIF  
   CASE gcDevice = 'S'
     qRepo_Scr = .T.
     qRepoTXT  = gfTempName()
     SET DEVICE TO PRINT
     SET PRINTER TO &qWD.&qRepoTXT..TXT
    CASE gcDevice = 'F'
      qRepo_Scr = .F.
      SET DEVICE TO PRINT
      IF !(" ADDITIVE" $ UPPER(gcOutFile))
        SET PRINTER TO ( gcOutFile )
      ELSE
        SET PRINTER TO ( gcOutFile ) ADDITIVE
      ENDIF
       *-- Send the output report to the batch server.
    CASE gcDevice = 'B'
      lcPaprTyp= IIF(gnPrint_Wd=240,'XW',IIF(gnPrint_Wd=132,'W','N'))    
      =lfToBatch()
  ENDCASE
  DO &lcSetRpPrg
  gcDevice = lcDevSelect
ELSE
  DO &lcSetRpPrg
ENDIF  




********************
PROCEDURE ENDREPORT
PARAMETERS llPrtFile
********************
llPrtFile = IIF(PARAMETERS()>0,llPrtFile,.T.)
IF gcDevice = 'SCREEN'
   lcMemWidth=SET('MEMOWIDTH')
   SET MEMOWIDTH TO 230
   SET PRINTER TO 
   SET DEVI TO SCREEN
*   lcOGWinTitl='Report'
   *MAN
   *DO GetFile WITH gcWorkDir+gcOutFile+'.TXT',lcOGWinTitl
   DO GetFile WITH gcOutFile,lcOGWinTitl
   *MAN end
   SET MEMOWIDTH TO lcMemWidth
   *MAN
   *ERASE (gcWorkDir+gcOutFile+'.TXT')
   ERASE (gcOutFile)
   *MAN end
ELSE
  =gfToPrintr()
*    =gfPrtFile(qWD+qRepoTXT+'.TXT',llPrtFile)
ENDIF
RETURN

*E300399,1 Hesham El-Sheltawi (End)

*E300581,1 Hesham El-Sheltawi (End)

*B601645,1 Hesham El-Sheltawi (Start)
*B601645,1 Called through the Menu bars for the system defined
*B601645,1 Windows to restore
*B601645,1 the window in a proper way for the windows 95
*!*************************************************************
*! Name      : lfZoomWin
*! Developer : Hesham El-Sheltawi
*! Date      : 03/06/97
*! Purpose   : To restore the old window in windows 95
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : lcWindToZoom Window Name
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
* Restore last enviroment if requird in case of ubnormal termination
FUNCTION lfZoomWin
PARAMETERS lcWindToZoom
IF WMINIMUM(lcWindToZoom)
  HIDE WINDOW (lcWindToZoom)
  ACTIVATE WINDOW  (lcWindToZoom)
  ZOOM WINDOW (lcWindToZoom) NORM
ENDIF
ACTIVATE WINDOW (lcWindToZoom) TOP
*ZOOM WINDOW (lcWindToZoom) MAX
*ZOOM WINDOW (lcWindToZoom) NORM
*ACTIVATE WINDOW (lcWindToZoom) TOP
*B601645,1 Hesham El-Sheltawi (End)


*E300633,1 Hesham El-Sheltawi (Start)
*!*************************************************************
*! Name      : gfUpdSetup
*! Developer : Hesham El-Sheltawi
*! Date      : 04/09/97
*! Purpose   : To update the setup files for all the companies
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : laCmpSetup && Pointer to array hold
*!                                 && all the companies 
*!                                 && inst. in the system info.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : 
*!*************************************************************
*E301252,1 AMM This function is not used anymore, instead use lfUSetup()
*FUNCTION gfUpdSetup
*PARAMETERS laCmpSetup
*PRIVATE lnCount,laCmpSetup,laApplField,lcTmpName,laApplIndex,lcActWord
*lcActWord=SELECT()
*FOR lnCount = 1 TO ALEN(laCmpSetup,1)
*  IF !EMPTY(laCmpSetup[lnCount,1])
*    laCmpSetup[lnCount,2] = ALLT(laCmpSetup[lnCount,2])
*    lcTmpName=gfTempName()
*    DIMEN laCSetData[1]
*    STORE '  ' TO laCSetData
*    IF USED('SETUPS')
*      USE IN SETUPS
*    ENDIF
*    SELECT DIST CAPP_ID FROM (laCmpSetup[lnCount,2]+'SETUPS') INTO ARRAY laCSetData
*    IF !USED('SYCCONFG')
*      SELECT 0
*      USE (gcSysHome+'SYCCONFG')
*    ENDIF
*
*    SELECT SYCCONFG  
*    COPY TO (laCmpSetup[lnCount,2]+lcTmpName) FOR ASCAN(laCSetData,CAPP_ID)>0 WITH CDX
*    USE (laCmpSetup[lnCount,2]+lcTmpName) IN 0
*    IF USED('SYCCONFG')
*      USE IN SYCCONFG
*    ENDIF
*    IF !USED('SETUPS')
*      SELECT 0
*      USE (laCmpSetup[lnCount,2]+'SETUPS')
*    ENDIF
*    SELECT SETUPS
*    SET ORDER TO TAG VARNAME
*    SELECT (lcTmpName)
*    SET ORDER TO TAG VARNAME
*    lcTagExp = SYS(14,VAL(SYS(21)))
*    SET RELATION TO &lcTagExp INTO SETUPS ADDI
*    GO TOP
*    SCAN
*       IF !EOF('SETUPS')
*         *B601979,1 Copy field type (value or expression) of the company
*         *B601979,1 seting
*         *REPLACE MDATA_DEF WITH SETUPS.MDATA_DEF
*         REPLACE MDATA_DEF WITH SETUPS.MDATA_DEF,;
*         		 cDefa_Typ WITH SETUPS.cDefa_Typ
*         *B601979,1 end         		 
*       ENDIF
*    ENDSCAN
*    IF USED('SETUPS')
*      USE IN SETUPS
*    ENDIF
*    IF USED(lcTmpName)
*      USE IN (lcTmpName)
*    ENDIF
*    ERASE (laCmpSetup[lnCount,2]+'SETUPS.DBF')
*    ERASE (laCmpSetup[lnCount,2]+'SETUPS.FPT')
*    ERASE (laCmpSetup[lnCount,2]+'SETUPS.CDX')
*    IF FILE(laCmpSetup[lnCount,2]+lcTmpName+'.DBF')
*      RENAME (laCmpSetup[lnCount,2]+lcTmpName+'.DBF') TO (laCmpSetup[lnCount,2]+'SETUPS.DBF')
*    ENDIF
*    IF FILE(laCmpSetup[lnCount,2]+lcTmpName+'.FPT')
*      RENAME (laCmpSetup[lnCount,2]+lcTmpName+'.FPT') TO (laCmpSetup[lnCount,2]+'SETUPS.FPT')
*    ENDIF  
*    IF FILE(laCmpSetup[lnCount,2]+lcTmpName+'.CDX')
*      RENAME (laCmpSetup[lnCount,2]+lcTmpName+'.CDX') TO (laCmpSetup[lnCount,2]+'SETUPS.CDX')
*    ENDIF  
*  ENDIF
*ENDFOR
*SELECT (lcActWord)
*E300633,1 Hesham El-Sheltawi (eND)

*!*************************************************************
*! Name      : lfUSetup
*! Developer : Ahmed Mohamed Ibrahim [AMM]
*! Date      : 06/15/1999
*! Purpose   : Function to Update SYCCONFG and SETUPS files
*!*************************************************************
*! Calls     : -----
*!*************************************************************
*! Passed Parameters  : lcParam,lcMod_ID,lcDataDr
*!                      lcParam : indicate whether update SYCCONFG or SETUPS
*!                      lcMod_ID: Module ID
*!                      lcDataDr: company Data directory
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Called Form        : 
*!*************************************************************
*! Example            : =lfUSetup('A',lcMod_ID,lcFilePath)
*!*************************************************************
*! Ref : *E301252,1 AMM
*!*************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION lfUSetup
FUNCTION x_lfUSetup
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcParam,lcMod_ID,lcDataDr
PRIVATE laCFGVrPos, laSplVrPos, lcModule, lnPAlias, lnElem, lnStToPos,;
	    llStUpdate, llUsUpdate
lnPAlias = SELECT(0)
DECLARE laCFGVrPos[1,2], laSplVrPos[1,2]
lcModule = IIF(lcMd_id='SM',CHR(255),lcMd_id)
DO CASE
  CASE lcParam = 'S'
    IF FILE (gcSysHome+lcMd_id+"CCONFG.DBF") 
      USE (gcSysHome+lcMd_id+"CCONFG") ORDER TAG NVARPOS IN 0
      SELECT SYCCONFG
      SET ORDER TO TAG MODVAR

      SELECT CUPGRDLVL, MAX(NVARPOS) FROM SYCCONFG;
      		 WHERE CAPP_ID+STR(NVARPOS) = lcModule;
      		 GROUP BY CUPGRDLVL;
      		 INTO ARRAY laCFGVrPos
	  
	  SELECT CUPGRDLVL, MAX(NVARPOS) FROM (lcMd_id+"CCONFG");
      		 WHERE CAPP_ID+STR(NVARPOS) = lcModule;
      		 GROUP BY CUPGRDLVL;
      		 INTO ARRAY laSplVrPos
      lnElem = ASCAN(laSplVrPos, "S")
      IF lnElem > 0
        lnStToPos  = laSplVrPos[ASUBSCRIPT(laSplVrPos, lnElem, 1), 2]
        llStUpdate = .T.
      ELSE
        lnStToPos  = 0
        llStUpdate = .F.
      ENDIF
      llUsUpdate = ASCAN(laSplVrPos, "U") > 0
      IF !llStUpdate
        lnElem     = ASCAN(laCFGVrPos, "S")
        IF lnElem > 0
          lnStToPos = laCFGVrPos[ASUBSCRIPT(laCFGVrPos, lnElem, 1), 2]
        ENDIF
      ENDIF       		 
      *-- If upgrading standard records, 
      IF llStUpdate
        
        *-- If updating "U"ser records, or, there are no "U"ser records,
        *-- delete all existing records and append from SYCCONFG
        IF llUsUpdate .OR. ASCAN(laCFGVrPos, "U") = 0
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule 
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG") 
        ELSE
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule FOR cUpgrdLvl = "S"
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
            =lfShiftUsr(lnStToPos + 1, lcModule)                        
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG")  
        ENDIF
      ELSE
        IF llUsUpdate
          *-- Delete exising records from SYCCONFG
          SELECT SYCCONFG
          IF SEEK(lcModule)
            DELETE REST WHILE cApp_ID=lcModule FOR cUpgrdLvl = "U"
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [Start] 
            *PACK
            *B609590,4 Comment the PACK command in the function  lfUSetup [Media] TMI 05/30/2011 [End  ] 
          *B609764,2 TMI 12/08/2011 [Start] restore the pack command
          PACK
          *B609764,2 TMI 12/08/2011 [End  ]           
          ENDIF  
          APPEND FROM (gcSysHome + lcMd_id+"CCONFG") 
          =lfShiftUsr(lnStToPos + 1, lcModule)            
        ENDIF
      ENDIF        
    ENDIF  
  CASE lcParam = 'A'
    IF USED('SETUPS')
      USE IN SETUPS
    ENDIF
    USE (lcDataDr+"SETUPS") ORDER TAG MODVAR IN 0
    *-- Delete any extra settings..
    SET ORDER TO TAG MODVAR IN SYCCONFG
    SET RELATION TO cApp_Id+cFld_Name INTO SYCCONFG
    IF SEEK(lcModule)
      DELETE REST WHILE cApp_ID = lcModule FOR EOF('SYCCONFG')
      SET RELATION OFF INTO SYCCONFG
      SELECT SYCCONFG
      SET RELATION TO cApp_Id+cFld_Name INTO SETUPS
      IF SEEK(lcModule)
        SCAN WHILE cApp_ID = lcModule
          SCATTER MEMVAR MEMO
          IF EOF('SETUPS')
            *E301252,1 AMM If new setup variable, insert it
            INSERT INTO SETUPS FROM MEMVAR
          ELSE
            *E301252,1 AMM If existing setup variable, update it
            SELECT SETUPS
            GATHER MEMVAR MEMO FIELDS EXCEPT mData_Def,cDefa_Typ
          ENDIF
          SELECT SYCCONFG
        ENDSCAN
      ENDIF
    ELSE
      SET RELATION OFF INTO SYCCONFG
    ENDIF  
    USE IN SETUPS
ENDCASE
SELECT (lnPAlias)

*!*************************************************************
*! Name      : lfShiftUsr
*! Developer : Ahmed Mohamed Ibrahim [AMM]
*! Date      : 11/08/1999
*! Purpose   : Function to sort user defined setups in SYCCONFG 
*!*************************************************************
*! Calls     : -----
*!*************************************************************
*! Passed Parameters  : lnStartPos : start position of shifting
*!                      lcMod_ID   : module ID
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Called Form        : 
*!*************************************************************
*! Example            : =lfShiftUsr(lnStartPos, lcModID)
*!*************************************************************
*! Ref : *E301252,1 AMM & RENEE
*!*************************************************************
FUNCTION lfShiftUsr
PARAMETERS lnStartPos, lcModID
PRIVATE lnAlias, lnVarPos

lnAlias = SELECT(0)
    
SELECT SYCCONFG

*BSAMEH Update all the records with the upgrade level "U". [Begin]
*IF SEEK(lcModID)
*  LOCATE REST FOR cUpgrdLvl = "U" WHILE cApp_ID = lcModID 
*  IF FOUND() AND nVarPos <> lnStartPos
*    lnVarPos = lnStartPos - nVarPos
*    REPLACE REST nVarPos WITH nVarPos + lnVarPos;
*            WHILE cApp_ID = lcModID FOR cUpgrdLvl = "U"
*  ENDIF
*ENDIF
PRIVATE lcOldTag
lcOldTag = ORDER() 
SET ORDER TO TAG nVarPos IN SYCCONFG
IF SEEK(lcModID)
  IF FOUND()
    SELECT ConfgCur
    ZAP
    SELECT SycConfg
    SCAN REST WHILE capp_id + STR(nvarpos) = lcModID
      IF cUpgrdLvl = "U"
        SCATTER MEMVAR MEMO
        INSERT INTO ConfgCur FROM MEMVAR
        DELETE
      ENDIF
    ENDSCAN
    PACK
    SELECT ConfgCur
    SCAN
      REPLACE nVarPos WITH lnStartPos 
      lnStartPos = lnStartPos + 1    
    ENDSCAN
    SELECT ConfgCur
    SCAN
      SCATTER MEMVAR MEMO
      SELECT SycConfg
      APPEND BLANK
      GATHER MEMVAR MEMO  
    ENDSCAN

  ENDIF
ENDIF
SET ORDER TO TAG (lcOldTag) IN SYCCONFG
*BSAMEH Update all the records with the upgrade level "U". [End]

SELECT (lnAlias)

*E300646,1 Hesham El-Sheltawi (Start)
*E300646,1 Write new function to check the user priv. on specific
*E300646,1 process & subprocess and return the users accessebility on it
*!*************************************************************
*! Name      : gfUserPriv
*! Developer : Hesham El-Sheltawi
*! Date      : 04/10/97
*! Purpose   : To get user priv. on process or subprocess
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : lcModule    Module ID
*!                      lcProcess   Process ID
*!                      lcSubProc   SubProcess
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : if gfUserPriv('AP','')
*!*************************************************************
FUNCTION gfUserPriv
PARAMETERS lcModule,lcProcess,lcSubProc
IF EMPTY(lcModule) OR EMPTY(lcProcess) OR PARAMETERS()<2
  RETURN .F.
ENDIF
IF !glLog_Requ
  RETURN .T.
ENDIF
PRIVATE lcTmpPriv,lcOldAlias,llRetrun,laUsrSubP
lcTmpPriv = gfTempName()
lcOldAlias = SELECT()
SELECT 0
USE (gcSysHome+'SYUUSRPR') AGAIN ALIAS &lcTmpPriv ORDER TAG CUSER_ID
*MAN
*llRetrun = SEEK(gcUser_ID+UPPER(lcModule+gcAct_Comp+lcProcess))

*B605544,1 WAB (Start) - seek olso if the user group exist in the table 
*llRetrun = SEEK(ALLTRIM(gcUser_ID)+UPPER(lcModule+gcAct_Comp+lcProcess))

llRetrun = SEEK(ALLTRIM(gcUser_ID)+UPPER(lcModule+gcAct_Comp+lcProcess)) .OR. SEEK(ALLTRIM(gcUser_GRp)+UPPER(lcModule+gcAct_Comp+lcProcess))

*B605544,1 WAB (End)

*B604750,1 TMI [Start] fix the bug that the function gfUserPriv return .t. if the operator has 
*B604750,1 TMI         not assigned any subprocesses.
llRetrun = IIF(TYPE('lcSubProc')='C',.F.,llRetrun)
*--Be sure that no empty string is in the memo field 
*IF !EMPTY(mSubProc) AND TYPE('lcSubProc')='C'
IF !EMPTY(ALLTRIM(mSubProc)) AND TYPE('lcSubProc')='C'
*B604750,1 TMI [End  ]

   DIMEN laUsrSubP[1,2]
   *=gfSubStr(mSubProc,@laUsrSubP,"|")
   =gfSubStr(LEFT(mSubProc,ATC('|',mSubProc)-1),@laUsrSubP)
   llRetrun = ASCAN(laUsrSubP,UPPER(lcSubProc))>0
ENDIF
USE IN (lcTmpPriv)
SELECT (lcOldAlias)
RETURN llRetrun
*E300646,1 Hesham El-Sheltawi (End)

FUNCTION gfRunCalnd
DO gpDoProg WITH 'AWRSCHEDUL',.F.,'SM'


*:---------------------------------------------------------------------
*! Name      : gfwCodePop
*! Developer : Yasser Mohammed Aly - (YMA)
*! Date      : 04/27/97
*! Purpose   : Function to fill any code array with on of the 
*:             following values :
*:               1) A list of the available codes from the codes file.
*:               2) The default code value.
*:               3) "ALL"
*:               4) "N/A"
*: Job ID    : E# 300631
*:---------------------------------------------------------------------
*: Calls              : gfIsEdtble()
*:---------------------------------------------------------------------
*: Passed Parameters  : laInfArray : Pointer to the code information array.
*:                      lcField    : The code to be displayed.
*:                      lcFillWith : Fill the array with ...
*:                      "L" : List of the available codes.
*:                      "D" : Default value.
*:                      "A" : "All"
*:                      "N" : "N/A"
*:---------------------------------------------------------------------
*: Example            : = gfwCodePop(@laCodInfo, "CTERMCODE", "A")
*:---------------------------------------------------------------------

FUNCTION gfwCodePop
PARAMETERS laInfArray, lcField, lcFillWith, lcActComp

PRIVATE lnAlias, lcTag, lcToUpdat, lcCurPopUp, lcStatus, llAddAll
PRIVATE llAddNoA, lcAltFile, lcAltIndx, lcAltExp, lcAltField, llEditable
PRIVATE lcAll, lcNA, lcAllCode, lcNACode, lcSeprat, lcCurCode, lcTag
PRIVATE lcFields, lnNewVal, llAltFile, lcSerFile, lcSerIndx, lcSerExp
PRIVATE lcSerField, lcCode, lcDesc, lcOrdTag

*-- If the passed parameters are not valid than go out of the function.
IF TYPE("laInfArray")#"C" OR TYPE("lcField")#"C"
  RETURN .F.
ENDIF

*-- If the last parameter is not passed than default it to build the list.
lcSetWith  = SPACE(0)
lcFillWith = IIF(TYPE("lcFillWith")#"C", "L", ALLTRIM(UPPER(lcFillWith)))
IF ATC(",",lcFillWith) > 0
  lcSetWith  = RIGHT(lcFillWith,LEN(lcFillWith)-ATC(",",lcFillWith))
  lcSetWith  = ALLTRIM(lcSetWith)
  lcFillWith = IIF(EMPTY(lcSetWith), "L", "V")
ELSE
  lcFillWith = IIF(!(lcFillWith $ "LDANT"), "L", lcFillWith)
ENDIF

*-- Set the company used variable.
lcActComp = IIF(TYPE("lcActComp")#"C", gcAct_Comp, lcActComp)

*-- Get the position of the nedded field in the code information array.
lnPos      = ASCAN (laInfArray, lcField)

*-- If it does not exist than go out of the function.
IF lnPos = 0 
  RETURN .F.
ENDIF

*-- Be sure that the field name has a 10 character length.
lcField    = UPPER(PADR(lcField,10))

*-- Initialize the needed variables from the code information array.
lcToUpdat  = laInfArray[lnPos+1]
lcCurPopUp = laInfArray[lnPos+2]
lcStatus   = laInfArray[lnPos+3]
llAddAll   = laInfArray[lnPos+4]
llAddNoA   = laInfArray[lnPos+5]
lcAltFile  = laInfArray[lnPos+6]
lcAltIndx  = laInfArray[lnPos+7]
lcAltExp   = laInfArray[lnPos+8]
lcAltField = laInfArray[lnPos+9]

*-- Check if this code is editable or not.
lnFW       = 0
llEditable = gfIsEdtble(lcField, @lnFW, lcActComp)

*-- The "ALL" string and code, and the "N/A" string and code.
lcAll      = PADR("ALL",IIF(llEditable, 39, 30))
lcNA       = PADR("N/A",IIF(llEditable, 39, 30))
lcAllCode  = CHR(42)
lcNACode   = SPACE(0)
lcSeprat   = SPACE(1) + "-" + SPACE(1)
lnAlias    = SELECT()
DO CASE
  
  *-- If we want to build the array and it is not built from before.
  CASE lcFillWith = "L" AND lcStatus # lcFillWith
    lcCurCode = &lcToUpdat[&lcCurPopUp,2]
    SELECT Codes
    lcTag = TAG()
    SET ORDER TO
    lcFields = IIF(llEditable, "CCODE_NO+lcSeprat+CDISCREP AS Code", "CDISCREP")

    *--HDM B602174,1 Sort the codes by the code number if the code is editable, 
    *--HDM B602174,1 otherwise sort them by the description.
    *--HDM B602174,1 (Added the if condition and the SQL in the else part).
    IF llEditable
      *E300789,1 Hesham (Start)
      *SELECT &lcFields,CCODE_NO FROM Codes;
      WHERE CCOMP_ID+CRLTFIELD+CFLD_NAME = lcActComp+"N"+lcField;
      ORDER BY CCODE_NO ;
      INTO ARRAY &lcToUpdat

      SELECT &lcFields,CCODE_NO FROM Codes;
      WHERE CDEFCODE+CRLTFIELD+CFLD_NAME = "NN"+lcField;
      ORDER BY CCODE_NO ;
      INTO ARRAY &lcToUpdat
      *E300789,1 Hesham (End)
    ELSE
      *E300789,1 Hesham (Start)
      *SELECT &lcFields,CCODE_NO FROM Codes;
      WHERE CCOMP_ID+CRLTFIELD+CFLD_NAME = lcActComp+"N"+lcField;
      ORDER BY CDISCREP ;
      INTO ARRAY &lcToUpdat

      SELECT &lcFields,CCODE_NO FROM Codes;
      WHERE CDEFCODE+CRLTFIELD+CFLD_NAME = "NN"+lcField;
      ORDER BY CDISCREP ;
      INTO ARRAY &lcToUpdat
      
      *E300789,1 Hesham (eND)
    ENDIF
    *--HDM B602174,1 End.

    SELECT Codes
    SET ORDER TO TAG &lcTag
    laInfArray[lnPos+3] = "L"

    IF llAddAll
      DIMENSION &lcToUpdat[ALEN(&lcToUpdat,1)+1,2]
      = AINS(&lcToUpdat,1)
      &lcToUpdat[1] = lcAll
      &lcToUpdat[2] = lcAllCode
    ENDIF
    
    IF llAddNoA
      DIMENSION &lcToUpdat[ALEN(&lcToUpdat,1)+1,2]
      = AINS(&lcToUpdat,1)
      &lcToUpdat[1] = lcNA
      &lcToUpdat[2] = lcNACode
    ENDIF

    lnNewVal    = ASCAN(&lcToUpdat, lcCurCode)
    *B802459,1 Start, Alwayes take the secund element of the array
    *B802459,1 because sometimes the code may be exist in the descreption
    *B802459,1 element wich give you a fractions after deviding.
    *&lcCurPopUp = IIF(lnNewVal <> 0, IIF(lnNewVal=1,1,lnNewVal/2), 1)
    &lcCurPopUp = IIF(lnNewVal <> 0, IIF(lnNewVal=1,1,ROUND(lnNewVal/2,0)), 1)
    *B802459,1 End.

  *-- Put a passed value in the array.
  CASE lcFillWith = "V"
    lcCode = PADR(lcSetWith,6)
    SELECT Codes
    lcOrdTag = TAG()
    SET ORDER TO TAG CODES
    *E300789,1 Hesham (Start)
    *lcDesc = IIF(SEEK(lcActComp+lcCode+"N"+lcField), cDiscrep, SPACE(0))
    lcDesc = IIF(SEEK('N'+lcCode+"N"+lcField), cDiscrep, SPACE(0))
    *E300789,1 Hesham (eND)
    SET ORDER TO TAG lcOrdTag
    DIMENSION &lcToUpdat[1,2]
    &lcToUpdat[1,1] = IIF(llEditable, lcCode+lcSeprat+lcDesc, lcDesc)
    &lcToUpdat[1,2] = lcCode
    &lcCurPopUp     = 1
    laInfArray[lnPos+3] = lcFillWith
    
  *-- Put only the default value from an alternative file in the Array.
  CASE lcFillWith = "T" 
    llAltFile  = TYPE("lcAltFile")  = "C" AND !EMPTY(lcAltFile ) AND ;
                 TYPE("lcAltIndx")  = "C" AND !EMPTY(lcAltIndx ) AND ;
                 TYPE("lcAltExp")   = "C" AND !EMPTY(lcAltExp  ) AND ;
                 TYPE("lcAltField") = "C" AND !EMPTY(lcAltField)
    lcSerFile  = IIF(llAltFile, lcAltFile , "") 
    lcSerIndx  = IIF(llAltFile, lcAltIndx , "")
    lcSerExp   = IIF(llAltFile, lcAltExp  , "")
    lcSerField = IIF(llAltFile, lcAltField, "")

    STORE SPACE(0) TO lcCode, lcDesc
    IF llAltFile
      SELECT (lcSerFile)
      lcTag     = TAG()
      lcIdxExp  = SYS(14,VAL(SYS(21)))
      lcCurRecP = &lcIdxExp
      SET ORDER TO TAG &lcSerIndx
      IF SEEK(&lcSerExp, lcSerFile)
        lcCode = ALLTRIM(&lcSerField)
        IF EMPTY(lcCode) OR lcCode = "*"
          lcDesc = IIF(EMPTY(lcCode), lcNA, lcAll)
        ELSE
          lcCode = PADR(&lcSerField,6)
          SELECT Codes
          lcOrdTag = TAG()
          SET ORDER TO TAG CODES
          *E300789,1 Hesham (Start)
          *lcDesc = IIF(SEEK(lcActComp+lcCode+"N"+lcField), cDiscrep, SPACE(0))
          lcDesc = IIF(SEEK('N'+lcCode+"N"+lcField), cDiscrep, SPACE(0))
          *E300789,1 Hesham (End)
          SET ORDER TO TAG lcOrdTag
        ENDIF  
      ENDIF  
      SELECT (lcSerFile)
      SET ORDER TO TAG &lcTag
      = SEEK(lcCurRecP)
    ENDIF  
    lcCode = PADR(lcCode,06)
    lcDesc = PADR(lcDesc,30)
    DIMENSION &lcToUpdat[1,2]
    &lcToUpdat[1,1]     = IIF(llEditable, lcCode+lcSeprat+lcDesc, lcDesc)
    &lcToUpdat[1,2]     = lcCode
    &lcCurPopUp         = 1
    laInfArray[lnPos+3] = "T"

  *-- Put only the default value from the codes file in the Array.
  CASE lcFillWith = "D" 
    SELECT Codes
    lcTag = TAG()
    SET ORDER TO TAG cCode_No
    STORE SPACE(0) TO lcCode, lcDesc
    *E300789,1 Hesham (Start)
    *IF SEEK(SPACE(2)+lcField)
    IF SEEK('D'+lcField)
    *E300789,1 Hesham (End)
      lcCode = cCode_No
      lcDesc = cDiscrep
    ENDIF
    SET ORDER TO TAG &lcTag
    lcCode = PADR(lcCode,06)
    lcDesc = PADR(lcDesc,30)
    DIMENSION &lcToUpdat[1,2]
    &lcToUpdat[1,1]     = IIF(llEditable, lcCode+lcSeprat+lcDesc, lcDesc)
    &lcToUpdat[1,2]     = lcCode
    &lcCurPopUp         = 1
    laInfArray[lnPos+3] = "D"

  *-- Put only "N/A" or "All" in the list.
  CASE lcFillWith $ "AN" 
    DIMENSION &lcToUpdat[1,2]
    &lcToUpdat[1,1] = IIF(lcFillWith = "A", lcAll,     lcNA)
    &lcToUpdat[1,2] = IIF(lcFillWith = "A", lcAllCode, lcNACode)
    &lcCurPopUp     = 1
    laInfArray[lnPos+3] = lcFillWith

ENDCASE

*-- Refresh the popup.
SHOW GET &lcCurPopUp

SELECT(lnAlias) 

*:---------------------------------------------------------------------
*! Name      : gfIsEdtble
*! Developer : Yasser Mohammed Aly - (YMA)
*! Date      : 04/27/97
*! Purpose   : Function to tell if a specific code is editable by the
*!             user or not.
*: Job ID    : E# 300631
*:---------------------------------------------------------------------
*: Calls              : None
*:---------------------------------------------------------------------
*: Passed Parameters  : lcField  -> The code to be checked.
*:                      lnFieldW -> Pointer to a numeric variable to 
*:                                  hold the field width.
*:---------------------------------------------------------------------
*: Example            : = gfIsEdtble("TERMS", @lnWidth)
*:---------------------------------------------------------------------
FUNCTION gfIsEdtble
PARAMETERS lcPField, lnFieldW, lcActvComp
PRIVATE llRetVal, lcDataDir

*-- Set the company used variable with it's path.
lcActvComp = IIF(TYPE("lcActvComp")#"C", gcAct_Comp, lcActvComp)
lcDataDir  = gcDataDir
IF !(lcActvComp == gcAct_Comp)
  USE (gcSysHome+"SYCCOMP") IN 0 ORDER cComp_ID AGAIN ALIAS CompFile
  IF SEEK(lcActvComp,'CompFile')
    *E301098,1 Hesham (Start)
    *lcDataDir = ALLTRIM(CompFile.cCom_DDir)
    lcDataDir = gfGetDataDir(ALLTRIM(CompFile.cCom_DDir))
    *E301098,1 Hesham (End)
  ENDIF
  USE IN CompFile
ENDIF  

USE (gcSysHome+"SYDFIELD") IN 0 ORDER CFLD_NAME AGAIN ALIAS FieldFile
USE (lcDataDir+"CODESET" ) IN 0 ORDER Fildname  AGAIN ALIAS CodeSetF
*E301046,4 Change [= 'EDITABLE'] to ['EDITABLE' $] because the fields may include other codes.
*llRetVal = IIF(SEEK(lcPField, "FieldFile"), (ALLTRIM(FieldFile.mCodeInfo) = "EDITABLE"), .F.)
llRetVal = IIF(SEEK(lcPField, "FieldFile"),;
              ("EDITABLE" $ UPPER(ALLTRIM(FieldFile.mCodeInfo))), .F.)
*E301046,4 end
lnFieldW = IIF(SEEK(lcPField, "CodeSetF" ), CodeSetF.nfld_wdth, FieldFile.nFld_Wdth)
USE IN FieldFile
USE IN CodeSetF

RETURN llRetVal

* --------------------------------------------------

FUNCTION ARIABROW1
PARAMETER lcFltrExp,lcBrowTitle,lnY1,lnX1,lnY2,lnX2,lcOnSelect,lcBrPushB,lcFieldsNam,lcArrName,llChckKey,lcAliasName,llGetTree
IF (TYPE("lcFieldsNam")$"UL") .OR. (TYPE("lcArrName")$"UL")
  lcFieldsNam = FIELDS(1)
  DECLARE laArrName[1]
  lcArrName = 'laArrName'
ENDIF
RETURN(gfBrows(lcFltrExp,lcFieldsNam,lcArrName,lcBrowTitle))


*E300693,1 Hesham El_Sheltawi (Start)
*:---------------------------------------------------------------------
*! Name      : gfCPPrint
*! Developer : Hesham El-Sheltawi
*! Date      : 06/22/97
*! Purpose   : valid function for the control panel print
*: Job ID    : E# 300693,1
*:---------------------------------------------------------------------
*: Calls              : gfOpGrid
*:---------------------------------------------------------------------
*: Passed Parameters  : 
*:---------------------------------------------------------------------
*: Example            : 
*:---------------------------------------------------------------------
FUNCTION gfCPPrint
*PARAMETERS lcRunType
*lcRunType = IIF(PARAMETERS()=0,'P',lcRunType)
IF TYPE('lcReportID')='C' AND !EMPTY(lcReportID)
  SELECT (lcBaseFile)
  lnCPRecNo = RECNO(lcBaseFile)
  lcMdRports = gcRepHome+gcWinAppl+"REPORT"
  DO &lcMdRports WITH lcReportID,.F.,'P'
  SELECT (lcBaseFile)
  GO lnCPRecNo
ENDIF



*:---------------------------------------------------------------------
*! Name      : GFVCPPRINT
*! Developer : Hesham El-Sheltawi
*! Date      : 06/22/97
*! Purpose   : validation for Print Bar validation from the file pad in 
*!             sys menu
*: Job ID    : E# 300693,1
*:---------------------------------------------------------------------
*: Calls              : gpRpPrint
*:---------------------------------------------------------------------
*: Passed Parameters  : 
*:---------------------------------------------------------------------
*: Example            : 
*:---------------------------------------------------------------------
FUNCTION GFVCPPRINT
IF TYPE('lcReportID')='C' AND !EMPTY(lcReportID)
*  IF RDLEVEL() > 1
*    IF TYPE('lcBaseWind') = 'U'
*      CLEAR READ
*    ELSE
*      *** Get the current object at this moment
*      lnCurObj   = _CUROBJ          && Save current object to variable
*      =gfStatic()                   && Save inviroment before terminate
*      CLEAR READ                    && Terminat old program
*      IF glFromBrow 
*        glFromBrow = .F.
*        ON KEY LABEL CTRL+Q
*        KEYBOARD "{CTRL+Q}" PLAIN CLEAR
*      ENDIF  
*    ENDIF  
*    gcNextRepo = lcReportID
*    gcPrgPram  = 'M'
*  ELSE
*    DO gpRpPrint WITH lcReportID
*  ENDIF
  SELECT (lcBaseFile)
  lnCPRecNo = RECNO(lcBaseFile)
  lcMdRports = gcRepHome+gcWinAppl+"REPORT"
  DO &lcMdRports WITH lcReportID,.F.,'M'
  SELECT (lcBaseFile)
  GO lnCPRecNo

ENDIF
* =gfCPPrint('R')


*:---------------------------------------------------------------------
*! Name      : GFPRINTSET
*! Developer : Hesham El-Sheltawi
*! Date      : 06/22/97
*! Purpose   : validation for Printer setup Bar validation from the file 
*!             pad in sys menu
*: Job ID    : E# 300693,1
*:---------------------------------------------------------------------
*: Calls              : 
*:---------------------------------------------------------------------
*: Passed Parameters  : 
*:---------------------------------------------------------------------
*: Example            : 
*:---------------------------------------------------------------------
FUNCTION GFPRINTSET
=SYS(1037)
*E300693,1 Hesham El_Sheltawi (End)

*!*************************************************************************
*! Name      : gfPkTkBrow
*! Developer : Reham Alallamy
*! Date      : 30/03/97
*! Purpose   : Func. to brow all the available picking tickets.
*!*************************************************************************
*! Calls     :
*!*************************************************************************      
*! Returns   :  
*!*************************************************************************     
*
FUNCTION gfPkTkBrow
PARAMETER lcPikTkt,llRetAlias
PRIVATE lcBrFields,lnCurAlias

DECLARE laData[1]  && array to get values from browse
STORE '' TO laData
llWasSel = .T.
llBrowse = IIF(TYPE('llBrowse') = 'U' , .T. , llBrowse) && variable to determine forcing browse or not

IF _WINDOWS .OR. _MAC
  lcBrFields = [PikTkt:8,Account:7:H="Acct#",lcDummy=LOOKUP(CUSTOMER.BtName,"M"+PikTkt.Account,CUSTOMER.ACCOUNT,"CUSTOMER"):30:H="Name",Store:12,Order:8,Date:8]+;
               [,cWareCode:9:H="WareHouse",PrtFlag:7]
ELSE
  lcBrFields = [PikTkt:6,Account:5:H="Acct#",lcDummy=LOOKUP(CUSTOMER.BtName,"M"+PikTkt.Account,CUSTOMER.ACCOUNT,"CUSTOMER"):18:H="Name",Store:8,Order:6,Date:8]+;
               [,cWareCode:9:H="WareHouse",PrtFlag:7]
ENDIF

lnCurAlias = SELECT()

llOpenCst = .F.
IF !USED("CUSTOMER")
  SELECT 0
  *E300637,1 WAM 06/03/1997 Use the new global variables names
  *USE (Qdd+'CUSTOMER') IN 0 ORDER TAG CUSTOMER
  USE (gcDataDir+'CUSTOMER') IN 0 ORDER TAG CUSTOMER
  *E300637,1 WAM 06/03/1997 (End)
  llOpenCst = .T.
ELSE
  SELECT CUSTOMER
  lcCstOrder = TAG()
  SET ORDER TO TAG CUSTOMER
ENDIF

llOpenPik = .F.
IF !USED("PIKTKT")
  SELECT 0
  *E300637,1 WAM 06/03/1997 Use the new global variables names
  *USE (Qdd+'PIKTKT') IN 0 ORDER TAG PIKTKT
  USE (gcDataDir+'PIKTKT') IN 0 ORDER TAG PIKTKT
  *E300637,1 WAM 06/03/1997 (End)
  llOpenPik = .T.
ELSE
  SELECT PIKTKT
  lcPikOrder = TAG()
  SET ORDER TO TAG PIKTKT
ENDIF

IF llBrowse .OR. !SEEK(lcPikTkt)
  lnSoftSeek = RECNO(0)
  IF lnSoftSeek > 0 .AND. lnSoftSeek <= RECCOUNT("PIKTKT")
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF  
  llWasSel = ARIABROW([],"Picking Tickets",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'','PIKTKT',"laData")
  lcPikTkt = IIF(llWasSel , laData[1] , SPACE(6))
ENDIF

IF llOpenCst
  USE IN CUSTOMER
ELSE
  SELECT CUSTOMER
  IF !EMPTY(lcCstOrder)
    SET ORDER TO TAG (lcCstOrder)
  ELSE
    SET ORDER TO
  ENDIF
ENDIF

IF llOpenPik
  USE IN PIKTKT
ELSE
  SELECT PIKTKT
  IF !EMPTY(lcPikOrder)
    SET ORDER TO TAG (lcPikOrder)
  ELSE
    SET ORDER TO
  ENDIF
ENDIF

IF llRetAlias
  SELECT (lnCurAlias)
ENDIF

RETURN (lcPikTkt)

*!*************************************************************************
*! Name      : gfCrdtBrow
*! Developer : Reham Alallamy
*! Date      : 30/03/97
*! Purpose   : Func. to browse all the available credit memos.
*!*************************************************************************
*! Calls     :
*!*************************************************************************      
*! Returns   :  
*!*************************************************************************     
*
FUNCTION gfCrdtBrow
PARAMETER lcCrMemo,llRetAlias
PRIVATE lcBrFields,lnCurAlias

DECLARE laData[1]  && array to get values from browse
STORE '' TO laData
llWasSel = .T.
llBrowse = IIF(TYPE('llBrowse') = 'U' , .T. , llBrowse) && variable to determine forcing browse or not

IF _WINDOWS .OR. _MAC
  lcBrFields = [CrMemo:8,Account:7:H="Acct#",Store:12,CrDate:8,RaNo:8,]+;
               [Status:1:H="S",Reference:15:H="Ref.",Pieces:7,Amount:10,]+;
               [cWareCode:9:H="WareHouse",Invoice:8,Order:8,Reason:6,]+;
               [cDivision:8,Salesrep1:9,Salesrep2:9]
ELSE
  lcBrFields = [CrMemo:6,Account:5:H="Acct#",Store:8,CrDate:8,RaNo:6,]+;
               [Status:1:H="S",Reference:15:H="Ref.",Pieces:7,Amount:10,]+;
               [cWareCode:9:H="WareHouse",Invoice:6,Order:6,Reason:6,]+;
               [cDivision:8,Salesrep1:9,Salesrep2:9]
ENDIF

lnCurAlias = SELECT()

llOpenCrM = .F.
IF !USED("RETHDR")
  SELECT 0
  *E300637,1 WAM 06/03/1997 Use the new global variables names
  *USE (Qdd+'RETHDR') IN 0 ORDER TAG RETHDR
  USE (gcDataDir+'RETHDR') IN 0 ORDER TAG RETHDR
  *E300637,1 WAM 06/03/1997 (End)
  llOpenCrM = .T.
ELSE
  SELECT RETHDR
  lcCrMOrder = TAG()
  SET ORDER TO TAG RETHDR
ENDIF

IF llBrowse .OR. !SEEK(lcCrMemo)
  lnSoftSeek = RECNO(0)
  IF lnSoftSeek > 0 .AND. lnSoftSeek <= RECCOUNT("RETHDR")
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF
  llWasSel = ARIABROW([],"Credit Memos",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'','CrMemo',"laData")
  lcCrMemo = IIF(llWasSel , laData[1] , SPACE(6))
ENDIF

IF llOpenCrM
  USE IN RETHDR
ELSE
  SELECT RETHDR
  IF !EMPTY(lcCrMOrder)
    SET ORDER TO TAG (lcCrMOrder)
  ELSE
    SET ORDER TO
  ENDIF
ENDIF

IF llRetAlias
  SELECT (lnCurAlias)
ENDIF

RETURN (lcCrMemo)

*!*************************************************************************
*! Name      : gfInvBrow
*! Developer : Reham Alallamy
*! Date      : 30/03/97
*! Purpose   : Func. to browse all the available invoices.
*!*************************************************************************
*! Calls     :
*!*************************************************************************      
*! Returns   :  
*!*************************************************************************     
*
FUNCTION gfInvBrow
PARAMETER lcInvoice,llRetAlias
PRIVATE lcBrFields,lnCurAlias

DECLARE laData[1]  && array to get values from browse
STORE '' TO laData
llWasSel = .T.
llBrowse = IIF(TYPE('llBrowse') = 'U' , .T. , llBrowse) && variable to determine forcing browse or not

IF _WINDOWS .OR. _MAC
  lcBrfields = "INVOICE:6:H='Invoice',INVDATE:H='Date',"+;
               "ACCOUNT:H='Acct#',STORE:H='Store',"+;
               "ORDER:H='Order',lcDummy=LOOKUP(CUSTOMER.BtName,'M'+InvHdr.Account,CUSTOMER.ACCOUNT,'CUSTOMER'):H='Name':23 ,"+;
               "SHIP:H='Pieces',TOTALCHG:H='Amount'"
ELSE
  lcBrfields = "INVOICE:6:H='Invoice',INVDATE:H='Date',"+;
               "ACCOUNT:H='Acct#',STORE:H='Store',"+;
               "ORDER:H='Order',lcDummy=LOOKUP(CUSTOMER.BtName,'M'+InvHdr.Account,CUSTOMER.ACCOUNT,'CUSTOMER'):H='Name':13 ,"+;
               "SHIP:H='Pieces',TOTALCHG:H='Amount'"
ENDIF

lnCurAlias = SELECT()

llOpenCst = .F.
IF !USED("CUSTOMER")
  SELECT 0
  *E300637,1 WAM 06/03/1997 Use the new global variables names
  *USE (Qdd+'CUSTOMER') IN 0 ORDER TAG CUSTOMER
  USE (gcDataDir+'CUSTOMER') IN 0 ORDER TAG CUSTOMER
  *E300637,1 WAM 06/03/1997 (End)
  llOpenCst = .T.
ELSE
  SELECT CUSTOMER
  lcCstOrder = TAG()
  SET ORDER TO TAG CUSTOMER
ENDIF

llOpenInv = .F.
IF !USED("InvHdr")
  SELECT 0
  *E300637,1 WAM 06/03/1997 Use the new global variables names
  *USE (Qdd+'InvHdr') IN 0 ORDER TAG InvHdr
  USE (gcDataDir+'InvHdr') IN 0 ORDER TAG InvHdr
  *E300637,1 WAM 06/03/1997 (End)
  llOpenInv = .T.
ELSE
  SELECT InvHdr
  lcInvOrder = TAG()
  SET ORDER TO TAG InvHdr
ENDIF

IF llBrowse .OR. !SEEK(lcInvoice)
  lnSoftSeek = RECNO(0)
  IF lnSoftSeek > 0 .AND. lnSoftSeek <= RECCOUNT("InvHdr")
    GO lnSoftSeek
  ELSE
    GO TOP
  ENDIF
  llWasSel = ARIABROW([],"Invoices",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",'','Invoice',"laData")
  lcInvoice = IIF(llWasSel , laData[1] , SPACE(6))
ENDIF

IF llOpenCst
  USE IN CUSTOMER
ELSE
  SELECT CUSTOMER
  IF !EMPTY(lcCstOrder)
    SET ORDER TO TAG (lcCstOrder)
  ELSE
    SET ORDER TO
  ENDIF
ENDIF

IF llOpenInv
  USE IN InvHdr
ELSE
  SELECT INVHDR
  IF !EMPTY(lcInvOrder)
    SET ORDER TO TAG (lcInvOrder)
  ELSE
    SET ORDER TO
  ENDIF
ENDIF

IF llRetAlias
  SELECT (lnCurAlias)
ENDIF

RETURN (lcInvoice)


*!*************************************************************
*! Name : gfDialog.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 03/22/94.
*!         
*! Synopsis : Generates a gialog window with the passed message
*!            and buttons.
*!          
*! Called from : All ARIA programs.
*! 
*! Calls : 
*!         Functions  : gfArrayStr.
*! 
*! Passed :
*!        Parameters : 
*!          lcDlgTyp .. The dialog type which is one of the following :-
*!                      1) "I" Information dialog.
*!                      2) "!" Alert dialog (dangerous message). 
*!                      3) "?" Query dialog (qustion).
*!                      If there is no value for this parameter, the 
*!                      default will be "I".
*!          lcMsg ..... The message that will displayed, If there is 
*!                      no value for this parameter the default will 
*!                      be an empty space.   
*!          lcButton .. The buttons that will be activated on the dialog,
*!                      It should be written according to the push buttons
*!                      ruels used by FoxPro, The default for this parameter 
*!                      is : "\!<Ok" if it is empty.
*!        Files      : None.
*! 
*! Returned : 
*!        Variables  : The selected push button (lnDlgOpTion).
*! 
*! Example :
*!        lnSelBut = gfDialog (lcType,lcMessage,lcButtons)
*!*************************************************************
FUNCTION gfDialog
PARAMETER lcDlgTyp,lcMsg,lcButton

*-- Declare and initialize some variables.
PRIVATE lnButtons,lcButtChk,lnDlgOpTion,lnButtSize,lnBetwButt,lnMinWidth, ;
        lnMaxWidth,lcClrSet,lnTotBtWid,lnMaxButt,lnBtLnWid,lnButXPos,     ;
        lnButtLines,lnWinHight,lwDialog,lnButYPos,lnFirstCh,lnNumOfCh,    ;
        lcButPerLn,lwLstWin,lcOldClr,lnWerToPut,lcLastBut,lnDefButt

DECLARE laButtNo [1]   && Array to hold the buttons separetly.
lnDlgOpTion = 01       && Variable to get the result in.
lnButtSize  = 01       && Variable to hold the Maximum Button size.
lnBetwButt  = 03       && Variable to hold the default seperators length.
lnMinWidth  = 50       && Variable to hold the default minimum win. width.
lnMaxWidth  = 70       && Variable to hold the default maximum win. width.

*-- Validate the passed parameters.
lcDlgTyp = IIF(EMPTY(lcDlgTyp).OR.TYPE('lcDlgTyp') $ "UL".OR.!(lcDlgTyp $"I!?"),'I',lcDlgTyp)
lcMsg    = IIF(TYPE('lcMsg') $ "UL",'',lcMsg)
lcButton = IIF(EMPTY(lcButton).OR.TYPE('lcButton') $ "UL","\!\<Ok",lcButton)

*-- Save the current environment.
*- Save the current key action and get red of the escape key.
PUSH KEY
ON KEY
ON KEY LABEL ESCAPE STORE .T. TO llNoThing

*-- Remove all controle characters " \ ! < ?" from the button string
lcButtChk  = STRTRAN(STRTRAN(STRTRAN(STRTRAN(lcButton,'\',''),;
             '!',''),'<',''),'?','')

*-- Collect all Buttons in an array, And Compute the buttons number.
lnButtNo = gfArrayStr(lcButtChk,@laButtNo,';')

*-- Chcek if there is no default button then set the last button to be 
*-- the default, And initialize "lnDefButt" with the default button number.
IF ATC('\!',lcButton) = 0
  IF lnButtNo = 1
    lcButton   = '\!' + lcButton 
  ELSE
    lnWerToPut = ATC(';',lcButton,lnButtNo-1)
    lcLastBut  = SUBSTR(lcButton,lnWerToPut+1,LEN(lcButton)-lnWerToPut)
    lcButton   = SUBSTR(lcButton,1,lnWerToPut) + '\!' + lcLastBut
  ENDIF   
  lnDefButt  = lnButtNo
ELSE
  lnDefButt  = OCCURS(';',SUBSTR(lcButton,1,ATC('\!',lcButton,1)))+1
ENDIF

*-- Get the maximum width of the button.
FOR lnButtons = 1 TO lnButtNo
  lnButtSize = MAX(lnButtSize,LEN(laButtNo[lnButtons]))
ENDFOR

*-- Buttons width should not be less than 10 after adding 4 charactters 
*-- which are "<" + space + space + ">".
lnButtSize = MAX(10,lnButtSize+4)

*-- Calculat window width according to total buttons width. We will 
*-- keep in mind the 6 characters for the right and left margins.
lnTotBtWid = (lnButtSize * lnButtNo) + ((lnButtNo-1)*lnBetwButt)
lnWinWidth = IIF(BETWEEN(lnTotBtWid,lnMinWidth,lnMaxWidth),lnTotBtWid+6,;
                 IIF(lnTotBtWid>lnMaxWidth,lnMaxWidth,lnMinWidth))

*-- Calculat X position of the button to be centerd

*- Calculate the maximum number of buttons per line.
lnMaxButt = IIF(lnWinWidth=lnMinWidth,lnButtNo,;
                INT(((lnWinWidth-6)+lnBetwButt)/(lnButtSize+lnBetwButt)))
lnMaxButt = IIF(lnMaxButt>lnButtNo,lnButtNo,lnMaxButt)

*- Calculate the button line width.
lnBtLnWid = (lnMaxButt*lnButtSize)+((lnMaxButt-1)*lnBetwButt)

*- Get X position.
lnButXPos = INT ((lnWinWidth - lnBtLnWid)/2)

*-- Calculat window higth according to the length of the message and
*-- the button lines number.

*- Get the button lines number.
lnButtLines = CEILING (lnButtNo/lnMaxButt)

*- Get the window hight. The constant 5 is the fixed number of lines
*- that will be taken into consideration which are :
*- 2 lines for the border, 1 empty line before the message and 2 empty 
*- lines after the message.
lnWinHight  = INT(LEN(ALLTRIM(lcMsg))/lnWinWidth)+(5+lnButtLines)

*-- Define dialog window with right width and hight.
IF _WINDOWS
    DEFINE WINDOW lwDialog             ;
	       AT  0.000, 0.000            ;
		   SIZE lnWinHight,lnWinWidth  ;
		   FONT "System", 10           ;
		   STYLE "B"                   ;
		   FLOAT                       ;
           SYSTEM                      ;
           TITLE "Aria Advantage Series" ;
		   NOCLOSE                     ;
		   NOMINIMIZE                  ;
		   COLOR RGB(,,,192,192,192)
ELSE
  DEFINE WINDOW lwDialog                        ;
         FROM 0,0 TO lnWinHight,lnWinWidth      ;
         SHADOW                                 ;
         FLOAT                                  ;
         DOUBLE                                 ;
         COLOR SCHEME IIF(lcDlgTyp = "!", 7, 5)
ENDIF         

*-- Activate dialog window no show so that the window will pop with 
*-- the message when activated.
ACTIVATE WINDOW lwDialog NOSHOW

*-- Put the type mark and the message in the window.
IF _WINDOWS
  @ 0.000,0.000 TO 0.000,lnWinWidth ;
  PEN 1, 8 ;
  STYLE "1" ;
  COLOR RGB(255,255,255,255,255,255)
  
  @ 0.000,0.000 TO lnWinHight,0.000 ;
  PEN 1, 8 ;
  COLOR RGB(255,255,255,255,255,255)
  
  @ 0.188,0.429 TO 0.188,lnWinWidth-.6 ;
  PEN 1, 8 ;
  STYLE "1" ;
  COLOR RGB(128,128,128,128,128,128)
  
  @ 0.188,0.429 TO lnWinHight-.3,0.429 ;
  PEN 1, 8 ;
  COLOR RGB(128,128,128,128,128,128)
  
  @ 0.000,lnWinWidth TO lnWinHight,lnWinWidth ;
  PEN 1, 8 ;
  COLOR RGB(128,128,128,128,128,128)
  
  @ 0.188,lnWinWidth-.6 TO lnWinHight-.3,lnWinWidth-.6 ;
  PEN 1, 8 ;
  COLOR RGB(255,255,255,255,255,255)
  
  @ lnWinHight,0.143 TO lnWinHight,lnWinWidth ;
  PEN 1, 8 ;
  STYLE "1" ;
  COLOR RGB(128,128,128,128,128,128)
  
  @ lnWinHight-.3,0.4 TO lnWinHight-.3,lnWinWidth-.4 ;
  PEN 1, 8 ;
  STYLE "1" ;
  COLOR RGB(255,255,255,255,255,255)
    
  *lcIcon = "BMPS\"+SUBSTR ("TR  QRY INFO",ATC(lcDlgTyp,"!000?000I"),4)+".BMP"
*  @ 1.0,1.5 SAY lcIcon BITMAP STYLE "T"

  @ 1.5,7 SAY lcMsg SIZE lnWinHight-3,lnWinWidth-10
ELSE
  @ 00,01 , 02,05 BOX
  @ 01,03 SAY SUBSTR ('!?I',ATC(lcDlgTyp,'!?I',1),1)
  @ 01,07 SAY lcMsg SIZE lnWinHight-3,lnWinWidth-10
ENDIF
 
*-- Move the dialog window to the center of the screen.
MOVE WINDOW lwDialog CENTER

*-- When the read is activated fox will activate the window.
ACTIVATE WINDOW lwDialog NOSHOW
FOR lnI = 1 TO lnButtLines
  lnButYPos = lnWinHight-((lnButtLines+2)-lnI)
  lnFirstCh = IIF(lnI=1,1,ATC(';',lcButton,(lnI-1)*lnMaxButt)+1)
  lnNumOfCh = IIF(lnButtNo>1 ,;
                  IIF(ATC(';',lcButton,(lnI*lnMaxButt)-1)=0,LEN(lcButton),;
                      IIF(ATC(';',lcButton,lnI*lnMaxButt)=0,LEN(lcButton),;
                          ATC(';',lcButton,lnI*lnMaxButt)-lnFirstCh)),;
                          LEN(lcButton))
  lcButPerLn = SUBSTR(lcButton,lnFirstCh,lnNumOfCh)
  @ lnButYPos,lnButXPos GET     lnDlgOpTion ;             
                        PICTURE "@*HT "+lcButPerLn       ;
                        VALID   lfValidDef(@lnDlgOpTion) ;
                        SIZE    1,lnButtSize,lnBetwButt
ENDFOR

ACTIVATE WINDOW lwDialog 

READ CYCLE            ; 
     MODAL            ;
     OBJECT lnDefButt
RELEASE WINDOW lwDialog

*-- Set the pre saved environment.
*- Pop the pushed key again.
POP KEY

RETURN lnDlgOpTion

*!*************************************************************
*! Name : lfValidDef.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 03/22/94.
*!         
*! Synopsis : Valid function to be used with the dialog function
!*            to set the right value of the choosen button
*!            in the passed parameter according to the current 
*!            object number.
*!          
*! Called from : 
*!         Functions  : gfDialog.
*! 
*! Passed :
*!        Parameters : lnOpTion ... Pointer to the selected button 
*!                                  within the GET statement to be 
*!                                  validated.   
*!        Files      : None.
*! 
*! Returned : 
*!        Variables  : Always will return true.
*!        Parameters : lnOpTion ... The same passed parameter after
*!                                  setting it to the right value.
*!        Files      : None.
*! 
*! Example :
*!        @1,1 GET lnDlgOpTion VALID lfValidDef (@lnDlgOpTion)  
*! 
*! Modifications :
*!        None 
*!*************************************************************
FUNCTION lfValidDef
PARAMETER lnOpTion

lnOpTion = _CUROBJ
RETURN .T.


*!*************************************************************
*! Name : gfArrayStr.
*! Auth : Yasser Mohammed Aly (YMA).
*! Date : 03/22/94.
*!         
*! Synopsis : Cuts the passed string into words, redimensions the 
*!            passed array and fills it with these words. 
*!          
*! Called from : All ARIA programs.
*! 
*! Passed :
*!        Parameters : 
*!              1) lcString .... The string to be cut.
*!              2) laArr ....... Pointer to the array to be recreated
*!                               and filled.
*!              3) lcSeprator .. The character which is used to separate
*!                               the words in the string.
*!        Files      : None.
*! 
*! Returned : 
*!        Variables  : The number of words in the returned array 'lnCount'.
*!        Parameters : The passed array filled with the cut words.
*!        Files      : None.
*! 
*! Example :
*!        = gfArrayStr(lcString,@laArray,lcSeprator)
*! 
*! Modifications :
*!        None 
*!*************************************************************
FUNCTION gfArrayStr
PARAMETER lcString, laArr, lcSeprator

PRIVATE lnNumOcc,lnFirstCh,lnNumOfCh,lnCount

*-- Validate the passed parameters.
lcSeprator = IIF (EMPTY(lcSeprator),SPACE(1),lcSeprator)

lnCount   = 0                          && To hold the number of the words .
*-- If the string is empty then go on cutting otherwise return 0.
IF NOT EMPTY(lcString)
  *-- Compute the words number to be cut.
  lnNumOcc = OCCURS (lcSeprator,lcString)

  *-- Cut the first word.
  laArr[1] = SUBSTR (lcString,1,IIF (ATC(lcSeprator,lcString,1)=0,;
                                     LEN(lcString)               ,;
                                     ATC(lcSeprator,lcString,1)-1))
  lnCount = 1
  *-- If there is more than one word then go on cutting.
  IF lnNumOcc > 0
    FOR lnCount = 1 TO lnNumOcc
      lnFirstCh  = ATC(lcSeprator,lcString,lnCount)+1
      lnNumOfCh  = IIF (ATC(lcSeprator,lcString,lnCount+1)=0,;
                        LEN(lcString)-lnFirstCh+1     ,;
                        ATC(lcSeprator,lcString,lnCount+1)-lnFirstCh)
      DECLARE laArr[lnCount+1]                  
      laArr[lnCount+1] = SUBSTR (lcString,lnFirstCh,lnNumOfCh)
    ENDFOR
  ENDIF  
ENDIF

RETURN (lnCount)
   
*!*************************************************************
*! Name     : lfUSmpData.
*! Auth     : Yasser Mohammed Aly (YMA).
*! Date     : 06/24/97
*! Task ID  : E300613,1 
*!*************************************************************
*! Synopsis : Update the SYCCOMP with the sample '99' company
*!            record if it was installed.
*!*************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION lfUSmpData
FUNCTION x_lfUSmpData
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PRIVATE lnActAlias, llFound

llFound    = .F.
llEndSlash = (RIGHT(gcSysHome,1) = "\")
lc99Path   = IIF(llEndSlash, LEFT(gcSysHome,LEN(gcSysHome)-1), gcSysHome)
lc99Path   = LEFT(lc99Path , ATC("\",gcSysHome,OCCUR("\",lc99Path)))
lc99Path   = lc99Path + "DBFS\99\"
lnActAlias = SELECT()

IF FILE(lc99Path+"SYCCOMP.DBF")
  USE (lc99Path+"SYCCOMP.DBF") IN 0 AGAIN ALIAS InsComp
  SELECT InsComp
  GOTO TOP
  SCATTER MEMVAR MEMO
  USE (gcSysHome+"SYCCOMP") ORDER cComp_ID AGAIN ALIAS SysComp
  IF !SEEK("99")
    APPEND BLANK
  ENDIF
  llFound = .T.
  GATHER MEMVAR MEMO
  ERASE (lc99Path+"SYCCOMP.DBF")
  ERASE (lc99Path+"SYCCOMP.CDX")
  ERASE (lc99Path+"SYCCOMP.FPT")
ELSE
  USE (gcSysHome+"SYCCOMP") IN 0 ORDER cComp_ID AGAIN ALIAS SysComp
  SELECT SysComp
  llFound = SEEK("99")
  IF llFound
     *E301098,1 Hesham (Start)
     *lc99Path = ALLT(ccom_ddir)  
     lc99Path = gfGetDataDir(ALLT(ccom_ddir))
     *E301098,1 Hesham (End)
  ENDIF   
ENDIF  



IF llFound
  *E300712,1 Hesham El-Sheltawi (Start)
  *E300712,1 Update the currency file & the exchange file from
  *E300712,1 the sample data dir. if exist
  =gfUpdCurr(lc99Path)
  *E300712,1 Hesham El-Sheltawi (End)
  USE (gcSysHome+"SYDAPPL") IN 0 AGAIN ALIAS SysAppl
  SELECT SysAppl
  lcMod = SPACE(0)
  SCAN
    lcModule = UPPER(ALLTRIM(cApp_ID))
    IF lcModule # "SY" AND lcModule # "SM"
      lcMod = lcMod + IIF(EMPTY(lcMod),"","|") + lcModule
    ENDIF
    *E300717,1 Hesham (Start)
    *E300717,1 if the module that is being installed one of the list
    *E300717,1 then update the schedule file for company 99 for
    *E300717,1 the installed module
    IF INLIST(lcModule,'SM','PO','AP','AR')
      =gfUpdSched(lc99path,lcModule)
    ENDIF
    *E300717,1 Hesham (End)    
  ENDSCAN
  *E300717,1 Hesham (Start)
  *E300717,1 Erase the schedule file from the company 99 directory
  ERASE (lc99Path+"SYSCHDUL.DBF")
  ERASE (lc99Path+"SYSCHDUL.FPT")
  ERASE (lc99Path+"SYSCHDUL.CDX")
  *E300717,1 Hesham (End)  
  USE

  SELECT SysComp
  *MAN 07/18/2000 Start 
  *REPLACE mComp_Mdl WITH lcMod ,;
          mModlSet  WITH lcMod ,;
          cCom_DDir WITH lc99Path
   *-- The following code is written to make sure that only the modules that 
   *-- have demo data are replaced in mComp_Mdl and mModlSet with the exception 
   *-- of the modules that have not been installed. We know what modules have 
   *-- demo data installed by checking the mComp_Mdl and mModlSet in the splited
   *-- syccomp
   DECLARE laMod99[1]       
   laMod99 = ' '
   lcInstMod = ""
   lcSetMod  = ""
   = gfSubStr(SysComp.mComp_Mdl,@laMod99,'|')    
   FOR lnCount = 1 TO ALEN(laMod99,1)
     IF laMod99[lnCount] $ lcMod 
       lcInstMod = lcInstMod + IIF(EMPTY(lcInstMod),"","|") + laMod99[lnCount]
     ENDIF  
   ENDFOR     
   DECLARE laMod99[1]       
   laMod99 = ' '
   = gfSubStr(SysComp.mModlSet,@laMod99,'|')    
   FOR lnCount = 1 TO ALEN(laMod99,1)
     IF laMod99[lnCount] $ lcMod 
       lcSetMod = lcSetMod + IIF(EMPTY(lcInstMod),"","|") + laMod99[lnCount]
     ENDIF  
   ENDFOR
   SELECT SysComp     
   REPLACE mComp_Mdl WITH lcInstMod ,;
           mModlSet  WITH lcSetMod  ,;
           cCom_DDir WITH lc99Path
   *MAN 07/18/2000 End
        
ENDIF
USE IN SysComp

SELECT(lnActAlias)
 
*!*************************************************************
*! Name     : gpOpnCmp
*! Auth     : MAN - Mohamed Abdel Salam
*! Date     : 07/12/97
*! Task ID  : E300705,1
*!*************************************************************
*! Synopsis : Open the company global files (Files not related to specific
*!            moudle)
*!*************************************************************

PROCEDURE gpOpnCmp
PRIVATE laGenFiles,lcOldPath
RETURN
*E301077,78 Hesham (Start)
llfiles = gfSysOpen(gcSysHome+'sydfiles')
*E301077,78 Hesham (End)
SELECT CFILE_NAM,cFile_tag ;
  FROM (gcSysHome+"SYDFILES") ;
 WHERE 'SY' $ (mfile_app) .AND. ;
        LEFT(CFILE_NAM,2) <> "SY" AND CUPGRDLVL='S' ;
  INTO ARRAY laGenFiles

*E301077,78 Hesham (Start)
USE IN IIF(llfiles,'sydfiles',0)
*E301077,78 Hesham (End)
*E301077,78 Hesham (Start)
PRIVATE llCompUse
llCompUse=gfSysOpen(gcSysHome+'SYCCOMP',"CCOMP_ID")
*E301077,78 Hesham (End)
  
lcOldPath = SET("FULLPATH")
SET FULLPATH ON
FOR lnCnt = 1 TO ALEN(laGenFiles,1) 
   laGenFiles[lnCnt,1] = ALLTRIM(laGenFiles[lnCnt,1])
   IF USED(laGenFiles[lnCnt,1])
      USE IN (laGenFiles[lnCnt,1])
   ENDIF
   IF !EMPTY(gcPrnt_Cmp) .AND. gcAct_comp <> gcPrnt_Cmp .AND. INLIST(laGenFiles[lnCnt,1],'ACCOD','FISHD','FSHLD','FSPRD')
     *E301098,1 Hesham (Start)
     *lcDataDir = ALLTRIM(LOOKUP(sycComp.cCom_dDir,gcAct_Comp,sycComp.cComp_ID,'CCOMP_ID'))
     lcDataDir = gfGetDataDir(ALLTRIM(LOOKUP(sycComp.cCom_dDir,gcAct_Comp,sycComp.cComp_ID,'CCOMP_ID')))
     *E301098,1 Hesham (End)
   ELSE
     lcDataDir = gcDataDir
   ENDIF
   
   IF FILE(lcDataDir+laGenFiles[lnCnt,1]+'.DBF')
     USE (lcDataDir+laGenFiles[lnCnt,1]) IN 0 AGAIN SHARED
     IF !EMPTY(laGenFiles[lnCnt,2])
       SET ORDER TO TAG (laGenFiles[lnCnt,2]) IN ALLTRIM(laGenFiles[lnCnt,1])
     ENDIF  
   ENDIF  
ENDFOR
*E301077,78 Hesham (Start)
USE IN IIF(llCompUse,'SYCCOMP',0)
*E301077,78 Hesham (End)

SET FULLPATH &lcOldPath.
*!*************************************************************

*E300712,1 Hesham (Start)
*E300712,1 check if the currency file exist in the sample data direc.
*E300712,1 then update the currency file in system dir.
*!*************************************************************************
*! Name      : gfUpdCurr
*! Developer : Hesham El-Sheltawi 
*! Date      : 
*! Purpose   : function to update the currency files for the sample company 
*!             "company 99"
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfUpdCurr
FUNCTION x_gfUpdCurr
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lc99Path
IF FILE(lc99Path+"SYCCURR.DBF")
  USE (gcSysHome+"SYCCURR") ORDER CCURRCODE IN 0 AGAIN ALIAS SysCurr
  USE (lc99Path+"SYCCURR.DBF") IN 0 AGAIN ALIAS CompCurr ORDER CCURRCODE
  SELECT CompCurr
  GO TOP
  SCAN
    IF !SEEK(CompCurr.ccurrcode,'SysCurr')
      SCATT MEMVAR MEMO
      SELECT SysCurr
      APPEND BLANK
      GATHER MEMVAR MEMO
    ENDIF
  ENDSCAN  
  USE IN SysCurr
  USE IN CompCurr
  ERASE (lc99Path+"SYCCURR.DBF")
  ERASE (lc99Path+"SYCCURR.CDX")
  ERASE (lc99Path+"SYCCURR.FPT")
  
ENDIF

IF FILE(lc99Path+"SYCEXCH.DBF")
  USE (gcSysHome+"SYCEXCH") ORDER CURRENCY IN 0 AGAIN ALIAS SysExch
  USE (lc99Path+"SYCEXCH.DBF") IN 0 AGAIN ALIAS CompExch ORDER CURRENCY
  SELECT CompExch
  GO TOP
  SCAN
    IF !SEEK(cbasecurr+ccurrcode+DTOS(dratedate),'SysExch')
      SCATT MEMVAR MEMO
      SELECT SysExch
      APPEND BLANK
      GATHER MEMVAR MEMO
    ENDIF
  ENDSCAN  
  USE IN SysExch
  USE IN CompExch
  ERASE (lc99Path+"SYCEXCH.DBF")
  ERASE (lc99Path+"SYCEXCH.CDX")
  ERASE (lc99Path+"SYCEXCH.FPT")
ENDIF

*E300712,1 Hesham (End)

*E300717,1 Hesham (Start)
*!*************************************************************************
*! Name      : gfUpdSched
*! Developer : Hesham El-Sheltawi 
*! Date      : 02/02/97    
*! Purpose   : function to update the schedule file for the sample company
*!             "company 99"
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*! Returns   :  
*:*************************************************************************     
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfUpdSched
FUNCTION x_gfUpdSched
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lc99path,lcModule
IF FILE(lc99Path+"SYSCHDUL.DBF")
  USE (gcSysHome+"SYSCHDUL") ORDER Schuser IN 0 AGAIN ALIAS SysShed
  SELECT SysShed
  lcContType = IIF(lcModule $ 'POAP',[CCONTTYPE = 'V'],IIF(lcModule $ 'AR',[CCONTTYPE = 'C'],[!(CCONTTYPE $ 'VC')]))
  DELETE ALL FOR CCOMP_ID = '99' AND CUSER_ID = 'ADMIN' AND &lcContType
  APPEND FROM lc99Path+"SYSCHDUL.DBF" FOR CUSER_ID = 'ADMIN'
  USE IN SysShed
ENDIF
*E300717,1 Hesham (End)


*!*************************************************************
*! Name     : gfItemMask
*! Auth     : MAN - Mohamed Abdel Salam
*! Date     : 07/12/97
*! Task ID  : E300705,1
*!*************************************************************
*! Synopsis : function to return the item code mask or the item 
*!            code header
*!*************************************************************
*E300703,1 Hesham (Start)
FUNCTION gfItemMask
*E300998,1 AMM Add a new parameter to include the data directory of the company.
*PARAMETERS lcMaskOrHead
PARAMETERS lcMaskOrHead, lcDataDr
IF TYPE('lcDataDr') # 'C' .OR. EMPTY(lcDataDr)
  lcDataDr = gcDataDir
ENDIF
*E300998,1 AMM end
PRIVATE lcReturn,llStructUse,lnRecNo,lcStructOrd,lnCurAlias,llArray,;
        laSeg,lcItemDim,lcHeader,lnStartNonM,lnNoSeg,lnPosistion
STORE '' TO lcReturn        
llArray = TYPE('lcMaskOrHead[1]') # 'U'
lcItemDim = 'I'
IF !llArray
  IF TYPE('lcMaskOrHead')<>'C'
    RETURN .F.
  ENDIF
  lcMaskOrHead = UPPER(lcMaskOrHead)
  lcItemDim = IIF(LEN(lcMaskOrHead)>1,RIGHT(lcMaskOrHead,1),'I')  
  lcMaskOrHead = LEFT(lcMaskOrHead,1)  
ENDIF
lcLoopExt = lcItemDim 
lnCurAlias = SELECT()
llStructUse = .F.
IF !USED('ICISTRU')
  *E300998,1 AMM Open the table of the required company.
  *USE (gcDataDir+'ICISTRU') IN 0
  USE (lcDataDr+'ICISTRU') IN 0
  *E300998,1 AMM end
  llStructUse = .T.
ELSE
  SELECT ICISTRU
  lcStructOrd = ORDER()
  lnRecNo = RECNO()
ENDIF
SELECT ICISTRU
SET ORDER TO TAG SEGNO
*GO TOP
=SEEK('U1')
lcHeader = cIsegHead
lnNoSeg = 0
lnPosistion = 1
SCAN REST WHILE citemrecty+cisegno = 'U'
  IF lcLoopExt <> 'N'
    lnNoSeg = lnNoSeg + 1
    DIMEN laSeg[lnNoSeg,7]
    laSeg[lnNoSeg,1] = cisegType
    laSeg[lnNoSeg,2] = ALLT(cisegsdes)
    laSeg[lnNoSeg,3] = REPL('X',nisegsize)
    laSeg[lnNoSeg,4] = lnPosistion
    laSeg[lnNoSeg,5] = ALLT(CISEGLDES)
    laSeg[lnNoSeg,6] = CISEGSEPR
    laSeg[lnNoSeg,7] = LSEGENDMAJ  
    lcReturn = lcReturn+REPL('X',nisegsize)+ALLT(CISEGSEPR)
  ENDIF
  lnPosistion = lnPosistion + nisegsize + LEN(ALLT(CISEGSEPR))
  IF lcLoopExt = 'N' AND lSegEndMaj
    lcLoopExt = 'I'
  ENDIF
  IF lcItemDim = 'M' AND lSegEndMaj
     EXIT
  ENDIF    
ENDSCAN
IF llArray
  DIMEN lcMaskOrHead[ALEN(laSeg,1),ALEN(laSeg,2)]
  lcReturn=ACOPY(laSeg,lcMaskOrHead)
ELSE  
  DO CASE
    CASE  lcMaskOrHead = 'S'
      lcReturn = lnNoSeg
    CASE  lcMaskOrHead = 'P' AND  lcItemDim='M'
      IF gfItemMask('SN')>0
        lcReturn = SUBSTR(lcReturn,1,LEN(lcReturn)-1)
      ENDIF  
    CASE lcMaskOrHead = 'H' AND lcItemDim='M'
      IF gfItemMask('SN')>0
        lcReturn = SUBSTR(lcHeader,1,laSeg[lnNoSeg,4]+LEN(laSeg[lnNoSeg,2])-1)
      ELSE
        lcReturn = lcHeader        
      ENDIF  
    CASE lcMaskOrHead = 'H' AND lcItemDim='N'  AND lnNoSeg>0
      lcReturn = SUBSTR(lcHeader,laSeg[1,4])  
    CASE lcMaskOrHead = 'H' AND lcItemDim='I'
      lcReturn = lcHeader  
  ENDCASE
ENDIF  

IF llStructUse 
    USE IN ICISTRU
ELSE    
  SELECT ICISTRU
  SET ORDER TO TAG (lcStructOrd)
  IF lnRecNo>0 AND lnRecNo<=RECCOUNT()
    GO lnRecNo
  ENDIF  
ENDIF
SELECT (lnCurAlias)
RETURN lcReturn
*E300703,1 Hesham (End)

*:*************************************************************
*! Name      : ShipBrow
*! Purpose   : Browsing the shipment header file
*:*************************************************************
PROCEDURE ShipBrow
PARAMETER lcShipNo
PRIVATE lcAlias

lcTitle = 'Style Purchase Orders Shipments'
lcAlias = ALIAS()   && Save the current alias.

llWasSel=gfBrows()

SELECT (lcAlias)
RETURN llWasSel



*:*************************************************************
*! Name      : gfSetDevice
*! Purpose   : set the deive and printer for the @ say reports
*:*************************************************************
FUNCTION DgfSetDevice
DO CASE
   CASE gcDevice     = "PRINTER" 
   *MAN Start
    *gcOutFile    = gfTempName()
    _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))
    *SET PRINTER TO (gcWorkDir+gcOutFile+'.TXT')
    gcOutFile    = gcWorkDir+gfTempName()+'.TXT'
    SET PRINTER TO (gcOutFile)
    *B603034,1 Hesham (Start)
    IF "NT" $ GETENV('OS') AND TYPE('_pdparms[3]')='C'
      SET DEVICE TO PRINTER
      lcCompType = ""
      IF TYPE('glPrtAcomp')='L' AND glPrtAcomp=.T. AND TYPE('gnPrint_Wd')='N' AND _RMARGIN>gnPrint_Wd
        lcCompType = ALLTRIM(gc16CPInch)
      ELSE  		
        lcCompType = IIF(TYPE("_pdparms[8]")='C',_pdparms[8],"")
      ENDIF
      @0,0 SAY ALLT(_pdparms[3])+lcCompType
      SET PRINTER TO
      SET PRINTER TO (gcOutFile) ADDI
      SET PRINTER ON
    ENDIF
    *B603034,1 Hesham (End)
    *MAN End
    SET DEVICE TO PRINTER
    
   CASE gcDevice     = "SCREEN" 
   *MAN Start
    *gcOutFile    = gfTempName()
    *SET PRINTER TO (gcWorkDir+gcOutFile+'.TXT')
    gcOutFile    = gcWorkDir+gfTempName()+'.TXT'
    SET PRINTER TO (gcOutFile)
*    SET DEVICE TO PRINTER

   *MAN End 
   CASE gcDevice     = "FILE"     
    SET PRINTER TO &gcOutFile
    SET DEVICE TO PRINTER   
ENDCASE



*:*************************************************************
*! Name      : gfToPrintr
*! Purpose   : print the temprory file that was created by
*!             a @ say report
*:*************************************************************
FUNCTION DgfToPrintr
lcPrntTool = IIF(_WINDOWS,GETENV('ARIAPRN'),IIF(GETENV('ARIAPRN')='LIB',"",GETENV('ARIAPRN')))
lcPrntTool = IIF(EMPTY(lcPrntTool) AND _WINDOWS,'TYPE',lcPrntTool)

*-- MAB Comment out the following line and surround it by printer condition.
*B602236,1 Report print on printer when user choice is to print on File. [begin]
*SET PRINTER TO
*SET PRINTER TO (gcPrnt_Port)
IF gcDevice = "PRINTER"
  
  *B603034,1 Hesham (Start)  
  lcPdDriv = _PDRIVER
  lcPDSetup = _PDSETUP
  gcLoclPrt = gcPrnt_Port
  IF "NT" $ GETENV("OS")
    _PDSETUP = ""    
  ENDIF
  *B603034,1 Hesham (End)

  SET PRINTER TO
  SET PRINTER TO (gcPrnt_Port)
ENDIF
*B602236,1 Report print on printer when user choice is to print on File. [end  ]
*-- MAB

llError=.F.
lcOnErr=ON('ERROR')
ON ERROR llError=.T.
lcSetSafe=SET('SAFE')
SET SAFE OFF
DO WHILE SYS(13)='OFFLINE'
  IF gfModalGen("QRM00054B00015",'ALERT') = 2
    llError=.T.
    EXIT
  ENDIF
ENDDO 
IF FILE(gcOutFile) AND llError=.F.

  *-- MAB Surround the following lines by device is printer if condition.
  *B602236,1 Report print on printer when user choice is to print on File. [begin]
  IF gcDevice = "PRINTER"

    *B603034,1 Hesham (Start) 
    *lcPdDriv = _PDRIVER
    *lcPDSetup = _PDSETUP
    *gcLoclPrt = gcPrnt_Port
    *=lfSetEscSeq()
    *SET PRINTER TO
    IF !("NT" $ GETENV('OS'))
        =lfSetEscSeq()
        SET PRINTER TO
    ENDIF    
    *B603034,1 Hesham (End)  
  ENDIF
  *B602236,1 Report print on printer when user choice is to print on File. [end  ]
  *-- MAB Surround the following lines by device is printer if condition. [end ]

  DO CASE
    CASE lcPrntTool = '???' OR lcPrntTool = '??' OR lcPrntTool = '?'
      lcTmpCur = gfTempName() && temprory cursor
      lcWorkA = SELECT()      && curr. work area
      CREATE CURS &lcTmpCur (mprnfile M) && create temp. cursor
      APPEND BLANK 
      *-- append memo with the output file
      APPEND MEMO mprnfile FROM (gcOutFile) 
      IF glPrnt_Lan                && if it is a lan option
        lcPrintSet = '\\SPOOLER\P='+ALLTRIM(STR(gnPrnt_No))+'\S='+ALLTRIM(gcServ_Nam);
                    +'\Q='+ALLTRIM(gcQueu_nam);
                    +IIF(_pCopies>1,"\C="+ALLTRIM(STR(_PCOPIES)),"");
                    +IIF(glBaner,'\B='+gcBaner_H,'\N')
        SET PRINTER TO &lcPrintSet        
      ELSE
        SET PRINTER TO (gcLoclPrt)
      ENDIF       
      SET PRINTER ON
      lnMemoWid = SET('MEMOW')
      lcConsSet = SET('CONS')
      llWrapStat = _WRAP
      lnIndent = _INDENT
      lnRMargin = _RMARGIN
      lnLMargin = _LMARGIN
      SET CONS OFF
      SET MEMOW TO 65              
      _WRAP = .T.
      _RMARGIN = 255
      _LMARGIN = 0
      _INDENT = 2
      *-- reset the printing cursor then start printing the memo field
      *B802847,1 Hesham (Start)
      *IF lcPrntTool == '???'
      *  &lcPrntTool ALLTRM(mprnfile)
      *ELSE
      *  &lcPrntTool MPRNFILE FUNCTION 'V253'
      *ENDIF  
      FOR lnNoCopy = 1 TO _PCOPIES
        IF lcPrntTool == '???'
          &lcPrntTool ALLTRM(mprnfile)
        ELSE
          &lcPrntTool MPRNFILE FUNCTION 'V253'
        ENDIF  
      ENDFOR
      *B802847,1 Hesham (End)      
      *-- reset the device to screen and clear the printer buffer to make
      *-- the printer start printing.
      SET PRINTER OFF
      SET PRINTER TO
      SET CONS &lcConsSet
      SET MEMOW TO lnMemoWid
      _WRAP = llWrapStat
      _INDENT = lnIndent 
      _RMARGIN = lnRMargin 
      _LMARGIN = lnLMargin 
              
      *-- close the temp. cursor and select the curr. work area
      USE IN &lcTmpCur
      SELECT (lcWorkA)          

    CASE lcPrntTool="COPY"
     *-- MAB Surround the following lines by device is printer if condition. [begin]
     *B602236,1 Report print on printer when user choice is to print on File. [begin]
      IF gcDevice = "PRINTER"
        lcHeadSet = SET('HEADING')
        lnMemoWid = SET('MEMOW')
        lcConsSet = SET('CONS')
        llWrapStat = _WRAP
        lnRMargin = _RMARGIN
        lnLMargin = _LMARGIN
        lcAdvance = _PADVANCE
        SET MEMOW TO 255              
        _WRAP = .F.
        _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
        _LMARGIN = 0
        _PADVANCE = 'LINEFEED'
        SET HEADING OFF
        SET CONS OFF
        SET PRINTER TO (gcLoclPRT)  
        *B802847,1 Hesham (Start)        
        *!COPY &gcOutFile. &gcLoclPRT
        FOR lnNoCopy = 1 TO _PCOPIES
          !COPY &gcOutFile. &gcLoclPRT
        ENDFOR  
        *B802847,1 Hesham (End)
        SET HEADING &lcHeadSet
        SET CONS &lcConsSet
        SET MEMOW TO lnMemoWid
        _WRAP = llWrapStat
        _RMARGIN = lnRMargin 
        _LMARGIN = lnLMargin 
        _PADVANCE = lcAdvance
      ENDIF  
     *B602236,1 Report print on printer when user choice is to print on File. [end  ]
     *-- MAB Surround the following lines by device is printer if condition. [end ]
    CASE lcPrntTool="LIB"
*!*	      IF FILE("TXTSPOOL.FLL") AND FILE("PRTWIN.EXE") 
*!*	        SET LIBRARY TO TXTSPOOL.FLL ADDITIVE
*!*	        lcWinPrt  = "IBM Proprinter on " + ALLTRIM(gcLoclPRT)
*!*	        lcOrgPrnt = PRTWIN(lcWinPrt)
*!*	        *B802847,1 Hesham (Start)
*!*	        *=TXTSPOOL(gcOutFile,"ARIA SYSTEMS")
*!*	        FOR lnNoCopy = 1 TO _PCOPIES
*!*	          =TXTSPOOL(gcOutFile,"ARIA SYSTEMS")
*!*	        ENDFOR  
*!*	        *B802847,1 Hesham (End)
*!*	        = PRTWIN(lcOrgPrnt)
*!*	        RELEASE LIBRARY TXTSPOOL.FLL
*!*	      ENDIF
    CASE lcPrntTool = 'TYPE'
      lcHeadSet = SET('HEADING')
      lnMemoWid = SET('MEMOW')
      lcConsSet = SET('CONS')
      llWrapStat = _WRAP
      lnRMargin = _RMARGIN
      lnLMargin = _LMARGIN
      lcAdvance = _PADVANCE
      SET MEMOW TO 255              
      _WRAP = .F.
      _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
      _LMARGIN = 0
      _PADVANCE = 'LINEFEED'
      SET HEADING OFF
      SET CONS OFF
      lcTempPr=_PDSETUP
      SET PRINTER TO (gcPrnt_Port)
      *B802847,1 Hesham (Start)
      *TYPE (gcOutFile) TO PRINTER
      FOR lnNoCopy = 1 TO _PCOPIES
        TYPE (gcOutFile) TO PRINTER
      ENDFOR  
      *B802847,1 Hesham (End)
      SET PRINTER TO 
      SET HEADING &lcHeadSet
      SET CONS &lcConsSet
      SET MEMOW TO lnMemoWid
      _PDSETUP = lcTempPr
      _WRAP = llWrapStat
      _RMARGIN = lnRMargin 
      _LMARGIN = lnLMargin 
      _PADVANCE = lcAdvance
    OTHERWISE
      *B802847,1 Hesham (Start)
      *COPY FILE (gcOutFile) TO (gcPrnt_Port)          
      FOR lnNoCopy = 1 TO _PCOPIES
        COPY FILE (gcOutFile) TO (gcPrnt_Port)
      ENDFOR  
      *B802847,1 Hesham (End)
  ENDCASE

  *-- MAB Surround the following lines by device is printer if condition. [begin]
  *B602236,1 Report print on printer when user choice is to print on File. [begin]
  IF gcDevice = "PRINTER"
    _PDSETUP = lcPDSetup
  ENDIF  
  *B602236,1 Report print on printer when user choice is to print on File. [end  ]
  *-- MAB Surround the following lines by device is printer if condition. [end ]
  
ENDIF
ON ERROR &lcOnErr
SET SAFE &lcSetSafe    

*-- MAB Surround the following lines by device is printer if else conditions. [begin]
*B602236,1 Report print on printer when user choice is to print on File. [begin]
IF gcDevice = "PRINTER"
  ERASE (gcOutFile)

ELSE  && B602236,1 else if device is File relase file from printer port (i.e. user can read it)
  SET PRINTER TO
ENDIF
*B602236,1 Report print on printer when user choice is to print on File. [end ]
*-- MAB Surround the following lines by device is printer if condition. [end]

*!*************************************************************
*! Name      : lfSetEscSeq
*! Developer : Hesham Al-Sheltawi
*! Date      : 08/10/1998
*! Purpose   : Adds Escape Sequence the output file
*!*************************************************************
*! Calls     : gftempName
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Returns   :  None
*!*************************************************************
*! Example   :  =lfSetEscSeq()
*!*************************************************************
FUNCTION DlfSetEscSeq
PRIVATE lcTempFile

lcHeadSet = SET('HEADING')
lcConsSet = SET('CONS')
llWrapStat = _WRAP
lnRMargin = _RMARGIN
lnLMargin = _LMARGIN
lcAdvance = _PADVANCE

_WRAP = .F.
_RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
_LMARGIN = 0
_PADVANCE = 'LINEFEED'
SET HEADING OFF
SET CONS OFF

lcTempFile = gcWorkDir+gfTempName()+'.TXT'
SET PRINTER TO (lcTempFile)
TYPE (gcOutFile) TO PRINTER
ERASE (gcOutFile)
gcOutFile = lcTempFile

SET HEADING &lcHeadSet.
SET CONS    &lcConsSet.
_WRAP     = llWrapStat 
_RMARGIN  = lnRMargin 
_LMARGIN  = lnLMargin 
_PADVANCE = lcAdvance 


****
*:*************************************************************
*! Name      : gfSetDevice
*! Purpose   : set the deive and printer for the @ say reports
*:*************************************************************
*B603034,1 Fix problems encountered when printing under Window NT
FUNCTION gfSetDevice
DO CASE
   CASE gcDevice     = "PRINTER" 
   *MAN Start
    *gcOutFile    = gfTempName()
    _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))
    *SET PRINTER TO (gcWorkDir+gcOutFile+'.TXT')
    gcOutFile    = gcWorkDir+gfTempName()+'.TXT'
    SET PRINTER TO (gcOutFile)
    *B603034,1 Hesham (Start)
    *IF "NT" $ GETENV('OS') AND TYPE('_pdparms[3]')='C'
    *  SET DEVICE TO PRINTER
    *  lcCompType = ""
    *  IF TYPE('glPrtAcomp')='L' AND glPrtAcomp=.T. AND TYPE('gnPrint_Wd')='N' AND _RMARGIN>gnPrint_Wd
    *    lcCompType = ALLTRIM(gc16CPInch)
    *  ELSE  		
    *    lcCompType = IIF(TYPE("_pdparms[8]")='C',_pdparms[8],"")
    *  ENDIF
    *  @0,0 SAY ALLT(_pdparms[3])+lcCompType
    *  SET PRINTER TO
    *  SET PRINTER TO (gcOutFile) ADDI
    *  SET PRINTER ON
    *ENDIF
    *B603034,1 Hesham (End)
    *MAN End
    SET DEVICE TO PRINTER
    
   CASE gcDevice     = "SCREEN" 
   *MAN Start
    *gcOutFile    = gfTempName()
    *SET PRINTER TO (gcWorkDir+gcOutFile+'.TXT')
    gcOutFile    = gcWorkDir+gfTempName()+'.TXT'
    SET PRINTER TO (gcOutFile)
*    SET DEVICE TO PRINTER

   *MAN End 
   CASE gcDevice     = "FILE"     
    SET PRINTER TO &gcOutFile
    SET DEVICE TO PRINTER   
ENDCASE



*:*************************************************************
*! Name      : gfToPrintr
*! Purpose   : print the temprory file that was created by
*!             a @ say report
*:*************************************************************
*B603034,1 Fix problems encountered when printing under Window NT
FUNCTION gfToPrintr
lcPrntTool = IIF(_WINDOWS,GETENV('ARIAPRN'),IIF(GETENV('ARIAPRN')='LIB',"",GETENV('ARIAPRN')))
lcPrntTool = IIF(EMPTY(lcPrntTool) AND _WINDOWS,'TYPE',lcPrntTool)
*COCO
lcPrntTool = IIF(_WINDOWS,GETENV('ARIAPRN'),IIF(GETENV('ARIAPRN')='LIB',"",GETENV('ARIAPRN')))
*COCO

*-- MAB Comment out the following line and surround it by printer condition.
*B602236,1 Report print on printer when user choice is to print on File. [begin]
*SET PRINTER TO
*SET PRINTER TO (gcPrnt_Port)
IF gcDevice = "PRINTER"

  *B603034,1 Hesham (Start)  
  lcPdDriv = _PDRIVER
  lcPDSetup = _PDSETUP
  gcLoclPrt = gcPrnt_Port
  *IF "NT" $ GETENV("OS")
  *  _PDSETUP = ""    
  *ENDIF
  *B603034,1 Hesham (End)
  
  SET PRINTER TO
  SET PRINTER TO (gcPrnt_Port)
ENDIF
*B602236,1 Report print on printer when user choice is to print on File. [end  ]
*-- MAB

llError=.F.
lcOnErr=ON('ERROR')
ON ERROR llError=.T.
lcSetSafe=SET('SAFE')
SET SAFE OFF
DO WHILE SYS(13)='OFFLINE'
  IF gfModalGen("QRM00054B00015",'ALERT') = 2
    llError=.T.
    EXIT
  ENDIF
ENDDO 
 
IF FILE(gcOutFile) AND llError=.F.

  *-- MAB Surround the following lines by device is printer if condition.
  *B602236,1 Report print on printer when user choice is to print on File. [begin]
  IF gcDevice = "PRINTER"
    *B603034,1 Hesham (Start) 
        =lfSetEscSeq()
    *IF !("NT" $ GETENV('OS'))
    *    =lfSetEscSeq()
    *    SET PRINTER TO
    *ENDIF    
    *B603034,1 Hesham (End)      
  ENDIF
  *B602236,1 Report print on printer when user choice is to print on File. [end  ]
  *-- MAB Surround the following lines by device is printer if condition. [end ]
  DO CASE
    CASE lcPrntTool = '???' OR lcPrntTool = '??' OR lcPrntTool = '?'
      lcTmpCur = gfTempName() && temprory cursor
      lcWorkA = SELECT()      && curr. work area
      CREATE CURS &lcTmpCur (mprnfile M) && create temp. cursor
      APPEND BLANK 
      *-- append memo with the output file
      APPEND MEMO mprnfile FROM (gcOutFile) 
      IF glPrnt_Lan                && if it is a lan option
        lcPrintSet = '\\SPOOLER\P='+ALLTRIM(STR(gnPrnt_No))+'\S='+ALLTRIM(gcServ_Nam);
                    +'\Q='+ALLTRIM(gcQueu_nam);
                    +IIF(_pCopies>1,"\C="+ALLTRIM(STR(_PCOPIES)),"");
                    +IIF(glBaner,'\B='+gcBaner_H,'\N')
        SET PRINTER TO &lcPrintSet        
      ELSE
        SET PRINTER TO (gcLoclPrt)
      ENDIF       
      SET PRINTER ON
      lnMemoWid = SET('MEMOW')
      lcConsSet = SET('CONS')
      llWrapStat = _WRAP
      lnIndent = _INDENT
      lnRMargin = _RMARGIN
      lnLMargin = _LMARGIN
      SET CONS OFF
      SET MEMOW TO 65              
      _WRAP = .T.
      _RMARGIN = 255
      _LMARGIN = 0
      _INDENT = 2
      *-- reset the printing cursor then start printing the memo field
      *B802847,1 Hesham (Start)
      *IF lcPrntTool == '???'
      *  &lcPrntTool ALLTRM(mprnfile)
      *ELSE
      *  &lcPrntTool MPRNFILE FUNCTION 'V253'
      *ENDIF  
      FOR lnNoCopy = 1 TO _PCOPIES
        IF lcPrntTool == '???'
          &lcPrntTool ALLTRM(mprnfile)
        ELSE
          &lcPrntTool MPRNFILE FUNCTION 'V253'
        ENDIF  
      ENDFOR
      *B802847,1 Hesham (End)      
      *-- reset the device to screen and clear the printer buffer to make
      *-- the printer start printing.
      SET PRINTER OFF
      SET PRINTER TO
      SET CONS &lcConsSet
      SET MEMOW TO lnMemoWid
      _WRAP = llWrapStat
      _INDENT = lnIndent 
      _RMARGIN = lnRMargin 
      _LMARGIN = lnLMargin 
              
      *-- close the temp. cursor and select the curr. work area
      USE IN &lcTmpCur
      SELECT (lcWorkA)          

    CASE lcPrntTool="COPY"
     *-- MAB Surround the following lines by device is printer if condition. [begin]
     *B602236,1 Report print on printer when user choice is to print on File. [begin]
      IF gcDevice = "PRINTER"
        lcHeadSet = SET('HEADING')
        lnMemoWid = SET('MEMOW')
        lcConsSet = SET('CONS')
        llWrapStat = _WRAP
        lnRMargin = _RMARGIN
        lnLMargin = _LMARGIN
        lcAdvance = _PADVANCE
        SET MEMOW TO 255              
        _WRAP = .F.
        _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
        _LMARGIN = 0
        _PADVANCE = 'LINEFEED'
        SET HEADING OFF
        SET CONS OFF
        SET PRINTER TO (gcLoclPRT)  
        
        *B802847,1 Hesham (Start)        
        *!COPY &gcOutFile. &gcLoclPRT
        FOR lnNoCopy = 1 TO _PCOPIES
          !COPY &gcOutFile. &gcLoclPRT
        ENDFOR  
        *B802847,1 Hesham (End)

        SET HEADING &lcHeadSet
        SET CONS &lcConsSet
        SET MEMOW TO lnMemoWid
        _WRAP = llWrapStat
        _RMARGIN = lnRMargin 
        _LMARGIN = lnLMargin 
        _PADVANCE = lcAdvance
      ENDIF  
     *B602236,1 Report print on printer when user choice is to print on File. [end  ]
     *-- MAB Surround the following lines by device is printer if condition. [end ]
    CASE lcPrntTool="LIB"
*!*	      IF FILE("TXTSPOOL.FLL") AND FILE("PRTWIN.EXE") 
*!*	        SET LIBRARY TO TXTSPOOL.FLL ADDITIVE
*!*	        lcWinPrt  = "IBM Proprinter on " + ALLTRIM(gcLoclPRT)
*!*	        lcOrgPrnt = PRTWIN(lcWinPrt)
*!*	        *B802847,1 Hesham (Start)
*!*	        *=TXTSPOOL(gcOutFile,"ARIA SYSTEMS")
*!*	        FOR lnNoCopy = 1 TO _PCOPIES
*!*	          =TXTSPOOL(gcOutFile,"ARIA SYSTEMS")
*!*	        ENDFOR  
*!*	        *B802847,1 Hesham (End)
*!*	        = PRTWIN(lcOrgPrnt)
*!*	        RELEASE LIBRARY TXTSPOOL.FLL
*!*	      ENDIF
    CASE lcPrntTool = 'TYPE'
      lcHeadSet = SET('HEADING')
      lnMemoWid = SET('MEMOW')
      lcConsSet = SET('CONS')
      llWrapStat = _WRAP
      lnRMargin = _RMARGIN
      lnLMargin = _LMARGIN
      lcAdvance = _PADVANCE
      SET MEMOW TO 255              
      _WRAP = .F.
      _RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
      _LMARGIN = 0
      _PADVANCE = 'LINEFEED'
      SET HEADING OFF
      SET CONS OFF
      lcTempPr=_PDSETUP
      SET PRINTER TO (gcPrnt_Port)
      *B802847,1 Hesham (Start)
      *TYPE (gcOutFile) TO PRINTER
      FOR lnNoCopy = 1 TO _PCOPIES
        TYPE (gcOutFile) TO PRINTER
      ENDFOR  
      *B802847,1 Hesham (End)
      SET PRINTER TO 
      SET HEADING &lcHeadSet
      SET CONS &lcConsSet
      SET MEMOW TO lnMemoWid
      _PDSETUP = lcTempPr
      _WRAP = llWrapStat
      _RMARGIN = lnRMargin 
      _LMARGIN = lnLMargin 
      _PADVANCE = lcAdvance
    OTHERWISE
      *B802847,1 Hesham (Start)
      *COPY FILE (gcOutFile) TO (gcPrnt_Port)          
      FOR lnNoCopy = 1 TO _PCOPIES
        COPY FILE (gcOutFile) TO (gcPrnt_Port)
      ENDFOR  
      *B802847,1 Hesham (End)
  ENDCASE

  *HESHAM TMP
  SET PRINTER OFF
  *HESHAM TMP

  *-- MAB Surround the following lines by device is printer if condition. [begin]
  *B602236,1 Report print on printer when user choice is to print on File. [begin]
  IF gcDevice = "PRINTER"
    _PDSETUP = lcPDSetup
  ENDIF  
  *B602236,1 Report print on printer when user choice is to print on File. [end  ]
  *-- MAB Surround the following lines by device is printer if condition. [end ]
  
ENDIF
ON ERROR &lcOnErr
SET SAFE &lcSetSafe    

*-- MAB Surround the following lines by device is printer if else conditions. [begin]
*B602236,1 Report print on printer when user choice is to print on File. [begin]
IF gcDevice = "PRINTER"
  ERASE (gcOutFile)

ELSE  && B602236,1 else if device is File relase file from printer port (i.e. user can read it)
  SET PRINTER TO
ENDIF
*B602236,1 Report print on printer when user choice is to print on File. [end ]
*-- MAB Surround the following lines by device is printer if condition. [end]

*!*************************************************************
*! Name      : lfSetEscSeq
*! Developer : Hesham Al-Sheltawi
*! Date      : 08/10/1998
*! Purpose   : Adds Escape Sequence the output file
*!*************************************************************
*! Calls     : gftempName
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Returns   :  None
*!*************************************************************
*! Example   :  =lfSetEscSeq()
*!*************************************************************
*B603034,1 Fix problems encountered when printing under Window NT
FUNCTION lfSetEscSeq
PRIVATE lcTempFile

lcHeadSet = SET('HEADING')
lcConsSet = SET('CONS')
llWrapStat = _WRAP
lnRMargin = _RMARGIN
lnLMargin = _LMARGIN
lcAdvance = _PADVANCE

_WRAP = .F.
_RMARGIN  = IIF(R_Width='XW',240,IIF(R_Width='W',132,80))      
_LMARGIN = 0
_PADVANCE = 'LINEFEED'
SET HEADING OFF
SET CONS OFF

lcTempFile = gcWorkDir+gfTempName()+'.TXT'
SET PRINTER TO (lcTempFile)
SET PRINTER ON
IF _PEJECT = "NONE"
  _PADVANCE = 'LINEFEED'
ELSE
  _PADVANCE = 'FORMFEED'
  IF INLIST(_PEJECT ,"BEFORE",'BOTH')
    EJECT
  ENDIF  
ENDIF  


*IF "NT" $ GETENV('OS') AND TYPE('_pdparms[3]')='C'
*   SET DEVICE TO PRINTER
*   lcCompType = ""
*   IF TYPE('glPrtAcomp')='L' AND glPrtAcomp=.T. AND TYPE('gnPrint_Wd')='N' AND _RMARGIN>gnPrint_Wd
*     lcCompType = ALLTRIM(gc16CPInch)
*   ELSE  		
*     lcCompType = IIF(TYPE("_pdparms[8]")='C',_pdparms[8],"")
*   ENDIF
*   @0,0 SAY ALLT(_pdparms[3])+lcCompType
*   SET PRINTER TO
*   SET PRINTER TO (lcTempFile) ADDI
*   SET PRINTER ON
*   *B603034,1 Hesham (Start)  
*   _PDSETUP = ""    
*  *B603034,1 Hesham (End)
   
*ENDIF
PRINTJOB
  TYPE (gcOutFile) TO PRINTER
ENDPRINTJOB  
ERASE (gcOutFile)

*IF "NT" $ GETENV('OS') AND TYPE('_pdparms[3]')='C'
*   SET PRINTER TO
*   SET PRINTER OFF   
*ENDIF
SET PRINTER OFF
SET PRINTER TO
gcOutFile = lcTempFile
SET HEADING &lcHeadSet.
SET CONS    &lcConsSet.
_WRAP     = llWrapStat 
_RMARGIN  = lnRMargin 
_LMARGIN  = lnLMargin 
_PADVANCE = lcAdvance 


*!*************************************************************
*! Name      : gfSheetItem
*! Developer : Wael Aly Mohamed
*! Date      : 01/01/1996
*! Purpose   : Generate, Modify or Delete cost sheet items for style
*!*************************************************************
*! Calls     : gfGetMemVar,gfModalGen,gfItemMask,gpAdStyWar,gpAdFabWar,lfSelDyelot
*!*************************************************************
*! Parameters: lcTranType : Transaction type   ('M'-'I'-'T')
*!             lcTicketNo : Ticket number
*!             lcLinkCode : WIP Link code
*!             lcItem     : Style/Fabric
*!             lcColor    : Color
*!             lnLineNo   : Ticket line number
*!             lcDyelot   : Dyelot
*!             lcStyWare  : Default Style Issue Warehouse
*!             lcMatWare  : Default Fabric Issue Warehouse
*!             laQty      : Quantity array
*!             lcTmpBom   : Style Cost Sheet file name
*!             lcTktSheet : Cost sheet header file name
*!             lcDetFile  : Cost sheet detailed file name
*!             lcOprHdr   : Operation header file name
*!             lcLastOpr  : Last Operation
*!             lnPrice    : Purchase Price
*!             lnEst1     : Estimated cost 1
*!             lnEst2     : Estimated cost 2
*!             lnEst3     : Estimated cost 3
*!             lnEst4     : Estimated cost 4
*!             lnEst5     : Estimated cost 5
*!             lcTmpName  : Temp name needed to arrange new fabric dyelots
*!             llBackOnly : If .T. update all records in background.
*!*************************************************************
*! Returns   :  None
*!*************************************************************
*! Example   :  =gfSheetItem('M','000001','DEFDEF','ITEMD001','',0,'Dyelot',;
*!                           'WARE1',@laQty,100,'BOM','CTKTBOM','BOMLINE',;
*!                           'MFGOPRHD','000001',0,0,0,0,0)
*!:************************************************************************
*!
*!B602179,1 AMM 11/25/98 Erase temporary files at the end of before returning
*!B602124,1 WAM 11/26/98 Update Cost item dyelot in the BOMLINE file
*!*************************************************************

*B606496,1 AMH Rename the function [Start]
*FUNCTION gfSheetItem
FUNCTION XgfSheetItem
*B606496,1 AMH [End]

*E300935,4 MAB
*E300935,4 add new parameter to update bomline,fabdye,stydye, and dye_rel in background.
*PARAMETERS lcTranType,lcTicketNo,lcLinkCode,lcItem,lcColor,lnLineNo,lcDyelot,;
           lcStyWare,lcMatWare,laQty,lcTmpSheet,lcTktSheet,lcDetFile,lcOprHdr,;
           lcLastOpr,lnPrice,lnEst1,lnEst2,lnEst3,lnEst4,lnEst5,lcTmpName

PARAMETERS lcTranType,lcTicketNo,lcLinkCode,lcItem,lcColor,lnLineNo,lcDyelot,;
           lcStyWare,lcMatWare,laQty,lcTmpSheet,lcTktSheet,lcDetFile,lcOprHdr,;
           lcLastOpr,lnPrice,lnEst1,lnEst2,lnEst3,lnEst4,lnEst5,lcTmpName,llBackOnly
*E300935,4 MAB
PRIVATE    lcMjrMsk,lcMjrHdr,lcNMjrMsk,laItemSeg,lcClrMsk,lnClrPos,lcItemFile,;
           llDyelot,lcScale,lcItemType,lnTranQty,lcSizes,lnCount,lcCstClr,lnUnitPri,;
           lcCstItm,llContinue,laMfgRFld,lnLastSeq,lnSizePos,lcTmpBomSh,laReq,;
           lcContCode,lcContName,lcOperSeq,llInHouse,llMfgOpr,lnLeadTime
*B605741,1 KHM 03/27/2002 (Begin) Adding a new variable to hold the unit qty.
*PRIVATE    lcMfgGlAcnt,lcExSign,lcUntSin,lnAlias,lcPriceCur,lnPriceRate,;
           lnPriceUnit,lcDutyCur,lnDutyRate,lnDutyUnit

*B606216,1 KHM 07/07/2002 (Begin) Adding a new variable to hold the transaction's status.
*PRIVATE    lcMfgGlAcnt,lcExSign,lcUntSin,lnAlias,lcPriceCur,lnPriceRate,;
           lnPriceUnit,lcDutyCur,lnDutyRate,lnDutyUnit, lnUntQty

PRIVATE    lcMfgGlAcnt,lcExSign,lcUntSin,lnAlias,lcPriceCur,lnPriceRate,;
           lnPriceUnit,lcDutyCur,lnDutyRate,lnDutyUnit
*B606216,1 KHM 07/07/2002 (End)

*B605741,1 KHM 03/27/2002 (End)


*C200080,1 AMM (Start) set new variable to fit the case of dye order (lcTranType='D')
PRIVATE lcTranLett
lcTranLett = IIF(lcTranType $ "IMT",lcTranType ,"I")
*C200080,1 AMM End
STORE 1   TO lnPriceRate,lnPriceUnit,lnDutyRate,lnDutyUnit
STORE '/' TO lcExSign,lcUntSin
IF lcTranType = 'I' 
  =SEEK('P'+lcTicketNo,'POSHDR')
  lcPriceCur  = IIF(EMPTY(POSHDR.cPriceCur),gcBaseCurr,POSHDR.cPriceCur)
  lnPriceRate = IIF(POSHDR.nPriceRat=0,1,POSHDR.nPriceRat)
  lnPriceUnit = IIF(POSHDR.nCurrUnit=0,1,POSHDR.nCurrUnit)
  lcDutyCur   = IIF(EMPTY(POSHDR.cDutyCur),gcBaseCurr,POSHDR.cDutyCur)
  lnDutyRate  = IIF(POSHDR.nDutyRat=0,1,POSHDR.nDutyRat)
  lnDutyUnit  = IIF(POSHDR.nDCurUnit=0,1,POSHDR.nDCurUnit)
ENDIF
STORE ''  TO M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC
=gfGetMemVar('M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC',gcAct_Comp)
lcMjrMsk  = gfItemMask("PM")
lcMjrHdr  = gfItemMask("HM")
lcNMjrMsk = gfItemMask("PN")
lcItmMsk  = gfItemMask("PI")
=gfOpenFile(gcDataDir+'BOM',gcDataDir+'BOM','SH')
IF !SEEK(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),lcTmpSheet)
  *E300725,1 Message : 38031
  *E300725,1 Cost sheet not found for style: xxx cannot generate cutting 
  *E300725,1 ticket cost sheet
  *E300725,1 Button : 00000
  *E300725,1 Ok
  =gfModalGen('TRM38031B00000','ALERT',IIF(lcTranType='T','Fabric: ',lcMjrHdr+':')+;
              ALLTRIM(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))))+;
              '|'+IIF(lcTranType='M','cutting ticket',IIF(lcTranType='I','purchase order','order')))
  RETURN(.F.)
ENDIF
lnAlias = SELECT()
DECLARE laMfgRFld[7,2],laItemSeg[1],laReq[8]
STORE '' TO lcContCode,lcContName,lcOperSeq,llInHouse,llMfgOpr,lnLeadTime,lcMfgGlAcnt
laMfgRFld[1,1] = 'CCONTCODE'
laMfgRFld[1,2] = 'lcContCode'
laMfgRFld[2,1] = 'CCONTNAME'
laMfgRFld[2,2] = 'lcContName'
laMfgRFld[3,1] = 'COPERSEQ'
laMfgRFld[3,2] = 'lcOperSeq'
laMfgRFld[4,1] = 'LINHOUSE'
laMfgRFld[4,2] = 'llInHouse'
laMfgRFld[5,1] = 'LMFGOPR'
laMfgRFld[5,2] = 'llMfgOpr'
laMfgRFld[6,1] = 'LEADTIME'
laMfgRFld[6,2] = 'lnLeadTime'
laMfgRFld[7,1] = 'GLACCOUNT'
laMfgRFld[7,2] = 'lcMfgGlAcnt'

=gfItemMask(@laItemSeg)
FOR lnCount = 1 TO ALEN(laItemSeg,1)
  IF laItemSeg[lnCount,1]='C'
    lcClrMsk = laItemSeg[lnCount,3]
    lnClrPos = laItemSeg[lnCount,4]
  ENDIF
  IF laItemSeg[lnCount,1]='S'
    lnSizePos = laItemSeg[lnCount,4]
  ENDIF
ENDFOR
lnLastSeq = 0
IF !EMPTY(lcLastOpr)
  =gfRltFld(lcLastOpr,@laMfgRFld,'MFGCODE')
  lnLastSeq = VAL(LEFT(lcOperSeq,2))
ENDIF
STORE 0 TO lnEst1,lnEst2,lnEst3,lnEst4,lnEst5,lnFEst1,lnFEst2,lnFEst3,lnFEst4,lnFEst5
lcItemFile = IIF(lcTranType='T','Fabric','Style')
llDyelot   = SEEK(lcItem+ALLTRIM(lcColor),lcItemFile) .AND. &lcItemFile..cDye_Flg='Y'
lcScale    = IIF(lcTranType='T','',Style.Scale)
llContinue = .T. 

=gfOpenFile(gcDataDir+'Ctktbom',gcDataDir+'Ctktbom','SH')
=gfOpenFile(gcDataDir+'BomLine',gcDataDir+'BomLine','SH')
=gfOpenFile(gcDataDir+'MFGOPRHD',gcDataDir+'MFGOPRHD','SH')

SET ORDER TO TAG Ctktbom  IN (lcTktSheet)
SET ORDER TO TAG BomLine  IN (lcDetFile)
SET ORDER TO TAG MFGOPRHD IN (lcOprHdr)

lcTmpBomSh = gfTempName()
SELECT BOM
=AFIELDS(laFileStru)
CREATE TABLE (gcWorkDir+lcTmpBomSh) FROM ARRAY laFileStru
*E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
=lfCrFox2x()
*E303074,1 TMI 02/20/2012 [End  ] 
INDEX ON typ+item+iclr+citmmajor+citmmask TAG (lcTmpBomSh)
SELECT (lcTmpSheet)
=SEEK(PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19))
SCAN REST WHILE cItmMajor = PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19)
  SCATTER MEMVAR MEMO
  IF cCatGTyp='S' .AND. M_USEEXSSC .AND. !EMPTY(MSZCROSREF) .AND. ;
     SUBSTR(ALLTRIM(Item),lnSizePos) = STRTRAN(SUBSTR(lcItmMsk,lnSizePos),'X','*')
    FOR lnCount = 1 TO MEMLINES(MSZCROSREF)
      lcLine = MLINE(MSZCROSREF,lnCount)
      IF SUBSTR(lcLine,1,3) <> lcScale
        LOOP
      ENDIF
      m.Item = PADR(SUBSTR(m.Item,1,lnSizePos-1)+SUBSTR(lcLine,AT('~',lcLine)+1,3),19)
      IF !SEEK(m.typ+m.item+m.iclr+m.citmmajor+m.citmmask,lcTmpBomSh)
        INSERT INTO (lcTmpBomSh) FROM MEMVAR
      ENDIF
    ENDFOR
  ELSE
    INSERT INTO (lcTmpBomSh) FROM MEMVAR
  ENDIF
ENDSCAN

*-- HDM E301234,4 [Start] Check if we are updating cost sheet for MMO style file not used
*SELECT STYLE
*lcStyFIlt = SET('FILTER')
*SET FILTER TO

IF USED('STYLE')
  SELECT STYLE
  lcStyFIlt = SET('FILTER')
  SET FILTER TO
ENDIF
*-- HDM E301234,4 [End]
lcGrade = ''
*C200080,1 AMM Adjust to fit the new type 'D' for dye order
*IF lcTranType $ 'IM'
IF lcTranType <> 'T'
*C200080,1 AMM end
  =SEEK(lcItem,'Style')
  lcGrade = Style.cStyGrade
ELSE
  =SEEK(lcItem+lcColor,'Fabric')
  lcGrade = Fabric.cFabGrade
ENDIF

*B602951,1 Added to update the temp P/O cost sheet (lcTmpBomSh) file.
*C200098,1 Added case of Dye Order.
*IF lcTranType = 'I'
IF lcTranType = 'I' OR lcTranType = 'D'
*C200098,1 End.
  *--Update Bom cost elements depend on cost in P/O.
  =lfUpdPOBom() 
ENDIF
*B602951,1 End.

*-- MAN Add Flag to check if the message already appeares dont display it again.
llMsgDispd = .F.

SELECT (lcTmpBomSh)
SCAN
  *--MAN Added IF EMPTY(cCatGTyp) .OR. EMPTY(Typ)
  IF EMPTY(cCatGTyp) .OR. EMPTY(Typ)
    IF !llMsgDispd
      *--One or more cost items does not have a proper cost tyoe.
      *--Message : 38171
      =gfModalgen("INM38171B00000","ALERT",cItmMask)
      llMsgDispd = .T.
    ENDIF
    LOOP
  ENDIF
  
*MAN  
*  IF !LIKE(STRTRAN(cItmMask,'*','?'),IIF(lcTranType='T',lcColor,lcItem)) .OR. ;
     (!EMPTY(MSIZES) .AND. ATCLINE(lcScale+'~',MSIZES)=0) .OR. ;
     (!EMPTY(MSZCROSREF) .AND. ATCLINE(lcScale+',',MSZCROSREF)=0)
  IF !LIKE(STRTRAN(IIF(lcTranType='T',LEFT(cItmMask,6),cItmMask),'*','?'),IIF(lcTranType='T',lcColor,lcItem)) .OR. ;
     (!EMPTY(MSIZES) .AND. ATCLINE(lcScale+'~',MSIZES)=0) .OR. ;
     (!EMPTY(MSZCROSREF) .AND. ATCLINE(lcScale+',',MSZCROSREF)=0)     
    LOOP
  ENDIF
  lcItemType = Typ
  IF EMPTY(MSIZES)
    lnTranQty = laQty[9]
    lcSizes   = '1,2,3,4,5,6,7,8'
  ELSE
    lcSizes = SUBSTR(MLINE(MSIZES,ATCLINE(lcScale+'~',MSIZES)),5)
    lnTranQty = 0
    FOR lnCount = 1 TO 8
      lnTranQty = lnTranQty + IIF(STR(lnCount,1) $ lcSizes,laQty[lnCount],0)
    ENDFOR
  ENDIF
  STORE '' TO lcCstClr,lcCstItm,lcCmSizes
  lcCstItmDye = SPACE(10)
  DO CASE
    CASE cCatGTyp='S'
      lcCmSizes='12345678'
      FOR lnCount = 1 TO 8
        laReq[lnCount]=laQty[lnCount]
      ENDFOR
      lcCstItm=''
      FOR lnCount = 1 TO LEN(ITEM)
        IF SUBSTR(ITEM,lnCount,1)='*'
          lcCstItm = lcCstItm + SUBSTR(lcItem,lnCount,1)
        ELSE
          lcCstItm = lcCstItm + SUBSTR(ITEM,lnCount,1)
        ENDIF
      ENDFOR
      IF !SEEK(lcCstItm,'Style')
        LOOP
      ENDIF
      lcCsItmSc = Style.Scale
      =SEEK(lcItem,'Style')
      IF !EMPTY(MSZCROSREF)
        lcCmSizes = ''
        STORE 0 TO laReq
        FOR lnCount = 1 TO MEMLINES(MSZCROSREF)
          lcLine = MLINE(MSZCROSREF,lnCount)
          IF SUBSTR(lcLine,1,3) = lcScale .AND. SUBSTR(lcLine,7,3)=lcCsItmSc
            laReq[VAL(SUBSTR(lcLine,11,1))] = laReq[VAL(SUBSTR(lcLine,11,1))]+;
            laQty[VAL(SUBSTR(lcLine,5,1))]
            lcCmSizes = lcCmSizes + SUBSTR(lcLine,11,1)
          ENDIF
        ENDFOR
      ENDIF
      IF M_WAREHOUSE='Y' .AND. !EMPTY(lcStyWare) .AND. ;
         !SEEK(lcCstItm+lcStyWare+SPACE(10),'STYDYE')
        *E300725,1 Message : 38029
        *E300725,1 Style xxxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        
        *E300935,4 adjust condition to update without message if llBackOnly is .T.
        *E300935,4 IF gfModalGen('QRM38029B38001','ALERT','Style: '+ALLTRIM(lcCstItm)+'|'+lcStyWare) = 1
        IF llBackOnly OR gfModalGen('QRM38029B38001','ALERT','Style: '+ALLTRIM(lcCstItm)+'|'+lcStyWare) = 1
          DO gpAdStyWar WITH lcCstItm,SPACE(10),lcStyWare
        ENDIF   
      
      ENDIF
      IF !EMPTY(lcStyWare) AND M_DYELOT='Y' .AND. SEEK(lcCstItm,'Style') .AND. Style.cDye_Flg='Y'

        *!B602124,1 Update Cost item dyelot in the BOMLINE file
        *lcCstItmDye = lcDyelot
        SELECT (lcDetFile)
        *C200080,1 AMM Adjust to fit the new type 'D' for dye order
        *=SEEK(lcTranType+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        *LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranType+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')

        =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')
        *C200080,1 AMM End

        lcCstItmDye = IIF(FOUND(),&lcDetFile..Dyelot,lcDyelot)
        *!B602124,1 (End)

        
        IF SEEK(lcCstItm+lcStyWare+SPACE(10),'STYDYE') AND ;
          (EMPTY(lcCstItmDye) OR !SEEK(lcCstItm+lcStyWare+lcCstItmDye,'StyDye'))
          *E300935,4 Adjust calling with background parameter (llBackOnly)
          *E300935,4 =gfSelDyelot(lcTranType,'S',lcItem,lcColor,lcStyWare,@lcCstItmDye,lcCstItm)
          =gfSelDyelot(lcTranType,'S',lcItem,lcColor,lcStyWare,@lcCstItmDye,lcCstItm,'','',llBackOnly)
        ENDIF
      ENDIF

    CASE INLIST(cCatGTyp,'F','T')
      lcCstItm = SUBSTR(Item,1,7)
      IF IClr = '******'
        lcCstClr = IIF(lcTranType='T',lcColor,SUBSTR(lcItem,lnClrPos,LEN(lcClrMsk)))
      ELSE
        lcCstClr = IClr
      ENDIF
      IF (cCatGTyp='F' OR Trim_Invt) AND !SEEK(lcCstItm+lcCstClr,'FABRIC')
        LOOP
      ENDIF
      IF (cCatGTyp='F' .OR. Trim_Invt) .AND. M_WAREHOUSE='Y' .AND. ;
         !EMPTY(lcMatWare) .AND. ;
         !SEEK(lcCstItm+lcCstClr+lcMatWare+SPACE(10),'FABDYE')
        *E300725,1 Message : 38029
        *E300725,1 Item/Color xxxxx/xxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        
        *E300935,4 adjust condition to update without message if llBackOnly is .T.
        *E300935,4 IF gfModalGen('QRM38029B38001','ALERT','Item/Color: '+ALLTRIM(lcCstItm)+'/'+ALLTRIM(lcCstClr)+'|'+lcMatWare) = 1
        IF llBackOnly OR gfModalGen('QRM38029B38001','ALERT','Item/Color: '+ALLTRIM(lcCstItm)+'/'+ALLTRIM(lcCstClr)+'|'+lcMatWare) = 1
          DO gpAdFabWar WITH lcCstItm,lcCstClr,SPACE(10),lcMatWare
        ENDIF   
      ENDIF
      IF !EMPTY(lcMatWare) AND (cCatGTyp='F' OR Trim_Invt) AND M_MATDYE='Y' AND ;
         SEEK(lcCstItm+lcCstClr,'Fabric') .AND. Fabric.cDye_Flg='Y' 

        *!B602124,1 Update Cost item dyelot in the BOMLINE file
        *lcCstItmDye = lcDyelot
        SELECT (lcDetFile)
        *C200080,1 AMM Adjust to fit the new type 'D' for dye order
        *=SEEK(lcTranType+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        *LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranType+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')

        =SEEK(lcTranLett +'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranLett +'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')
        *C200080,1 AMM End

        lcCstItmDye = IIF(FOUND(),&lcDetFile..Dyelot,lcDyelot)
        *!B602124,1 (End)



        IF SEEK(lcCstItm+lcCstClr+lcMatWare+SPACE(10),'FABDYE') AND ;
          (EMPTY(lcCstItmDye) OR !SEEK(lcCstItm+lcCstClr+lcMatWare+lcCstItmDye,'FabDye'))
         
          *E300935,4 Adjust calling with background parameter (llBackOnly)
          *E300935,4 =gfSelDyelot(lcTranType,'F',lcItem,lcColor,lcMatWare,@lcCstItmDye,lcCstItm,lcCstClr,lcTmpName)
          =gfSelDyelot(lcTranType,'F',lcItem,lcColor,lcMatWare,@lcCstItmDye,lcCstItm,lcCstClr,lcTmpName,llBackOnly)
        ENDIF
      ENDIF
    CASE cCatGTyp='M'
      =gfRltFld(&lcTmpBomSh..MfgCode,@laMfgRFld,'MFGCODE')
      *C200080,1 AMM Adjust to fit the new type 'D' for dye order
      *IF llMfgOpr .AND. !SEEK(lcTranType+lcTicketNo+&lcTmpBomSh..MfgCode,lcOprHdr)
      IF llMfgOpr .AND. !SEEK(lcTranLett+lcTicketNo+&lcTmpBomSh..MfgCode,lcOprHdr)
      *C200080,1 AMM End
        lcOperSeq = LEFT(lcOperSeq,2)
        IF VAL(lcOperSeq) > lnLastSeq
          lnLastSeq = VAL(lcOperSeq)
          lcLastOpr = &lcTmpBomSh..MfgCode
        ENDIF
        *C200080,1 AMM Adjust to fit the new type 'D' for dye order
        *INSERT INTO (lcOprHdr) (cIMTYp,cTktNo,cOprCode,cOperSeq,cContCode,cContName,lInHouse,nNxtLotNo);
        VALUES (lcTranType,lcTicketNo,&lcTmpBomSh..MfgCode,lcOperSeq,lcContCode,lcContName,llInHouse,1)
        INSERT INTO (lcOprHdr) (cIMTYp,cTktNo,cOprCode,cOperSeq,cContCode,cContName,lInHouse,nNxtLotNo);
        VALUES (lcTranLett,lcTicketNo,&lcTmpBomSh..MfgCode,lcOperSeq,lcContCode,lcContName,llInHouse,1)
        *C200080,1 AMM End
      ENDIF
      IF lcTranType = 'I'
        lcExSign = gfGetExSin(@lcUntSin,lcDutyCur)
      ENDIF  
    CASE cCatGTyp='P'
      lcExSign = gfGetExSin(@lcUntSin,lcPriceCur)
    CASE !INLIST(cCatGTyp,'S','F','T') AND lcTranType = 'I'
      lcExSign = gfGetExSin(@lcUntSin,lcDutyCur)
  ENDCASE
  SELECT (lcTktSheet)
  *C200080,1 AMM Start Changed lcTranType to lcTranLett in the seek and replace
  *IF !SEEK(lcTranType+lcTicketNo+&lcTmpBomSh..Typ+PADR(lcCstItm,19)+;
     PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode+lcCstItmDye)
  IF !SEEK(lcTranLett+lcTicketNo+&lcTmpBomSh..Typ+PADR(lcCstItm,19)+;
     PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode+lcCstItmDye)
    APPEND BLANK
    REPLACE CutTkt    WITH lcTicketNo    ,;
            cIMTyp    WITH lcTranLett    ,;
            cCatGTyp  WITH &lcTmpBomSh..cCatGTyp  ,;
            TRIM_INVT WITH &lcTmpBomSh..TRIM_INVT ,;
            cWareCode WITH IIF(cCatGTyp='S',lcStyWare,IIF(cCatGTyp='F' OR ;
                           (cCatGTyp='T' AND TRIM_INVT),lcMatWare,'')) ,;
            Link_Code WITH lcLinkCode            ,;
            cOprCode  WITH &lcTmpBomSh..cOprCode ,;
            TYP       WITH &lcTmpBomSh..Typ      ,;
            ITEM      WITH lcCstItm              ,;
            ICLR      WITH lcCstClr              ,;
            MfgCode   WITH &lcTmpBomSh..MfgCode  ,;
            cOprCode  WITH &lcTmpBomSh..cOprCode ,;
            DESC      WITH &lcTmpBomSh..Desc     ,;
            Dyelot    WITH lcCstItmDye           ,;
            UOM       WITH &lcTmpBomSh..UOM      ,;
            DATE      WITH gdSysDate             ,;
            WIDTH     WITH IIF(cCatGTyp='F' OR (cCatGTyp='T' AND TRIM_INVT),FABRIC.WIDTH,'') 
    *B604623,1 AMH Update marker field for C/T cost sheet [Start]
    IF lcTranType = 'M'
      REPLACE CMARKER WITH &lcTmpBomSh..cMarker
    ENDIF
    *B604623,1 AMH [End]
    
    *B608125,1 TMI [Start] Refresh the relation
    GO RECNO()
    *B608125,1 TMI [End  ] 
    
  ENDIF

  *B604974,1 KHM 09/30/2001 (Begin) Using the Unit Qty from the CTKTBOM file
  *B604974,1                instead of BOM file.  
  *REPLACE Pieces  WITH Pieces  + lnTranQty ,;
          Req_Qty WITH Req_Qty + lnTranQty*&lcTmpBomSh..nBomTotQty ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)

  *B605741,1 KHM 03/27/2002 (Begin) Check if the PO/CT cost sheet has not
  *B605741,1                been created then get the unit qty from the BOM 
  *B605741,1                file. Otherwise get the unit qty from BOMLINE file
  *REPLACE Pieces  WITH Pieces  + lnTranQty ,;
          Req_Qty WITH Req_Qty + lnTranQty*IIF(UntQty = 0,&lcTmpBomSh..nBomTotQty,UntQty) ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)
  SELECT (lcDetFile)
  =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
  LOCATE REST WHILE ;
  cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
  lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
  PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
  FOR cSizes = STRTRAN(lcSizes,',','')
  llFoundRec = FOUND()         
  SELECT (lcTktSheet)
  IF !llFoundRec
    REPLACE Pieces  WITH Pieces  + lnTranQty ,;
          Req_Qty WITH Req_Qty + lnTranQty * &lcTmpBomSh..nBomTotQty ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)
    lnUntQty = &lcTmpBomSh..nBomTotQty
  ELSE
    
    *B606216,1 KHM 07/07/2002 (Begin) Getting the unit quantity from the style cost sheet
    *B606216,1                in case of status is "Hold".
    *REPLACE Pieces  WITH Pieces  + lnTranQty ,;
          Req_Qty WITH Req_Qty + lnTranQty * &lcDetFile..UnitQty ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)
    *lnUntQty = &lcDetFile..UnitQty

    REPLACE Pieces  WITH Pieces  + lnTranQty ,;
          Req_Qty WITH Req_Qty + lnTranQty * IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,&lcDetFile..UnitQty) ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)
          
    lnUntQty = IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,&lcDetFile..UnitQty)
    *B606216,1 KHM 07/07/2002 (End)
    
  ENDIF
  *B605741,1 KHM 03/27/2002 (End)

  *B604974,1 KHM 09/30/2001 (End)
  
  *B603007,1 Start.
  *--If tranQty was zero take it from pieces.
  *--to make sure that the cost was updated.
  *--Read lnTotCost and lnFTotCost depend on lnTTranQty insted of lnTranQty.
  lnTTranQty = lnTranQty
  IF lnTranQty = 0
    lnTTranQty = Pieces
  ENDIF 
  DO CASE
    CASE cCatGTyp = 'P'
      lnTotCost  = lnPrice * lnTTranQty &lcExSign lnPriceRate &lcUntSin lnPriceUnit
      lnFTotCost = lnPrice * lnTTranQty 
    CASE &lcTmpBomSh..nPercent > 0
      lnTotCost  = lnPrice*lnTTranQty*(&lcTmpBomSh..nPercent/100) &lcExSign lnPriceRate &lcUntSin lnPriceUnit
      lnFTotCost = lnPrice*lnTTranQty*(&lcTmpBomSh..nPercent/100)
    CASE cCatGTyp = 'S'

      *B604974,1 KHM 09/30/2001 (Begin) Using the Unit Qty from the CTKTBOM
      *B604974,1                file instead of BOM file.            
      *lnTotCost  = Style.TotCost * lnTTranQty * &lcTmpBomSh..nBomTotQty
      lnTotCost  = Style.TotCost * lnTTranQty * &lcTktSheet..UntQty        
      *B604974,1 KHM 09/30/2001 (End)
      
      lnFTotCost = lnTotCost
    CASE cCatGTyp = 'F' OR (cCatGTyp='T' AND TRIM_INVT)

      *B604974,1 KHM 09/30/2001 (Begin) Using the Unit Qty from the CTKTBOM
      *B604974,1                file instead of BOM file.      
      *lnTotCost  = Fabric.CostBuy/Fabric.Conv * lnTTranQty * &lcTmpBomSh..nBomTotQty
      
      *B605741,1 KHM 03/27/2002 (Begin) Changing &lcTktSheet..UntQty to lnUntQty.
      *lnTotCost  = Fabric.CostBuy/Fabric.Conv * lnTTranQty * &lcTktSheet..UntQty
      lnTotCost  = Fabric.CostBuy/Fabric.Conv * lnTTranQty * lnUntQty      
      *B604974,1 KHM 09/30/2001 (End)
      
      lnFTotCost = lnTotCost
    OTHERWISE
      lnTotCost  = &lcTmpBomSh..TotCost * lnTTranQty &lcExSign lnDutyRate &lcUntSin lnDutyUnit
      lnFTotCost = &lcTmpBomSh..TotCost * lnTTranQty
  ENDCASE
  *REPLACE Est_Cost WITH Est_Cost + lnTotCost,;
          UntCost  WITH IIF(Req_Qty<>0,Est_Cost/Req_Qty,0)
  IF lnTranQty=0
    REPLACE Est_Cost WITH lnTotCost
  ELSE
    REPLACE Est_Cost WITH Est_Cost + lnTotCost
  ENDIF
  REPLACE UntCost  WITH IIF(Req_Qty<>0,Est_Cost/Req_Qty,0)
  *B603007,1 End.

  lnEst&lcItemType = lnEst&lcItemType  + lnTotCost
  lnFEst&lcItemType= lnFEst&lcItemType + lnFTotCost
  IF &lcTmpBomSh..cCatGTyp = 'S'
    FOR lnCount = 1 TO 8
      lcCount = STR(lnCount,1)

      *B604974,1 KHM 09/30/2001 (Begin) Using the Unit Qty from the CTKTBOM
      *B604974,1                file instead of BOM file.      
      *REPLACE REQ_QTY&lcCount WITH REQ_QTY&lcCount+laReq[lnCount]*&lcTmpBomSh..nBomTotQty
      REPLACE REQ_QTY&lcCount WITH REQ_QTY&lcCount+laReq[lnCount]*&lcTktSheet..UntQty
      *B604974,1 KHM 09/30/2001 (End)      
      
    ENDFOR
  ENDIF
  *B602658,4 [BEGIN] Replace fields ADD_DATE , ADD_TIME , ADD_USERID 
  *                  and its values with calling gfAdd_Info('<File Name>')

  *REPLACE cCompSizes WITH lcCmSizes ,;
          ADD_DATE   WITH gdSysDate ,;
          ADD_TIME   WITH TIME()    ,;
          ADD_USERID WITH gcUSer_Id
  REPLACE cCompSizes WITH lcCmSizes 
  =gfAdd_Info(lcTktSheet)
  
  *B602658,4 [END..] Replace fields ADD_DATE , ADD_TIME , ADD_USERID 
  *                  and its values with calling gfAdd_Info('<File Name>')

  IF Pieces = 0 AND !llBackOnly
    DELETE
  ENDIF
  SELECT (lcTmpBomSh)
  DO CASE
    CASE &lcTmpBomSh..CCATGTYP = 'P'
      lnUnitPri = lnPrice
    CASE INLIST(&lcTmpBomSh..CCATGTYP,'M','D')

      *B604151,1 KHM 01/28/2001 Change the calculation of the duty.
      *lnUnitPri = &lcTmpBomSh..UntCost
      IF &lcTmpBomSh..nPercent > 0
        lnUnitPri  = lnPrice*(&lcTmpBomSh..nPercent/100)
      ELSE
        lnUnitPri = &lcTmpBomSh..UntCost
      ENDIF  
      *B604151,1 KHM 01/28/2001 (End)

    CASE INLIST(&lcTmpBomSh..CCATGTYP,'F','T') .AND. SEEK(SUBSTR(lcCstItm,1,7)+lcCstClr,'Fabric')
      lnUnitPri = Fabric.CostBuy/Fabric.Conv
    OTHERWISE
      lnUnitPri = &lcTktSheet..UntCost
  ENDCASE
  SELECT (lcDetFile)
  *C200080,1 AMM Changed lcTranType to lcTranLett in the seek, locate and replace
  =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
  LOCATE REST WHILE ;
  cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
  lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
  PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
  FOR cSizes = STRTRAN(lcSizes,',','')
  IF !FOUND()         
    *!B602124,1 Update Cost item dyelot in the BOMLINE file
    APPEND BLANK
    REPLACE cIMTyp     WITH lcTranLett     ,;
            cTktNo     WITH lcTicketNo     ,;
            LineNo     WITH lnLineNo       ,;
            cStyGrade  WITH lcGrade        ,;
            Style      WITH lcItem         ,;
            SClr       WITH lcColor        ,;
            cBomTyp    WITH &lcTmpBomSh..Typ,;
            cType      WITH '1'            ,;
            cCatGTyp   WITH &lcTmpBomSh..cCatGTyp   ,;
            cOprCode   WITH &lcTmpBomSh..cOprCode   ,;
            UnitQty    WITH &lcTmpBomSh..nBomTotQty ,;
            UnitCost   WITH lnUnitPri      ,;
            Item       WITH lcCstItm       ,;
            IClr       WITH lcCstClr       ,;
            MfgCode    WITH &lcTmpBomSh..MfgCode    ,;
            Dyelot     WITH lcCstItmDye ,;
            cSizes     WITH STRTRAN(lcSizes,',','') ,;
            cCompSizes WITH lcCmSizes

    *B604294,1 KHM 04/30/2001 (Begin) Adding the replacement of the cCostStae
    *B604294,1                in order to know the dutable cost elements 
    *B604294,1                and npercent to know the percentage of the duty.    
    REPLACE cCostStat WITH &lcTmpBomSh..cCostStat,;
            nPercent   WITH &lcTmpBomSh..nPercent
    *B604294,1 KHM 04/30/2001 (End)        

  ENDIF

  *B603007,1 Added case for lnTranQty=0 .
  IF lnTranQty = 0
    
    *B603361,1 MAN  12/23/1999 Fixed the bug of screwing up the the PO 
    *B603361,1 MAN             cost sheet yeild after modifing a PO line.
    *REPLACE ItemAmt  WITH ItemQty*&lcTmpBomSh..nBomTotQty*lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)
     REPLACE ItemAmt  WITH ItemQty*lnUnitPri ,;
             UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)            
  ELSE
  *B603007,1 End.

    *B604974,1 KHM 09/30/2001 (Begin) Using the uni qty from Bomline file
    *B604974,1                instead of BOM file.        
    *REPLACE StyQty   WITH StyQty  + lnTranQty ,;
            ItemQty  WITH ItemQty + lnTranQty*&lcTmpBomSh..nBomTotQty  ,;
            UnitQty  WITH IIF(StyQty=0,0,ItemQty/StyQty) ,;
            ItemAmt  WITH ItemAmt + lnTranQty*&lcTmpBomSh..nBomTotQty*lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)

    *B606216,1 KHM 07/07/2002 (Begin) Getting the unit quantity from the style cost sheet
    *B606216,1                in case of status is "Hold".
    *REPLACE StyQty   WITH StyQty  + lnTranQty ,;
            ItemQty  WITH ItemQty + lnTranQty*UnitQty  ,;
            UnitQty  WITH IIF(StyQty=0,0,ItemQty/StyQty) ,;
            ItemAmt  WITH ItemAmt + lnTranQty*UnitQty*lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)
    
    REPLACE StyQty   WITH StyQty  + lnTranQty ,;
            ItemQty  WITH ItemQty + lnTranQty* IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,UnitQty)  ,;
            UnitQty  WITH IIF(StyQty=0,0,ItemQty/StyQty) ,;
            ItemAmt  WITH ItemAmt + lnTranQty * IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,UnitQty) * lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)
    *B606216,1 KHM 07/07/2002 (End)
    
    *B604974,1 KHM 09/30/2001 (End)        

  ENDIF

  IF StyQty = 0 AND !llBackOnly
    DELETE
  ENDIF
ENDSCAN
IF llContinue
  DO CASE
    *B802507,1 AMM Update statuses other than 'O' as well
    *CASE lcTranType='M' .AND. SEEK(lcTicketNo,'CUTTKTH') .AND. CUTTKTH.Status='O'
    CASE lcTranType='M' .AND. SEEK(lcTicketNo,'CUTTKTH')  .AND. CUTTKTH.Status # 'H'
    *B802507,1 AMM end
      SELECT CUTTKTH
      =RLOCK()
      REPLACE CLASTOPR   WITH lcLastOpr ,;
              NEST_COST1 WITH NEST_COST1 + lnEst1 ,;
              NEST_COST2 WITH NEST_COST2 + lnEst2 ,;
              NEST_COST3 WITH NEST_COST3 + lnEst3 ,;
              NEST_COST4 WITH NEST_COST4 + lnEst4 ,;
              NEST_COST5 WITH NEST_COST5 + lnEst5
      UNLOCK
    *C200080,1 AMM  Adjust to fit the new type 'D' for dye order
    *CASE lcTranType='I' .AND. SEEK('P'+lcTicketNo,'POSHDR') .AND. POSHDR.Status='O'
    CASE lcTranType$'DI' .AND. SEEK(IIF(lcTranType='I','P','D')+lcTicketNo,'POSHDR') .AND. POSHDR.Status='O'
    *C200080,1 AMM end
      SELECT POSHDR
      =RLOCK()
      REPLACE CLASTOPR WITH lcLastOpr ,;
              NICOST1  WITH NICOST1 + lnEst1 ,;
              NICOST2  WITH NICOST2 + lnEst2 ,;
              NICOST3  WITH NICOST3 + lnEst3 ,;
              NICOST4  WITH NICOST4 + lnEst4 ,;
              NICOST5  WITH NICOST5 + lnEst5 ,;
              NFCOST1  WITH NFCOST1 + lnFEst1 ,;
              NFCOST2  WITH NFCOST2 + lnFEst2 ,;
              NFCOST3  WITH NFCOST3 + lnFEst3 ,;
              NFCOST4  WITH NFCOST4 + lnFEst4 ,;
              NFCOST5  WITH NFCOST5 + lnFEst5
      UNLOCK
    CASE lcTranType='T' .AND. SEEK(lcTicketNo,'MMFGORDH') .AND. MMFGORDH.Status='O'
      SELECT MMFGORDH
      =RLOCK()
      REPLACE CLASTOPR   WITH lcLastOpr ,;
              NEST_COST1 WITH NEST_COST1 + lnEst1 ,;
              NEST_COST2 WITH NEST_COST2 + lnEst2 ,;
              NEST_COST3 WITH NEST_COST3 + lnEst3 ,;
              NEST_COST4 WITH NEST_COST4 + lnEst4
      UNLOCK
  ENDCASE
ENDIF
*-- HDM E301234,4 [Start] Check if we are updating cost sheet for MMO style file not used
*SELECT STYLE
*SET FILTER TO &lcStyFIlt
IF USED('STYLE')
  SELECT STYLE
  SET FILTER TO &lcStyFIlt
ENDIF
*-- HDM E301234,4 [End]
USE IN (lcTmpBomSh)

*B602179,1 AMM 11/25/98 Erase temporary files 
ERASE (gcWorkDir+lcTmpBomSh+'.DBF')
ERASE (gcWorkDir+lcTmpBomSh+'.CDX')
ERASE (gcWorkDir+lcTmpBomSh+'.FPT')
*:B602179,1 AMM end

SELECT (lnAlias)
RETURN(llContinue)

*!*************************************************************
*! Name      : gfSelDyelot
*! Developer : Wael Aly Mohamed
*! Date      : 01/01/1996
*! Purpose   : Check ticket sheet item have dyelots
*!*************************************************************
*! Calls     : FDYEBROW,SDYEBROW
*!*************************************************************
*! Parameters: lcTranType : Transaction type   ('M'-'I'-'T')
*!             lcType     : 'F' Fabric / 'S' Style
*!             lcItem     : Ticket Item 
*!             lcColor    : Ticket Color
*!             lcWareCode : Warehouse
*!             lcDyelot   : Dyelot
*!             lcCstItem  : Cost sheet item
*!             lcCstItmClr: Cost sheet color
*!             lcTmpName  : Temp Name
*!             llBackOnly : Update files in background
*!*************************************************************
*! Returns   :  None
*!*************************************************************
*! Example   :  
*!*************************************************************
FUNCTION gfSelDyelot
*E300935,4
*E300935,4 Change parameters
*PARAMETER lcTranType,lcType,lcItem,lcColor,lcWareCode,lcDyelot,lcCstItem,;
          lcCstItmClr,lcTmpName
PARAMETER lcTranType,lcType,lcItem,lcColor,lcWareCode,lcDyelot,lcCstItem,;
          lcCstItmClr,lcTmpName,llBackOnly
          
*E300935,4 adjust condition to update without message if llBackOnly is .T.
          
PRIVATE lnAlias,lnSelect,lcMessage,lcMessage1,lcItmHdr

lnAlias = SELECT()
lcItmHdr= gfItemMask("HI")
STORE '' TO M_WAREHOUSE
=gfGetMemVar('M_WAREHOUSE',gcAct_Comp)

*E300935,4 [begin]
*E300935,4 adjust condition to update without message if llBackOnly is .T.
lnSelect = 1
IF !llBackOnly AND !EMPTY(lcDyelot)
  IF lcTranType = 'T'
    IF EMPTY(lcItem+lcColor)
      lcMessage = 'One or more Fabrics'+;
      IIF(M_WAREHOUSE='Y','in warehouse '+lcWareCode,'')
    ELSE
      lcMessage = 'Fabric/Color'+IIF(M_WAREHOUSE='Y','/Warehouse: ',': ')+;
                  ALLTRIM(lcItem)+'/'+ALLTRIM(lcColor)+;
                  IIF(M_WAREHOUSE='Y','/'+lcWareCode,'')
    ENDIF
  ELSE
    IF EMPTY(lcItem)
      lcMessage = 'One or more '+ALLTRIM(lcItmHdr)+;
      IIF(M_WAREHOUSE='Y','in warehouse '+lcWareCode,'')
    ELSE
      lcMessage = ALLTRIM(lcItmHdr)+IIF(M_WAREHOUSE='Y','/Warehouse: ',': ')+;
                  ALLTRIM(lcItem)+IIF(M_WAREHOUSE='Y','/'+lcWareCode,'')
    ENDIF
  ENDIF

  IF lcType = 'F'
    lcMessage1 = 'Fabric/Color/Dyelot: '+ALLTRIM(lcCstItem)+'/'+ALLTRIM(lcCstItmClr)+;
                  '/'+ALLTRIM(lcDyelot)
  ELSE
    lcMessage1 = ALLTRIM(lcItmHdr)+'/Dyelot: '+ALLTRIM(lcCstItem)+'/'+ALLTRIM(lcDyelot)
  ENDIF

  *E300725,1 Message : 38090
  *E300725,1 Fabric/Color/warehouse: xxx/xxx/xxx requires fabric/color/dyelot
  *E300725,1 xxx/xxx/xxx. This dyelot is not available for the fabric
  *E300725,1 Button : 38011
  *E300725,1 Add dyelot  Select dyelot Cancel
  lnSelect=gfModalGen('QRM38090B38011','ALERT',lcMessage+'|'+lcMessage1+'|'+;
                      IIF(lcType='F','Fabric/Color',ALLTRIM(lcItmHdr)))
ENDIF  
*E300935,4 [end]
IF EMPTY(lcDyelot)
  lnSelect = 2
ENDIF
DO CASE
  CASE lnSelect = 1
    IF lcType = 'F' .AND. !SEEK(lcCstItem+lcCstItmClr+lcWareCode+lcDyelot,'FABDYE')
      DO gpAdFabWar WITH lcCstItem, lcCstItmClr, lcDyelot, lcWareCode,lcTmpName
    ENDIF
    IF lcType = 'S' .AND. !SEEK(lcCstItem+lcWareCode+lcDyelot,'STYDYE')
      DO gpAdStyWar WITH lcCstItem, lcDyelot, lcWareCode
    ENDIF
  CASE lnSelect = 2
    IF !IIF(lcType='F',FDYEBROW(lcCstItem,lcCstItmClr,@lcDyelot,.T.),;
                    SDYEBROW(lcCstItem,@lcDyelot,.T.)) .OR. EMPTY(lcDyelot)
      lcDyelot=SPACE(10)
      RETURN(.F.)
    ENDIF
  CASE lnSelect = 3
    lcDyelot=SPACE(10)
    RETURN(.F.)
ENDCASE
SELECT (lnAlias)
RETURN

*!*************************************************************
*! Name      : lfUpdPOBom                           *B602951,1
*! Developer : Timour A. K.
*! Date      : 05/30/1999
*! Purpose   : Update Temp P/O cost sheet used in Creation of 
*!             P/o cost sheet in gfSheetItem.
*!*************************************************************
*! Calls From: gfSheetItem()
*!*************************************************************
*! Parameters:  Nome
*!*************************************************************
*! Returns   :  None
*!:************************************************************
FUNCTION lfUpdPOBom


*C200098,1 Update rate per lb cost in mfg record in dye order cost sheet.
*--If dye order cost sheet.
IF lcTranType = 'D'
  *--Overwite the cost of dyeing operation by the rate per lib * weight.
  lcDyeOpr = gfGetMemvar('M_DYEOPR')
  SELECT (lcTmpBomSh)
  LOCATE FOR CCATGTYP='M' AND cItmMajor=STYLE.cStyMajor AND MfgCode=lcDyeOpr
  lcI = Typ
  IF FOUND() AND POSLN.nCost&lcI <> 0
    REPLACE UntCost    WITH POSLN.nCost&lcI,;
            nBomTotQty WITH 1,;
            TotCost    WITH POSLN.nCost&lcI
  ENDIF
ELSE
*C200098,1 End.

  *--If there is More than one PPrice for the same style, create the P/O cost
  *--sheet for PPrice element only one record with the cost that in P/O.
  SELECT (lcTmpBomSh)
  *B803852,1 HBG 11/20/2000 Check if there is lines for P.Price in the temp file or not [Begin]
  =SEEK('1')
  LOCATE REST WHILE typ+item+iclr+citmmajor+citmmask = '1' ;
              FOR cItmMajor=STYLE.cStyMajor
  IF FOUND()
    *--  If there is lines for P.Price delete it [Begin]
    *DELETE FOR CCATGTYP='P' AND cItmMajor=STYLE.cStyMajor
    
    *B604294,1 KHM 04/30/2001 (Begin) Saving the filed that determine if
    *B604294,1                the cost element is dutable or no.
    lcCostStat = cCostStat
    *B604294,1 KHM 04/30/2001 (End)

    DELETE REST WHILE typ+item+iclr+citmmajor+citmmask = '1' ;
                FOR cItmMajor=STYLE.cStyMajor
    *B803852,1 [End]
    *B608109,1 HBG 06/04/2007 Allow adding lines with zero cost to BOMLINE [Begin]
    *IF lnPrice <> 0
    *B608109,1 HBG 06/04/2007 [End]
      *--Delete the cost sheet created from the BOM that contail multiple 
      *--record for PPrice and create a new one from P/O with P/O price.
      APPEND BLANK
      *B603738,1 KHM 07/20/2000 (Begin) Fixing the replcement of the MfgCode
      *REPLACE cItmMajor  WITH STYLE.cStyMajor,;
              Typ        WITH '1',;
              cItmMask   WITH STYLE.Style,;
              MfgCode    WITH '*1',;
              Uom        WITH 'EAC',;
              nBomTotQty WITH 1,;
              UntCost    WITH lnPrice,;
              TotCost    WITH lnPrice,;
              CCatgTyp   WITH 'P'

      REPLACE cItmMajor  WITH STYLE.cStyMajor,;
              Typ        WITH '1',;
              cItmMask   WITH STYLE.Style,;
              MfgCode    WITH IIF(!STYLE.LDetCost,'*1',"******"),;
              Uom        WITH 'EAC',;
              nBomTotQty WITH 1,;
              UntCost    WITH lnPrice,;
              TotCost    WITH lnPrice,;
              CCatgTyp   WITH 'P'
      *B603738,1 KHM 07/20/2000 (End)
      
      *B604294,1 KHM 04/30/2001 (Begin) Replace the value of the cCostStat
      REPLACE cCostStat WITH lcCostStat      
      *B604294,1 KHM 04/30/2001 (End)
    *B608109,1 HBG 06/04/2007 Allow adding lines with zero cost to BOMLINE [Begin]  
    *ENDIF
    *B608109,1 HBG 06/04/2007 [End]
  *B803852,1 HBG 11/20/2000 End if there is lines for P.Price in the temp file [Begin]
  ENDIF
  *B803852,1 [End]

  *--If no detail costing for style and there is a cost elements entered.
  *--Create or update the P/O cost sheet for this cost element with the
  *--cost that ented in P/O.
  IF !STYLE.LDetCost
  *--Delete the cost sheet created from the BOm and create a new one from P/O.
    DELETE FOR CCATGTYP<>'P' AND cItmMajor=STYLE.cStyMajor
    FOR lnI=2 TO 5
      lcI=STR(lnI,1)
      IF POSLN.nCost&lcI <> 0
        lcIType&lcI = gfGetMemVar('M_cIType'+lcI)
        APPEND BLANK
        GATHER MEMVAR
        REPLACE cItmMajor WITH STYLE.cStyMajor,;
                Typ       WITH lcI,;
                cItmMask  WITH STYLE.Style,;
                MfgCode   WITH '*'+lcI ,;
                Uom       WITH 'EAC',;
                UntCost   WITH POSLN.nCost&lcI,;
                nBomTotQty WITH 1,;
                TotCost   WITH POSLN.nCost&lcI,;
                CCatgTyp  WITH lcIType&lcI
      ENDIF
    ENDFOR
  ENDIF
ENDIF
RETURN

*:----------------------------------------------------------------
*: Name      : gfCkWhsDye
*: Developer : Wael Aly Mohamed
*: Date      : 11/03/1997
*: Purpose   : 
*:----------------------------------------------------------------
*: Calls     : gfGetMemVar
*:             gfModalGen
*:             gfItemMask
*:             gpAdStyWar
*:             gpAdFabWar
*:             gfSelDyelot
*:----------------------------------------------------------------
*: Parameters: lcTranType : Transaction type   ('M'-'I'-'T')
*:             lcTicketNo : Ticket number
*:             lcItem     : Style/Fabric
*:             lcColor    : Color
*:             lcDyelot   : Dyelot
*:             lcWareCode : Warehouse
*:----------------------------------------------------------------
*: Returns   :  None
*:----------------------------------------------------------------
*: Example   :  =gfSheetItem('M','000001','ITEMD001','','Dyelot','WARE1')
*:----------------------------------------------------------------
FUNCTION gfCkWhsDye
PARAMETERS lcTranType,lcTicketNo,lcItem,lcColor,lcDyelot,lcWareCode

PRIVATE lcMjrMsk,lcMjrHdr,lcNMjrMsk,laItemSeg,lcClrMsk,lnClrPos
PRIVATE lcItemFile, llDyelot,lcScale,lnCount,lcCstClr,lcCstItm
PRIVATE llContinue,lnSizePos,lcTmpBomSh,lnAlias

STORE '' TO M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC
= gfGetMemVar('M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC',gcAct_Comp)
lcMjrMsk  = gfItemMask("PM")
lcMjrHdr  = gfItemMask("HM")
lcNMjrMsk = gfItemMask("PN")
IF !SEEK(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),'BOM')
  *E300725,1 Message : 38031
  *E300725,1 Cost sheet not found for style: xxx cannot generate cutting 
  *E300725,1 ticket cost sheet
  *E300725,1 Button : 00000
  *E300725,1 Ok
  =gfModalGen('TRM38031B00000','ALERT',IIF(lcTranType='T','Fabric: ',lcMjrHdr+':')+;
              ALLTRIM(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))))+;
              '|'+IIF(lcTranType='M','cutting ticket',IIF(lcTranType='I','purchase order','order')))
  RETURN(.F.)
ENDIF
lnAlias = SELECT()
DECLARE laItemSeg[1]
=gfItemMask(@laItemSeg)
FOR lnCount = 1 TO ALEN(laItemSeg,1)
  IF laItemSeg[lnCount,1]='C'
    lcClrMsk = laItemSeg[lnCount,3]
    lnClrPos = laItemSeg[lnCount,4]
  ENDIF
  IF laItemSeg[lnCount,1]='S'
    lnSizePos = laItemSeg[lnCount,4]
  ENDIF
ENDFOR
lcItemFile = IIF(lcTranType='T','Fabric','Style')
llDyelot   = SEEK(lcItem+ALLTRIM(lcColor),lcItemFile) .AND. &lcItemFile..cDye_Flg='Y'
lcScale    = IIF(lcTranType='T','',Style.Scale)
llContinue = .T. 
lcTmpBomSh = gfTempName()
SELECT BOM
=AFIELDS(laFileStru)
CREATE TABLE (gcWorkDir+lcTmpBomSh) FROM ARRAY laFileStru
*E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
=lfCrFox2x()
*E303074,1 TMI 02/20/2012 [End  ] 
INDEX ON typ+item+iclr+citmmajor+citmmask TAG (lcTmpBomSh)
SELECT BOM
=SEEK(PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19))
SCAN REST WHILE cItmMajor = PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19)
  SCATTER MEMVAR MEMO
  IF cCatGTyp='S' .AND. M_USEEXSSC .AND. !EMPTY(MSZCROSREF) .AND. ;
      RIGHT(ALLTRIM(Item),LEN(lcNMjrMsk)) = STRTRAN(lcNMjrMsk,'X','*')
    FOR lnCount = 1 TO MEMLINES(MSZCROSREF)
      lcLine = MLINE(MSZCROSREF,lnCount)
      IF SUBSTR(lcLine,1,3) <> lcScale
        LOOP
      ENDIF
      m.Item = ALLTRIM(m.Item)
      m.Item = PADR(SUBSTR(m.Item,1,LEN(m.Item)-3)+SUBSTR(lcLine,AT('~',lcLine)+1,3),19)
      IF !SEEK(m.typ+m.item+m.iclr+m.citmmajor+m.citmmask,lcTmpBomSh)
        INSERT INTO (lcTmpBomSh) FROM MEMVAR
      ENDIF
    ENDFOR
  ELSE
    INSERT INTO (lcTmpBomSh) FROM MEMVAR
  ENDIF
ENDSCAN
SELECT (lcTmpBomSh)
SCAN
  IF !LIKE(STRTRAN(cItmMask,'*','?'),IIF(lcTranType='T',lcColor,lcItem)) .OR. ;
     (!EMPTY(MSIZES) .AND. ATCLINE(lcScale+'~',MSIZES)=0) .OR. ;
     (!EMPTY(MSZCROSREF) .AND. ATCLINE(lcScale+',',MSZCROSREF)=0)
    LOOP
  ENDIF
  STORE '' TO lcCstClr,lcCstItm
  DO CASE
    CASE cCatGTyp='S'
      DO CASE
        CASE M_USEEXSSC
          lcCstItm = SUBSTR(Item,1,LEN(lcMjrMsk))+;
                     SUBSTR(lcItem,LEN(lcMjrMsk)+1,lnSizePos-LEN(lcMjrMsk)-1)+SUBSTR(Item,lnSizePos)
        CASE RIGHT(ALLTRIM(Item),LEN(lcNMjrMsk)) = STRTRAN(lcNMjrMsk,'X','*')
          lcCstItm = SUBSTR(Item,1,LEN(lcMjrMsk))+SUBSTR(lcItem,LEN(lcMjrMsk)+1)
        OTHERWISE
          lcCstItm = Item
      ENDCASE
      IF !SEEK(lcCstItm,'Style')
        LOOP
      ENDIF
      lcCsItmSc = Style.Scale
      =SEEK(lcItem,'Style')
      IF M_WAREHOUSE='Y' .AND. !SEEK (lcCstItm+lcWareCode+SPACE(10),'STYDYE')
        *E300725,1 Message : 38029
        *E300725,1 Style xxxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        IF gfModalGen('QRM38029B38001','ALERT','Style: '+ALLTRIM(lcCstItm)+'|'+lcWareCode) = 1
          DO gpAdStyWar WITH lcCstItm,SPACE(10),lcWareCode
        ELSE
          llContinue = .F.
          EXIT
        ENDIF   
      ENDIF
      IF M_DYELOT='Y' .AND. SEEK(lcCstItm,'Style') .AND. Style.cDye_Flg='Y'
        *IF lcTranType='I'
          *E300725,1 Message : 38030
          *E300725,1 You cannot work with dyelots when creating
          *E300725,1 cost sheet for purchase orders. Cannot proceed.
          *E300725,1 Button : 00000
          *E300725,1 Ok
        *  =gfModalGen('TRM38030B00000','ALERT')
        *  llContinue = .F.
        *  EXIT
        *ENDIF
        IF llDyelot .AND. !SEEK(lcCstItm+lcWareCode+lcDyelot,'StyDye') ;
          .AND. !gfSelDyelot(lcTranType,'S',lcItem,lcColor,lcWareCode,lcDyelot,lcCstItm,'')
          llContinue = .F.
          EXIT
        ENDIF
      ENDIF
    CASE cCatGTyp='F' .OR. (cCatGTyp='T' .AND. Trim_Invt)
      lcCstItm = SUBSTR(Item,1,7)
      IF IClr = '******'
        lcCstClr = IIF(lcTranType='T',lcColor,SUBSTR(lcItem,lnClrPos,LEN(lcClrMsk)))
      ELSE
        lcCstClr = IClr
      ENDIF
      IF M_WAREHOUSE='Y' .AND. !SEEK (lcCstItm+lcCstClr+lcWareCode+SPACE(10),'FABDYE')
        *E300725,1 Message : 38029
        *E300725,1 Item/Color xxxxx/xxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        IF gfModalGen('QRM38029B38001','ALERT','Item/Color: '+ALLTRIM(lcCstItm)+'/'+ALLTRIM(lcCstClr)+'|'+lcWareCode) = 1
          DO gpAdFabWar WITH lcCstItm,lcCstClr,SPACE(10),lcWareCode
        ELSE
          llContinue = .F.
          EXIT
        ENDIF   
      ENDIF
      IF M_MATDYE='Y' .AND. SEEK(lcCstItm+lcCstClr,'Fabric') .AND. Fabric.cDye_Flg='Y'
        *IF lcTranType='I'
          *E300725,1 Message : 38030
          *E300725,1 You cannot work with dyelots when creating
          *E300725,1 cost sheet for purchase orders. Cannot proceed.
          *E300725,1 Button : 00000
          *E300725,1 Ok
         * =gfModalGen('TRM38030B00000','ALERT')
         * llContinue = .F.
         * EXIT
        *ENDIF
        IF llDyelot .AND. !SEEK(lcCstItm+lcCstClr+lcWareCode+lcDyelot,'FabDye') ;
          .AND. !gfSelDyelot(lcTranType,'F',lcItem,lcColor,lcWareCode,lcDyelot,lcCstItm,lcCstClr)
          llContinue = .F.
          EXIT
        ENDIF
      ENDIF
  ENDCASE
ENDSCAN
USE IN (lcTmpBomSh)
SELECT (lnAlias)
RETURN(llContinue)

*:----------------------------------------------------------------
FUNCTION gfGetWPrnt
PARAMETERS lcWindow
DO WHILE !EMPTY(WPARENT(lcWindow)) AND WPARENT(lcWindow) <> 'FNDATION'
   lcWindow = WPARENT(lcWindow)
ENDDO
RETURN UPPER(ALLTRIM(lcWindow))

*!*************************************************************************
*! Name      : gfCrtTmp
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/08/97    
*! Purpose   : to Create uncomplete session temprory files
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*: Passed parameters  : lcFileStruc
*:                      lcTagExp
*:                      lcTag
*:*************************************************************************
*! Returns   :  Temprary file name
*:*************************************************************************     
FUNCTION gfCrtTmp
PARAMETERS lcFile,lcFileStruc,lcTagExp,lcTag
PRIVATE lcFileType,lcOnError,llError,laFileStruc,lcFileName,lnWorkArea,lcTagType,;
        lnCount
lnWorkArea = SELECT()
lcFileName = IIF(TYPE('lcFile')='C',lcFile,gfTempName())
lcOnError = ON('ERROR')
llError = .F.
ON ERROR llError = .T.
lcFileType = 'A'
lcFileType = IIF(TYPE("lcFileStruc[1]")#"U",'A',;
             IIF(LEFT(ALLT(lcFileStruc),1)='(','S','F'))
ON ERROR &lcOnError
DO CASE
  CASE lcFileType = 'F'
    SELECT (lcFileStruc)
    =AFIELDS(laFileStruc)
    lcFileType = 'A'
  CASE lcFileType= 'A'
    =ACOPY(lcFileStruc,laFileStruc)
ENDCASE
lcTagType = 'A'
lcTagType = IIF(TYPE("lcTagExp[1]")#"U",'A','S')

IF lcFileType = 'A'
  CREATE TABLE (gcWorkDir+lcFileName) FROM ARRAY laFileStruc
  *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
  =lfCrFox2x()
  *E303074,1 TMI 02/20/2012 [End  ] 
ELSE
  CREATE TABLE (gcWorkDir+lcFileName) &lcFileStruc
  *E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
  =lfCrFox2x()
  *E303074,1 TMI 02/20/2012 [End  ] 
ENDIF
SELECT (lcFileName)
IF lcTagType = 'A'
  FOR lnCount = 1 TO ALEN(lcTagExp,1)
    INDEX ON &lcTagExp[lnCount,1] Tag &lcTagExp[lnCount,2]
  ENDFOR
ELSE
  IF TYPE('lcTagExp') = 'C' AND TYPE('lcTag') <> 'C'
    lcTag = Field(1)
  ENDIF
  IF TYPE('lcTagExp') = 'C' AND TYPE('lcTag') = 'C'
    INDEX ON &lcTagExp Tag &lcTag
  ENDIF
ENDIF  
USE
USE (gcWorkDir+lcFileName) &&EXCL
IF lcTagType = 'A'
  SET ORDER TO TAG &lcTagExp[1,2]
ELSE
  IF TYPE('lcTagExp') = 'C' AND TYPE('lcTag') = 'C'
    SET ORDER TO TAG (lcTag)
  ENDIF
ENDIF  
SELECT (lnWorkArea)
RETURN lcFileName


*B601927,1 Hesham El-Sheltawi (Start)
*!*************************************************************************
*! Name      : GFUNCOMPSESSION
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/08/97    
*! Purpose   : to check if there is an uncompete session then the function
*!             will open the uncomplete session temprory files and initialize
*!             the variables that hold the temprory files names
*!*************************************************************************
*: Calls       :
*:            FUNCTION : lfGetTmpFile
*!*************************************************************************      
*: Passed parameters  : lcsesstype
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION gfUnCompSession
PARAMETERS lcSessType,lnSessNo,lcMesStr
PRIVATE llCanContinue,lnOption
lcMesStr = IIF(TYPE('lcMesStr')#'C','',lcMesStr)
llCanContinue = .F.
SET ORDER TO TAG TRANS IN UNCMSESS
lnReprocess = SET('REPROCESS')
*E301164,1 Hesham (Start)
lcMenUnProce = lcSessType
*E301164,1 Hesham (End)
IF lnSessNo = 1 .AND. SEEK('O'+PADR(lcSessType,10)+gcUser_id,'UNCMSESS')
  SET REPROCESS TO 1
  SELECT UNCMSESS
  LOCATE REST WHILE Status+cUTranType+gcUser_id=;
                    'O'+PADR(lcSessType,10)+gcUser_id FOR RLOCK()
  SET REPROCESS TO lnReprocess
  IF FOUND()
    *E300408,1 Message : 00258
    *E300408,1 The system detected an incomplete    session.
    *E300408,1 Button : 00000
    *E300408,1 Ok
    lnOption = gfModalGen('INM00258B00033','ALERT', lcMesStr)
    IF INLIST(lnOption,2,3)
       REPLACE UNCMSESS.STATUS WITH IIF(lnOption=2,'X',UNCMSESS.STATUS)
       RETURN  .F.
    ENDIF
    *E300408,1 Message : 00259
    *E300408,1 The system will now attempt to resume processing on the uncompleted session.
    *E300408,1 Button : 00000
    *E300408,1 Ok
*    =gfModalGen('INM00259B00000','ALERT')
    IF lfGetTmpFile()
      lcSession = UNCMSESS.cSession
      llCanContinue = .T.
    ELSE
     =lfErsTmpFile()
    ENDIF
  ENDIF
ENDIF
RETURN llCanContinue



*!*************************************************************************
*! Name      : LFGETTMPFILE
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/08/97    
*! Purpose   : Open all the uncomplete session temprory files
*!*************************************************************************
*! Returns   :  logical .t. if all temprory files are opened correctly
*:*************************************************************************     
FUNCTION lfGetTmpFile
PRIVATE lcTmpFiles,lcPhyName,lcFileName,lcTagName,llContinue,lcOnError,lnWorkArea
lnWorkArea = SELECT()
lcOnError = ON("ERROR")
ON ERROR llContinue = .F.
llContinue = .T.
lcTmpFiles = UNCMSESS.mTmpFiles
FOR lnCount = 1 TO OCCURS(';',lcTmpFiles)
  lcPhyName  = SUBSTR(lcTmpFiles,1,AT(',',lcTmpFiles,1)-1)
  lcFileName = SUBSTR(lcTmpFiles,AT(',',lcTmpFiles,1)+1,AT(',',lcTmpFiles,2)-AT(',',lcTmpFiles,1)-1)
  lcTagName  = SUBSTR(lcTmpFiles,AT(',',lcTmpFiles,2)+1,AT(';',lcTmpFiles)-AT(',',lcTmpFiles,2)-1)
  *B602759,1 MAN Stop Overwriting the temp Var name with 
  *B602759,1     the temp file until we make sure 
  *B602759,1     that we will be able to restore the session.
  *&lcPhyName = lcFileName
  *B602759,1 MAN Added check if the file exist before opening, 
  *B602759,1     To give the program the chance to complete 
  *B602759,1     the session even if one of the files doesn't exist.
  IF FILE(gcWorkDir+lcFileName+".DBF")
    SELECT 0
    USE (gcWorkDir+lcFileName) &&EXCL
  ENDIF  
  IF !llContinue
    EXIT
  ENDIF
  *B602759,1 MAN Added check if the file exist before opening, 
  *B602759,1     To give the program the chance to complete 
  *B602759,1     the session even if one of the files doesn't exist.
  *B602759,1     Added AND USED(lcFileName)
  IF !EMPTY(lcTagName) AND USED(lcFileName)
    SET ORDER TO TAG (lcTagName)
  ENDIF
  lcTmpFiles = SUBSTR(lcTmpFiles,AT(';',lcTmpFiles)+1)
ENDFOR
*B602759,1 MAN Added Loop to assign the Variable that holds the temp. file
*B602759,1     names to the session temp file names.
IF llContinue
  lcTmpFiles = UNCMSESS.mTmpFiles
  FOR lnCount = 1 TO OCCURS(';',lcTmpFiles)
    lcPhyName  = SUBSTR(lcTmpFiles,1,AT(',',lcTmpFiles,1)-1)
    lcFileName = SUBSTR(lcTmpFiles,AT(',',lcTmpFiles,1)+1,AT(',',lcTmpFiles,2)-AT(',',lcTmpFiles,1)-1)
    &lcPhyName = lcFileName
    lcTmpFiles = SUBSTR(lcTmpFiles,AT(';',lcTmpFiles)+1)
  ENDFOR
ENDIF

ON ERRO &lcOnError
SELECT (lnWorkArea)
IF llContinue
  PRIVATE lcVarName , lcVarType , lcVarVal , lcVarStr
  lcVarStr = UNCMSESS.mComent      && Varible to hold the field UNCMSESS.mComent
  FOR lnCount = 1 TO OCCURS('~',lcVarStr)
    lcVarName = SUBSTR(lcVarStr , 1 , AT('|',lcVarStr) - 1)      && The varible name
    lcVarType = SUBSTR(lcVarStr , AT('|',lcVarStr) + 1 , 1)      && The varible Type
    lcVarVal = SUBSTR(lcVarStr , AT('|' , lcVarStr , 2) + 1 ,;
               AT('~' , lcVarStr) - AT('|' , lcVarStr , 2) -1)          && The varible value
    &lcVarName = IIF(lcVarType='N',VAL(lcVarVal) ,;
                 IIF(lcVarType='D',CTOD(lcVarVal) ,;
                 IIF(lcVarType='L',(lcVarVal='Y') ,lcVarVal)))
    lcVarStr = SUBSTR(lcVarStr,AT('~',lcVarStr)+1)
  ENDFOR    && End of FOR Loop
ELSE
  REPLACE UNCMSESS.STATUS WITH 'C'
  UNLOCK IN 'UNCMSESS'
ENDIF
RETURN llContinue


*!*************************************************************************
*! Name      : LFERSTMPFILE
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/10/97    
*! Purpose   : Delete the Uncomplete session temprory files
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION lfErsTmpFile
PRIVATE lcTmpFiles,lcPhyName,lcFileName,lnWorkArea
lnWorkArea = SELECT()
lcTmpFiles = UNCMSESS.mTmpFiles
FOR lnCount = 1 TO OCCURS(';',lcTmpFiles)
  lcPhyName  = SUBSTR(lcTmpFiles,1,AT(',',lcTmpFiles,1)-1)
  lcFileName = SUBSTR(lcTmpFiles,AT(',',lcTmpFiles,1)+1,AT(',',lcTmpFiles,2)-AT(',',lcTmpFiles,1)-1)
  *B602759,1 MAN Stop Overwriting the temp Var name with 
  *B602759,1     the temp file until we make sure 
  *B602759,1     that we will be able to restore the session.
  *&lcPhyName = lcFileName
  IF USED(lcPhyName)
    USE IN (lcPhyName)
  ENDIF
  *B602759,1 MAN Stop Erasing the Temp Files, To give chance to the support
  *ERASE (gcWorkDir+lcPhyName+'.DBF')
  *ERASE (gcWorkDir+lcPhyName+'.FPT')  
  *ERASE (gcWorkDir+lcPhyName+'.CDX')  
  lcTmpFiles = SUBSTR(lcTmpFiles,AT(';',lcTmpFiles)+1)
ENDFOR
SELECT (lnWorkArea)
*B601927,1 Hesham El-Sheltawi (End)


*!*************************************************************************
*! Name      : gfSavSess
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/10/97    
*! Purpose   : SAVE the temporary files names and variables for the uncomp
*!             session
*!*************************************************************************
*! Returns   :  
*:*************************************************************************     
FUNCTION gfSavSess

*B602018,1 Change this line to add a new parameter (Session number)
*lcSession [Begin]

*PARAMETERS lcSessType,lcFiles,laVars
PARAMETERS lcSessType , lcFiles , laVars , lcSession

*B602018,1 Change this line to add a new parameter (Session number) [End]

*B602018,1 Add this line to add a new parameter (Session number)
*lcSession [Begin]
lcSession = IIF(TYPE('lcSession') <> 'C' , '' , lcSession)
*B602018,1 Add this line to add a new parameter (Session number) [End]

PRIVATE lnAlias,lnVarNum , lcReturnSt , lcVarNam
lcSessType = UPPER(PADR(lcSessType,10))

*B602018,1 Add these lines to make sure that the UNCMSESS file is opened
*with the correct index tag [Begin]
PRIVATE laFilsTUse
DIMENSION laFilsTUse[1,8]

laFilsTUse[1,1] = 'UNCMSESS'
laFilsTUse[1,2] = 'TRANS'

=gfChkFile(.T. , @laFilsTUse)
*B602018,1 Add these lines to make sure that the UNCMSESS file is opened [End]

lnAlias = SELECT(0)

lcReturnSt = SPACE(0)
FOR lnVarNum = 1 TO ALEN(laVars)
  lcVarNam   = laVars[lnVarNum]
  lcReturnSt = lcReturnSt + lcVarNam + "|" + TYPE(lcVarNam) + "|" +      ;
               IIF(TYPE(lcVarNam)="N", ALLTRIM(STR(EVALUATE(lcVarNam),13,4)) ,;
               IIF(TYPE(lcVarNam)="D", ALLTRIM(DTOC(EVALUATE(lcVarNam))),;
               IIF(TYPE(lcVarNam)="L", IIF(EVALUATE(lcVarNam),"Y","N")  ,;
               &lcVarNam))) + '~'
ENDFOR

*B602018,1 Change this line to add a new parameter (Session number)
*lcSession [Begin]

*IF SEEK('O'+PADR(lcSessType,10)+gcUser_id,'UNCMSESS')
IF EMPTY(lcSession) .OR. ;
   SEEK('O' + PADR(lcSessType , 10) + gcUser_id + lcSession , 'UNCMSESS')

*B602018,1 Change this line to add a new parameter (Session number) [End]
  
  SELECT UnCmSess
  REPLACE mTmpFiles  WITH lcFiles   ,;
          mComent    WITH lcReturnSt
  
ENDIF          
llNoThing  = RLOCK()

SELECT(lnAlias)

*B602018,1 Add this line to restore the old environment [Begin]
=gfChkFile(.F. , @laFilsTUse)
*B602018,1 Add this line to restore the old environment [End]

*E300775,1 Hesham (Start)
*!*************************************************************************
*! Name      : gfCtrlTrig
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/15/97    
*! Purpose   : to check if there is any processes in the trigger file to run
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*: Passed parameters  : lcProgName Program Name
*:                      lcEvent    Event
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
*E301297,1 Remove this function because we are going to use one function
*          called gfDoTriger() to control any triggers (customized process
*          and workflow server requests including creating new project)
*          found in the triggers file [Begin]
*FUNCTION gfCtrlTrig
*PARAMETERS lcProgName ,lcEvent
*PRIVATE llTrigUsed,lnCurAlias,llPrjTmpUsed,llAtoProc,laPrjTempl
*DIME laPrjTempl[1,2]
*STORE '' TO laPrjTempl
*STORE .F. TO llTrigUsed,llPrjTmpUsed
*lnCurAlias = SELECT()
*llAtoProc = !USED('SYDATPRC')
*IF llAtoProc
*  USE (gcSysHome+'SYDATPRC') IN 0 
*ENDIF
*lcActivity = LOOKUP(SYDATPRC.CACTCOMM,'CP',SYDATPRC.CACTIVEID,'CACTIVEID')
*llTrigUsed = !USED('WFTRIGER')
*IF llTrigUsed
*  USE (gcDataDir+'WFTRIGER') IN 0 
*ENDIF
*SELECT WFTRIGER
*SET ORDER TO TAG Cobjtriger
***if create prject does not exist in the Triggers file then check if there is any
***projects can be created in this program event if there is any then ask the user
***which template he want to create a project from  
*IF !SEEK(PADR(lcProgName,LEN(cobject_id))+PADR(lcEvent,LEN(cevent_id))+'CP')
*  llPrjTmpUsed = !USED('wfptmdev')
*  IF llPrjTmpUsed
*    USE (gcDataDir+'wfptmdev') IN 0 
*  ENDIF
*  SELECT wfptmdev
*  SET ORDER TO TAG Cobjectid
*  IF SEEK(PADR(lcProgName,10)+lcEvent+SPACE(LEN(coperat_id)))
*    lcTemplate = ""
*    SELECT Wfptmdev.ctemplatid+' '+Wfprjtmp.cdescrip,Wfptmdev.ctemplatid;
*         FROM &gcDataDir.Wfptmdev, &gcDataDir.Wfprjtmp;
*         WHERE Wfprjtmp.ctemplatid = Wfptmdev.ctemplatid;
*         AND Wfptmdev.cobject_id+Wfptmdev.cevent_id+Wfptmdev.coperat_id = PADR(lcProgName,10)+lcEvent+SPACE(LEN(coperat_id));
*         INTO ARRAY laPrjTempl
*    DO sygettmp.spr
*    IF !EMPTY(lcTemplate)
*      lcCommand = '='+ALLT(lcActivity)+'("'+lcTemplate+'")'
*      &lcCommand
*    ENDIF
*  ENDIF
*ENDIF
*SELECT WFTRIGER
*IF SEEK(PADR(lcProgName,10)+lcEvent)
*  PRIVATE lnWorkArea
*  SCAN REST WHILE cobject_id+cevent_id = PADR(lcProgName,10)+lcEvent
*      lcActivity = LOOKUP(SYDATPRC.CACTCOMM,CACTIVEID,SYDATPRC.CACTIVEID,'CACTIVEID')
*      lcCommand = '='+ALLT(lcActivity)+'('+ALLTRIM(MACTPARM)+')'
*      &lcCommand
*      SELECT WFTRIGER      
*  ENDSCAN
*ENDIF
*IF llAtoProc
*  USE IN SYDATPRC
*ENDIF
*IF llTrigUsed
*  USE IN WFTRIGER
*ENDIF
*IF llPrjTmpUsed
*  USE IN wfptmdev
*ENDIF 
*SELECT (lnCurAlias)
*E301297,1 [End]

*!*************************************************************************
*! Name      : gfCtrlFlow
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/15/97    
*! Purpose   : to check all operations opened for the current program
*!             and send record to the workflow server with the evaluations
*!             of the needed expressions to change the status of the operation
*!             needed to be changed
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*: Passed parameters  : lcProgName Program Name
*:                      lcEvent    Event
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
*E301297,1 Remove this function because we are going to use one function
*          called gfDoTriger() to control any triggers (customized process
*          and workflow server requests including creating new project)
*          found in the triggers file [Begin]
*FUNCTION gfCtrlFlow
*PARAMETERS lcProgName ,lcEvent
*PRIVATE llPrjDet,llPrjTmp,llClientSer,lnCurWork
*lnCurWork = SELECT()
*llClientSer = !USED('WFUCLSER')
*IF llClientSer 
*  USE (gcDataDir + 'WFUCLSER') IN 0
*ENDIF
*
*llPrjTmp = !USED('wfprjtmp')
*IF llPrjTmp
*  USE (gcDataDir + 'wfprjtmp') IN 0
*ENDIF 
*SELECT wfprjtmp
*SET ORDER TO TAG Ctempltid
*llPrjDet = !USED('WFPRJDEV')
*IF llPrjDet
*  USE  (gcDataDir+'WFPRJDEV') IN 0
*ENDIF
*SELECT WFPRJDEV
*SET ORDER TO TAG Cobjevent
*SET RELATION TO cprjtype INTO wfprjtmp
*IF SEEK(PADR(lcProgName,LEN(cobject_id))+PADR(lcEvent,LEN(CEVENT_ID))+'O')
*  SCAN REST WHILE cobject_id+cevent_id+cstatus+cprjtype+cprojectid+coperat_id = PADR(lcProgName,LEN(cobject_id))+PADR(lcEvent,LEN(CEVENT_ID))+'O'
*    IF ALLT(EVAL(ALLT(wfprjtmp.MPRJKEY))) == ALLT(cprojectid)
*      SELECT WFUCLSER
*      APPEND BLANK
*      REPLACE CPRJTYPE   WITH WFPRJDEV.cprjtype,;
*              cprojectID WITH WFPRJDEV.cprojectid,;
*              CACTIVEID  WITH 'CS'
*      =GFADD_INFO()
*    ENDIF
*  ENDSCAN
*ENDIF
*IF llClientSer 
*  USE IN WFUCLSER
*ENDIF
*IF llPrjTmp
*  USE IN wfprjtmp
*ENDIF 
*IF llPrjDet
*  USE IN WFPRJDEV
*ENDIF
*SELECT (lnCurWork)
*E301297,1 [End]

*!*************************************************************************
*! Name      : gfCreatePrj
*! Developer : Hesham El-Sheltawi 
*! Date      : 12/15/97    
*! Purpose   : to send record to the workflow module to notify the server
*!             the project needed to be created and its type
*!*************************************************************************
*: Calls       :
*!*************************************************************************      
*: Passed parameters  : lcTemplateID   the project type to be created
*:*************************************************************************
*! Returns   :  
*:*************************************************************************     
*E301297,1 Remove this function because we are going to handle the project
*          creation from the Workflow module by adding a server request in
*          the triggers file to create the new projects [Begin]
*FUNCTION gfCreatePrj
*PARAMETERS lcTemplateID
*PRIVATE llPrjTmpUsed,llClientSer,llPrjHead
*STORE .F. TO llClientSer,llPrjHead
*llPrjTmpUsed = !USED('wfprjtmp')
*IF llPrjTmpUsed
*  USE (gcDataDir+'wfprjtmp') IN 0 
*ENDIF
*SELECT wfprjtmp
*SET ORDER TO TAG Ctempltid
*IF SEEK(lcTemplateID)
*  llClientSer = !USED('WFUCLSER')
*  IF llClientSer 
*    USE (gcDataDir + 'WFUCLSER') IN 0
*  ENDIF
*  SELECT WFUCLSER
*  SET ORDER TO TAG CPRJTYPE
*  IF !SEEK(PADR(lcTemplateID,LEN(Cprjtype))+EVAL(WFPRJTMP.MPRJKEY))
*    IF EMPTY(WFPRJTMP.MCREATECND) OR EVAL(WFPRJTMP.MCREATECND)
*      SELECT WFUCLSER
*      APPEND BLANK
*      REPLACE CPRJTYPE   WITH lcTemplateID,;
*              cprojectID WITH EVAL(WFPRJTMP.MPRJKEY),;
*              CACTIVEID  WITH 'CP'
*      =GFADD_INFO()
*    ENDIF  
*  ENDIF  
*ENDIF
*IF llClientSer 
*  USE IN WFUCLSER
*ENDIF
*IF llPrjTmpUsed
*  USE IN wfprjtmp
*ENDIF
*E300775,1 Hesham (End)
*E301297,1 [End]




FUNCTION lfGetSpr
PRIVATE lcSprName,laPrgStr
DIMEN laPrgStr[1]
STORE '' TO lcSprName,laPrgStr
lnCount = 1
DO WHILE !EMPTY(SYS(16,lnCount))
  DIMEN laPrgStr[lnCount]
  laPrgStr[lnCount] = SYS(16,lnCount)
  lnCount = lnCount + 1
ENDDO
FOR lnCount = ALEN(laPrgStr) TO 1 STEP -1
  IF '.SPX' $ laPrgStr[lnCount]
    lcSprName = laPrgStr[lnCount]
    EXIT
  ENDIF
ENDFOR
lcSprName = IIF(ATC('\',lcSprName)>0,SUBSTR(lcSprName,RAT('\',lcSprName)+1),lcSprName)
RETURN lcSprName



*!**************************************************************************
*!
*!      Function: lfGetFac
*!
*E300824,1 Factor field validation, called from AP programs
*!**************************************************************************
* Valid function for get field laData[43] representing factor
*
FUNCTION lfGetFac
PARAMETERS lcOldVal, llBrowse
*** Old factor value
*** .T. if browsed from browsing invisible button
PRIVATE lcPrFactor, lcFactObj, lcCurAlias, lnSavFacTg, lnClosRec,;
        llFactFound, llOpenFact, lcFile_Ttl, lcBrFields 

lcFactObj    = SYS(18)
lcPrFactor     = ALLTRIM(EVALUATE(lcFactObj))

llFactFound  = .F.

IF llBrowse .OR. !EMPTY(lcPrFactor) 

  lcCurAlias = ALIAS()

  IF !USED('SYCFACT')  && Check if the factors file is open or not.
    llOpenFact  = .T.     && Indicates that the file is open by the function.
    ** Use the file and assign the index.
    SELECT 0
    USE &gcSysHome.SYCFACT ORDER TAG cFacCode
  ELSE
    llOpenFact = .F.
    SELECT SYCFACT
    lnSavFacTg = VAL(SYS(21)) 
    SET ORDER TO TAG cFacCode 
  ENDIF  

  lcPrFactor   = PADR(ALLTRIM(lcPrFactor), FSIZE('cFacCode','SYCFACT'))
  &lcFactObj = lcPrFactor
  SHOW GET (lcFactObj)

  *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [start ] 
  *IF llBrowse .OR. !SEEK(lcPrFactor,'SYCFACT'))
  IF llBrowse .OR. !SEEK(lcPrFactor,'SYCFACT')
    *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
    *** If a record is to be selected 
    DIMENSION laTemp[1]
    laTemp = ''
    lcFile_Ttl = 'Factors'
    lcBrFields = ' '
    lnClosRec = RECNO(0)
    
    *** Get browse fields from dictionary
     =lfGetBrF(@lcFile_Ttl, @lcBrFields, 'SYCFACT',;
               "cFacCode,cFaccomp,cPhoneNo,cFaxNo,cFacTitle,cFacCont")
    IF BETWEEN(lnClosRec,1,RECCOUNT())
      GO lnClosRec
    ELSE
      GO TOP
    ENDIF        

    =gfBrows(.F.,'cFacCode','laTemp')
    *** If a factor has been selected from the browse
    IF !EMPTY(laTemp[1])
      &lcFactObj  = laTemp[1]
      llFactFound = .T.      
    ELSE
      &lcFactObj  = lcOldVal
      llFactFound = .F.       
    ENDIF
    SHOW GET (lcFactObj)
  ELSE
    llFactFound = .T.
  ENDIF  

  IF USED('SYCFACT')
    IF llOpenFact
      USE IN SYCFACT
    ELSE
      SET ORDER TO lnSavFacTg IN SYCFACT
    ENDIF  
  ENDIF

  SELECT IIF(!EMPTY(lcCurAlias), (lcCurAlias), 0)
ENDIF

RETURN llFactFound

*!**************************************************************************
*!
*!      Function: lfGetBrF
*!
*E300824,1 Function to Get browse field string
*E300824,1 called from Factor field validation, called from AP programs
*!**************************************************************************
* Forms a browse fields string according to parameters
* and gets file title
* example : lfGetBrF(@lcFileTitl, @lcBrowFlds, 'SYCFACT',"cFacCode, cFaccomp")
*
FUNCTION lfGetBrF
PARAMETERS lcFileTitl, lcBrowFlds, lcSrchFile, lcFields

PRIVATE lcCurAlias, lnSavFlsTg, lnSavFldTg, lnFieldNum,;
        llSydFiles, llSydField, llMayProceed, laFields

*** Check parameters
*llMayProceed = TYPE('lcFileTitl'= C) .AND. ;
 *              TYPE('lcBrowFlds'= C)
llMayProceed = .T.  
  
IF llMayProceed

  STORE " " TO lcFileTitl, lcBrowFlds 
  
  *** If a file name is not included as a parameter,
  *** use the current work area alias ( if there is any)
  lcCurAlias = ALIAS()
  
  lcSrchFile   = IIF(TYPE('lcSrchFile') <> 'C' .OR.;
                     EMPTY(lcSrchFile), lcCurAlias, lcSrchFile)
                     
  IF !EMPTY(lcSrchFile)
    
    IF !USED('SYDFILES')  && Check if the internationals file is open or not.
      llSydFiles   = .T.     && Indicates that the file is open by the function.
      *** Use the file and assign the index.
      USE &gcSysHome.SYDFILES ORDER TAG cFile_Nam IN 0 
    ELSE
      llSydFiles   = .F.
      SELECT SYDFILES
      lnSavFlsTg = VAL(SYS(21)) 
      SET ORDER TO TAG cFile_Nam   && Change the order
    ENDIF  

    IF !USED('SYDFIELD')  && Check if the internationals file is open or not.
      llSydField  = .T.     && Indicates that the file is open by the function.
      *** Use the file and assign the index.
      USE &gcSysHome.SYDFIELD ORDER TAG cFld_Name IN 0 
    ELSE
      llSydField       = .F.
      SELECT SYDFIELD
      lnSavFldTg = VAL(SYS(21)) 
      SET ORDER TO TAG cFld_Name    && Change the order
    ENDIF  

    DECLARE laFields[1,1]
    laFields   = " "

    lcFileTitl = ALLTRIM(LOOKUP(SYDFILES.cFile_Ttl, UPPER(ALLTRIM(lcSrchFile)),;
                                SYDFILES.cFile_Nam, 'cFile_Nam'))
    lcFields   = IIF(TYPE('lcFields') <> 'C' .OR. EMPTY(lcFields),;
                     STRTRAN(SYDFILES.mBrow_Fld, '|', ','), lcFields)
    
    =gfSubStr(lcFields, @laFields, ",")   
    FOR lnFieldNum = 1 TO ALEN(laFields,1)
      lcBrowFlds = lcBrowFlds + laFields[lnFieldNum]+;
                    [:H=']+ALLTRIM(LOOKUP(SYDFIELD.cFld_Head,;
                            UPPER(ALLTRIM(laFields[lnFieldNum])),;
                            SYDFIELD.cFld_Name,;
                            'cFld_Name'))+[',]
    ENDFOR
    lcBrowFlds  = SUBSTR(lcBrowFlds, 1, LEN(lcBrowFlds)-1)

    IF USED('SYDFILES')
      IF llSydFiles
        USE IN SYDFILES
      ELSE
        SET ORDER TO lnSavFlsTg IN SYDFILES
      ENDIF
    ENDIF

    IF USED('SYDFIELD')
      IF llSydField
        USE IN SYDFIELD
      ELSE
        SET ORDER TO lnSavFldTg IN SYDFIELD 
      ENDIF  
    ENDIF

    SELECT IIF(!EMPTY(lcCurAlias),(lcCurAlias),0)  
  ELSE
    llMayProceed = .F.
  ENDIF
ENDIF
   
RETURN llMayProceed

*!*************************************************************
*! Name      : gfLanguage
*! Developer : Mohamed Badran (MAB)
*! Date      : 03/09/98
*! Purpose   : Detect arabic mode.
*!*************************************************************
*! Calls     : 
*!             Procedures : None.
*!             Functions  : None.
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : Character - Mode of windows
*!*************************************************************
*! Example   : = gfLanguage()
*!*************************************************************
*! E300825,1 : Detect window language.
*!*************************************************************
FUNCTION gfLanguage
*B601996,1 Hesham (Start)
*B601996,1 in case of windows nt the system variable called windir
*B601996,1 does not appear for the run time library there for
*B601996,1 we have to distinguish between the nt and window 
*B601996,1 by the systemroot system variable
*lcWinDir   = GetEnv("WinDir") + "\"
lcWinDir   = GetEnv("WinDir") &&+ "\"
lcWinDir = IIF(EMPTY(lcWinDir),GetEnv("SystemRoot"),lcWinDir)+ "\"
llWinNt = IIF(EMPTY(GetEnv("SystemRoot")),.F.,.T.)
*-- If you find file arabic.cnt it means that you working under 
*-- Window NT Arabic version 
lcFullPath = SET('FULL')
SET FULLPATH ON
lcLanguage = 'E'
IF llWinNt AND  FILE(lcWinDir+"ARABIC.CNT") 
*B601996,1 Hesham (End)
    lcLanguage = "A"
ELSE  && Windows 95 or other. 
  IF FILE(lcWinDir + "Win.ini")
    CREATE CURSOR Winitial (mWinini M)
    APPEND BLANK
    APPEND MEMO mWinini FROM (lcWinDir + "Win.ini")  && Copy win.ini file to memo field.
    lcLanguage = IIF(ATC("[ARABIC",mWinini) = 0 , "E" , "A")
    USE IN Winitial
  ENDIF  
ENDIF
SET FULLPATH &lcFullPath
RETURN lcLanguage
*-- end of gfLanguage.



*!*************************************************************
*! Name      : gfTraceKey
*! Developer : Hesham El-Sheltawi (Hesham)
*! Date      : 03/30/98
*! Purpose   : Adding Record in the transaction tracing file
*!             For modification happed in specific data file
*!*************************************************************
*! Calls     : 
*!             Procedures : None.
*!             Functions  : None.
*!*************************************************************
*! Passed Parameters  : lcFileName   file that was modified
*!                      lcKeyExpr    key of the record modified
*!                      lcEventOccr  Event occurs on record "E,A,D"
*!*************************************************************
*! Returns            : None
*!*************************************************************
*! Example   : = gfTraceKey('INVHDR','INV#1','E')
*!*************************************************************
*!E300842,4 
*!*************************************************************
*! Modifications *E301058,1 11/01/1998 support multi companies system.
*!
FUNCTION gfTraceKey
*E301058,1 add new two parameters to update in multi companies system (From SM)[begin]
*PARAMETERS lcFileName,lcKeyExpr,lcEventOccr
PARAMETERS lcFileName,lcKeyExpr,lcEventOccr,lcUpdtDir,lcUpdtModl
*E301058,1 add new two parameters to update in multi companies system (From SM)[end]

IF TYPE('lcUpdtDir') $ 'UL' OR EMPTY(lcUpdtDir) OR TYPE('lcUpdtModl') $ 'UL' OR EMPTY(lcUpdtModl)
  lcUpdtDir  = gcDataDir
  lcUpdtModl = gcComp_Mdl
ENDIF

** If the communication module is not installed for the active company
** return

*E301058,1 Change (gcComp_Mdl to lcUpdtModl) to support multi-companies system
*IF ! ('CM' $ gcComp_Mdl)
IF ! ('CM' $ lcUpdtModl)
  RETURN
ENDIF
** end checking module existance
** define private variables used by the function
*E301058,1 I will open files in another alias avoiding using same name for another company. [Begin]

*PRIVATE lnAlias,llCMTRACE,llViewUsed,llViewSite
PRIVATE lnAlias
lnAlias = SELECT()            && save the active work area

*E301058,1 I will open files in another alias avoiding using same name for another company. [Begin]
*llCMTRACE  = USED('CMTRACE')  && check opening of CMTRACE FILE
*llViewUsed = USED('CMVIEWD')  && check opening of CMVIEWD FILE
*llViewSite = USED('CMSITVEW') && check opening of CMSITEVEW FILE 

** IF trans. tracing file was not opend then open it
*E301058,1 no codition wanted Open in another alias.
*IF !llCMTRACE
*E301058,1 Change (gcDataDir to lcUpdtDir) to support multi-companies system
  *USE (gcDataDir+'CMTRACE') IN 0 ORDER TAG CTRANS
USE (lcUpdtDir+'CMTRACE') IN 0 ORDER TAG CTRANS AGAIN ALIAS TRACE_ALIS
*ENDIF
** end IF trans.

** IF site views file was not opend then open it
*E301058,1 no codition wanted Open in another alias.
*IF !llViewSite
*E301058,1 Change (gcDataDir to lcUpdtDir) to support multi-companies system
  *USE (gcDataDir+'CMSITVEW') IN 0 ORDER TAG CVIEWID
USE (lcUpdtDir+'CMSITVEW') IN 0 ORDER TAG CVIEWID AGAIN ALIAS SITVW_ALIS
*ENDIF
** End IF site views

** IF view details file was not opend then open it
*E301058,1 no codition wanted Open in another alias.
*IF !llViewUsed
*E301058,1 Change (gcDataDir to lcUpdtDir) to support multi-companies system
  *USE (gcDataDir+'CMVIEWD') IN 0 ORDER TAG FILENAME
USE (lcUpdtDir+'CMVIEWD') IN 0 ORDER TAG FILENAME AGAIN ALIAS VIEW_ALIS
*ENDIF
** End IF view details 
*E301058,1 I will open files in another alias avoiding using same name for another company. [End]

lcFileName = PADR(UPPER(lcFileName),8)  && make the file name 8 char width
lcKeyExpr = lcKeyExpr+CHR(250)
*E301058,1 Change expresion to use new alias
*lcKeyExpr = PADR(lcKeyExpr,LEN(CMTRACE.CKEYEXPR))  && make the key expr 80 char width
lcKeyExpr = PADR(lcKeyExpr,LEN(TRACE_ALIS.CKEYEXPR))  && make the key expr 80 char width

*E301058,1 Change order to use new alias
*SET ORDER TO TAG CVIEWID IN CMSITVEW    
SET ORDER TO TAG CVIEWID IN SITVW_ALIS    

*E301058,1 Change relation to use new alias
*SELECT CMVIEWD
SELECT VIEW_ALIS
SET ORDER TO TAG FILENAME

*SET RELATION TO CVIEWID INTO CMSITVEW ADDI
SET RELATION TO CVIEWID INTO SITVW_ALIS ADDI

*E301058,1 Change select to use new alias
*SELECT CMTRACE
SELECT TRACE_ALIS
SET ORDER TO TAG CTRANS
** if the file we want to add record for exist in any user defined view
** and this view is selected for any site to send data for

*E301058,1 Change next command to use new alias
*IF SEEK(lcFileName,'CMVIEWD') AND !EOF(CMSITVEW)
IF SEEK(lcFileName,'VIEW_ALIS') AND !EOF('SITVW_ALIS')
  ** check the event occured on the record
  DO CASE
    ** if the event was add new record then add the record directly in
    ** the trans. tracing file
    CASE lcEventOccr = 'A'
      
     *E301058,1 Change insert to use new alias
     *INSERT INTO CMTRACE (CFILE_NAM,CKEYEXPR,CSTATUS);
     *            VALUES  (lcFileName,lcKeyExpr,lcEventOccr)
     INSERT INTO TRACE_ALIS (CFILE_NAM,CKEYEXPR,CSTATUS);
                    VALUES  (lcFileName,lcKeyExpr,lcEventOccr)

    ** otherwise if the event was delete or modify then             
    OTHERWISE
      ** check if there was a record added for the same file+key in the
      ** trans. tracing file
      IF SEEK(lcFileName+lcKeyExpr)
        ** if there was record for the file+key then
        DO CASE
          ** if the event was deleting a record and the record in the
          ** trans. tracing file was just added the delete the record
          ** from the trans. tracing file
          CASE lcEventOccr = 'D' AND CSTATUS = 'A'
            BLANK
            DELETE
          ** if the event was deleting a record and the record in the
          ** trans. tracing file was modied then change the status
          ** of the record in the trans. tracing file to deleted
          CASE lcEventOccr = 'D' AND CSTATUS = 'M'        
            REPLACE CSTATUS WITH 'D'
        ENDCASE
      ** else if there was no record for file+key in the trans. tracing
      ** file then add new record with status like the event passed for
      ** the function
      ELSE
       *E301058,1 Change insert to use new alias
        *INSERT INTO CMTRACE (CFILE_NAM,CKEYEXPR,CSTATUS);
        *            VALUES  (lcFileName,lcKeyExpr,lcEventOccr)
        INSERT INTO TRACE_ALIS (CFILE_NAM,CKEYEXPR,CSTATUS);
                       VALUES  (lcFileName,lcKeyExpr,lcEventOccr)
      ENDIF
  ENDCASE  
ENDIF
** clear relation on the site views file

*E301058,1 Change next command to use new alias
*SELECT CMVIEWD
SELECT VIEW_ALIS
*SET RELATION OFF INTO CMSITVEW
SET RELATION OFF INTO SITVW_ALIS

** if the trace file was opend by the function the close it

*E301058,1 I open file in another alias then will close it now not under condition [begin]

*IF !llCMTRACE
  *USE IN CMTRACE
USE IN TRACE_ALIS
*ENDIF
** end closing trace file

** if the sites view file was opend by the function the close it
*IF !llViewSite
  *USE IN CMSITVEW
USE IN SITVW_ALIS
*ENDIF
** end closing sites view file

** if the views details file was opend by the function the close it
*IF !llViewUsed
  *USE IN CMVIEWD
USE IN VIEW_ALIS
*ENDIF
** end closing views details file

** restore the current work area
SELECT (lnAlias)
*-- end of gfTraceKey.

*!*************************************************************
*! Name      : gfChkFile
*! Developer : Haytham El_Sheltawi
*! Date      : 05/11/98
*! Purpose   : 1) make sure that the needed files [The files
*!                needed by any global function or any program]
*!                is opened with the needed index tags after
*!                saving environment.
*!             
*!             2) restore the old environment.
*!             
*!*************************************************************
*! Calls     : 
*!             Procedures : None.
*!             Functions  : None.
*!*************************************************************
*! Passed Parameters  : llOpen       .T. to save env. and open file
*!                                   .F. to restore environment
*!                      
*!                      laFilsAray   reference to Array to hold the 
*!                                   needed files and index tags.
*!
*!           Note :     1) The array should be of dimension [X , 8]
*!                         where X : number of files to open
*!                      2) If llOpen = .T. the function will add
*!                         a new row to the array to save the
*!                         current alias
*!                         
*!  Array columns :  1 - File name [If its empty* this row will
*!                       be ignored].
*!                   2 - Index tag [If empty* the order will be
*!                       set to 0].
*!                   3 - Path [If .T. the system directory will
*!                       be used and if empty* the data directory
*!                       will be used if the file is not opened].
*!                       Path may also include a character expression
*!                       to hold a specific path to use
*!                       e.g. 'P:\SBTPRO\'
*!                   4 - Don't restore the old record pointer
*!                       [if .T. the function will not restore the
*!                       old record pointer].
*!                   5 - 8 these columns are used by the function.
*!                   
*!                   (* Or not of the correct type)
*!
*!*************************************************************
*! Returns            : 1) .F. If llOpen is not of type logic
*!                         or if laFilsAray is not an array.
*!                      2) .T. Otherwise.
*!*************************************************************
*! Example   : = gfChkFile(.T. , @laFiles)
*!*************************************************************
*!E300875,1 This function was add by HS for the Enhancement.
*!*************************************************************
*
FUNCTION gfChkFile

PARAMETERS llOpen , laFilsAray

PRIVATE laTmpArray , lnCount , lnRow , lnCol , lcFileTUse , lcPath ,;
        lcUserPath , lcUsedPath , lcUsedDbf , lcTagToUse , llRestrRec ,;
        lcOldDbf , lcSetFull , lnFileTUse

*--If llOpen is not of type logic or laFilsAray is not an array
IF TYPE('llOpen') <> 'L' .OR. TYPE('laFilsAray[1,1]') <> 'C'
  RETURN .F.
ENDIF    && End of IF TYPE('llOpen' <> 'L') .OR. TYPE('laFilsAray[1,1]' <> 'C')

*-- If the function is to open the needed files and to save environment
IF llOpen
  lcSetFull = SET('FULLPATH')      && Save the SET FULLPATH status
  SET FULLPATH ON
  
  *-- If the array dimension is not correct
  IF ALEN(laFilsAray , 2) < 8
    DIMENSION laTmpArray[ALEN(laFilsAray , 1) , 8]
    
    *-- For loop to scan the array rows
    FOR lnRow = 1 TO ALEN(laFilsAray , 1)
      
      *-- For loop to scan the array columns
      FOR lnCol = 1 TO ALEN(laFilsAray , 2)
        
        *-- Copy the elements from the array laFilsAray to the array
        *-- laTmpArray [For if we used the DIMENSION command and changed
        *-- the number of columns the elements will be moved from one
        *-- position to another]
        laTmpArray[lnRow , lnCol] = laFilsAray[lnRow , lnCol]
      ENDFOR    && End of FOR lnCol = 1 TO ALEN(laFilsAray , 2)
    ENDFOR    && End of FOR lnRow = 1 TO ALEN(laFilsAray , 1)
    
    DIMENSION laFilsAray[ALEN(laFilsAray , 1) , 8]
    =ACOPY(laTmpArray , laFilsAray)
  ENDIF    && End of IF ALEN(laFilsAray , 2) < 8
  
  *-- For loop to scan the array rows
  FOR lnCount = 1 TO ALEN(laFilsAray , 1)
    
    *-- Variable to hold the name of the file to be opened
    lcFileTUse = UPPER(ALLTRIM(laFilsAray[lnCount , 1]))
    
    laFilsAray[lnCount , 8] = ''
    
    *-- If lcFileTUse is of type character and not empty
    IF TYPE('lcFileTUse') = 'C' .AND. !EMPTY(lcFileTUse)
      
      *-- If the file is opened
      IF !USED(lcFileTUse)
        
        *-- Get the path that will be used to open the file
        lcPath = laFilsAray[lnCount , 3]
        lcPath = IIF(TYPE('lcPath') = 'C' , ALLTRIM(lcPath) ,;
                     IIF(TYPE('lcPath') = 'L' .AND. lcPath , gcSysHome ,;
                         gcDataDir))
        
        USE (lcPath + lcFileTUse) IN 0
        laFilsAray[lnCount , 5] = .T.          && Flag to know that the file was not opened befor
      ELSE    && Else [If the file is not opened]
        laFilsAray[lnCount , 5] = .F.          && Flag to know that the file was opened befor
        
        *-- Save the controlling index tag
        laFilsAray[lnCount , 6] = ORDER(lcFileTUse)
        
        *-- Save the record pointer position
        laFilsAray[lnCount , 7] = IIF(EOF(lcFileTUse) , 0 , RECNO(lcFileTUse))
        
        *-- Variable to hold the file path that was sent to the function
        lcUserPath = laFilsAray[lnCount , 3]
        lcUserPath = IIF(TYPE('lcPath') = 'C' , ALLTRIM(lcPath) ,;
                     IIF(TYPE('lcPath') = 'L' .AND. lcPath , gcSysHome , ''))
        
        *-- Variable to hold the file path of the file used with alias lcFileTUse
        lcUsedPath = SUBSTR(DBF(lcFileTUse) , 1 , AT('\' , DBF(lcFileTUse) ,;
                     OCCURS('\' , DBF(lcFileTUse))))
        
        *-- Variable to hold the name of the file used with alias lcFileTUse
        lcUsedDbf  = SUBSTR(DBF(lcFileTUse) , AT('\' , DBF(lcFileTUse) ,;
                     OCCURS('\' , DBF(lcFileTUse))) + 1)
        
        lcUsedDbf = STRTRAN(UPPER(lcUsedDbf) , '.DBF')
        
        *-- If the file that is used with alias lcFileTUse is not the
        *-- needed one
        IF UPPER(lcUsedPath) <> UPPER(lcUserPath) .OR. !(lcUsedDbf == lcFileTUse)
          
          *-- Save the name and path of the file that is used with
          *-- alias lcFileTUse
          laFilsAray[lnCount , 8] = DBF(lcFileTUse)
          
          lnSelect = SELECT(lcFileTUse)
          
          *-- Get the path that will be used to open the file
          lcPath   = laFilsAray[lnCount , 3]
          lcPath   = IIF(TYPE('lcPath') = 'C' , ALLTRIM(lcPath) ,;
                     IIF(TYPE('lcPath') = 'L' .AND. lcPath , gcSysHome ,;
                     gcDataDir))
          
          USE (lcPath + lcFileTUse) IN lnSelect
        ENDIF    && End of IF UPPER(lcUsedPath) <> UPPER(lcUserPath) .OR. !(lcUsedDbf == lcFileTUse)
      ENDIF    && End of IF !USED(lcFileTUse)
      
      *-- The index tag that will be used
      lcTagToUse = laFilsAray[lnCount , 2]
      lcTagToUse = IIF(TYPE('lcTagToUse') <> 'C' .OR. EMPTY(lcTagToUse) , '' ,;
                       'TAG ' + ALLTRIM(lcTagToUse))
      
      SET ORDER TO &lcTagToUse IN (lcFileTUse)
    ENDIF    && End of IF TYPE('lcFileTUse') = 'C' .AND. !EMPTY(lcFileTUse)
  ENDFOR    && End of FOR lnCount = 1 TO ALEN(laFilsAray , 1)
  
  *-- Save the current alias
  DIMENSION laFilsAray[ALEN(laFilsAray , 1) + 1 , 8]
  laFilsAray[ALEN(laFilsAray , 1) , 1] = SELECT(0)
  
  *-- Restore the SET FULLPATH status
  SET FULLPATH &lcSetFull

ELSE    && Else [If the function is to restore the old environment]
  
  *-- For loop to scan the array rows except the last one
  FOR lnCount = 1 TO ALEN(laFilsAray , 1) - 1
    
    *-- Variable to hold the name of the file
    lcFileTUse = UPPER(ALLTRIM(laFilsAray[lnCount , 1]))
    
    *-- Variable to hold the name and path of the file that was used with
    *-- alias lcFileTUse
    lcOldDbf   = laFilsAray[lnCount , 8]
    
    *-- If the file is opened
    IF TYPE('lcFileTUse') = 'C' .AND. !EMPTY(lcFileTUse) .AND. USED(lcFileTUse)
      
      *-- If the file is to be closed
      IF laFilsAray[lnCount , 5]
        USE IN (lcFileTUse)
      ELSE    && Else [If the file is not to be closed]
        
        *-- Flag to know if we are to restore the old record pointer position
        llRestrRec = laFilsAray[lnCount , 4]
        llRestrRec = IIF(TYPE('llRestrRec') <> 'L' , .T. , !llRestrRec)
        
        *-- If there is another file that was open with alias lcFileTUse
        IF !EMPTY(lcOldDbf)
          llRestrRec = .T.
          lnSelect = SELECT(lcFileTUse)
          
          *-- Reopen the old file
          USE (lcOldDbf) IN lnSelect
        ENDIF    && End of IF !EMPTY(lcOldDbf)
        
        *-- If we are to restore the old record pointer position
        IF llRestrRec
          
          *-- If the old record pointer position is end of file
          IF laFilsAray[lnCount , 7] = 0
            
            *-- If we are not at the end of the file
            IF !EOF(lcFileTUse)
              GO BOTTOM IN (lcFileTUse)
              SKIP 1 IN (lcFileTUse)
            ENDIF    && End of IF !EOF(lcFileTUse)
          ELSE    && Else [If the old record pointer position is not end of file]
            
            *-- Restore the old record pointer position
            GO laFilsAray[lnCount , 7] IN (lcFileTUse)
          ENDIF    && End of IF laFilsAray[lnCount , 7] = 0
        ENDIF    && End of IF llRestrRec
        
        *-- Restore the old controlling index tag
        SET ORDER TO laFilsAray[lnCount , 6] IN (lcFileTUse)
      ENDIF    && End of IF laFilsAray[lnCount , 5]
    ENDIF    && End of IF TYPE('lcFileTUse') = 'C' .AND. ... .AND. USED(lcFileTUse)
  ENDFOR    && End of FOR lnCount = 1 TO ALEN(laFilsAray , 1) - 1
  
  *-- Restore the old alias
  lnFileTUse = laFilsAray[ALEN(laFilsAray , 1) , 1]
  SELECT (lnFileTUse)
ENDIF    && End of IF llOpen

RETURN .T.

*!*************************************************************
*! Name      : gfChkForm							*E300871,4
*! Developer : Renee
*! Date      : 09/26/1998
*! Purpose   : Function to check if a report ID is a form or a 
*! 			   report, and return form name and settings if it is 
*! 			   a form
*!*************************************************************
*! Called from : Main report programs..
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : Form Major, Form name, settings array
*!   				   (passed by reference)	
*!*************************************************************
*! Example	      	 : IF gfChkForm(@lcRep_ID, @lcRepForm, @lcFrmSpSets)
*!*************************************************************
*!Modifications      :
*!B603450,1 HDM 2/14/2000 Remove the extra element in laAllSets
*!                        Array also remove data redunduncy
*!*************************************************************

FUNCTION gfChkForm
*C101389,1 Add parameter for an optional program name
*PARAMETERS lcRepID, lcFormName, laSettings, lcFrmSpSets, lIsFRXForm
*E301251,1 HDM [Start] Add a new parameter holds laSpecFrm to hold all available forms
*PARAMETERS lcRepID, lcFormName, laSettings, lcFrmSpSets, lIsFRXForm, lcOptProg
PARAMETERS lcRepID, lcFormName, laFrmSets, laSpecFrm , laAllSets
*E301251,1 HDM [End]
*C101389,1 end
PRIVATE lcTempFrHd, lcTempFrDt, lnCurAlias, llUseFrmHd, llUseFrmDt,;
		lnCounter, lcFormID, laSettings 

lnCurAlias = SELECT(0)
STORE '' TO lcTempFrHd, lcTempFrDt

llUseFrmDt = gfOpenFile(gcDataDir + 'FORMCDDT', 'FORMCDDT',;
						'SH', @lcTempFrDt, .T.)
llUseFrmHd = gfOpenFile(gcDataDir + 'FORMCDHD', 'FORMCDHD',;
						'SH', @lcTempFrHd, .T.)

*-- Remove this variable
*lIsFRXForm = .F.

*-- If a parameter is sent as a form major name, (passed from the menu)
IF TYPE('lcRepID') = 'C' .AND. SEEK(UPPER(LEFT(lcRepID,6)))
  *-- Get the form name
  *lcCurForm = cCurForm
  lcFormName = UPPER(ALLTRIM(cFormMaj) + ALLTRIM(cCurForm))

  *E301251,1 [Start] laFrmSets is now filled in the scan Section no need to
  *E301251,1         fill it here
  **-- Restore Form Setting Variables
  DECLARE laFrmSets[1,2]
  IF !EMPTY(mFormSets)
    RESTORE FROM MEMO mFormSets ADDITIVE
  ELSE
    laFrmSets = ''
  ENDIF
  *E301251,1 [End]
  
  *E301251,1 [Start] Move to the scan section
  *C101389,1 Restore an optional program name per form in lcOptProg
  *-- Return the actual report ID
  *STORE '' TO lcOptProg, lcFrmSpSets
  *SELECT (lcTempFrDt)
  *IF SEEK(lcFormName)
  *  lcRepID       = IIF(!EMPTY(cRep_ID), UPPER(PADR(ALLTRIM(cRep_ID), 8)), lcRepID)
  *  *C101389,1 Restore an optional program name per form
  *  lcOptProg     = ALLTRIM(cOptProg)
  *  *C101389,1 end
  *  *-- Restore Fixed settings per form
  *  IF !EMPTY(mFrmSpSets)
  *    lcFrmSpSets = ALLTRIM(mFrmSpSets)
  *  ENDIF  
  *  lIsFRXForm = lFRXForm
  *ENDIF

  *E301251,1 Scan the form codes header to fill laSpecFrm with all available forms
  *-- Declare an array to hold all avilable form's settings
  *-- laSpecFrm Map
  *-- laSpecFrm[1,1] , laSpecFrm[1,2] , laSpecFrm[1,3]    , laSpecFrm[1,4] , laSpecFrm[1,5]
  *-- Form Name      , Form ID        , Optional Prog.    , mFrmSpSets     , lFRXForm Val.
  
  *-- Declare arrays to hold all subforms Settings
  DECLARE laSpecFrm[1,5], laAllSets[1,3]
  STORE '' TO laSpecFrm, laAllSets
  lnCounter = 0
    
  SCAN REST WHILE CFORMMAJ = UPPER(LEFT(lcRepID,6))
     
    *-- Restore Form Setting Variables
    DECLARE laSettings[1,2]
    IF !EMPTY(mFormSets)
      RESTORE FROM MEMO mFormSets ADDITIVE
    ELSE
      laSettings = ''
    ENDIF
      
    *-- Re-Dimension laAllSets To include the new form's settings + old Settings
    IF !EMPTY(laSettings[1,1])
      *B603450,1 [START] Dimension the array inside the for loop
      *                  to void extra element adding
      * lnLoopStart = length of the laAllSets + 1
      *lnLoopStart = ALEN(laAllSets,1)
      lnLoopStart = IIF(ALEN(laAllSets,1) = 1 AND EMPTY(laAllSets[1,2]) ,;
                                            1 , ALEN(laAllSets,1) + 1)
      *DIMENSION laAllSets[ALEN(laAllSets,1) + ALEN(laSettings,1), 3]
      PRIVATE lnSetsElm
      lnSetsElm = 0
      *B603450,1 [End]

      FOR lnLoopCnt = lnLoopStart TO lnLoopStart + ALEN(laSettings,1) -1
        *B603450,1 [Start] Increase the laSettings Array Element Counter
        *                  Then Dimension the laAllSets Array
        *lnSetsElm = IIF(lnLoopCnt - lnLoopStart = 0, 1 , lnLoopCnt - lnLoopStart)
        lnSetsElm = lnSetsElm + 1
        DIMENSION laAllSets[lnLoopCnt,3]
        *B603450,1 [End]
        laAllSets[lnLoopCnt,1] = UPPER(PADR(cFormID,2))
        laAllSets[lnLoopCnt,2] = laSettings[lnSetsElm,1]
        laAllSets[lnLoopCnt,3] = laSettings[lnSetsElm,2]

      ENDFOR
    ENDIF
    
    *-- Get the form name
    lcFormID = UPPER(PADR(cFormMaj,6)) + UPPER(PADR(cCurForm,2)) + UPPER(PADR(cFormID,2))
    SELECT (lcTempFrDt)
      
    IF SEEK(lcFormID)
      *-- Get the optional program Name and restore fixed settings 
      *-- per form
      lnCounter = lnCounter + 1
      DIMENSION laSpecFrm[lnCounter,5]
      laSpecFrm[lnCounter,1] = &lcTempFrHd..cFormMaj + &lcTempFrHd..cCurForm
      laSpecFrm[lnCounter,2] = cFormID
      laSpecFrm[lnCounter,3] = ALLTRIM(cOptProg)
      laSpecFrm[lnCounter,4] = ALLTRIM(mFrmSpSets)
      laSpecFrm[lnCounter,5] = lFRXForm
    ENDIF
    SELECT (lcTempFrHd)
  ENDSCAN
  *B603450,1 [Start] Don't remove the last array element as its dimension is correct
  *IF ALEN(laAllSets,1) > 1
  *  DIMENSION laAllSets[ALEN(laAllSets,1) -1, 3]
  *ENDIF
  *B603450,1 [End]
  *-- E301251,1 HDM [End]
ELSE
  STORE SPACE(0) TO lcFormName
ENDIF  

*-- Close files if opened in this session
IF llUseFrmHd .AND. USED(lcTempFrHd)
  USE IN (lcTempFrHd)
ENDIF
IF llUseFrmDt .AND. USED(lcTempFrDt)
  USE IN (lcTempFrDt)
ENDIF

*-- Restore current alias
SELECT (lnCurAlias)
RETURN !EMPTY(lcFormName)


*!*************************************************************
*! Name      : lfUpFCode
*! Developer : AHMED Ibrahim
*! Date      : 11/22/1998
*! Purpose   : Function to update the Form Codes tables due to 
*!             form codes sysfiles for installed modules and existing 
*!             forms in the SYDREPRT
*! Reference : *E301065,1 AMM
*!*************************************************************
*! Called from : Main report programs..
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : lcMod_ID Module ID
*!                     lcDataDr Company ID
*!*************************************************************
*! Example	      	 : =lfUpFCode('AL','01')
*!*************************************************************
*!Modifications
*E301251,1 HDM 11/02/1999 While updaing form codes header file
*                         we have to take in consedration that
*                         header file may include more than one
*                         record for one MAJOR FORM
*!*************************************************************

FUNCTION lfUpFCode
PARAMETERS lcMod_ID,lcDataDr

IF FILE(lcDataDr+'FORMCDHD.DBF') .AND. FILE(lcDataDr+'FORMCDHD.DBF') 
  lnAlias = SELECT(0)
  lcFCDHD = gfTempName()
  lcFCDDT = gfTempName()
  USE (lcDataDr+'FORMCDHD.DBF') AGAIN ALIAS (lcFCDHD) ORDER TAG Formcdhd IN 0
  USE (lcDataDr+'FORMCDDT.DBF') AGAIN ALIAS (lcFCDDT) ORDER TAG Formcddt IN 0
  
  llrepop  = gfOpenFile(gcSysHome+'SYDREPRT','CREP_ID','SH')
  llFrDtOp = gfOpenFile(gcSysHome+'SYFRMCDD','FORMCDDT','SH')
  SET RELATION TO SYFrmCDD.CREP_ID INTO SYDREPRT ADDITIVE
    
  llFrHdOp = gfOpenFile(gcSysHome+'SYFRMCDH','FORMCDHD','SH')
  SET RELATION TO SYFrmcdh.cformmaj INTO SYFrmcdd ADDITIVE
  
  SCAN  
    *E301065,1 AMM Add records to dbfs' files
    llRecIns = .F.
    SELECT SYFRMCDD
    *E038033,1 HMA 04/03/2004 Select only Records belong to ARIA27 [BEGIN]
    *SCAN WHILE cformmaj = SYFrmcdh.cformmaj FOR lcMod_ID $ SYDREPRT.mCallMods
    SCAN WHILE cformmaj = SYFrmcdh.cformmaj FOR lcMod_ID $ SYDREPRT.mCallMods .AND. SYDREPRT.cVer<>"A40"
    *E038033,1 HMA [END]

      SCATTER MEMVAR MEMO
      IF SEEK(m.cformmaj+m.cformcode,lcFCDDT)
        SELECT (lcFCDDT)
        GATHER MEMVAR MEMO
      ELSE
        INSERT INTO (lcFCDDT) FROM MEMVAR
      ENDIF
      llRecIns = .T.
      SELECT SYFRMCDD
    ENDSCAN
    IF llRecIns 
      SELECT SYFRMCDH        
      SCATTER MEMVAR MEMO 
      *E301251,1 HDM [Start] Change the seek command to include subForm ID(cFormID)
      *E301251,1 HDM         as seconed part of the index
      *IF SEEK(SYFRMCDH.cformmaj,lcFCDHD)
      IF SEEK(SYFRMCDH.cformmaj + SYFRMCDH.cFormID,lcFCDHD)
      *E301251,1 HDM [End]
        SELECT (lcFCDHD)
        GATHER MEMVAR MEMO FIELDS EXCEPT cCurForm, mFormSets
      ELSE
        INSERT INTO (lcFCDHD) FROM MEMVAR
      ENDIF
    ENDIF
    SELECT SYFRMCDH    
  ENDSCAN    
  
  IF llrepop .AND. USED('SYDREPRT')     
    USE IN SYDREPRT
  ENDIF
  USE IN (lcFcdHd)
  USE IN (lcFcdDt)
  IF llFrHdOp .AND. USED('SYFRMCDH')
    USE IN SYFRMCDH
  ELSE
    SELECT SYFRMCDH
    SET RELATION TO
  ENDIF
  IF llFrDtOp .AND. USED('SYFRMCDD')
    USE IN SYFRMCDD
  ELSE
    SELECT SYFRMCDD
    SET RELATION TO
  ENDIF
  SELECT (lnAlias)
ENDIF

*!*************************************************************
*! Name      : gfToglErr
*! Developer : Hesham El-Sheltawi
*! Date      : 11/25/1998
*! Purpose   : function to togle error handler enabling
*!*************************************************************
*! Called from : Main Menu
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : None
*!*************************************************************
*! Example	      	 : gfToglErr()
*!*************************************************************
*E300797,1 Hesham (Start)
*E300797,1 function to enable and disable error handler
FUNCTION gfToglErr
glErrorHand = !glErrorHand
IF glErrorHand
    ON ERROR DO gfEHan WITH ERROR(), MESSAGE(), MESSAGE(1), ;
        SYS(16), LINENO(), SYS(102), SYS(100), SYS(101), LASTKEY(), ;
        ALIAS(), SYS(18), SYS(5), SYS(12), SYS(6), SYS(2003), WONTOP(), ;
        SYS(2011), SYS(2018), SET("CURSOR")
ELSE
  ON ERROR
ENDIF
IF !EMPTY(BAR()) AND !EMPTY(POPUP())
  SET MARK OF BAR BAR() OF (POPUP()) glErrorHand
ENDIF
*E300797,1 Hesham (End)

*!*************************************************************
*! Name      : gfAddCurSm
*! Developer : Haytham El-Sheltawi
*! Date      : 11/29/1998
*! Purpose   : Function to add the currency symbol to a numeric value
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : 1) Currency code.
*!                     2) Amount.
*!                     3) Number of decimal places.
*!*************************************************************
*! Example	      	 : =gfAddCurSm('USDLR' , 100.97 , 2)
*!*************************************************************
*E301078,1 HSS 11/29/98 Add this function.
*!*************************************************************
*
FUNCTION gfAddCurSm

PARAMETERS lcCurrCode , lnAmount , lnDecimals

IF TYPE('lnAmount') <> 'N' .OR. TYPE('lcCurrCode') <> 'C'
  RETURN ''
ENDIF
lnDecimals = IIF(TYPE('lnDecimals') <> 'N' , 0 , lnDecimals)

PRIVATE lnSelect , lcOldOrd , llCloseFil , lcReturn

lnSelect   = SELECT()

IF !USED('SYCCURR')
  llCloseFil = .T.
  SELECT 0
  USE &gcSysHome.SYCCURR ORDER TAG CCURRCODE
ELSE
  llCloseFil = .F.
  SELECT SYCCURR
  lcOldOrd = ORDER()
  SET ORDER TO TAG CCURRCODE
ENDIF

lcCurrCode = PADR(ALLTRIM(lcCurrCode) , LEN(cCurrCode))
IF lnDecimals <> 0
  lcReturn = STR(lnAmount , LEN(ALLTRIM(STR(lnAmount))) + lnDecimals + 1 ,;
                 lnDecimals)
  
ELSE
  lcReturn = ALLTRIM(STR(lnAmount))
ENDIF

IF SEEK(lcCurrCode)
  lcReturn = IIF(SET('CURRENCY') = 'LEFT' , ALLTRIM(cCurrSmbl) , '') +;
             lcReturn +;
             IIF(SET('CURRENCY') = 'LEFT' , '' , ALLTRIM(cCurrSmbl))
  
ENDIF

IF llCloseFil
  USE
ELSE
  SET ORDER TO (lcOldOrd)
ENDIF

SELECT (lnSelect)

RETURN lcReturn

*E301098,1 Hesham (Start)
*E301098,1 if user defined an env. data path then use it
*!*************************************************************
*! Name      : gfGetDataDir
*! Developer : Hesham El-Sheltawi
*! Date      : 12/16/1998
*! Purpose   : Function to return company data directory
*!*************************************************************
*! Calls       : None
*!*************************************************************
*! Passed Parameters : 1) company data dir
*!*************************************************************
*! Example	      	 : lcDataDir=gfGetDataDir(syccomp.ccom_ddir)
*!*************************************************************
*E301078,1 HSS 11/29/98 Add this function.
*!*************************************************************
*
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfGetDataDir
FUNCTION x_gfGetDataDir
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcDataDir
lcDataDir = ALLT(lcDataDir)
lcDataDir = lcDataDir+IIF(RIGHT(lcDataDir,1)='\','','\')

*B609556,3 TMI 03/31/2011 [Start] If this is SaaS then keep the same folder data path
IF FILE('CLIENTS.DBF')
  RETURN lcDataDir
ENDIF
*B609556,3 TMI 03/31/2011 [End  ] 

IF !EMPTY(gcDataEnv)
  lcDataDir = gcDataEnv+SUBSTR(lcDataDir,RAT('\',lcDataDir,2)+1)
ELSE
  PRIVATE lcSysPath,lcFullSet, lcOrgPath
  lcFullSet = SET('FULL')
  SET FULL ON
  *E301109,1 At installation, gcOrgPath is empty.
  *lcSysPath = UPPER(SUBSTR(gcOrgPath,1,ATC('\SYSFILES',gcOrgPath)))
  lcOrgPath = IIF(!EMPTY(gcOrgPath), gcOrgPath, gcSysHome)
  lcSysPath = UPPER(SUBSTR(lcOrgPath,1,ATC('\SYSFILES',lcOrgPath)))
  *E301109,1 end
  *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
  *IF lcSysPath = UPPER(SUBSTR(lcDataDir,1,LEN(lcSysPath)))
  *  lcDataDir = FULLPATH(SET('DEFAULT'))+SUBSTR(lcDataDir,LEN(lcSysPath)+1)
  *ENDIF
  *T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
  SET FULL &lcFullSet
ENDIF  
RETURN ALLTRIM(lcDataDir)


*E301077,1 Hesham (Start)
*!*************************************************************
*! Name      : gfCloseFile
*! Developer : Hesham 
*! Date      : 12/17/1998
*! Purpose   : To Close database file
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  : File Name
*!*************************************************************
*! Example            : =gfCloseFile('ORDHDR')
*!*************************************************************
*!*************************************************************
FUNCTION gfCloseFile
PARAMETER lcFileName
FOR lnFilePos = 1 TO ALEN(laFileName,1)
  IF ALLTRIM(laFileName[lnFilePos,1]) == ALLTRIM(lcFileName)
    EXIT
  ENDIF
ENDFOR
IF lnFilePos > ALEN(laFileName,1)
  lnFilePos = 0
ENDIF
IF lnFilePos > 0
  FOR lnFileElm = 1 TO ALEN(gaMnu_Fl,1)
    IF ALLTRIM(gaMnu_Fl[lnFileElm,1]) == ALLTRIM(laFileName[lnFilePos ,1])
      EXIT
    ENDIF
  ENDFOR
  IF lnFileElm > ALEN(gaMnu_Fl,1)
    lnFileElm = 0
  ENDIF
  IF lnFileElm > 0 
    lnRowNo = lnFileElm
    gaMnu_Fl[lnRowNo,4] = gaMnu_Fl[lnRowNo,4] - 1
    IF gaMnu_Fl[lnRowNo,5] ="P" .AND. USED(gaMnu_Fl[lnRowNo,1])
      USE IN (lcFileName)
    ENDIF
    IF gaMnu_Fl[lnRowNo,4]<=0 AND gaMnu_Fl[lnRowNo,5] ="P"
      =ADEL(gaMnu_Fl,lnRowNo)
      IF ALEN(gaMnu_Fl,1) > 1
        DECLARE gaMnu_Fl[ALEN(gaMnu_Fl,1) -1,ALEN(gaMnu_Fl,2)]
      ENDIF
    ENDIF  
  ENDIF
  =gfAdel(@laFileName,lnFilePos)
ENDIF




*E301077,78 Hesham (Start)
*!*************************************************************
*! Name      : gfSysOpen
*! Developer : Hesham
*! Date      : 02/22/1990
*! Purpose   : To open database needed by the program.
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Passed Parameters  : File Name, Index Tag, 
*!                          Open Mode "EX" ----> "EXCLUSIVE"
*!                                    "SH" ----> "SHARED"
*!*************************************************************
*! Returns            :  True  ----> If passed file is open by this function
*!                       False ----> If passed file is already open.
*!*************************************************************
*! Example            : =gfSysOpen(QDD+'ORDHDR',QDD+'ORDHDR','SH')
*!*************************************************************
*!*************************************************************

FUNCTION gfSysOpen

PARAMETERS NFILE,lcIndex,MODE,lcAliasNam,llForceOp

PRIVATE MODE,lcFileName,lcPath,llReturnVal,lcMsg
*E301316,1 [Start]
PRIVATE lcMacroSub
lcMacroSub=""
*E301316,1 [End..]

lcFileName  = IIF(ATC('\',nfile)<>0,SUBSTR(NFILE,RAT('\',nfile)+1),NFILE)
lcOpenMode  = IIF(TYPE('MODE')='C' AND MODE='EX', "EXCLUSIVE", "SHARED")
lcOrderTag  = IIF(TYPE('lcIndex')='C',SUBSTR(lcIndex,IIF('\' $ lcIndex,ATC('\',lcIndex,OCCURS('\',lcIndex)),0) +1),'') 

IF TYPE('lcAliasNam') <> 'C'
  lcAliasNam = lcFilename
ENDIF

lcMsg = 'Opening '+NFILE+IIF(EMPTY(lcIndex),'', ' Index Tag '+lcOrderTag)+'....'
lcMsg = PROPER(lcMsg)
lnCurRow = ROW()
lnCurCol = COL()
IF 'SCREEN' $ SYS(101)
  DO CASE
    CASE _DOS OR _UNIX
      lcActWin = WONTOP()
      ACTIVATE SCREEN
      @ 24,00 SAY gfMsgStr(lcMsg) COLOR &gcMsgClr
      IF !EMPTY(lcActWin)
        ACTIVATE WINDOW (lcActWin) 
      ENDIF  
    CASE _WINDOWS OR _MAC
      SET MESSAGE TO lcMsg
  ENDCASE
ENDIF

llReturnVal = .T.
lcFPathSt   = SET('FULLPATH')
SET FULLPATH ON
IF USED(lcFilename)
      *-- if forced open is not desired
      llReturnVal = .F.
      lcAliasNam  = ALLTRIM(STRTRAN(UPPER(lcFileName),".DBF"))
      *-- if there is no tag is desired to set order to
      IF EMPTY(lcOrderTag)
        SET ORDER TO 0 IN (lcAliasNam)
      ELSE
        SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
      ENDIF   &&IF EMPTY(lcOrderTag)
ELSE
  *-- if the file is not used
  lcAliasNam  = ALLTRIM(STRTRAN(UPPER(lcFileName),".DBF"))
  *E301316,1 [Start]
  *USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode
  lcMacroSub="USE (NFILE) ALIAS (lcAliasNam) AGAIN IN 0 &lcOpenMode"
  &lcMacroSub
  *E301316,1 [End..]
  IF !EMPTY(lcOrderTag)
    SET ORDER TO TAG lcOrderTag IN (lcAliasNam)
  ENDIF    &&IF !EMPTY(lcOrderTag)
ENDIF    &&IF IF USED(lcFilename)
SELECT (lcAliasNam)
SET FULLPATH &lcFPathSt
RETURN llReturnVal


FUNCTION gfSysClose
PARAMETERS lcFile
PRIVATE lnFilePos 

lnFilePos = 0
IF (TYPE('laFileName[1,1]')='C' AND !EMPTY(laFileName[1,1])) 
  FOR lnFilePos = 1 TO ALEN(laFileName,1)
    IF ALLTRIM(laFileName[lnFilePos,1]) == ALLTRIM(lcFile)
      EXIT
    ENDIF
  ENDFOR
  IF lnFilePos > ALEN(laFileName,1)
    lnFilePos = 0
  ENDIF
ENDIF
IF lnFilePos = 0 AND USED(lcFile)
  USE IN (lcFile)
ENDIF

*IF (TYPE('laFileName[1,1]')#'C' OR EMPTY(laFileName[1,1])) AND USED(lcFile)
*  USE IN (lcFile)
*ENDIF


*!*************************************************************
*! Name      : gfvOrdNote
*! Developer : Hossam El Etreby [HDM]
*! Date      : 03/18/1999
*! Purpose   : Function To call Notepad Program and passes its
*!             parameters
*!*************************************************************
*! Calls     : NotePad.PRG
*!*************************************************************
*! Passed Parameters  : NONE
*!*************************************************************
*! Returns            : NONE
*!*************************************************************
*! Called Form        : Control Pannel NotePad Button
*!*************************************************************
*! Example            : = gfvOrdNote()
*!*************************************************************
*! Due To Enh 301176,1
*!*************************************************************
FUNCTION gfvOrdNote
*-- B603060,1 [Start] Define a new private variable to be used in notepad calling
*PRIVATE lnPrevAl , lnStarPos , lnSepPos
PRIVATE lnPrevAl , lnStarPos , lnSepPos , lcNNoteKey
*-- B603060,1 [End]


*- These variables Defined And Filled By gfSetUp()
*- lcNoteType => Note Type [Charecter indicates the Note type eg. 'F' -> Style]
*- lcNoteKey  => Notepad Key that will besaved in sydFile if Not Found consider
*-               laKeyField instead
*- lcSydKey   => NotePadKey That Found in SydFiles.DBF

IF TYPE('lcSydKey')="C" AND !EMPTY(lcSydKey)
  *-- Start Collecting Paremeters From cNoteKey Field
  lnPrevAl   = SELECT(0)
  SELECT(lcBaseFile)
  lcNoteType = LEFT(ALLTRIM(lcSydKey),1)
  lcNoteKey  = SUBSTR(ALLTRIM(lcSydKey),2)
  IF ATC('*',lcNoteKey) <> 0
    lnStarPos = ATC('*',lcNoteKey)
    lnSepPos  = ATC('+',lcNoteKey)
    lcNoteKey = ALLTRIM(SUBSTR(lcNoteKey,lnSepPos+1))
  ENDIF
  lnLastPos = ATC('|',lcNoteKey)
  *--GET TAG NUMBER
  IF lnLastPos <> 0
    lnTagNo = gfGetTagNo(lcBaseFile,ALLTRIM(SUBSTR(lcNoteKey,lnLastPos + 1)))
    *lnTagNo   = INT(VAL(SUBSTR(lcNoteKey,lnLastPos + 1)))
    lcNoteKey = SUBSTR(lcNoteKey,1,lnLastPos - 1)
  ENDIF

  *-- B603060,1 [Start] Assign lcNoteKey value to lcNNoteKey and use it in the notepad calling
  *lcNoteKey  = &lcNoteKey
  lcNNoteKey = &lcNoteKey
  
  *--Call Notepad Using the collected Parameters
  *= NotePad(lcNoteType , lcNoteKey)
  = NotePad(lcNoteType , lcNNoteKey)
  *-- B603060,1 [End]
  
  SELECT(lnPrevAl)
ENDIF

*B602746,1 MAN 4/5/99 Call Function to release browse windows
*!*************************************************************
*! Name      : gfClrBro
*! Developer : Mohamed Abdel Salam
*! Date      : 04/05/99
*! Purpose   : 
*!*************************************************************
*! Calls     : 
*!             Procedures :
*!             Functions  :
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : 
*!*************************************************************
*! Example   : =gfClrBro()
*!*************************************************************
*
FUNCTION gfClrBro

IF TYPE("laFromBrow[1]") = "C"
  FOR i = 1 TO ALEN(laFromBrow,1)
    IF !EMPTY(laFromBrow[i,1])
      RELEASE WINDOW (laFromBrow[i,1])
    ENDIF  
  ENDFOR
ENDIF

*!*************************************************************
*! Name      : gfRunFxPrg
*! Developer : Hesham El-Sheltawi
*! Date      : 04/13/1999
*! Purpose   : Function To run fix programs before update file
*!             structure and to update the sydfxprg file
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : lcModToRun    Module ID to run its fix prgs
*!*************************************************************
*! Returns            : NONE
*!*************************************************************
*! Called Form        : gfupdmodul
*!*************************************************************
*! Example            : = gfRunFxPrg('AP')
*!*************************************************************
*! Due To E301199,1
*!*************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*FUNCTION gfRunFxPrg
FUNCTION x_gfRunFxPrg
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 

*++NAD40
*PARAMETERS lcModToRun
PARAMETERS lcModToRun , llRunAfter
*++NAD40


*-- if the module id that we pass is not the SM module then we are running
*-- data fix programs
*B609580,2 TMI 05/10/2011 [Start] whether gcAppHome is defined or not, gcAppHome should be the same as the path of AAS_WIN.EXE
*B609580,2                        exactly as the value built in the SYCINST and retrived later in the normal run
*IF TYPE('gcAppHome')#'C'
*  gcAppHome = STRTRAN(UPPER(gcSysHome),'\SYSFILES\','\PRGS\')
*ENDIF
gcAppHome = FULLPATH('')+'PRGS\'
*B609580,2 TMI 05/10/2011 [End  ] 
gcFxPrgDir = gcAppHome+'SM\'
*-- if the module we are updating does not have the file than hold fix programs
IF !FILE(gcSysHome+lcModToRun+'DFXPRG.DBF')
  RETURN
ENDIF
*-- if the system file than hold fix programs does not exit in the system path
*-- directory then copy the module fix programs file
IF !FILE(gcSysHome+'SYDFXPRG.DBF')
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.DBF') TO (gcSysHome+'SYDFXPRG.DBF')
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.FPT') TO (gcSysHome+'SYDFXPRG.FPT')  
  COPY FILE (gcSysHome+lcModToRun+'DFXPRG.CDX') TO (gcSysHome+'SYDFXPRG.CDX')  
ENDIF

*B603392,1 Hesham (Start)
*B603392,1 Open application file
llOpenApp = .F.
llMdFreshInst = .T.  
IF !llFreshInst AND !USED('SYDAPPL')
  SELECT 0 
  USE (gcSysHome+"SYDAPPL") ORDER TAG  CAPP_ID  EXCL
  llOpenApp = .t.      
  llMdFreshInst = !SEEK(lcModToRun,"SYDAPPL")  
ENDIF  

*B603392,1 Hesham (End)

*-- if not fresh installation then start running the fix programs
DIMEN laFxPrg[1,4]
STORE '' TO laFxPrg
*B603392,1 Hesham (Start)
*B603392,1 Check if moule we are running fix programs for is
*B603392,1 not a fresh installation
IF !llMdFreshInst
*IF !llFreshInst
*B603392,1 Hesham (End)
  *-- open the system fix programs file
  USE (gcSysHome+'SYDFXPRG') IN 0 ORDER TAG COBJECTID
  *-- open the installed module fix program file
  USE (gcSysHome+lcModToRun+'DFXPRG') IN 0 AGAIN ALIAS FLFLDPRG ORDER TAG COBJECTTYP
  SELECT 0
  USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ALIAS PRGFILE ORDER TAG COBJECTTYP
  lcPrgAlias = lcModToRun+'DFXPRG'
  SET RELATION TO COBJECTID+COBJECTTYP INTO FLFLDPRG ADDI
  SELECT 0
 
  *++NAD40
  *USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ORDER TAG COBJECTTYP
  IF USED(lcModToRun+'DFXPRG')
    SELECT (lcModToRun+'DFXPRG')
    SET ORDER TO COBJECTTYP
    LOCATE
  ELSE
    USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ORDER TAG COBJECTTYP
  ENDIF
  *++NAD40
 
  *-- build relation to the system fix program file
  SET RELATION TO COBJECTID INTO SYDFXPRG ADDI
  SET RELATION TO COBJECTID+'File' INTO PRGFILE ADDI
  *-- if there is any program information exist in the module fix programs file 
  IF SEEK(SPACE(10)+'Program')
    *-- scan through the records that hold fix programs in the installed module
    *++NAD40
    *SCAN REST WHILE CPARENTID+COBJECTTYP = SPACE(10)+'Program'
    SCAN REST WHILE CPARENTID+COBJECTTYP = SPACE(10)+'Program' FOR ;
              IIF(TYPE(lcPrgAlias+'.LRUNAFTER')="L",&lcPrgAlias..LRUNAFTER = llRunAfter,.T.)
    *++NAD40
    
      *-- if the the fix program was not deleted and the program was not runned before
      *-- or the fix program is installed for the first time
      IF (CSTATUS<>'D' AND !SYDFXPRG.LPRGRUN) OR EOF('SYDFXPRG')
        llRunData = CUPGRDLVL = 'A'
        *-- if the fix program exist
        IF FILE(gcFxPrgDir+ALLT(COBJECTNAM)+'.FXP') 
          *-- redimention the array that hold the fix programs to be run
          IF !EMPTY(laFxPrg[1,1])
            DIMEN laFxPrg[ALEN(laFxPrg,1)+1,ALEN(laFxPrg,2)]
          ENDIF
          *-- variable to hold the companies that the fix program can run on it's data
          lcCompToRun = ''
          SELECT PRGFILE
          *-- check if there is any data files the program need to check for existence
          llFound = !SEEK(&lcPrgAlias..COBJECTID+'File ')
          llTagErr = .F.
          lcCompToRun = ''
          lcOnErr = ON('ERROR')
          llTagErr = .F.
          ON ERROR llTagErr = .T.
          *-- loop through the comapanies installed if we are running a data fix programs
          *-- if we are running a system fix programs then loop only one time
          IF llRunData 
            IF EMPTY(laCompany[1,1])
              LOOP
            ENDIF
          ENDIF  
          FOR lnCount = 1 TO IIF(llRunData,ALEN(laCompany,1),1)
            =SEEK(&lcPrgAlias..COBJECTID+'File ')
            *-- scan through all files need by the fix program
            SCAN REST WHILE CPARENTID+COBJECTTYP = &lcPrgAlias..COBJECTID+'File '
              IF CSTATUS='D'
                LOOP
              ENDIF
              *-- if the file needed by the fix program exist then check the fields
              *-- and indexes
              IF FILE(IIF(llRunData,ALLT(laCompany[lnCount,2]),gcSysHome)+ALLT(COBJECTNAM)+'.DBF')
                SELECT FLFLDPRG
                *-- if there is any field or index needed to be checked in the file structure
                IF SEEK(PRGFILE.COBJECTID)
                  *-- if the data file used then close it
                  IF USED(ALLT(PRGFILE.COBJECTNAM))
                    USE IN (ALLT(PRGFILE.COBJECTNAM))
                  ENDIF
                  *-- open the data or system file needed by the fix program
                  USE (IIF(llRunData,ALLT(laCompany[lnCount,2]),gcSysHome)+ALLT(PRGFILE.COBJECTNAM)+'.DBF') IN 0
                  SELECT FLFLDPRG
                  llTagErr = .F.
                  *--scan through the fields and indexes needed by the file that the fix program
                  *--need to be in the file structure
                  SCAN REST WHILE CPARENTID+COBJECTTYP = PRGFILE.COBJECTID
                    IF CSTATUS='D'
                      LOOP
                    ENDIF
                    SELECT (ALLT(PRGFILE.COBJECTNAM))
                      *--check if the field or index exist in the file structure
                      DO CASE
                        CASE FLFLDPRG.COBJECTTYP = 'Field'
                          llTagErr = TYPE(ALLT(PRGFILE.COBJECTNAM)+'.'+ALLT(FLFLDPRG.COBJECTNAM))='U'
                        CASE FLFLDPRG.COBJECTTYP = 'Index'
                          SET ORDER TO TAG (ALLT(FLFLDPRG.COBJECTNAM))
                          IF !llTagErr AND !EMPTY(FLFLDPRG.COBJECTEXP)
                            llTagErr = UPPER(SYS(14,VAL(SYS(21))))<>UPPER(ALLT(FLFLDPRG.COBJECTEXP))
                          ENDIF
                      ENDCASE
                    *-- if there is any field or index does not exist in the file structure then
                    *-- exit and dont check for the rest  
                    IF llTagErr
                      EXIT
                    ENDIF
                  ENDSCAN
                  *-- close the data or system file needed by the fix program
                  IF USED(ALLT(PRGFILE.COBJECTNAM))
                    USE IN (ALLT(PRGFILE.COBJECTNAM))
                  ENDIF
                ENDIF  
              *-- if the data or system file needed by the fix program  does not
              *-- exist then notify the program that this fix program cannot be run
              ELSE  
                llTagErr = .T.
              ENDIF
              *-- if the fix program can not be run for any reason  like the file
              *-- we are checking does not exist or a field needed in the file
              *-- structure does not exist then do not check the rest of file 
              IF llTagErr
                EXIT
              ENDIF
            ENDSCAN            
            *-- if the files and file structure needed by the fix program is ok
            *-- then add the company id to the companies that we can run the fix
            *-- program on it's data
            IF !llTagErr
              lcCompToRun = lcCompToRun+IIF(EMPTY(lcCompToRun),'',',')+IIF(llRunData,LEFT(laCompany[lnCount,1],2),'SYSTEM')
            ENDIF
          ENDFOR
          ON ERROR &lcOnErr
          *-- IF The fix program can be runing on any company or on the system files
          *-- then add the program name and id to the fix programs list needed to be run 
          IF NOT EMPTY(lcCompToRun) &&!llTagErr 
            laFxPrg[ALEN(laFxPrg,1),1] = &lcPrgAlias..COBJECTID
            laFxPrg[ALEN(laFxPrg,1),2] = ALLT(&lcPrgAlias..COBJECTNAM)
            laFxPrg[ALEN(laFxPrg,1),3] = llRunData
            laFxPrg[ALEN(laFxPrg,1),4] = IIF('SYSTEM' $ lcCompToRun,'',lcCompToRun)
          ELSE
             *--Ramy
            IF ALEN(laFxPrg,1) > 1
              DIMEN laFxPrg[ALEN(laFxPrg,1)-1,ALEN(laFxPrg,2)]
            ENDIF  
          ENDIF  
        ENDIF
      ENDIF
    ENDSCAN
  ENDIF
  *-- close the fix programs files  
  IF USED('SYDFXPRG')
    USE IN SYDFXPRG
  ENDIF  

  IF USED('FLFLDPRG')
    USE IN FLFLDPRG
  ENDIF  

  IF USED('PRGFILE')
    USE IN PRGFILE
  ENDIF  
  *-- if there is any programs in the fix program list 
  
  IF !EMPTY(laFxPrg[1,1])
    *--loop through the fix programs needed to be run
    FOR lnFxPrg = 1 TO ALEN(laFxPrg,1)
      *-- loop through the companies installed in the system or just once if we are
      *-- running a system fix programs
      IF laFxPrg[lnFxPrg,3]
        IF EMPTY(laCompany[1,1])
          LOOP
        ENDIF
      ENDIF  
      FOR lnCount = 1 TO IIF(laFxPrg[lnFxPrg,3],ALEN(laCompany,1),1)
        *-- check if the company exist in the fix program list
        IF IIF(laFxPrg[lnFxPrg,3],LEFT(laCompany[lnCount,1],2) $ laFxPrg[lnFxPrg,4],.T.)
          *-- run the fix program and pass the system files dir. or the data path to it 
          DO (gcFxPrgDir+laFxPrg[lnFxPrg,2]) WITH IIF(laFxPrg[lnFxPrg,3],ALLT(laCompany[lnCount,2]),gcSysHome)
        ENDIF
      ENDFOR
    ENDFOR
  ENDIF
ENDIF

*B603392,1 Hesham (Start)
*B603392,1 Close application file
IF llOpenApp 
  USE IN SYDAPPL
ENDIF  
*B603392,1 Hesham (End)

*-- open the fix programs system file again
USE (gcSysHome+'SYDFXPRG') IN 0 ORDER TAG COBJECTID
SELECT 0
USE (gcSysHome+lcModToRun+'DFXPRG') AGAIN ALIAS MDFXPRG ORDER TAG COBJECTID
SET RELATION TO COBJECTID INTO SYDFXPRG ADDI
*--scan through all objects in the installed module fix programs file
SCAN
  *-- if the object does not exist in the system file that hold the fix programs info.
  *-- then add it to the system file
  IF EOF('SYDFXPRG')
    SCATT FIELDS EXCEPT LPRGRUN MEMVAR MEMO
    INSERT INTO SYDFXPRG FROM MEMVAR
  *-- if the object exist in the system file that hold the fix programs info.  
  *-- then change the status with the installed module object status
  ELSE
    SELECT SYDFXPRG
    REPLACE SYDFXPRG.CSTATUS WITH MDFXPRG.CSTATUS
  ENDIF
ENDSCAN
*-- if there is any fix programs in the list
IF !EMPTY(laFxPrg[1,1])
  SELECT SYDFXPRG
  FOR lnFxPrg = 1 TO ALEN(laFxPrg,1)
    *-- change the system file to now in the next upgrade that this program
    *-- was run before
    IF SEEK(laFxPrg[lnFxPrg,1])
      REPLACE LPRGRUN WITH .T.
    ENDIF
  ENDFOR
ENDIF

*-- close the fix programs files
IF USED('SYDFXPRG')
  USE IN SYDFXPRG
ENDIF  
IF USED('MDFXPRG')
  USE IN MDFXPRG
ENDIF
*!*************************************************************
*! Name      : gfGetTagNo
*! Developer : Hossam El Etreby [HDM]
*! Date      : 04/15/1999
*! Purpose   : Function to get tag number for specific file 
*!             using desired tag
*!*************************************************************
*! Calls     : -----
*!*************************************************************
*! Passed Parameters  : lcPFile , lcPTag
*!*************************************************************
*! Returns            : Tag Number
*!*************************************************************
*! Called Form        : 
*!*************************************************************
*! Example            : = gfGetTagNo('customer','customer')
*!*************************************************************
*! Due To Enh 301176,1
*!*************************************************************

FUNCTION gfGetTagNo
PARAMETER lcPFile , lcPOrder
PRIVATE lnPrevAlias , lcPrevOrd , lcFileOrd , lnRetVal

*--Save Original File Invironment
lnPrevAlias = SELECT(0)

*--Save Parameter file Environment
SELECT(lcPFile)
lcFileOrd = ORDER()

*--Start getting the tag Number
SET ORDER TO &lcPOrder
lnRetVal = VAL(SYS(21))

*--RESTORE Parameter file Environment
SET ORDER TO &lcFileOrd

*--Restore Original File Invironment
SELECT(lnPrevAlias)

RETURN (lnRetVal)

*!*************************************************************
*! Name      : gfvUsrFld
*! Developer : Hesham El_Sheltawi
*! Date      : 03/23/1999
*! Purpose   : Function To call option grid to define user
*!             defined fields values
*!*************************************************************
*! Calls     : GFOPGRID.PRG
*!*************************************************************
*! Passed Parameters  : NONE
*!*************************************************************
*! Returns            : NONE
*!*************************************************************
*! Called Form        : Control Pannel User defined fields Button
*!*************************************************************
*! Example            : = gfvUsrFld()
*!*************************************************************
*! Due To C101459,1
*!*************************************************************

FUNCTION gfvUsrFld
=gfOpGrid(SUBSTR(gcBaseWind,4),.T.,IIF(laScrMode[2],'X','T')+'P')


*!*************************************************************
*! Name      : gfVldUsrFld
*! Developer : Hesham El_Sheltawi
*! Date      : 04/19/1999
*! Purpose   : Function to Validate User define fields Values
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Passed Parameters  : laPrUsrFields Array
*!*************************************************************
*! Returns            : Logical 
*!*************************************************************
*! Called Form        : gfOpGrid , Control panel save
*!*************************************************************
*! Example            : = gfVldUsrFld(@laUsrFields)
*!*************************************************************
*! Due To C101459,1
*!*************************************************************
FUNCTION gfVldUsrFld
PARAMETERS laPrUsrFields
PRIVATE lnCount,llValid,lnAlias
lnAlias = SELECT()
SELECT 0
llValid = .T.
FOR lnCount = 1 TO ALEN(laPrUsrFields,1)
  IF !EMPTY(laPrUsrFields[lnCount,8])
    lcFldName = laPrUsrFields[lnCount,1]
    PRIVATE &lcFldName
    &lcFldName = laPrUsrFields[lnCount,6]
    *B604098,1 AMH Cutting the when function bart from the valid str. [Start]
    *llValid = EVAL(ALLT(STRTRAN(laPrUsrFields[lnCount,8],ALLT(laPrUsrFields[lnCount,1]),'m.'+ALLT(laPrUsrFields[lnCount,1]))))
    lnWhenPos = AT('WHEN',laPrUsrFields[lnCount,8])
    lcValid = SUBSTR(laPrUsrFields[lnCount,8],1,IIF(lnWhenPos=0,LEN(laPrUsrFields[lnCount,8]),lnWhenPos-1))
    llValid = EVAL(ALLT(STRTRAN(lcValid,ALLT(laPrUsrFields[lnCount,1]),'m.'+ALLT(laPrUsrFields[lnCount,1]))))
    *B604098,1 AMH [End]

    IF !llValid
      lcErrMessage = "User defined field ("+ALLT(laPrUsrFields[lnCount,9])+") is not valid."+CHR(13)+CHR(10)+;
                     "Value must be "+ALLT(STRTRAN(laPrUsrFields[lnCount,8],laPrUsrFields[lnCount,1],ALLT(laPrUsrFields[lnCount,9])))
      =gfModalGen(.F.,.F.,.F.,.F.,lcErrMessage)
      EXIT
    ENDIF
  ENDIF
ENDFOR
SELECT (lnAlias)
RETURN llValid

*!********************************************************************
*! Name      : gfAmntDisp
*! Developer : Mohamed Hassan
*! Date      : 12/26/95
*! Purpose   : Return the amount according to the display condition.
*!********************************************************************
*! Parameters: lnAmount     && The amount that you want to display.
*!           : lcRpDispCur  && The way to display the amount.
*!           : ldExRateDt   && If you are going to display the amount
*!           :                 with an exchange rate of a specific date.
*!           : lcTmepFile   && The temp file name that hold the temp. 
*!           :                 exchange rates.
*!           : llAprvCurr   && If you are using the Approved currency.
*!********************************************************************
*! Call      : From all the AP reports that is using the currency display
*!           : feature.
*!********************************************************************
*! Returns   : lnAmount
*!********************************************************************
*! Example   : gfAmntDisp(APINVHDR.NINVAMNT,lcRpCurr,ldRpExDate,lcRpTmpNam,.F.).
*!********************************************************************
*E301214,1   : MAB 05/06/1999 .
*E301214,1   : Transfer this function from AP Module and AR Module to be a global function.
*B603186,1 ADEL09/11/2000 Avoid dividing by 0 when canculating amount with diff currency.
**********
FUNCTION gfAmntDisp
*E301265,1 Add new parameter detect which alias we get currency values from it.
*PARAMETER lnAmount,lcRpDispCur,ldExRateDt,lcTmepFile,llAprvCurr

*B603891,1 ABD 09/28/2000 Add new parameter detect which Field we get currency values from it. [Begin]
*PARAMETER lnAmount,lcRpDispCur,ldExRateDt,lcTmepFile,llAprvCurr,lcGetFile
*PRIVATE lnAmount,lcRpDispCur,ldExRateDt,lcTmepFil,llAprvCurr,lcExSin1,lcExSin2,lnSavAlias
PARAMETER lnAmount,lcRpDispCur,ldExRateDt,lcTmepFile,llAprvCurr,lcGetFile,lcGetField
PRIVATE lnAmount,lcRpDispCur,ldExRateDt,lcTmepFil,llAprvCurr,lcExSin1,lcExSin2,lnSavAlias,lcGetField
*B603891,1 ABD [End]


lnAmount    = IIF(TYPE('lnAmount') = 'N',lnAmount,0)
lcRpDispCur = IIF(TYPE('lcRpDispCur') ='C',lcRpDispCur,'')
ldExRateDt  = IIF(TYPE('ldExRateDt') = 'D',ldExRateDt,{})
lcTmepFile  = IIF(TYPE('lcTmepFile') = 'C',lcTmepFile,'')
llAprvCurr  = IIF(TYPE('llAprvCurr') = 'L',llAprvCurr,.F.)

lcExSin1    = ''       && Variable to hold the first sign in the equation.
lcExSin2    = ''       && Variable to hold the second sign in the equation.

*E301214,1 Save current alias [Begin]
*lcSavAlias  = ALIAS()  && Variable to save the alias.
lnSavAlias  = SELECT(0)  && Variable to save the alias.
lcGetFile   = IIF(TYPE('lcGetFile')$"UL",'',lcGetFile)
*E301214,1 Save current alias [End  ]

*B603891,1 ABD Add new flag to detect if filed currency have send . [Begin]
lcGetField  = IIF(TYPE('lcGetField') ='C',lcGetField,'')
*B603891,1 ABD [End]

DO CASE
  CASE lcRpDispCur = 'F'

  CASE lcRpDispCur = 'O'
    *E301265,1 Add code for another file [Begin]
    IF EMPTY(lcGetFile)
      lcCurrCode = IIF(llAprvCurr,CAPRCURCOD,CCURRCODE)
    ELSE
      *B603891,1 ABD Get filed currency if send . [Begin]
      *lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,&lcGetFile..CCURRCODE)
       lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,;
                   IIF(EMPTY(lcGetField),&lcGetFile..CCURRCODE,EVAL(lcGetFile+'.'+lcGetField)))
      *B603891,1 ABD [End]
    ENDIF  
    *E301265,1 Add code for another file [End  ]

    lcExSin2   = ' '
    lcExSin1   = gfGetExSin(@lcExSin2,lcCurrCode)

    *B601526,1 Add this lines to get the Exchange rate and the number of units
    lnExRate = 0

    *E301265,1 Add code for another file [Begin]
    IF EMPTY(lcGetFile)
      IF ALIAS()='APINVAHD'
        lnUnit = 1
        lnExRate = 1
      ELSE
        lnUnit = NCURRUNIT
        lnExRate = IIF(llAprvCurr , gfChkRate('lnUnit' , lcCurrCode , DINVDATE , .F.) , NEXRATE)
      ENDIF
    ELSE
      lnUnit = &lcGetFile..NCURRUNIT
      lnExRate = IIF(llAprvCurr , gfChkRate('lnUnit' , lcCurrCode , &lcGetFile..DINVDATE , .F.) , &lcGetFile..NEXRATE)
    ENDIF  
    *E301265,1 Add code for another file [End  ]

    lnExRate = IIF(lnExRate <> 0 , lnExRate , 1)
    *B603186,1 (Begin) Avoid dividing by 0 when canculating amount with diff currency.
    *lnUnit = IIF(lnExRate <> 0 , lnUnit , 1)
    lnUnit = IIF(lnUnit <> 0 , lnUnit , 1)
    *B603186,1 (End)
    
    *B601526,1 Add this lines [End]
    
    *B601526,1 Change this line [Begin]
    *lnAmount   = ROUND(lnAmount &lcExSin1 IIF(llAprvCurr,NAPREXRAT,NEXRATE) &lcExSin2 IIF(llAprvCurr,NAPRCURUNT,NCURRUNIT),2)
    lnAmount   = ROUND(lnAmount &lcExSin1 lnExRate &lcExSin2 lnUnit , 2)
    *B601526,1 Change this line [End]

  CASE lcRpDispCur = 'D'
    lnExRate   = 0
    lnUnit     = 0
    
    *E301265,1 Add code for another file [Begin]
    IF EMPTY(lcGetFile)
      lcCurrCode = IIF(llAprvCurr,CAPRCURCOD,CCURRCODE)
    ELSE
      *B603891,1 ABD Get filed currency if send . [Begin]
      *lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,&lcGetFile..CCURRCODE)
      lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,;
                   IIF(EMPTY(lcGetField),&lcGetFile..CCURRCODE,EVAL(lcGetFile+'.'+lcGetField)))
      *B603891,1 ABD [End]
    ENDIF
    *E301265,1 Add code for another file [End  ]
      
    IF lcCurrCode = gcBaseCurr
      lnExRate = 1
      lnUnit   = 1
    ELSE

      *B601526,1 Change this line [Begin]
      *lnExRate   = gfChkRate('lnUnit',CCURRCODE,ldExRateDt,.F.)
      lnExRate   = gfChkRate('lnUnit',lcCurrCode,ldExRateDt,.F.)
      *B601526,1 Change this line [Begin]

    ENDIF

    *B601526,1 Add this lines [Begin]
    lnExRate = IIF(lnExRate <> 0 , lnExRate , 1)
    *B603186,1 (Begin) Avoid dividing by 0 when canculating amount with diff currency.
    *lnUnit = IIF(lnExRate <> 0 , lnUnit , 1)
    lnUnit = IIF(lnUnit <> 0 , lnUnit , 1)
    *B603186,1 (End)
    *B601526,1 Add this lines [End]

    lcExSin2   = ' '
    lcExSin1   = gfGetExSin(@lcExSin2,lcCurrCode)
    lnAmount   = ROUND(lnAmount &lcExSin1 lnExRate &lcExSin2 lnUnit,2)

  CASE lcRpDispCur = 'U'

    lnExRate   = 0
    lnUnit     = 0
    
    *E301265,1 Add code for another file [Begin]
    IF EMPTY(lcGetFile)
      lcCurrCode = IIF(llAprvCurr,CAPRCURCOD,CCURRCODE)
    ELSE
      *B603891,1 ABD Get filed currency if send . [Begin]
      *lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,&lcGetFile..CCURRCODE)
      lcCurrCode = IIF(llAprvCurr,&lcGetFile..CAPRCURCOD,;
                   IIF(EMPTY(lcGetField),&lcGetFile..CCURRCODE,EVAL(lcGetFile+'.'+lcGetField)))
      *B603891,1 ABD [End]
    ENDIF  
    *E301265,1 Add code for another file [End  ]

    IF lcCurrCode = gcBaseCurr
      lnExRate = 1
      lnUnit   = 1
    ELSE
      IF SEEK(lcCurrCode,lcTmepFile)
        lnExRate = &lcTmepFile..NEXRATE
        lnUnit   = &lcTmepFile..NCURRUNIT
      ENDIF
    ENDIF

    *B601526,1 Add this lines [Begin]
    lnExRate = IIF(lnExRate <> 0 , lnExRate , 1)
    *B603186,1 (Begin) Avoid dividing by 0 when canculating amount with diff currency.
    *lnUnit = IIF(lnExRate <> 0 , lnUnit , 1)
    lnUnit = IIF(lnUnit <> 0 , lnUnit , 1)
    *B603186,1 (End)
    *B601526,1 Add this lines [End]

    lcExSin2   = ' '
    lcExSin1   = gfGetExSin(@lcExSin2,lcCurrCode)
    lnAmount   = ROUND(lnAmount &lcExSin1 lnExRate &lcExSin2 lnUnit,2)
ENDCASE

*E301214,1 Restore alias [Begin]
SELECT (lnSavAlias)
*E301214,1 Restore alias [End  ]

RETURN lnAmount
*-- end of gfAmntDisp.

*************************************************************************
*************************************************************************
*********hesham**********************************************************
*C200074,1 add function to remove the user defined fields from
*C200074,1 the fields of a custom base file defined
FUNCTION gfReInUsrF
PARAMETERS lcScrObj,laUsrArray
PRIVATE lnDelCount,lnCount
lcScrObj = UPPER(lcScrObj)
lnDelCount = 0
IF !EMPTY(laUsrArray[1,1])
  FOR lnCount = 1 TO ALEN(laUsrArray,1)
    IF ALLT(laUsrArray[lnCount-lnDelCount,1]) $ lcScrObj
      =gfADel(@laUsrArray,lnCount-lnDelCount)
      lnDelCount = lnDelCount + 1
    ENDIF
  ENDFOR
ENDIF
****************************************************************************

*!*************************************************************
*! Name      : gfDoTriger
*! Developer : HS (Haytham El_Sheltawi)
*! Date      : 07/22/99
*! Purpose   : Function to control any triggers found in the
*!             triggers file, customized processes and workflow
*!             server requests.
*!*************************************************************
*! Calls              : None.
*!*************************************************************
*! Passed Parameters  : 1) lcProgName, Object ID.
*!                      2) lcEvent, Event ID.
*!*************************************************************
*! Returns            : None.
*!*************************************************************
*! Example            :  =gfDoTriger()
*!*************************************************************
*E301297,1 this function was added by HS for the entry E301297,1.
*!*************************************************************
*
FUNCTION gfDoTriger

PARAMETERS lcProgName , lcEvent

PRIVATE lnOldAlias , lcProgToDo , laParamExp , laParam , lcParmStr ,;
        lnCount    , llReturn

llReturn = .T.

*-- If any of the parameters is not passed or passed incorrectly 
IF TYPE('lcProgName') <> 'C' .OR. EMPTY(lcProgName) .OR.;
   TYPE('lcEvent') <> 'C' .OR. EMPTY(lcEvent)
  RETURN
ENDIF

*-- Save the old alias
lnOldAlias = SELECT(0)

*-- Open the Trigger file if it was not opened
IF !USED('SYCTRIGG')
  =gfOpenFile(gcSysHome + 'SYCTRIGG' , 'OBJEVENT' , 'SH')
ENDIF

SELECT SYCTRIGG

*-- If there is triggers for this Object/Event
IF SEEK(PADR(lcProgName , 10) + PADR(lcEvent , 10))
  
  *-- Scan loop to scan the Object/Event triggers
  SCAN REST;
      WHILE cAPObjNam + cEvent_ID = PADR(lcProgName , 10) +;
            PADR(lcEvent , 10)
    
    *-- Get the name of the program that should be executed
    lcProgToDo = cTrig_ID
    
    *-- Initialize the parameter string variable
    lcParmStr  = ''
    
    *-- Restore the old alias to be able to evaluate the parameter
    *-- expressions properly
    SELECT (lnOldAlias)
    
    *-- If there is one or more parameters that should be passed to the
    *-- program
    IF !EMPTY(SYCTRIGG.mParmExpr)
      
      *-- Get the parameter expressions
      DIMENSION laParamExp[OCCURS('~' , SYCTRIGG.mParmExpr) + 1]
      =gfSubStr(SYCTRIGG.mParmExpr , @laParamExp , '~')
      
      *-- Initialize the parameters array
      DIMENSION laParam[ALEN(laParamExp , 1)]
      laParam = ""
      
      *-- Get the parameters values that will be passed to the program
      FOR lnCount = 1 TO ALEN(laParamExp , 1)
        laParam[lnCount] = EVALUATE(laParamExp[lnCount])
        lcParmStr = lcParmStr + IIF(lnCount = 1 , '' , ' , ') +;
                    'laParam[' + ALLTRIM(STR(lnCount)) + ']'
        
      ENDFOR    && End of FOR lnCount = 1 TO ALEN(laParamExp , 1)
    ENDIF    && End of IF !EMPTY(SYCTRIGG.mParmExpr)
    
    *-- If custom process
    IF SYCTRIGG.cActvTyp = 'C'
      *-- Call the program and get the returned value
      
      *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
      IF GCMULTIINST
        lcSetPath = FULLPATH('')
        *E302876,1 TMI 03/20/2011 [Start] do not use the x: drive
        *SET DEFAULT TO "X:\aria27"
        SET DEFAULT TO (SUBSTR(gcSysHome,1,RAT('\',gcSysHome,2)))
        *E302876,1 TMI 03/20/2011 [End  ] 
      ENDIF 
      *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]
      
      llReturn = &lcProgToDo(&lcParmStr)
      
      *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [Start]
      IF GCMULTIINST
        SET DEFAULT TO (lcSetPath)
      ENDIF 
      *E302566,1 MMT 01/06/2009 Modify SysFiles Paths for SAAS [End]

      
    ELSE    && Else [If Server request]
    ENDIF    && End of IF SYCTRIGG.cActvTyp = 'C'
  
    SELECT SYCTRIGG
  ENDSCAN    && End of SCAN REST WHILE cAPObjNam + cEvent_ID = ...
  
  *B603662,1 BWA 05/25/2000 In case the process doesn't exist.[START]
ELSE
  llReturn = .F.
  *B603662,1 [END]
  
ENDIF    && End of IF SEEK(PADR(lcProgName , 10) + PADR(lcEvent , 10))

*-- Restore the old alias
SELECT (lnOldAlias)

RETURN (llReturn)

*!*************************************************************
*! Name      : gfvAudTral
*! Developer : HS (Haytham El_Sheltawi)
*! Date      : 07/22/99
*! Purpose   : Valid function for the Audit Trail bush button (Control Panel)
*!*************************************************************
*! Calls              : None.
*!*************************************************************
*! Passed Parameters  : None.
*!*************************************************************
*! Returns            : None.
*!*************************************************************
*! Example            :  =gfvAudTral()
*!*************************************************************
*E301299,1 this function was added by HS for the entry E301299,1.
*!*************************************************************
*
FUNCTION gfvAudTral

PRIVATE lnSelect   , lcBrowKey , lcKeyExp , lcKey , lnStarPos , lnLastPos ,;
        lcOldBrFld

*-- Save the old alias
lnSelect   = SELECT(0)

*-- If there is a base file for this screen (Object) select it in order to
*-- be able to evaluate the Audit Trail Key properly
IF TYPE('lcBaseFile') = 'C' .AND. !EMPTY(lcBaseFile)
  SELECT (lcBaseFile)
ENDIF    && End of IF TYPE('lcBaseFile') = 'C' .AND. !EMPTY(lcBaseFile)

*-- Get the expression of the Audit Trail Key
lnStarPos = IIF(ATC('*',lcSydKey) <> 0 , ATC('*',lcSydKey) + 1 , 2)
lcKeyExp  = ALLTRIM(SUBSTR(lcSydKey , lnStarPos))
lnLastPos = ATC('|' , lcKeyExp)
IF lnLastPos <> 0
  lcKeyExp = SUBSTR(lcKeyExp , 1 , lnLastPos - 1)
ENDIF    && End of IF lnLastPos <> 0

*-- Get the Audit Trail Key
lcKey     = PADR(&lcKeyExp , 20)
*-- Get the key that will be used when browsing the Audit Trail file
lcBrowKey = PADR(lcProgName , 10) + lcKey

*-- Open the Audit Trail file if it was not opened
IF !USED('AUDTRAIL')
  =gfOpenFile(gcDataDir + 'AUDTRAIL' , 'AUDTRAIL' , 'SH')
ENDIF    && End of IF !USED('AUDTRAIL')

*-- Open the System Events file if it was not opened
IF !USED('SYCEVENT')
  =gfOpenFile(gcSysHome + 'SYCEVENT' , 'EVENTS' , 'SH')
ENDIF    && End of IF !USED('SYCEVENT')

SELECT AUDTRAIL
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
*SET RELATION TO cEvntObjID + cEvent_ID INTO SYCEVENT
*lcBrFields  = "SYCEVENT.cDiscrep :H='Event' ,"+;
              "cAdd_User :H='User ID' ," +;
              "cAdd_Time :H='Time' ," +;
              "dAdd_Date :H='Date' ," +;
              "NeededInf = SUBSTR(ALLTRIM(mNeededInf) , 1 , 65) : 65 :H='Needed Information'"


lcOldBrFld  = lcBrFields
lcBrFields  = "SYCEVENT.cDiscrep :H='Event' ,"+;
              "cAdd_User :H='User ID' ," +;
              "cAdd_Time :H='Time' ," +;
              "dAdd_Date :H='Date' ," +;
              "NeededInf = SUBSTR(ALLTRIM(mNeededInf) , 1 , 65) : 65 :H='Needed Information'"



PRIVATE lcDesc, mNeed , lcAdd_User , lcAdd_Time , ldAdd_Date
STORE '' TO lcDesc, mNeed , lcAdd_User , lcAdd_Time , ldAdd_Date
lcLinesBrw = 'Audit Trails lines'
lcTmpAudt = gfTempName()


SELECT cAdd_User,cAdd_Time,dAdd_Date,cEvntObjID,cEvent_ID,cAudtralid,capobjnam,key,mNeededInf ;
FROM (gcDataDir+"AUDTRAIL");
WHERE capobjnam+key+caudtralid = lcBrowKey;
INTO TABLE (gcWorkDir+lcTmpAudt);
ORDER BY capobjnam,key,caudtralid
INDEX ON caudtralid TAG (lcTmpAudt)

SELECT (lcTmpAudt)
LOCATE
IF EOF()
  =gfDialog('I',"No records to display")
  _CUROBJ = _CUROBJ
  RETURN
ENDIF
SET RELATION TO cEvntObjID + cEvent_ID INTO SYCEVENT

lcButStat = IIF(laScrMode[2],'DISABLE','ENABLE')
PUSH KEY
ON KEY
ON KEY LABEL ESC 
ON KEY LABEL ESC DO lpClose
DO syaudtrl.spr
POP KEY

*=ARIABROW('"' + lcBrowKey + '"' , 'Audit Trails' ,.F.,.F.,.F.,.F., '' ,;
		  'Fi\<nd;Or\<der by;\<Descending;Fi\<lter;;\!\?\<Ok')


lcBrFields = lcOldBrFld

*SET RELATION TO
*E301866,1 ABD - [End]
*-- Restore old alias
SELECT (lnSelect)

*!*************************************************************
*! Name      : lfCalAvCst
*! Developer : Hossam El Etreby [HDM]
*! Date      : 06/06/1999
*! Purpose   : Function to Calculate Average cost for all style colors
*!*************************************************************
*! Calls     : -----
*!*************************************************************
*! Passed Parameters  : 
*!*************************************************************
*! Returns            : Average cost
*!*************************************************************
*! Called Form        : 
*!*************************************************************
*! Example            : =lfCalAvCst()
*!*************************************************************
*! Due To Bug # 602933
*!*************************************************************

FUNCTION lfCalAvCst

PRIVATE lnTotStk, lnTotStVal , lnAvCstVal
STORE 0 TO lnTotStk , lnTotStk , lnAvCstVal

lnTotStk   = lfSumSeasn(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen),'TotStk')
lnTotStVal = lfSumSeasn(PADR(ALLTRIM(STYLE_A.CSTYMAJOR),lnMajLen),'NSTKVAL')
IF lnTotStk > 0
  lnAvCstVal = lnTotStVal / lnTotStk
ELSE
  RETURN STYLE_A.Ave_Cost
ENDIF

RETURN (lnAvCstVal)

*!*************************************************************
*! Name      : lfChkSrvPk
*! Developer : Hesham El-Sheltawi
*! Date      : 26/10/99
*! Purpose   : Check For Unupdated Service Packs
*!*************************************************************
*! Calls              : gfUserList
*!*************************************************************
*! Passed Parameters  : None.
*!*************************************************************
*! Returns            : None.
*!*************************************************************
*! Example            :  =lfChkSrvPk()
*!*************************************************************
*E301603,5 added for E301603,5
*!*************************************************************
*
FUNCTION lfChkSrvPk
PRIVATE lcInstAls,lcSrvPath,laSrvFiles,lnSrvFCnt,laNotUpd,lcAppAls,lnLoopCnt,lnUnupd,;
        lcSrvAls,lcMsgStr
lcInstAls = gfTempName()
IF gcUser_lvl = 'A' AND gfUserList(.T.) = 1
  USE (gcSysHome+'SYCINST') IN 0 AGAIN ALIAS &lcInstAls
  SELECT (lcInstAls)
  lcSrvPath = ALLT(CSERVPATH)
  USE IN (lcInstAls)
  lcSrvPath = lcSrvPath+IIF(RIGHT(lcSrvPath,1)='\','','\')
  lnSrvFCnt = ADIR(laSrvFiles,lcSrvPath+'*.EXE')
  IF lnSrvFCnt>0
    lcAppAls = gfTempName()
    lcSrvAls = gfTempName()
    USE (gcSysHome+'SYDAPPL') IN 0 AGAIN ALIAS &lcAppAls ORDER TAG CAPP_ID
    USE (gcSysHome+'SYDTRANS') IN 0 AGAIN ALIAS &lcSrvAls ORDER TAG CEXENAM
    lnUnupd = 0
    FOR lnLoopCnt = 1 TO lnSrvFCnt
       IF SEEK(LEFT(laSrvFiles[lnLoopCnt,1],2),lcAppAls)
         IF RIGHT(ALLT(&lcAppAls..CMDLBUILD),3) = SUBSTR(laSrvFiles[lnLoopCnt,1],3,3)
           IF !SEEK(STRTRAN(laSrvFiles[lnLoopCnt,1],'.EXE'),lcSrvAls) 
             lnUnupd = lnUnupd + 1
             DIME laNotUpd[lnUnupd,1]
             laNotUpd[lnUnupd,1] = STRTRAN(laSrvFiles[lnLoopCnt,1],'.EXE')
           ENDIF
         ENDIF
       ENDIF
    ENDFOR
    USE IN (lcAppAls)
    USE IN(lcSrvAls)
    IF lnUnupd > 0
      lcMsgStr = "One or more service packs has not been updated."
      *FOR lnLoopCnt = 1 TO lnUnupd
      *  lcMsgStr = lcMsgStr + CHR(13)+CHR(10) +laNotUpd[lnLoopCnt,1]
      *ENDFOR
      =gfModalGen(.F.,.F.,.F.,.F.,lcMsgStr)
    ENDIF
  ENDIF
ENDIF

*!**********************************************************************
*! Name      : gfOTSDisp
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! Purpose   : Function to show the open Qty To Sell.
*!**********************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : 1--> lcStyle	   style code 
*!                      2--> lcWareHouse   ware house code
*!                      3--> llAllWareHs ----(all ware house,warehouse)
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : =lf..()
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
FUNCTION gfOTSDisp
PARAMETER lcStyle,lcWareHouse,llAllWareHs
PRIVATE lcBrFields,lnAlias,llMFInstld,llSOInstld,llPOInstld,;
        lctmpOTS,lcEngland,llOtsinfo,lcexkey,lcwcondt,lcNMjrTl,lcMjrPct,;
        lcNMjrPt,lnstylewid,lncolorwid,llAllClrs

*--lcBrFields --> Hold Browse Fields
*--lnAlias    --> Hold Current Area
*--llMFInstld --> flag if the manufactring module is exist
*--llSOInstld --> flag if the Sales Order  module is exist
*--llPOInstld --> flag if the Purchaise Order module is exist
*--llOtsinfo  --> flag if there are O.T.S data
*--lcexkey    --> hold seek experation
*--lcwcondt   --> hold for experation
*--lctmpOTS   --> Hold O.T.S temp file name
*--lcPoHdrTmp --> hold poshdr alias temp name
*--lcPolinTmp --> hold posln alias temp name
*--lcShpHdTmp --> hold Shpmthdr alias temp name
*--lcCutHdTmp --> hold CutTkth alias temp name
*--lcCutlnTmp --> hold CutTktl alias temp name
*--lcOrdHdTmp --> hold OrdHdr alias temp name
*--lcOrdLnTmp --> hold ORDLINE alias temp name
*--lcStyleTmp --> hold Style alias temp name
*--lcStyDyTmp --> hold StyDye alias temp name
*--lcScaleTmp --> hold Scale alias temp name
*--lcNMjrTl   --> hold nonmajor title
*--lcMjrPct   --> Hold major picture
*--lcNMjrPt   --> hold non major picture
*--lnstylewid --> hold major length
*--lncolorwid --> hold color length
*--llAllClrs  --> flag if all colors
lcOtsPrd   = gfGetMemVar('M_OTSPRIOD')
*C102567,1 HBG 03/04/2002 Get the setting of OTS based on exact transaction date [Begin]
llOTSbasTr = gfGetMemVar('M_OTSBASTR',gcAct_Comp)
*C102567,1 [End]
lcMjrPct  = gfItemMask('PM')
lcNMjrPt  = gfItemMask('PN')
lcNMjrTl  = gfItemMask('HN')
lnstylewid=LEN(lcMjrPct)
lncolorwid=LEN(lcNMjrPt)
llAllClrs = EMPTY(SUBSTR(lcStyle,lnStyleWid+2))
llMFInstld = (OCCURS('MF',gcCmpModules)<>0)
llSOInstld = (OCCURS('SO',gcCmpModules)<>0)
llPOInstld = (OCCURS('PO',gcCmpModules)<>0)
lctmpOTS   = gftempname()
lcPoHdrTmp = gftempname()
lcPolinTmp = gftempname()
lcShpHdTmp = gftempname()
lcCutHdTmp = gftempname()
lcCutlnTmp = gftempname()
lcOrdHdTmp = gftempname()
lcOrdLnTmp = gftempname()
lcStyleTmp = gftempname()
lcStyDyTmp = gftempname()
lcScaleTmp = gftempname()
lcEngland  = 'ENG'
lcfcondt = IIF(!llAllWareHs,'cWareCode = lcWareHouse','.T.')

*B802943,1 WAB - if the  PO, MF, SO is not installed ALL of Them not any 
*B802943,1 WAB - One of them
*IF !llPOInstld OR !llMFInstld OR !llSOInstld
IF !llPOInstld AND !llMFInstld AND !llSOInstld
  RETURN
ENDIF
*B802943,1 WAB - END

lnAlias=SELECT()
=gfOpenFile(gcDataDir+"SCALE", "SCALE", "SH",@lcScaleTmp,.T.)
=gfOpenFile(gcDataDir+"STYLE", "STYLE", "SH",@lcStyleTmp,.T.)
*--Checking existance of OTS information.
=SEEK(lcStyle) 
llOtsinfo=.F.
*B606031,1 ASH 05/27/2002 (Begin) Fix the bug of checking the first color of the style.
SCAN WHILE Style = lcStyle
*B606031,1 ASH 05/27/2002 (End)
  FOR I=1 TO 8
    Z=STR(I,1)
    IF Stk&z<>0 OR Wip&z<>0 OR Ord&z<>0
	  llOtsinfo=.T.
  	  EXIT
    ENDIF
  ENDFOR
  *B606031,1 ASH 05/27/2002 (Begin) If only one color has data, stop checking.
  IF llOtsinfo
    EXIT
  ENDIF
ENDSCAN  
*B606031,1 ASH 05/27/2002 (End)
IF ! llOtsinfo
  *--No Open to sell information found.
  =gfModalGen('TRM42045B42001','DIALOG')
  RETURN
ENDIF

=gfOpenFile(gcDataDir+"STYDYE", "STYDYE", "SH",@lcStyDyTmp,.T.)
IF llPOInstld 
  =gfOpenFile(gcDataDir+'POShdr','POSHdr'  ,'SH',@lcPoHdrTmp,.T.)
  *B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [Start]
  *=gfOpenFile(gcDataDir+'POSLN' ,'POSLNS'  ,'SH',@lcPolinTmp,.T.)
  *B603915,1 AMH open POSLN with alias lcPolinTmp [Start]
  *=gfOpenFile(gcDataDir+'POSLN' ,'POSLNS'  ,'SH')
  *SELECT POSLN
  *COPY TO (gcDataDir+lcPolinTmp)
  *USE (gcDataDir+lcPolinTmp) IN 0
  *SELECT (lcPolinTmp)
  *INDEX ON style+cstytype+po+STR(lineno,6)+trancd TAG (lcPolinTmp) OF (lcPolinTmp)
  =gfOpenFile(gcDataDir+'POSLN' ,'POSLNS'  ,'SH',@lcPolinTmp,.T.)
  *B603915,1 AMH [End]
  *B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [End  ]
  =gfOpenFile(gcDataDir+'Shpmthdr','Shpmthdr','SH',@lcShpHdTmp,.T.)
ENDIF
IF llMFInstld 
  =gfOpenFile(gcDataDir+"CUTTKTH", "CUTTKTH", "SH",@lcCutHdTmp,.T.)
  =gfOpenFile(gcDataDir+"CUTTKTL", "CUTTKTLS", "SH",@lcCutlnTmp,.T.)
ENDIF
IF llSOInstld
  =gfOpenFile(gcDataDir+"ORDHDR", "ORDHDR", "SH",@lcOrdHdTmp,.T.)
  =gfOpenFile(gcDataDir+"ORDLINE", "ORDLINES", "SH",@lcOrdLnTmp,.T.)
ENDIF
SELECT (lnAlias)
*--Save current pointers since this function change it.
lnCrSav1=IIF(!EOF(),RECNO(),0)

WAIT WINDOW 'Collecting Open to Sell information...' NOWAIT

*E301800,4 ASH 01/21/2002 (Begin) Display 7 digits.
*CREATE CURSOR (lctmpots) (Style C(19),SZCnt C(1) ,Size C(5) ,;
                          nqty1 N(6),nqty2 N(6),nqty3 N(6),nqty4 N(6),;
                          nqty5 N(6),nqty6 N(6),nqty7 N(6),nqty8 N(6),;
                          nqty9 N(6),nqty10 N(6),nqty11 N(6),nqty12 N(6))
CREATE CURSOR (lctmpots) (Style C(19),SZCnt C(1) ,Size C(5) ,;
                          nqty1 N(7),nqty2 N(7),nqty3 N(7),nqty4 N(7),;
                          nqty5 N(7),nqty6 N(7),nqty7 N(7),nqty8 N(7),;
                          nqty9 N(7),nqty10 N(7),nqty11 N(7),nqty12 N(7))
*E301800,4 ASH 01/21/2002 (End)                          

SELECT IIF(llAllWareHs,lcStyleTmp,lcStyDyTmp)

lcwcondt = 'Style = lcStyle'

*B606462,1 TMI [Start] Don't include dylots in OTS browse screen
*lcfcondt = IIF(!llAllWareHs,'cWareCode = lcWareHouse','.T.')
lcfcondt = IIF(!llAllWareHs,'cWareCode = lcWareHouse .AND. IIF(TYPE("DYELOT")="C",EMPTY(DYELOT),.T.)','.T.')
*B606462,1 TMI [End  ] Don't include dylots in OTS browse screen


=SEEK(lcStyle)
SCAN WHILE &lcwcondt FOR &lcfcondt
	IF !llAllWareHs
	  =SEEK(&lcStyDyTmp..Style,lcStyleTmp)
	ENDIF
    lcColor = SUBSTR(Style,lnStyleWid+1,lnColorWid+1)
	=SEEK('S'+&lcStyleTmp..Scale,lcScaleTmp)
	SELECT (lctmpots)
	FOR I=1 TO &lcScaleTmp..cnt
		z=STR(I,1)
		APPEND BLANK
		REPLACE Style WITH &lcStyleTmp..Style,;
                SZCnt WITH Z,;
			    Size  WITH &lcScaleTmp..sz&z
	ENDFOR
ENDSCAN
SELECT (lctmpots)
INDEX ON Style+SZCnt TAG (lctmpots) OF (lctmpots)


*-- Initialize the necessary global variables.
ldToday = gdSysDate
lcThisM = ALLTRIM(STR(MONTH(ldToday)))
lcThisY = ALLTRIM(STR(YEAR(ldToday)))
lcThisD = ALLTRIM(STR(DAY(ldToday)))

*--No of dayes in the month.
DECLARE  laNoOfDays[12]
laNoOfDays = '31'
STORE '30' TO laNoOfDays[4],laNoOfDays[6],laNoOfDays[9],laNoOfDays[11]

*--Build periods from -To dates up to 10 periods.
DECLARE laDtPeriod[10,3]   
laDtPeriod = {}
lcPrdMonth = lcThisM
lnPrdMonth = INT(VAL(lcThisM))
lcPrdYear  = lcThisY
*--Read date format.
llEngDate = (ALLTRIM(gcContCode) = lcEngland .OR. SET('DATE')='BRITISH' )
lnPrdNum = 10
IF lcOtsPrd='E' AND VAL(lcThisD)<=15  
  lnPrdNum = 11
ENDIF

IF lcOtsPrd='W' 
  DO CASE
    CASE BETWEEN(VAL(lcThisD),8,15)
      lnPrdNum = 11
    CASE BETWEEN(VAL(lcThisD),16,22)
      lnPrdNum = 12
    CASE BETWEEN(VAL(lcThisD),22,31)
      lnPrdNum = 13
  ENDCASE
ENDIF
DECLARE laDtPeriod[lnPrdNum,3]   
laDtPeriod = {}

FOR I=1 TO lnPrdNum
  lcPrdCnt = ALLTRIM(STR(I,2))
  DO CASE
    CASE lcOtsPrd='E'
     IF lcPrdCnt $ '1-3-5-7-9-11'  &&First part of month.
       IF llEngDate
         laDtPeriod[I,1] = CTOD('01/'+lcPrdMonth+'/'+lcPrdYear)
         laDtPeriod[I,2] = CTOD('15/'+lcPrdMonth+'/'+lcPrdYear)
         laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 01-15'
       ELSE
         laDtPeriod[I,1] = CTOD(lcPrdMonth+'/01/'+lcPrdYear)  
         laDtPeriod[I,2] = CTOD(lcPrdMonth+'/15/'+lcPrdYear)
         laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 01-15'
       ENDIF
     ELSE
       IF llEngDate
         laDtPeriod[I,1] = CTOD('16/'+lcPrdMonth+'/'+lcPrdYear)  
         laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
         laDtPeriod[I,2] = CTOD(ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdMonth+'/'+lcPrdYear)
       ELSE
         laDtPeriod[I,1] = CTOD(lcPrdMonth+'/16/'+lcPrdYear)
         laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
         laDtPeriod[I,2] = CTOD(lcPrdMonth+'/'+ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdYear)
       ENDIF
       laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 16-'+ALLTRIM(laNoOfDays[lnPrdMonth])
       ldNewDate  = (laDtPeriod[I,2]+1)
       lcPrdMonth = ALLTRIM(STR(MONTH(ldNewDate)))
       lnPrdMonth = INT(VAL(lcPrdMonth))
       lcPrdYear  = ALLTRIM(STR(YEAR(ldNewDate)))
     ENDIF
    CASE lcOtsPrd='W'
      DO CASE
        *B606759,1 TMI [Start] Let the week# variable be two charachter width 
        *CASE lcPrdCnt $ '1-5-9-13'  &&First week.
        CASE PADL(lcPrdCnt,2,'0') $ '01-05-09-13'  &&First week.
        *B606759,1 TMI [End  ] 
         IF llEngDate
           laDtPeriod[I,1] = CTOD('01/'+lcPrdMonth+'/'+lcPrdYear)  
           laDtPeriod[I,2] = CTOD('07/'+lcPrdMonth+'/'+lcPrdYear)
         ELSE
           laDtPeriod[I,1] = CTOD(lcPrdMonth+'/01/'+lcPrdYear)  
           laDtPeriod[I,2] = CTOD(lcPrdMonth+'/07/'+lcPrdYear)
         ENDIF
         laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 01-07'
        *B606759,1 TMI [Start] Let the week# variable be two charachter width 
        *CASE lcPrdCnt $ '2-6-10'
        CASE PADL(lcPrdCnt,2,'0') $ '02-06-10'
        *B606759,1 TMI [End  ] 
          IF llEngDate
            laDtPeriod[I,1] = CTOD('08/'+lcPrdMonth+'/'+lcPrdYear)  
            laDtPeriod[I,2] = CTOD('15/'+lcPrdMonth+'/'+lcPrdYear)
          ELSE
            laDtPeriod[I,1] = CTOD(lcPrdMonth+'/08/'+lcPrdYear)  
            laDtPeriod[I,2] = CTOD(lcPrdMonth+'/15/'+lcPrdYear)
          ENDIF
          laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 08-15'
        *B606759,1 TMI [Start] Let the week# variable be two charachter width 
        *CASE lcPrdCnt $ '3-7-11'
        CASE PADL(lcPrdCnt,2,'0') $ '03-07-11'
        *B606759,1 TMI [End  ] 
          IF llEngDate
            laDtPeriod[I,1] = CTOD('16/'+lcPrdMonth+'/'+lcPrdYear)  
            laDtPeriod[I,2] = CTOD('22/'+lcPrdMonth+'/'+lcPrdYear)
          ELSE
            laDtPeriod[I,1] = CTOD(lcPrdMonth+'/16/'+lcPrdYear)  
            laDtPeriod[I,2] = CTOD(lcPrdMonth+'/22/'+lcPrdYear)
          ENDIF
          laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 16-22'
        *B606759,1 TMI [Start] Let the week# variable be two charachter width 
        *CASE lcPrdCnt $ '4-8-12'
        CASE PADL(lcPrdCnt,2,'0') $ '04-08-12'
        *B606759,1 TMI [End  ] 
          IF llEngDate
            laDtPeriod[I,1] = CTOD('23/'+lcPrdMonth+'/'+lcPrdYear)            
            laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
            laDtPeriod[I,2] = CTOD(ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdMonth+'/'+lcPrdYear)
          ELSE
            laDtPeriod[I,1] = CTOD(lcPrdMonth+'/23/'+lcPrdYear)  
            laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
            laDtPeriod[I,2] = CTOD(lcPrdMonth+'/'+ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdYear)
          ENDIF 
          laDtPeriod[I,3] = SUBSTR(CMONTH(laDtPeriod[I,1]),1,3)+'. 23-'+ALLTRIM(laNoOfDays[lnPrdMonth])
          ldNewDate  = (laDtPeriod[I,2]+1)
          lcPrdMonth = ALLTRIM(STR(MONTH(ldNewDate)))
          lnPrdMonth = INT(VAL(lcPrdMonth))
          lcPrdYear  = ALLTRIM(STR(YEAR(ldNewDate)))
      ENDCASE
    CASE lcOtsPrd='M'
      IF llEngDate
        laDtPeriod[I,1] = CTOD('01/'+lcPrdMonth+'/'+lcPrdYear)  
        laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
        laDtPeriod[I,2] = CTOD(ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdMonth+'/'+lcPrdYear)
      ELSE
        laDtPeriod[I,1] = CTOD(lcPrdMonth+'/01/'+lcPrdYear)  
        laNoOfDays[2]   = IIF(MOD(YEAR(laDtPeriod[I,1]),4)=0 ,'29' ,'28' )
        laDtPeriod[I,2] = CTOD(lcPrdMonth+'/'+ALLTRIM(laNoOfDays[lnPrdMonth])+'/'+lcPrdYear)
      ENDIF
      laDtPeriod[I,3] = PADR(CMONTH(laDtPeriod[I,1]),10)
      ldNewDate  = (laDtPeriod[I,2]+1)
      lcPrdMonth = ALLTRIM(STR(MONTH(ldNewDate)))
      lnPrdMonth = INT(VAL(lcPrdMonth))
      lcPrdYear  = ALLTRIM(STR(YEAR(ldNewDate)))
  ENDCASE
  *--Browse fields hedding.
ENDFOR
=ACOPY(laDtPeriod,laDtTmpPrd)
LNREMVCOL=0   
FOR I=1 TO ALEN(laDtTmpPrd,1)
  IF gdSysDate>laDtTmpPrd[I,1] AND gdSysDate>laDtTmpPrd[I,2]
    *--REMOVE
    LNREMVCOL=I   
    LOOP
  ENDIF
ENDFOR
=ACOPY(LADTTMPPRD,LADTPERIOD,(LNREMVCOL*3)+1)
FOR I=1 TO ALEN(laDtPeriod,1)
  lcPrdCnt = ALLTRIM(STR(I,2))

  IF I=1
  *B802763,1 WAB - wrong period date -- >keep first period as it is 
  *  laDtPeriod[I,1] = {01/01/01}
  *B802763,1 WAB - END
    laDtPeriod[I,3] = 'Current'
  ENDIF

  *--Browse fields hedding.
  lcMn&lcPrdCnt = laDtPeriod[I,3]
ENDFOR
* --- Filling the main array.
SELECT (lcStyleTmp)
=SEEK( lcStyle )

*B606978,1 WAB (Start) -in case of Exrened size scale and each scale with diffrencte Scale.cnt
*B606978,1 WAB 		   -there some sizes is displayed with zero aslo this bug occurec in Normal scale if
*B606978,1 WAB 		   -we have diffrent color and eacjh color with specific Scale
*lnSize_cnt = IIF(SEEK('S'+&lcStyleTmp..Scale,lcScaleTmp), &lcScaleTmp..cnt , 1)
lnSize_cnt = 8
*B606978,1 WAB (END)

DIMENSION laOTCInfo[lnSize_cnt,12]
laOTCInfo = 00
SELECT IIF(llAllWareHs,lcStyleTmp,lcStyDyTmp)
=SEEK( lcStyle )
SCAN WHILE &lcwcondt FOR &lcfcondt
  lcPStyle  = Style
  laOTCInfo = 0.00
  FOR  lnSz_no = 1 TO lnSize_cnt
    lcSz_no = STR(lnSz_no,1) 
	laOTCInfo[lnSz_no,01] = STK&lcSz_no
	laOTCInfo[lnSz_no,12] = ORD&lcSz_no + SHP&lcSz_no
  ENDFOR
  *--According to "MAKE" field call procedure.
  IF llMFInstld AND &lcStyleTmp..MAKE
    DO lpOTSmYes WITH lcPStyle
  ENDIF
  IF llPOInstld AND !&lcStyleTmp..Make
    DO lpOTSmNo  WITH lcPStyle
  ENDIF
  *-- To subtract the proper quantities in the "ORDLINE" file .
  IF llSOInstld
    DO lpOrdQSub WITH lcPStyle
  ENDIF
  *C102567,1 HBG 03/04/2002 IF Get the setting of OTS based on exact transaction date = 'No'
  *C102567,1                the calculation will remain the same [Begin]
  IF !llOTSbasTr
  *C102567,1 [End]
    *--To post the negative values to the nearst positive value.
    DO lppstnvvlu
  *C102567,1 HBG 03/04/2202 IF Get the setting of OTS based on exact transaction date = 'Yes'
  *C102567,1                get the OTS for each period [Begin]
  ELSE
    DO lpUpdOTS
  ENDIF
  *C102567,1 [End]
  *--Replace the OTS Quantities.
  DO lpotslins WITH lcPStyle

ENDSCAN
SELECT(lnAlias)
IF lnCrSav1<>0
  GOTO lnCrSav1
ENDIF
SELECT (lcTmpOTS)

SUM nQty1,nQty2,nQty3,nQty4,nQty5,nQty6,nQty7,nQty8,nQty9,nQty10,nQty11,nQty12 TO ;
    lnQty1,lnQty2,lnQty3,lnQty4,lnQty5,lnQty6,lnQty7,lnQty8,lnQty9,lnQty10,lnQty11,lnQty12

INSERT INTO (lcTmpOTS) (STYLE,SZCnt,nQty1,nQty2,nQty3,nQty4,nQty5,nQty6,nQty7,nQty8,nQty9,nQty10,nQty11,nQty12) ;
	 VALUES (REPL(CHR(255),LEN(ALLTRIM(SUBSTR(lcStyle,1,lnStyleWid)))),'W',lnQty1,lnQty2,lnQty3,lnQty4,lnQty5,lnQty6,lnQty7,lnQty8,lnQty9,lnQty10,lnQty11,lnQty12)

*--C102237,1 TMI [START] A new line will be added right below each style sizw shown in the OTS 
*--C102237,1 TMI         screen. This line will show the accumulative OTS balance
=gfDoTriger('ICSTYLE','ACCUMOTS  ')
*--C102237,1 TMI [END  ] 
	
GOTO TOP
lcBrFields = IIF(llAllClrs,"lcSty=SUBSTR(Style,lnStyleWid+2,lnColorWid) :H=lcNMjrTl,","")+;
             "Size ," +;
         	 "nQty1  :H=lcMn1  :P='999999',"+;
        	 "nQty2  :H=lcMn2  :P='999999',"+;
         	 "nQty3  :H=lcMn3  :P='999999',"+;
         	 "nQty4  :H=lcMn4  :P='999999',"+;
        	 "nQty5  :H=lcMn5  :P='999999',"+;
        	 "nQty6  :H=lcMn6  :P='999999',"+;
        	 "nQty7  :H=lcMn7  :P='999999',"+;
        	 "nQty8  :H=lcMn8  :P='999999',"+;
        	 "nQty9  :H=lcMn9  :P='999999',"+;
        	 "nQty10 :H='FUTURE' :P='999999',"+;
        	 "nQty11 :H='TOTAL AVAIL' :P='999999',"+;
        	 "nQty12 :H='TOT. SLD YTD' :P='999999'"

WAIT CLEAR
=ARIABROW('','Style Open To Sell for multiple periods',gnbrhsrow1, gnbrhscol1, gnbrhsrow2, gnbrhscol2,'',;
         	'Fi\<nd;Or\<der by;\<Descending;Fi\<lter;;\!\?\<Ok')
=gfCLoseFile(lcPoHdrTmp)
=gfCLoseFile(lcPolinTmp)
*B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [Start]
*B603915,1 AMH comment next lines [Start]
*=gfCLoseFile('POSLN')
*ERASE (gcDataDir+lcPolinTmp).*
*B603915,1 AMH [End]
*B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [End  ]
=gfCLoseFile(lcShpHdTmp)
=gfCLoseFile(lcCutHdTmp)
=gfCLoseFile(lcCutlnTmp)
=gfCLoseFile(lcOrdHdTmp)
=gfCLoseFile(lcOrdLnTmp)
=gfCLoseFile(lcStyleTmp)
=gfCLoseFile(lcStyDyTmp)
SELECT(lnAlias)
RETURN

*:******************************************************************
*! PROG : lpOTSmYes
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : Procedure to compute the OTS quantites for the
*!        manufactured styles (MAKE : YES)
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lcOtsKey->OTS key like style as ex.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
PROCEDURE lpOtsMYes
PARA lcOtsKey
SELECT (lcCutlnTmp)
SEEK lcOtsKey
SCAN WHILE Style = lcOtsKey FOR (llAllWareHs OR cWareCode=lcWareHouse)
  =SEEK(Cuttkt,lcCutHdTmp)
  IF &lcCutHdTmp..Status $ 'OAH'
    *--To accumulate the quantity in process.
    *C102567,1 HBG 03/04/2002 pass the parameter of add to current by .T. to get the OTS in the correct period[Begin]
    *DO acum_ots WITH lcCutlnTmp , &lcCutHdTmp..complete , IIF(Trancd='1',1,-1) , .T. 
    DO acum_ots WITH lcCutlnTmp , &lcCutHdTmp..complete , IIF(Trancd='1',1,-1) , .T. , .T.
    *C102567,1 [End]
  ENDIF
ENDSCAN
RETURN

*:******************************************************************
*! Name      : lpOTSmno
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! Purpose   : Procedure to compute the OTS quantites for the imported
*!        styles (MAKE : NO)
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lcOtsKey->OTS key like style as ex.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
PROCEDURE lpOtsMNo
PARA lcOtsKey
*B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [Start]
PRIVATE lcPo_no
DIMENSION lnQty[lnSize_cnt]
lcPo_no = ''
FOR lnCount = 1 TO lnSize_cnt
  lnQty[lnCount] = 0
ENDFOR
*B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [End  ]
*B605619,1 HBG 03/06/2002 Add 2 arrays to check if there is over rescive or not[Begin]
DIMENSION laPOVlu[lnSize_cnt],laOverResv[lnSize_cnt]
FOR lnCount = 1 TO lnSize_cnt
  laPOVlu[lnCount]  = 0
ENDFOR
laOverResv = .F.
*B605619,1 [End]

SELECT (lcPolinTmp)

SEEK lcOtsKey
SCAN WHILE Style = lcOtsKey ;
     FOR cStyType<>'C' AND (llAllWareHs OR cWareCode=lcWareHouse) AND TranCd<>'6'
  =SEEK(&lcPolinTmp..cStyType+&lcPolinTmp..PO,lcPoHdrTmp)
  *B119990,1 ASH 11/17/2003 (Begin) Include the Actualize PO's.
  *IF !(&lcPoHdrTmp..Status $ 'OH')
  IF !(&lcPoHdrTmp..Status $ 'OHA')
  *B119990,1 ASH 11/17/2003 (End)
    LOOP
  ENDIF  
  *B802763,1 WAB - add type A ( ADORNMENT ) , D ( DYE ORDER )
  *lcTrSign = IIF(Trancd='1',1,-1) * IIF(cStyType $ 'PN',1,-1)
  lcTrSign = IIF(Trancd='1',1,-1) * IIF(cStyType $ 'ADPN',1,-1)
  *B802763,1 WAB - END
  ldTranDate = IIF (EMPTY(&lcPoHdrTmp..available),&lcPoHdrTmp..complete ,&lcPoHdrTmp..available)
  *B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [Start]
  *B603915,1 AMH put .F. to flag use lnQty Array insted of QtyX fields [Start]
  llArrQty = .F.
  *B603915,1 AMH [End]
  IF lcPo_no = PO
    *B605619,1 HBG 03/06/2002 Check For reciving and damaged and canceled Qty to fix bug of over reciecve[Begin]
    *IF Trancd ='2'
    IF Trancd $ '245'
    *B605619,1 [END]

      *B603915,1 AMH put .T. to flag use lnQty Array insted of QtyX fields [Start]
      llArrQty = .T.
      *B603915,1 AMH [End]
      FOR lnCount = 1 TO lnSize_cnt
        lcCount = STR(lnCount,1)
        *B603915,1 AMH use lnQty Array insted of QtyX fields [Start]
        *REPLACE Qty&lcCount. WITH MIN(Qty&lcCount. , lnQty[lnCount])
        *B605619,1 HBG 03/06/2002 Check if there is over receive Add 0 To the Array of the quntites[Begin]
        *lnQty[lnCount] = MIN(Qty&lcCount. , lnQty[lnCount])
        IF laOverResv[lnCount]
          lnQty[lnCount] = 0
        ELSE
          IF Qty&lcCount. > laPOVlu[lnCount] AND laPOVlu[lnCount] > 0
            lnQty[lnCount] = laPOVlu[lnCount]
            laOverResv[lnCount] = .T.
          ELSE
            lnQty[lnCount]   = Qty&lcCount. 
            laPOVlu[lnCount] = laPOVlu[lnCount] - Qty&lcCount. 
            IF laPOVlu[lnCount] = 0
              laOverResv[lnCount] = .T.
            ENDIF
          ENDIF 
        ENDIF  
        *B605619,1 [End]

        *B603915,1 AMH [End]
      ENDFOR
    ENDIF
  ELSE
    lcPo_no = PO
    FOR lnCount = 1 TO lnSize_cnt
      lcCount = STR(lnCount,1)
      lnQty[lnCount] = Qty&lcCount.
      *B605619,1 HBG 03/06/2002 Save the budget Qty of the OP, and set the flagof over recive to .F.[Begin]
      laPOVlu[lnCount] = Qty&lcCount.
      laOverResv = .F.
      *B605619,1 [End]
      
    ENDFOR
  ENDIF
  *B603832,1 AMH 17/08/2000 Fix the bug of incorrect OTS in case Over Receive [End  ]
  *-- To accumulate the quantity in process.
  *B605619,1 HBG 03/06/2002 fix bug of wrong OTS in case of over recieve [Begin]
  *DO acum_ots WITH lcPolinTmp , ldTranDate , lcTrSign , .T. , .T.
  *B605586,1 HBG 26/03/2002 Update Open & hold PO's if it is prior to date range in First period not the current based on JL trigger[Begin]
  IF ASCAN(laEvntTrig , PADR('ACCUMOTS', 10)) <> 0 
    DO acum_ots WITH lcPolinTmp , ldTranDate , lcTrSign , .T. , .F. , llArrQty
  ELSE
  *B605586,1 [End]
    DO acum_ots WITH lcPolinTmp , ldTranDate , lcTrSign , .T. , .T. , llArrQty
  *B605586,1 HBG 26/03/2002 End if tigger of J&L [Begin]
  ENDIF
  *B605586,1 [End]
  
  *B605619,1 [End]

  IF Trancd ='3'
    =SEEK(&lcPolinTmp..ShipNo,lcShpHdTmp)
	*B605619,1 HBG 03/06/2002 fix bug of wrong OTS in case of over recieve [Begin]
	*DO acum_ots WITH lcPolinTmp , &lcShpHdTmp..eta , 1 , .T. , .T.
    *B605586,1 HBG 26/03/2002 Update Open & hold PO's if it is prior to date range in First period not the current based on JL trigger[Begin]
    IF ASCAN(laEvntTrig , PADR('ACCUMOTS', 10)) <> 0 
      DO acum_ots WITH lcPolinTmp , &lcShpHdTmp..eta , 1 , .T. , .F. , llArrQty
    ELSE
    *B605586,1 [End]
      DO acum_ots WITH lcPolinTmp , &lcShpHdTmp..eta , 1 , .T. , .T. , llArrQty
    *B605586,1 HBG 26/03/2002 End if tigger of J&L [Begin]
    ENDIF
    *B605586,1 [End]
	*B605619,1 [End]
  ENDIF
ENDSCAN
RETURN

*:******************************************************************
*! PROG : lpOrdQSub
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : Procedure to substract the order line quantities from the
*!        OTS quantities .
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lcOtsKey->OTS key like style as ex.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
PROCEDURE lpOrdQSub
PARA lcOtsKey

SELECT (lcOrdLnTmp)
SEEK lcOtsKey
SCAN WHILE Style = lcOtsKey FOR cOrdType='O'
  =SEEK('O'+&lcOrdLnTmp..Order,lcOrdHdTmp)
  IF &lcOrdHdTmp..Status$'OH' AND (llAllWareHs OR &lcOrdHdTmp..cWareCode=lcWareHouse)
	* -- To accumulate the quantity in process .
	*- Use the start ship date instead of the completion date.
	*B802763,1 WAB - we add new parameter to acum_ots to acumulate the qty with date
	*B802763,1 WAB - before periods date to current column
	*DO acum_ots WITH lcOrdLnTmp , start , -1 , .F. 
	DO acum_ots WITH lcOrdLnTmp , start , -1 , .F. , .T.
	*B802763,1 WAB - END
  ENDIF
ENDSCAN
RETURN

*:******************************************************************
*! PROG : ACUM_OTS
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : Procedure to accumulate the OTS quantities .
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  :
*!        1) lcMFile  -> To hold the file name in process .
*!        2) ldTrDate -> To hold the date in process .
*!        3) lnSnType -> To deside whether to add or subtract the
*!                          quantity in process to or from the balance .
*!        4) llAcumOTS->     if this funtion was called to accumalats O.T.S Qty
*!                 or Subtract the order Qty .
*!        5) llAddToCur-> the qty before periods add to the current coloumn.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
PROCEDURE Acum_Ots
*B802763,1 WAB - add parameter to determin that we add qty before periods date 
*B802763,1 WAB - to current column or to frist periods
*PARAMETERS lcMFile , ldTrDate , lnSnType , llAcumOTS  , llAddPriod
*B603915,1 AMH add parameter to use lnQty Array insted of QtyX fields or not [Start]
*PARAMETERS lcMFile , ldTrDate , lnSnType , llAcumOTS  , llAddToCur
PARAMETERS lcMFile , ldTrDate , lnSnType , llAcumOTS  , llAddToCur , llArrQty
*B603915,1 AMH [End]
*B802763,1 WAB - END
PRIVATE lnX
lnX=IIF(llAcumOTS,2,1)
*-- The columns of the array laOTCInfo are initialized
*-- By the stock Qty and this function is going to accumalats the O.T.S QTY
*-- Or Subtract the order Qty form each column , But now we need to exclude
*-- The first column of this array (i.e laOTCInfo[1,x]) form this process
*-- Because this column carry the current O.T.S Qty .    

SELECT (lcMFile)
*C102567,1 HBG 03/04/2202 IF Get the setting of OTS based on exact transaction date = 'No'
*C102567,1                the calculation will remain the same [Begin]
IF !llOTSbasTr
*C102567,1 [End]
  IF BETWEEN(ldTrDate,laDtPeriod[1,1],laDtPeriod[10,2])
    FOR  lnSz_no = 1 TO lnSize_cnt
      lcSz_no = STR(lnSz_no,1) 
      *B603915,1 AMH determin use lnQty Array or QtyX fields [Start]
      lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
      *B603915,1 AMH [End]
      * -- Search for the right period to process .
      FOR I=lnX TO 10
   	    IF BETWEEN(ldTrDate,laDtPeriod[I,1],laDtPeriod[I,2])
          *B603915,1 AMH use lcQty insted of QtyX fields [Start]
          *laOTCInfo[lnSz_no,I]=laOTCInfo[lnSz_no,I] + ( Qty&lcSz_no * lnSnType )
          laOTCInfo[lnSz_no,I]=laOTCInfo[lnSz_no,I] + ( EVALUATE(lcQty) * lnSnType )
          *B603915,1 AMH [End]
	      EXIT
        ENDIF
      ENDFOR
      *B603874,1 MHM 09/06/2000 [start]

      IF (laDtPeriod[1,1] <= ldTrDate).AND.(ldTrDate < laDtPeriod[2,1]) .AND. llAcumOTS
          *B603915,1 AMH use lcQty insted of QtyX fields [Start]
          *laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( Qty&lcSz_no * lnSnType )
          *C102567,1 HBG 03/04/2002 Get the OTS in the correct period[Begin]
          *laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( EVALUATE(lcQty) * lnSnType )
          *B606070,1 ASH 06/09/2002 (Begin) Fix a bug of adding the open PO to the current instead of the first period for JL.
          IF ASCAN(laEvntTrig , PADR('ACCUMOTS', 10)) <> 0 
            laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( EVALUATE(lcQty) * lnSnType )
          ELSE
          *B606070,1 ASH 06/09/2002 (End)
            laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( EVALUATE(lcQty) * lnSnType )
          ENDIF
          *C102567,1 [End]
          *B603915,1 AMH [End]
      ENDIF
      *B603874,1 MHM 09/06/2000 [end]  
    ENDFOR
  ELSE
    IF ldTrDate > laDtPeriod[10,2]
      FOR lnSz_no = 1 TO lnSize_cnt
        lcSz_no = STR(lnSz_no,1) 
        *B603915,1 AMH determin use lnQty Array or QtyX fields [Start]
        lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
        *laOTCInfo[lnSz_no,10]=laOTCInfo[lnSz_no,10] + ( Qty&lcSz_no * lnSnType )
        laOTCInfo[lnSz_no,10]=laOTCInfo[lnSz_no,10] + ( EVALUATE(lcQty) * lnSnType )
        *B603915,1 AMH [End]
      ENDFOR
    ELSE
      FOR lnSz_no = 1 TO lnSize_cnt
        lcSz_no = STR(lnSz_no,1) 
        *B603915,1 AMH determin use lnQty Array or QtyX fields [Start]
        lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
        *B603915,1 AMH [End]
        *B802763,1 WAB - if llAddToCur is true add the qty to current but if its 
        *B802763,1 WAB - False add it to the first period not the current period
        *laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( Qty&lcSz_no * lnSnType )
        IF llAddToCur
          *B603915,1 AMH use lcQty insted of QtyX fields [Start]
          *laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( Qty&lcSz_no * lnSnType )
          laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( EVALUATE(lcQty)* lnSnType )
          *B603915,1 AMH [End]
        ELSE
          *B603915,1 AMH use lcQty insted of QtyX fields [Start]
          *laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( Qty&lcSz_no * lnSnType )
          laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( EVALUATE(lcQty)* lnSnType )
          *B603915,1 AMH [End]
        ENDIF
        *B802763,1 WAB - END
      ENDFOR
    ENDIF
  ENDIF
*C102567,1 HBG 03/04/2002 IF Get the setting of OTS based on exact transaction date = 'Yes'
*C102567,1                Update each transaction date with the Qty of the transaction happen in it [Begin]
ELSE
  IF BETWEEN(ldTrDate,laDtPeriod[1,1],laDtPeriod[10,2])
    FOR lnSz_no = 1 TO lnSize_cnt
      IF BETWEEN(ldTrDate,laDtPeriod[1,1],laDtPeriod[1,2])
        lcSz_no = STR(lnSz_no,1) 
        lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
        laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( EVALUATE(lcQty) * lnSnType )
      ELSE
        *B607319,1 KHM 06/25/2003 (Begin) Changing the for loop to be 10 because lnPrdNum might
        *B607319,1                equal to 11,12 or 13 and this is wrong because the 1st cell is 
        *B607319,1                reserved for the Current and cell 12 is reserved for the ord&z+Ship&z.
        *FOR I= lnX TO lnPrdNum
        FOR I= lnX TO 10
        *B607319,1 KHM 06/25/2003 (End)
                
          IF BETWEEN(ldTrDate,laDtPeriod[I,1],laDtPeriod[I,2]) AND IIF(I > lnX,ldTrDate > laDtPeriod[I-1,2],.T.)
            lcSz_no = STR(lnSz_no,1) 
            lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
            laOTCInfo[lnSz_no,I]=laOTCInfo[lnSz_no,I] + ( EVALUATE(lcQty) * lnSnType )
          ENDIF  
        ENDFOR  
      ENDIF  
    ENDFOR
  ELSE
    IF ldTrDate > laDtPeriod[10,2]
      FOR lnSz_no = 1 TO lnSize_cnt
        lcSz_no = STR(lnSz_no,1) 
        lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
        laOTCInfo[lnSz_no,10]=laOTCInfo[lnSz_no,10] + ( EVALUATE(lcQty) * lnSnType )
	  ENDFOR
    ELSE
      FOR lnSz_no = 1 TO lnSize_cnt
        lcSz_no = STR(lnSz_no,1) 
        lcQty = IIF(llArrQty,'lnQty['+lcSz_no+']','Qty'+lcSz_no)
        IF llAddToCur
          laOTCInfo[lnSz_no,1]=laOTCInfo[lnSz_no,1] + ( EVALUATE(lcQty)* lnSnType )
        ELSE
          laOTCInfo[lnSz_no,2]=laOTCInfo[lnSz_no,2] + ( EVALUATE(lcQty)* lnSnType )
        ENDIF
      ENDFOR
    ENDIF  
  ENDIF      
ENDIF
*C102567,1 [End]

RETURN

*:******************************************************************
*! PROG : lpUpdOTS
*! Developer : Hend Ghanem (HBG)
*! Date      : 03/04/2002
*! DESC : Update OTS qty. in each period
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lcOtsKey->OTS key like style as ex.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*!C102567,1 HBG
PROCEDURE lpUpdOTS

FOR lnSz_no = 1 TO lnSize_cnt
  lnCurrent = laOTCInfo[lnSz_no,1]
  
  *B607319,1 KHM 06/25/2003 (Begin) Changing the for loop to be 10 because lnPrdNum might
  *B607319,1                equal to 11,12 or 13 and this is wrong because the 1st cell is 
  *B607319,1                reserved for the Current and cell 12 is reserved for the ord&z+Ship&z.
  *FOR I = 2 TO lnPrdNum
  FOR I = 2 TO 10
  *B607319,1 KHM 06/25/2003 (End)
  
    laOTCInfo[lnSz_no,I] = laOTCInfo[lnSz_no,I] + lnCurrent
    lnCurrent = laOTCInfo[lnSz_no,I]
  ENDFOR  
ENDFOR

*:******************************************************************
*! PROG : lpPstNvVlu
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : Procedure to post the negative values in any period to the
*!        nearst positive value of any next period.
*!        - We do this by looping the two dimensional array "laOTCInfo"
*!          in case of the report format is by size , otherwise we will
*!          loop just the last row of the same array (which holds the
*!          total OTS quantities for this color) ,to do the following :
*!        - If there is a negative value , we will make it 0 and subtract
*!          it from the nearst next period has a POSITIVE value.
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : ............
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*E500304,1 WAB
*!************************************************************************
PROCEDURE lpPstNvVlu
xon_hand = 0
FOR lnSz_no = 1 TO lnSize_cnt
  FOR I=1 TO 10
	IF laOTCInfo[lnSz_no,I] < 0    && -VE NUMBER
  	  xon_hand = laOTCInfo [lnSz_no,I]
	  laOTCInfo[lnSz_no,I] = 0
	  IF I = 1
		DO lppostbf WITH 2,10                  && GO_BACKWORD   ->
	  ELSE
		DO lppostbf WITH I-1,1                 && GO_BACKWORD   <-
		IF (xon_hand < 0) AND (I < 10)
	  	  DO lppostbf WITH I+1,10              && GO_FOREWORD   ->
		ENDIF
  	  ENDIF
	ENDIF   &&-> -VE NUMBER
  ENDFOR
  *--To put the remainning -ve quantity in the last period.
  IF xon_hand < 0
	laOTCInfo[lnSz_no,10] = xon_hand
  ENDIF
  xon_hand = 0
ENDFOR
RETURN

*:******************************************************************
*! PROG : lpPostBf
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : To do the posting either backword or forword.
*! NOTE : Called from lpPstNvVlu
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lnIniPer,lnEndPer->Initial and end periods.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*!E500304,1 WAB
*!*************************************************************
PROCEDURE lpPostBF
PARAMETERS lnIniPer ,lnEndPer
lcFloop=IIF(lnIniPer>lnEndPer,'lnIniPer TO lnEndPer STEP -1',;
                              'lnIniPer TO lnEndPer')
FOR I = &lcFloop
  xon_hand =  xon_hand + laOTCInfo[lnSz_no,I]
  IF xon_hand <= 0
	laOTCInfo[lnSz_no,I] = 0
  ELSE
	laOTCInfo[lnSz_no,I] = xon_hand
	xon_hand = 0
	EXIT
  ENDIF
ENDFOR
RETURN
*:******************************************************************
*! PROG : lpOTSLins
*! Developer : WAB - WALID A. WAHAB
*! Date      : 11/24/1999
*! DESC : Replace the OTS Quantities.
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : lcOtsKey->OTS key like style as ex.
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : Do ..
*!*************************************************************
*!E500304,1 WAB
*!*************************************************************
PROCEDURE lpOtsLins
PARA lcOtsKey
*-- Loop to accumulate the the OTS lines and total to the 11th col.
*-- in the array .
FOR lnSz_no = 1 TO lnSize_cnt
  *C102567,1 HBG 03/04/2202 IF Get the setting of OTS based on exact transaction date = 'No'
  *C102567,1                the calculation will remain the same [Begin]
  IF !llOTSbasTr
  *C102567,1 [End]
    FOR I = 1 TO 10
	  laOTCInfo[lnSz_no,11] = laOTCInfo[lnSz_no,11]+laOTCInfo[lnSz_no,I]
    ENDFOR
  *C102567,1 HBG 03/04/2202 IF Get the setting of OTS based on exact transaction date = 'Yes'
  *C102567,1                the Total avalibale is the future qty[Begin]
  ELSE
    laOTCInfo[lnSz_no,11] = laOTCInfo[lnSz_no,10]
  ENDIF
  *C102567,1 [End]
ENDFOR

*--Start Update.
*--OTS line for each [color\size].
FOR lnSz_no = 1 TO lnSize_cnt
  lcSz_no = STR(lnSz_no,1) 
  SELECT (lctmpots)
  =SEEK(lcOtsKey+lcSz_no)
  FOR I = 1 TO 12
	Z=ALLTRIM(STR(I,2))
	REPLACE nQty&Z WITH laOTCInfo[lnSz_no,I]
  ENDFOR
ENDFOR
RETURN

*E301361,1 Hesham (Start)
*:******************************************************************
*! Function  : gfDispSpack
*! Developer : Hesham El-Sheltawi
*! Date      : 01/13/2000
*! DESC      : function to display All tracking entries that was 
*!             updated through the service packs
*:******************************************************************
*! Calls     : 
*!             Procedures : ....
*!             Functions  : ....
*!*************************************************************
*! Passed Parameters  : None
*!*************************************************************
*! Returns            : ............
*!*************************************************************
*! Example   : =gfDispSpack()
*!*************************************************************
*!E301361,1 Hesham
*!*************************************************************
*E301361,1 function to display All tracking entries that was updated through
*E301361,1 the service packs

Function gfDispSpack
PRIVATE llServOpn,lcOldBrFld,lcOldAl,laPData,lcBaseFile,lcBrFields,laField_H,laField_N,;
        laFiltrExp,laScrMode
DIME laField_H[2,1],laField_N[2,1],laFiltrExp[1,7],laScrMode[5]
STORE "" TO laField_H,laField_N,laFiltrExp

STORE .F. TO laScrMode
laScrMode[2] = .T.

laField_H[1,1] = "Transsmision#"
laField_N[1,1] = "nBatchNo"

laField_H[2,1] = "Service Pack"
laField_N[2,1] = "cexenam"

lcOldAl = SELECT()
llServOpn=gfSysOpen(gcSysHome+'SYDTRANS')
lcBaseFile = "SYDTRANS"
SELECT SYDTRANS
SET ORDER TO TAG BATCHNO
lcBrFields = [cexenam:H="Service Pack",]+;
             [X=SUBSTR("Bug            Enhancement     New Develop    Custom Program ",(ATC(LEFT(ctrackNo,1),"BENC")-1)*15+1,15)]+;
             [:H="Entry Type",R=SUBSTR(ctrackNo,2):H="Entry ID",ctrksdsc:H="Description",DADD_DATE:H="Date Updated"]
DIME laPData[1]             
lcPushB = "Fi\<nd;;\<Descending;\<Filter;;\?\<Close"
llWasSel=ARIABROW(.F.,"Updated Service Packs",.f., .f., .f., .f.,"",lcPushB,"ctrackNo","laPData")  
USE IN IIF(llServOpn,'SYDTRANS',0)
SELECT (lcOldAl)
*E301361,1 Hesham (End)



*!*************************************************************
*! Name      : lfF3Key
*! Developer : RAMY MABROUK
*! Date      : 06/28/2000
*! Purpose   : Trap the F3 key
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Example   :  =lfF3Key()
*!*************************************************************
*
*E301434,1

FUNCTION lfF3Key

CLEAR TYPEA
KEYBOARD '{SHIFT+END}' PLAIN 
KEYBOARD '{DEL}' PLAIN 


KEYBOARD '{CTRL+END}' PLAIN 
KEYBOARD '{DEL}' PLAIN 

*!*************************************************************
*! Name      : lfSvUsrFld
*! Developer : Ahmed Maher
*! Date      : 11/02/2000
*! Purpose   : Save user defined fields
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Example   :  =lfSvUsrFld()
*!*************************************************************
*
*B803748,1
FUNCTION lfSvUsrFld
IF TYPE('laUsrFields[lnUsrField,6]') # laUsrFields[lnUsrField,3]
  DO CASE
    CASE laUsrFields[lnUsrField,3] = 'N'
      laUsrFields[lnUsrfield,6] = 0
    CASE laUsrFields[lnUsrField,3] = 'L'
      laUsrFields[lnUsrfield,6] = .F.
    CASE laUsrFields[lnUsrField,3] = 'D'
      laUsrFields[lnUsrfield,6] = {  /  /  }
  ENDCASE
ENDIF

*B604016,1 MHM 11/14/2000 [START]
*-- To determine a default value of a popup custom field and fill a popup with it
IF EMPTY(laUsrFields[lnUsrField,6]) 
  IF !(TYPE('laUsrFields[1,1]') $ "UL")
    PRIVATE lnOgCnt , laOgCodInf , llUseCodes , lcCodesOrd , lnActAlias , llCodOpend
    STORE .F. TO llCodOpend , llUseCodes
    lnOgCnt = 0      && loop counter
    lnActAlias = SELECT(0)    && Var. hold a current alias
    *B604688,1 WAB -(Start) - no need for looping on all the user define field because we calling the function for each one
    *FOR lnOgCnt = 1 TO ALEN(laUsrFields,1)      && loop from 1 to a number of custom fields on an OG
    **-- If type of a custom field is char. and empty.
    *  IF (TYPE("laUsrFields[lnOgCnt,6]") = "C") AND EMPTY(laUsrFields[lnOgCnt,6]) 
    *    IF !llCodOpend   && Var to avoid opening codes files within the for loop each time we enter it.
    *      llCodOpend = .T.
    *      llUseCodes = USED("CODES")    && Var. to know if codes file is already opened or not
    *      IF llUseCodes
    *        SELECT CODES
    *        lcCodesOrd = ORDER()   && Var. hold a current index of codes file
    *        SET ORDER TO Ccode_no
    *      ELSE
    *        =gfOpenFile(gcDataDir+"CODES","Ccode_no","SH")   && if codes file not opened open it.
    *      ENDIF
    *    ENDIF
    *    
    *    IF SEEK("D"+ALLTRIM(laUsrFields[lnOgCnt,1]))  && seek about current custom filed in codes file
    *      laUsrFields[lnOgCnt,6] = cCode_No    && if found put the default value in the popup
    *    ELSE  
    *      laUsrFields[lnOgCnt,6] = ""
    *    ENDIF
    *  ENDIF
    *ENDFOR  
    *-- If type of a custom field is char. and empty.
    IF (TYPE("laUsrFields[lnUsrField,6]") = "C") AND EMPTY(laUsrFields[lnUsrField,6]) 
      IF !llCodOpend   && Var to avoid opening codes files within the for loop each time we enter it.
        llCodOpend = .T.
        llUseCodes = USED("CODES")    && Var. to know if codes file is already opened or not
        IF llUseCodes
          SELECT CODES
          lcCodesOrd = ORDER()   && Var. hold a current index of codes file
          SET ORDER TO Ccode_no
        ELSE
          =gfOpenFile(gcDataDir+"CODES","Ccode_no","SH")   && if codes file not opened open it.
        ENDIF
      ENDIF
      
      IF SEEK("D"+ALLTRIM(laUsrFields[lnUsrField,1]))  && seek about current custom filed in codes file
        laUsrFields[lnUsrField,6] = cCode_No    && if found put the default value in the popup
      ELSE  
        laUsrFields[lnUsrField,6] = ""
      ENDIF
    ENDIF
    *B604688,1 WAB -(End) 
    
    IF llUseCodes    && if codes file already opened above change index to previous index
      SET ORDER TO &lcCodesOrd
    ELSE      &&Else close codes file
      =llCodOpend AND gfCloseFile("CODES")
    ENDIF
    SELECT (lnActAlias)
  ENDIF
ENDIF
*B604016,1 MHM 11/14/2000 [END]

IF laUsrFields[lnUsrField,3] = "G" .AND. TYPE('laUsrFields[lnUsrField,6]') # "G"
  RETURN
ELSE
  *B803923,1 (Begin) Save the default vaue for any UDF.
  *B604688,1 WAB -(Start) get the default value if the user didn't didn't select any element of popup
  *IF laScrMode[4]  
  IF laScrMode[4] .AND. EMPTY(laUsrFields[lnUsrField,6])
  *B604688,1 WAB - (End)
    lnActAlias = SELECT(0)
    llFLDUsed = USED("SYDFIELD")
    IF llFLDUsed
      SELECT SYDFIELD
      lcFldOrd = ORDER()
      lcKey = EVAL(KEY())
      SET ORDER TO cFld_Name
    ELSE
       =gfOpenFile(gcSysHome+"SYDFIELD",gcSysHome+"cFld_Name","SH")
    ENDIF
    IF SEEK(laUsrFields[lnUsrField,1])
      lcVEntries = mVEntries
      IF !EMPTY(lcVEntries) AND ATC("@",lcVEntries) <> 0
        *--Get the default value.

        *B129671,1 NNA 09/26/2005 (Begin) Seek For [~@] instead of [@] only
        *lnSt  = ATC("@",lcVEntries)
        lnSt  = ATC("~@",lcVEntries)
        *B129671,1 NNA (END)

        lnEnd = ATC("|",SUBSTR(lcVEntries,lnSt))
        lnEnd = IIF(lnEnd = 0,LEN(lcVEntries),lnEnd-1)
        lcDefVal = SUBSTR(lcVEntries,lnSt,lnEnd)

        *B129671,1 NNA 09/26/2005 (Begin) Seek For [~@] instead of [@] only
        *lcDefVal = STRTRAN(lcDefVal,"@",'')
        lcDefVal = STRTRAN(lcDefVal,"~@",'')
        *B129671,1 NNA (END)

        laUsrFields[lnUsrField,6] = lcDefVal
      ENDIF  
    ENDIF
    IF llFLDUsed
      SET ORDER TO &lcFldOrd
      =SEEK(lcKey)  
    ELSE
      =gfCloseFile("SYDFIELD")
    ENDIF
    SELECT (lnActAlias)


  ELSE
    IF TYPE("laUsrFields[lnUsrField,6]") = "C"
      *B129671,1 NNA 09/26/2005 (Begin) Comment the Else statement to prevent system from replacing [@] with ''
      *laUsrFields[lnUsrField,6]= STRTRAN(laUsrFields[lnUsrField,6],"@",'')
      laUsrFields[lnUsrField,6]= IIF(LEFT(laUsrFields[lnUsrField,6],1)=='@',STRTRAN(laUsrFields[lnUsrField,6],"@",''),laUsrFields[lnUsrField,6])
      *B129671,1 NNA (End)
    ENDIF  

  ENDIF  
  *B803923,1 (End)
  REPLACE &laUsrFields[lnUsrField,1] WITH laUsrFields[lnUsrField,6]
ENDIF
*-- end of lfSvUsrFld.

*!*************************************************************
*! Name      : lfDfRunDir
*! Developer : MAB (Mohamed Atia Badran)
*! Date      : 11/19/2000
*! Purpose   : Checks for current drive and if it is CD-ROM or Floopy drive
*!           : it will change the path to the directory of the running aria program. 
*!*************************************************************
*!
*B604025,1
FUNCTION lfDfRunDir
PRIVATE lcSetLibr , lcPathSet , lcDfRunDir
*-- Set Libarary to Foxtools.
lcSetLibr = SET("LIBRARY")
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  SET LIBRARY TO (SYS(2004)+"FOXTOOLS.FLL") ADDITIVE
*ENDIF

*-- Save full path setting
lcPathSet = SET("FULLPATH")
SET FULLPATH ON

lcDfRunDir = JUSTPATH(FULLPATH(SYS(16,0)))
SET DEFAULT TO &lcDfRunDir

*-- Restore Full path setting
SET FULLPATH &lcPathSet

*-- Release foxtools libarary.
*IF !(SYS(2004)+"FOXTOOLS.FLL" $ lcSetLibr)
*  RELEASE LIBRARY (SYS(2004)+"FOXTOOLS.FLL")
*ENDIF  
*-- end of lfDfRunDir.

*!*************************************************************
*! Name      : gfUsrVldFn
*! Developer : Ahmed Mohamed Ibrahim
*! Date      : 01/31/2001
*! Purpose   : Function to run any function withen its program
*!*************************************************************
*! Called from : Global all over the system
*!*************************************************************
*! Calls       : passed function as a parameter
*!*************************************************************
*! Passed Parameters : lcFncNam,lcFncLoc,lcParam
*!                     lcFncNam  : Variable hold the name function 
*!                     lcFncLoc  : Variable hold the function path
*!                     lcParam   : Variable hold the parameters 
*!*************************************************************
*! Return      : None
*!*************************************************************
*! Example     : = gfUsrVldFn()
*!*************************************************************
FUNCTION gfUsrVldFn
PARAMETERS lcFncNam,lcFncLoc,lcParam
*-- lcRetrn variable to hold the return value
PRIVATE lcRetrn

IF !EMPTY(lcFncNam)
  lcRetrn  = SPACE(0)
  lcRootDr = STRTRAN(UPPER(gcAppHome),'PRGS\','')
  * If lcFncLoc parm. is not empty that measns the lcFncNam function will be called from 
  * main program lcFncLoc 
  IF !EMPTY(lcFncLoc)  
    IF  FILE(lcRootDr+lcFncLoc+'.FXP')
      lcFncLoc = lcRootDr+lcFncLoc
    ELSE
      lcFncLoc= IIF(FILE(gcAppHome+lcFncLoc+'.FXP'),;
                       gcAppHome+lcFncLoc,;
  	  			       IIF(FILE(gcAppHome+gcAct_Appl+'\'+lcFncLoc+'.FXP'),;
  				            gcAppHome+gcAct_Appl+'\'+lcFncLoc,;
  				            gcAppHome+LEFT(lcFncLoc,2)+'\'+lcFncLoc))
    ENDIF
  ELSE
     * If lcFncLoc is empty that means the lcFncNam function is not embaeded into prg bit its a 
     * separate program. 
  ENDIF  
  IF EMPTY(lcParam)
    DO (lcFncNam) IN (lcFncLoc) WITH lcRetrn
  ELSE
    DO (lcFncNam) IN (lcFncLoc) WITH lcRetrn,&lcParam
  ENDIF
  RETURN lcRetrn
ENDIF

*!*************************************************************
*! Name      : lpZapTrans
*! Developer : MAB (Mohamed Atia Badran)
*! Date      : 02/04/2001
*! Purpose   : Zap SYDTRANS Table upon upgrading
*!*************************************************************
*! B803990,1 MAB 02/04/2001 
*!
PROCEDURE lpZapTrans
PRIVATE lnOAlias , llUseTrans , lcTransOrd
lnOAlias = SELECT(0)
llUseTrans = .F.
IF USED("SYDTRANS")
  llUseTrans = .T.
  lcTransOrd = ORDER("SYDTRANS")
  USE IN SYDTRANS
ENDIF  
USE(gcSysHome+"SYDTRANS") IN 0 EXCL
SELECT SYDTRANS 
ZAP
USE 
IF llUseTrans
  USE(gcSysHome+"SYDTRANS") IN 0 ORDER &lcTransOrd SHARED
ENDIF
SELECT  (lnOAlias)
*-- end of lpZapTrans.

*E500419,1 BWA 08/26/2001 Delete the temp. files that ARIA27 create it.[START]
*!*************************************************************
*! Name      : LFDELTEMP
*! Developer : BASSEM RAFAAT ERNEST(BWA)
*! Date      : 08/26/2001
*! Purpose   : Function to delete the temp. files from the work directory.
*!*************************************************************
*! Called from : ARIA27.PRG
*!*************************************************************
*! Calls       : 
*!*************************************************************
*! Passed Parameters : None
*!*************************************************************
*! Return      : ''
*!*************************************************************
FUNCTION LFDELTEMP
PRIVATE lcAlias

lcAlias = SELECT(0)
STORE .F. TO llSyccomp
STORE SPACE(0) TO lcSyccomp

IF !USED('SYCCOMP')
  llSyccomp = .T.
  USE (gcSysHome+"SYCCOMP") IN 0
  SELECT SYCCOMP
  SET ORDER TO TAG CCOMP_ID
ELSE
  SELECT SYCCOMP
  lcSyccomp = ORDER()
  SET ORDER TO TAG CCOMP_ID
ENDIF

lnPahDTmp = ATC("\WORK" , gcWorkDir )
lcDataDir = gcWorkDir

SELECT SYCCOMP
DIMENSION lcFilUnCmP[1]
llFirstTim = .T.

SCAN
  lcPathDir = SUBSTR(gcWorkDir , 1 , lnPahDTmp)
  lcPathDir = lcPathDir+"DBFS\"+ALLTRIM(SYCCOMP.CCOMP_ID)+"\UNCMSESS.DBF"
  USE &lcPathDir IN 0 ORDER 1
  SELECT UNCMSESS
  SCAN FOR STATUS = "O"
    STORE SPACE(0) TO lcNamFInM      &&lcNamFInM to get the name of the temp. files from the memo field.
    DIMENSION lcMemofld[1]
    STORE (UNCMSESS.MTMPFILES) TO lcMemofld[1]
    IF !EMPTY(lcMemofld[1])
      lnTimes = OCCURS("X" , lcMemofld[1])
      IF lnTimes > 0
        FOR lnLopTms = 1 TO lnTimes
          IF llFirstTim
            lcVarInsrt = SUBSTR(lcMemofld[1] , ATC("X" , lcMemofld[1] , lnLopTms) , 8)
            IF AT("," , lcVarInsrt) = 0
              lcFilUnCmP[1] = lcVarInsrt
              llFirstTim = .F.
            ENDIF
          ELSE
            lcValue  = SUBSTR(lcMemofld[1] , ATC("X" , lcMemofld[1] , lnLopTms) , 8)
            lnDataPos = ASCAN(lcFilUnCmP,lcValue)
            IF lnDataPos = 0 AND AT("," , lcValue) = 0
              lnLenghtD = ALEN(lcFilUnCmP,1)
              DIMENSION lcFilUnCmP[lnLenghtD+1]
              lcFilUnCmP[lnLenghtD+1] = SUBSTR(lcMemofld[1] , ATC("X" , lcMemofld[1] , lnLopTms) , 8)
            ENDIF
          ENDIF
        ENDFOR
      ENDIF
    ENDIF
  ENDSCAN
  IF USED("UNCMSESS")
    USE
  ENDIF
ENDSCAN

lcSaveDir = FULLPATH('')
lcWorkDIr = gcWorkDir
gcWorkDir = gcWorkDir + "X*.*"  &&E:\ARIA27\WORK\X*.*"
DIMENSION lcFilDlTmp[1]
=ADIR(lcFilDlTmp,(gcWorkDir))
gcWorkDir = lcWorkDIr

DIMENSION lcFlDlTmp2[1]
lnPahDTmp = ATC("\WORK" , gcWorkDir )
lcPathMstr = SUBSTR(gcWorkDir , 1 , lnPahDTmp) + "X*.*"
=ADIR(lcFlDlTmp2,(lcPathMstr))
lcPathMstr = SUBSTR(gcWorkDir , 1 , lnPahDTmp)

lcExtnson = "DBF,CDX,FPT"

SET DEFAULT TO &gcWorkDir
lnArayLen = ALEN(lcFilDlTmp,1)
IF lnArayLen > 0
  FOR lnDelTmp = 1 TO lnArayLen
    IF FILE(gcWorkDir + lcFilDlTmp[lnDelTmp,1]) AND ASCAN(lcFilUnCmP,LEFT(lcFilDlTmp[lnDelTmp,1],8)) = 0 AND lcFilDlTmp[lnDelTmp,3] < DATE()
      IF RIGHT((gcWorkDir + lcFilDlTmp[lnDelTmp,1]), 3) $ lcExtnson
        ERASE (gcWorkDir + lcFilDlTmp[lnDelTmp,1])
      ENDIF
    ENDIF
  ENDFOR
ENDIF

SET DEFAULT TO &lcPathMstr
lnArayLen = ALEN(lcFlDlTmp2,1)
IF lnArayLen > 0
  FOR lnDelTmp = 1 TO lnArayLen
    IF FILE(lcPathMstr + lcFlDlTmp2[lnDelTmp,1]) AND ASCAN(lcFilUnCmP,LEFT(lcFlDlTmp2[lnDelTmp,1],8)) = 0 AND lcFlDlTmp2[lnDelTmp,3] < DATE()
      IF RIGHT((lcPathMstr + lcFlDlTmp2[lnDelTmp,1]), 3) $ lcExtnson
        ERASE (lcPathMstr + lcFlDlTmp2[lnDelTmp,1])
      ENDIF
    ENDIF
  ENDFOR
ENDIF

DIMENSION lcFlDlTmp3[1]
lnPahDTmp = ATC("\WORK" , gcWorkDir )
lcPathMstr = SUBSTR(gcWorkDir , 1 , lnPahDTmp) + "*.TMP"
=ADIR(lcFlDlTmp3,(lcPathMstr))
lcPathMstr = SUBSTR(gcWorkDir , 1 , lnPahDTmp)

SET DEFAULT TO &lcPathMstr
lnArayLen = ALEN(lcFlDlTmp3,1)
IF lnArayLen > 0
  FOR lnDelTmp = 1 TO lnArayLen
    IF FILE(lcPathMstr + lcFlDlTmp3[lnDelTmp,1])
      ERASE (lcPathMstr + lcFlDlTmp3[lnDelTmp,1])
    ENDIF
  ENDFOR
ENDIF

SET DEFAULT TO &lcSaveDir

IF llSyccomp
  USE IN SYCCOMP
ELSE
  SELECT SYCCOMP
  SET ORDER TO &lcSyccomp
ENDIF

gcWorkDir = lcDataDir
SELECT(lcAlias)

*--End of LFDELTEMP.
*E500419,1 BWA 08/26/2001.[END]


*!*************************************************************
*! Name      : lpDelTrans
*! Developer : NAD(Nader Anis Mitry)
*! Date      : 02/04/2001
*! Purpose   : Delete SYDTRANS records upon upgrading Module(s)
*!B604944,1   NAD 09/20/2001 Fix Sydtrans is Zapped after runinig any 
*!B604944,1                standered fix program
*!**************************************************************

PROCEDURE lpDelTrans
PRIVATE lnOAlias , llUseTrans , lcTransOrd
lnOAlias = SELECT(0)
llUseTrans = .F.
IF USED("SYDTRANS")
  llUseTrans = .T.
  lcTransOrd = ORDER("SYDTRANS")
  USE IN SYDTRANS
ENDIF  
USE(gcSysHome+"SYDTRANS") IN 0 EXCL ORDER cExeNam
SELECT SYDTRANS 
 IF SEEK(lcMd_id, 'SYDTRANS')
   DELETE REST WHILE LEFT(cExeNam,2) =lcMd_id
   PACK
 ENDIF
USE 
IF llUseTrans
  USE(gcSysHome+"SYDTRANS") IN 0 ORDER &lcTransOrd SHARED
ENDIF
SELECT  (lnOAlias)
*-- end of lpZapTrans.

*!*************************************************************
*! Name      :lfUpdTrans
*! Developer : NAD(Nader Anis Mitry)
*! B605445,1 NAD 01/30/2002 Fix Bug in the Realease             
*!**************************************************************
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*PROCEDURE lfUpdTrans
*PROCEDURE x_lfUpdTrans
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 

*BADRAN    MAB 01/05/2002 Run this process once... BEGIN
IF llEXEzaped
  RETURN .T.
ELSE
  *-- BADRAN 02/16/2003 Check the existance of the transmission file.
  IF !FILE(gcSysHome+"HDDTRANS.DBF")
    llEXEzaped = .T.
    RETURN .T.
  ENDIF
ENDIF 
*BADRAN    MAB 01/05/2002 Run this process once... END

lnOAlias = SELECT(0)
llUseAppl = .F.
IF USED("SYDAPPL")
  llUseAppl = .T.
  lcAppOrd = ORDER("SYDAPPL")
  USE IN SYDAPPL
ENDIF  
USE(gcSysHome+"SYDAPPL") IN 0 SHARED ORDER cApp_ID

llUseTrans = .F.
IF USED("SYDTRANS")
  llUseTrans = .T.
  lcTransOrd = ORDER("SYDTRANS")
  USE IN SYDTRANS
ENDIF  
USE(gcSysHome+"SYDTRANS") IN 0 EXCL ORDER cExeNam DESC

*BADRAN    MAB 01/05/2002 ... BEGIN
*-- Open the history transaction table
USE(gcSysHome+"HDDTRANS") ORDER 1 IN 0 EXCL

*-- Open the EXEs table.
USE(gcSysHome+"SYDEXES") IN 0 EXCL
SELECT SYDEXES
ZAP
USE IN SYDEXES
llEXEzaped = .T.  && Avoid making this process again.
*BADRAN    MAB 01/05/2002 ... END

llPack = .F.
SELECT SYDAPPL
SCAN
  lcExe2Comp = PADR(SYDAPPL.cApp_Id,2) + RIGHT(ALLTRIM(SYDAPPL.cMdlBuild),3)
  IF SEEK(PADR(SYDAPPL.cApp_Id,2),"SYDTRANS") AND (lcExe2Comp > LEFT(ALLTRIM(SYDTRANS.cExeNam),5))
    REPLACE nSrvcPak WITH 0
    SELECT SYDTRANS
    DELETE REST WHILE LEFT(cExeNam,2) = PADR(SYDAPPL.cApp_Id,2)
    llPack = .T.
  ENDIF

  *BADRAN    MAB 01/05/2002 ... (Add the history record.) BEGIN
  IF SEEK(PADR(SYDAPPL.cApp_Id,2),"HDDTRANS")
    SELECT HDDTRANS
    SCATTER MEMVAR MEMO
    INSERT INTO SYDTRANS FROM MEMVAR
  ENDIF
  *BADRAN    MAB 01/05/2002 ... (Add the history record.) END

ENDSCAN

IF llPack
  SELECT SYDTRANS
  PACK
ENDIF

IF llUseTrans
  USE(gcSysHome+"SYDTRANS") IN 0 ORDER &lcTransOrd SHARED
ELSE
   USE IN SYDTRANS
ENDIF

IF llUseAppl
  USE(gcSysHome+"SYDAPPL") IN 0 ORDER &lcAppOrd SHARED 
ELSE
  USE IN SYDAPPL
ENDIF

*BADRAN    MAB 01/05/2002 ... (Erase the history table.) BEGIN
USE IN HDDTRANS
ERASE (gcSysHome+"HDDTRANS.CDX")
ERASE (gcSysHome+"HDDTRANS.DBF")
*BADRAN    MAB 01/05/2002 ... (Erase the history table.) END

SELECT  (lnOAlias)
RETURN .T.
*-- end of the update transaction process.
 
*:***************************************************************************
*: Name       : lfLnBrowse
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 04/07/2001
*: Purpose    : Browse the Material Manfacturning Order lines.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfLnBrowse()
*:***************************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
FUNCTION lfLnBrowse
PRIVATE lnAlias

lnAlias    = SELECT(0)
SELECT (lcTmpAudt)

lcBrFields = "SYCEVENT.cDiscrep :25:H='Event' ,"+;
              "cAdd_User :20:H='User ID' ," +;
              "cAdd_Time :15:H='Time' ," +;
              "dAdd_Date :H='Date' ," +;
              "NeededInf = SUBSTR(ALLTRIM(mNeededInf) , 1 , 65) : 65 :H='Needed Information'"
              
*B606411,1 ABD - Fix Bug variable lcLinesBrw NOT Found. [Begin]
*BROWSE FIELDS &lcBrFields;
       LOCK 0   ;
       NOAPPEND ;
       NOEDIT   ;
       NOCLEAR  ;
       NODELETE ;
       NOMENU   ;
       NOWAIT   ;
       SAVE     ;
       VALID :F lfvBrow();
       WHEN lfwLnBrow();       
       TITLE (lcLinesBrw);
       WINDOW syaudtr3 IN WINDOW syaudtrl
*=lfwLnBrow()       

BROWSE FIELDS &lcBrFields;
       LOCK 0   ;
       NOAPPEND ;
       NOEDIT   ;
       NOCLEAR  ;
       NODELETE ;
       NOMENU   ;
       NOWAIT   ;
       SAVE     ;
       VALID :F lfvLnBrows();
       WHEN lfwLnBrows();       
       TITLE (lcLinesBrw);
       WINDOW syaudtr3 IN WINDOW syaudtrl
       
*B606411,1 ABD - [End]


SELECT(lnAlias)

*-- End OF lfLnBrowse.
*:***************************************************************************
*: Name       : lfwLnBrow
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 04/07/2001
*: Purpose    : "WHEN" function of the Material MO lines browse.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfwLnBrow()
*:***************************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
*B606411,1 ABD - rename the next function to Fix Bug variable lcLinesBrw NOT Found. [Begin]
*FUNCTION lfwLnBrow
FUNCTION lfwLnBrows
*B606411,1 ABD - [End]
PRIVATE lnAlias

lnAlias    = SELECT(0)
SELECT (lcTmpAudt)
lcDesc      = SYCEVENT.cDiscrep
lcAdd_User  = &lcTmpAudt..cAdd_User
lcAdd_Time  = &lcTmpAudt..cAdd_Time
ldAdd_Date  = &lcTmpAudt..dAdd_Date

= lfRefresh('syaudtr1')

IF WEXIST(lcLinesBrw)
  SHOW WINDOW (lcLinesBrw) REFRESH
ENDIF

SELECT(lnAlias)

*-- End of lfwLnBrow.
*:***************************************************************************
*: Name       : lfvBrow
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 03/18/2001
*: Purpose    : Valid function for all the screen's browses.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfvBrow()
*:***************************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
*B606411,1 ABD - rename the next function to Fix Bug variable lcLinesBrw NOT Found. [Begin]
*FUNCTION lfvBrow
FUNCTION lfvLnBrows
*B606411,1 ABD - [End]

*-- Call the global function "gfStopBrow" if one of the screen's
*-- browses is active.
DO CASE
  CASE !(WONTOP()=lcLinesBrw)
    glFromBrow = .T.
    = gfStopBrow()
ENDCASE

*-- End of lfvBrow.
*:***************************************************************************
*: Name       : lfvOkAudt
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 03/18/2001
*: Purpose    : Valid function for all the screen's browses.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfvOkAudt()
*:***************************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
FUNCTION lfvOkAudt
PRIVATE lnAlias

lnAlias = SELECT (0)
SELECT (lcTmpAudt)
LOCATE
SCAN FOR !EMPTY(mNeededInf)
  =SEEK(capobjnam+key+caudtralid,'Audtrail')
  REPLACE Audtrail.mNeededInf WITH &lcTmpAudt..mNeededInf
ENDSCAN

IF USED(lcTmpAudt)
  USE IN (lcTmpAudt)
  ERASE (gcWorkDir+lcTmpAudt+".DBF")
  ERASE (gcWorkDir+lcTmpAudt+".CDX")
  ERASE (gcWorkDir+lcTmpAudt+".FPT")
ENDIF

SELECT (lnAlias)

*-- End Of lfvOkAudt
*:*************************************************************
*: Name      : lpClose
*: Developer : ABDOU ELGENDI - (ABD)
*: Date      : 11/19/2001
*: Purpose   : Trap Esc for lines entry.
*:*************************************************************
*: Calls     : None.
*:*************************************************************
*: Passed Parameters  : None.
*:*************************************************************
*: Returns   :  None.
*:*************************************************************
*: Example   :  DO lpClose
*:*************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
PROCEDURE lpClose

_CUROBJ = OBJNUM(pbCancel)
KEYBOARD '{ENTER}'
RETURN

*-- End Of lpClose
*:*************************************************************
*: Name      : lfvAdFind
*: Developer : ABDOU ELGENDI - (ABD)
*: Date      : 11/19/2001
*: Purpose   : Find.
*:*************************************************************
*: Calls     : None.
*:*************************************************************
*: Passed Parameters  : None.
*:*************************************************************
*: Returns   :  None.
*:*************************************************************
*: Example   :  = lfvAdFind ()
*:*************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
FUNCTION lfvAdFind
PRIVATE lnAlias, lcOldBfile,llmyOpen,lcWinTitl,llMyOpen

llMyOpen = .F.

lnAlias = SELECT (0)
IF !USED("SYDFLFLD")
  llMyOpen=.T.
  SELECT 0
  USE &gcSysHome.SYDFLFLD.DBF
    SET ORDER TO TAG CFILE_NAM
ELSE
  SELECT SYDFLFLD
  SET ORDER TO TAG CFILE_NAM
ENDIF  
STORE '' TO lvExpres
lcWinTitl = lcLinesBrw
lnLastobj = 1
STORE .F. TO llEmpty
puField_H = ''
SELECT (lcTmpAudt)


*WAIT WINDOW on('KEY','ALT+B' ) 
PUSH KEY
ON KEY
DO lfvFind.PRG IN ARIABROW.PRG
POP KEY

WAIT WINDOW ('') 
 
SHOW WINDOW (lcLinesBrw) REFRESH SAME
KEYBOARD "{ALT+B}"

IF llMyOpen
  = gfCloseFile('SYDFLFLD')
ENDIF

SELECT (lnAlias)

RETURN
*-- End of lfvAdFind
*:*************************************************************
*: Name      : lfvAdOrder
*: Developer : ABDOU ELGENDI - (ABD)
*: Date      : 11/19/2001
*: Purpose   : set order to .
*:*************************************************************
*: Calls     : None.
*:*************************************************************
*: Passed Parameters  : None.
*:*************************************************************
*: Returns   :  None.
*:*************************************************************
*: Example   :  DO lpClose
*:*************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
FUNCTION lfvAdOrder
lcOrder=SET("ORDER")

IF !EMPTY(lcOrder)
  IF 'DESCENDING' $ UPPER(lcOrder)
    lcOrder=SUBSTR(lcOrder,1,AT("DESCENDING",lcOrder)-1) + ' ASCENDING'
    SET ORDER TO &lcOrder
    SHOW GET pbOrder,1 PROMPT '\<Descending'
  ELSE
    lcOrder=lcOrder + ' DESCENDING'
    SET ORDER TO &lcOrder
    SHOW GET pbOrder,1 PROMPT ' Ascen\<ding'
  ENDIF 
ENDIF

SHOW WINDOW (lcLinesBrw) REFRESH SAME
KEYBOARD "{ALT+B}"

*-- End OF lfvAdOrder.
*:***************************************************************************
*: Name       : lfvAdFilter
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 03/18/2001
*: Purpose    : Filter on the current file.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfvAdFilter()
*:***************************************************************************
*E301866,1 ABD - Enhance the audit trail browse to be screen with memo zoom.
*E301866,1 ABD - We will add a memo field to anmed comment . so we ned
*E301866,1 ABD - To change the browse of the audit trail screen o be a 
*E301866,1 ABD - normal screen with browse and edit line and button zoom to the comment field.
FUNCTION lfvAdFilter
PRIVATE lnAlias , llMyOpen

lcWinTitl = lcLinesBrw
lnLastobj = 1
DIMENSION laCntObj[6,5]
STORE .F. TO laCntObj , llBrWasFltr, llMyOpen

STORE '' TO lcCurFilter , lcFiltExp , gcFiltexp

lnAlias = SELECT (0)
IF !USED("SYDFLFLD")
  llMyOpen=.T.
  SELECT 0
  USE &gcSysHome.SYDFLFLD.DBF
    SET ORDER TO TAG CFILE_NAM
ELSE
  SELECT SYDFLFLD
  SET ORDER TO TAG CFILE_NAM
ENDIF  

SELECT (lcTmpAudt)

PUSH KEY
ON KEY
DO lfvFilter.PRG IN ARIABROW.PRG
POP KEY

IF llMyOpen
  = gfCloseFile('SYDFLFLD')
ENDIF

SELECT (lnAlias)

*-- End OF lfvAdFilter
*:***************************************************************************



*!***************************************************************************
*! Name      : lpMenuPad
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 05/15/2002
*! Purpose   : Add either pad 1 or 4 or 5 for any module.
*!***************************************************************************
*! Example   : DO lpMenuPad
*!***************************************************************************
*B605903,1 Handle all the shifting of menu lines after inserting records.
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [Start] 
*PROCEDURE lpMenuPad
PROCEDURE x_lpMenuPad
*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 
PARAMETERS lcCurPadPo

PRIVATE lcAlias , lcSetDelet
lcAlias = ALIAS()

APPEND FROM (gcSysHome+lcMd_id+"CMENU") FOR cPad_Pos = lcCurPadPo
       
*-- Create Temp file for all lines that need to be shifted.
PRIVATE laTmpMnu
=AFIELDS(laTmpMnu)
CREATE TABLE (gcWorkDir + 'TmpEmpMn') FROM ARRAY laTmpMnu
*E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
=lfCrFox2x()
*E303074,1 TMI 02/20/2012 [End  ] 
       
PRIVATE lnCurBarPo , lnCurPopPo , lnCurSubPo , lnPrvBarPo
STORE 0 TO lnCurBarPo , lnCurPopPo , lnCurSubPo , lnPrvBarPo

*B038431,1 MHM 09/04/2004  [Start]
*-- we are replacing Custom menu with new value (cMstr_Nam ,cPross_ID)
*-- assigned with menu which come from Build for sub menu
SELECT SycMenu
=SEEK(lcMd_id)
SCAN REST WHILE capp_id+cpad_pos+cpop_pos+cpop_levl+cbar_pos = lcMd_id
  IF (csub_typ <> "S") OR (cPad_Pos <> "05")
    LOOP
  ENDIF
  SELECT (TmpSbMnu)
  *B609601,3 TMI 06/07/2011 [Start] remove the '\<' from the comparison
  *LOCATE FOR cApp_ID + cpad_pos + csub_typ + cSub_Prpt = SycMenu.cApp_ID + SycMenu.cpad_pos + SycMenu.csub_typ + SycMenu.cSub_Prpt 
  LOCATE FOR cApp_ID + cpad_pos + csub_typ + PADR(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) = SycMenu.cApp_ID + SycMenu.cpad_pos + SycMenu.csub_typ + PADR(chrtran(SycMenu.cSub_Prpt,'\<',''),LEN(cSub_Prpt))
  *B609601,3 TMI 06/07/2011 [End  ] 
  *
  IF FOUND()
    IF (cMstr_Nam <>  SycMenu.cMstr_Nam) OR (cPross_ID <>  SycMenu.cPross_ID)
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
      IF FOUND()
        *--check if this record updated befor or not
        SCAN FOR cMstr_Nam = &TmpSbMnu..cPross_ID AND cAdd_User <> "*****"
          REPLACE cMstr_Nam WITH SycMenu.cPross_ID ,;
                  cAdd_User WITH  "*****"
          
        ENDSCAN
      ENDIF  
      SELECT (TmpSbMnu)
      REPLACE &TmpSbMnu..cMstr_Nam WITH SycMenu.cMstr_Nam ,;
              &TmpSbMnu..cPross_ID WITH SycMenu.cPross_ID 
    ENDIF
  ENDIF
ENDSCAN

*B038431,1 MHM 09/04/2004  [End]

SELECT (TmpSbMnu)
*-- Scan all Sub types = "S"
SCAN FOR cPad_Pos = lcCurPadPo
  *-- Check this Sub Menu if it exists in standard menu file.
  SELECT SycMenu
  *B038431,1 MHM 09/04/2004 change key to get correct record  [Start]
  *LOCATE FOR cApp_ID + cMstr_Nam + cPross_ID = TmpSbMnu.cApp_ID + TmpSbMnu.cMstr_Nam + TmpSbMnu.cPross_ID
  *B609601,3 TMI 06/07/2011 [Start]  remove the '\<' from the comparison
  *LOCATE FOR cApp_ID + cpad_pos + csub_typ + cSub_Prpt = &TmpSbMnu..cApp_ID + &TmpSbMnu..cpad_pos + &TmpSbMnu..csub_typ+&TmpSbMnu..cSub_Prpt 
  LOCATE FOR cApp_ID + cpad_pos + csub_typ + padr(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) = &TmpSbMnu..cApp_ID + &TmpSbMnu..cpad_pos + &TmpSbMnu..csub_typ+ padr(chrtran(&TmpSbMnu..cSub_Prpt,'\<',''),LEN(cSub_Prpt))
  *B609601,3 TMI 06/07/2011 [End  ] 
  
  *B038431,1 MHM 09/04/2004 [End]

         
  *-- This Sub Menu EXISTS in standard menu file.
  IF FOUND()
    *-- If Sub Menu title is the same 
    *B609601,3 TMI 06/07/2011 [Start]  remove the '\<' from the comparison
    *IF cSub_Prpt == &TmpSbMnu..cSub_Prpt
    IF PADR(chrtran(cSub_Prpt,'\<',''),LEN(cSub_Prpt)) == PADR(chrtran(&TmpSbMnu..cSub_Prpt,'\<',''),LEN(cSub_Prpt))
      *B609601,3 TMI 06/07/2011 [End  ] 
      *-- We have to check for all Childs in this Sub Menu 
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
             
      *-- Childs for this Sub Menu EXISTS (we have to add them)
      IF FOUND()
        *-- Get Pop up position of previous Sub Menus or main bars.
        SELECT SycMenu
        LOCATE FOR cApp_ID + cMstr_Nam = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        lnPrvBarPo = 0
        SKIP -1
        IF !BOF()
          lnPrvBarPo = VAL(cBar_Pos)   
        ENDIF
        SKIP 1
               
        *-- Get last record in the child menus to delete rest of records after it.
        SET ORDER TO TAG AppPopBar DESCENDING
        LOCATE FOR cApp_ID + cMstr_Nam = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        SET ORDER TO TAG AppPopBar ASCENDING
        IF !FOUND()
          LOCATE FOR cApp_ID + cPross_ID = &TmpSbMnu..cApp_ID + &TmpSbMnu..cPross_ID
        ENDIF
        lnCurBarPo = VAL(cBar_Pos)
        lnCurPopPo = VAL(cPop_Pos)
        lnCurSubPo = VAL(cSub_Pos)
                 
        SKIP
        IF !EOF()
          DELETE REST WHILE cApp_ID = lcMenuToUp
          IF USED('TmpEmpMn')
            USE IN TmpEmpMn
          ENDIF
          lcSetDelet = SET('DELETE')        && Save Delete settings
          SET DELETE OFF
          COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED()
          SET DELETE &lcSetDelet
          USE (gcWorkDir + 'TmpEmpMn') IN 0
          PACK
          GO BOTTOM
        ENDIF
               
        *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
        SELECT (TmpMenu)
        LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
        IF FOUND()
          SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
            SCATTER MEMVAR MEMO
            SELECT SycMenu
            APPEND BLANK
            GATHER MEMVAR MEMO
            lnCurBarPo = lnCurBarPo + 1
            lnCurPopPo = lnCurPopPo + 1
            lnCurSubPo = lnCurSubPo + 1
            REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                    cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                    cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
          ENDSCAN
        ENDIF  
               
        *-- Scan rest of records in Temp. Menu file to adjust there positions.
        SELECT TmpEmpMn
        RECALL ALL
        LOCATE

        lnCurBarPo = 0
        SCAN
          lnCurPopPo = lnCurPopPo + 1
          lnCurSubPo = lnCurSubPo + 1
          IF VAL(cPop_Levl) > 1
            lnCurBarPo = lnCurBarPo + 1
            REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
          ELSE
            lnPrvBarPo = lnPrvBarPo + 1
            IF cSub_Typ = "S"
              lnCurBarPo = 0
              lnCurSubPo = lnCurSubPo + 1
            ENDIF
            REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
          ENDIF
          REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                  cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
        ENDSCAN

        *-- Finally append all the records to Master Menu file (SycMenu).
        SELECT SycMenu
        APPEND FROM (gcWorkDir + 'TmpEmpMn')
      ENDIF
    ELSE        && Sub Menu title is NOT THE SAME (it means a new Sub Menu is added.)
      *-- We have to add this Sub Menu and all its child.
      STORE 0 TO lnPrvBarPo , lnCurBarPo , lnCurPopPo , lnCurSubPo
      
      lnCurPopPo = VAL(cPop_Pos)
      lnCurSubPo = VAL(cSub_Pos)
      lnCurBarPo = VAL(cBar_Pos)
      lnPrvBarPo = VAL(cBar_Pos)        && not used in this case
                       
      IF !EOF()
        DELETE REST WHILE cApp_ID = lcMenuToUp
        IF USED('TmpEmpMn')
          USE IN TmpEmpMn
        ENDIF  
        lcSetDelet = SET('DELETE')        && Save Delete settings
        SET DELETE OFF
        COPY TO (gcWorkDir + 'TmpEmpMn') FOR DELETED()
        SET DELETE &lcSetDelet
        USE (gcWorkDir + 'TmpEmpMn') IN 0
        PACK
        GO BOTTOM
      ENDIF  
             
      SELECT (TmpSbMnu)
      SCATTER MEMVAR MEMO
                          
      SELECT SycMenu
      APPEND BLANK
      GATHER MEMVAR MEMO
      REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
              cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
              cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
             
      *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
      SELECT (TmpMenu)
      LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
      IF FOUND()
        lnCurBarPo = 0
        SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
          SCATTER MEMVAR MEMO
          SELECT SycMenu
          APPEND BLANK
          GATHER MEMVAR MEMO
          lnCurBarPo = lnCurBarPo + 1
          lnCurPopPo = lnCurPopPo + 1
          lnCurSubPo = lnCurSubPo + 1
          REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                  cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                  cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
        ENDSCAN
      ENDIF  

      *-- We have to change all the sub menus names in cMstr_Nam and cPross_ID      
      SELECT TmpEmpMn
      RECALL ALL
      LOCATE

      lnCurBarPo = 0
      SCAN
        lnCurPopPo = lnCurPopPo + 1
        lnCurSubPo = lnCurSubPo + 1
        IF VAL(cPop_Levl) > 1
          lnCurBarPo = lnCurBarPo + 1
          REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
          REPLACE cMstr_Nam WITH ALLTRIM(SUBSTR(cMstr_Nam,1,7)) + STRTRAN(STR(VAL(SUBSTR(cMstr_Nam,8,2))+1,2),' ','0')
        ELSE
          lnPrvBarPo = lnPrvBarPo + 1
          IF cSub_Typ = "S"
            lnCurBarPo = 0
            lnCurSubPo = lnCurSubPo + 1
            REPLACE cPross_ID WITH ALLTRIM(SUBSTR(cPross_ID,1,7)) + STRTRAN(STR(VAL(SUBSTR(cPross_ID,8,2))+1,2),' ','0')
          ENDIF
          REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
        ENDIF
        REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
      ENDSCAN
      SELECT SycMenu
      APPEND FROM (gcWorkDir + 'TmpEmpMn')
    ENDIF
  ELSE       && This Sub Menu DOES NOT EXIST in standard menu file.
    STORE 0 TO lnPrvBarPo , lnCurBarPo , lnCurPopPo , lnCurSubPo
    SET ORDER TO TAG AppPopBar DESCENDING
    SEEK lcMenuToUp + lcCurPadPo
    lnCurPopPo = VAL(cPop_Pos)
    lnCurSubPo = VAL(cSub_Pos)
    lnCurBarPo = VAL(cBar_Pos)
    lnPrvBarPo = VAL(cBar_Pos)

    IF VAL(cPop_Levl) > 1
      PRIVATE lcMenuKey
      lcMenuKey = EVALUATE(KEY())
      LOCATE FOR cApp_ID = lcMenuToUp AND cPop_Levl = "01" AND cSub_Typ = "S"
      IF FOUND()
        lnPrvBarPo = VAL(cBar_Pos)
      ENDIF
      SEEK lcMenuKey
    ELSE
      lnPrvBarPo = VAL(cBar_Pos)
    ENDIF
    SET ORDER TO TAG AppPopBar ASCENDING
           
    SELECT (TmpSbMnu)
    SCATTER MEMVAR MEMO
                          
    SELECT SycMenu
    APPEND BLANK
    GATHER MEMVAR MEMO
    lnPrvBarPo = lnPrvBarPo + 1
    lnCurBarPo = lnCurBarPo + 1
    lnCurPopPo = lnCurPopPo + 1
    lnCurSubPo = lnCurSubPo + 1
    IF m.cSub_Typ = "S"
      lnCurSubPo = lnCurSubPo + 1
    ENDIF
    REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0') , ;
            cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
            cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')

    *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
    SELECT (TmpMenu)
    LOCATE FOR cMstr_Nam = &TmpSbMnu..cPross_ID
    IF FOUND()
      lnCurBarPo = 0
      SCAN REST WHILE cMstr_Nam = &TmpSbMnu..cPross_ID
        SCATTER MEMVAR MEMO
        SELECT SycMenu
        APPEND BLANK
        GATHER MEMVAR MEMO
        lnCurBarPo = lnCurBarPo + 1
        lnCurPopPo = lnCurPopPo + 1
        lnCurSubPo = lnCurSubPo + 1
        REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
                cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
                cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
      ENDSCAN
    ENDIF  

    SELECT TmpEmpMn
    RECALL ALL
    LOCATE
             
    lnCurBarPo = 0
    SCAN
      lnCurPopPo = lnCurPopPo + 1
      lnCurSubPo = lnCurSubPo + 1
      IF VAL(cPop_Levl) > 1
        lnCurBarPo = lnCurBarPo + 1
        REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0')
      ELSE
        lnPrvBarPo = lnPrvBarPo + 1
        IF cSub_Typ = "S"
          lnCurBarPo = 0
          lnCurSubPo = lnCurSubPo + 1
        ENDIF
        REPLACE cBar_Pos WITH STRTRAN(STR(lnPrvBarPo,2),' ','0')
      ENDIF
      REPLACE cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
              cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
    ENDSCAN
    SELECT SycMenu
    APPEND FROM (gcWorkDir + 'TmpEmpMn')
  ENDIF
ENDSCAN
       
*-- After adding all the Sub Menus and all its Child we have to add the Main bars.
SELECT (TmpMenu)
LOCATE FOR cPad_Pos = lcCurPadPo AND cSub_Typ <> "S" AND VAL(cPop_Levl) = 1 
IF FOUND()
  SELECT SycMenu
  SET ORDER TO TAG AppPopBar DESCENDING
  SEEK lcMenuToUp + lcCurPadPo
  SET ORDER TO TAG AppPopBar ASCENDING
       
  lnCurBarPo = VAL(cBar_Pos)
  lnCurPopPo = VAL(cPop_Pos)
  lnCurSubPo = VAL(cSub_Pos)
                 
  *SAMEH     SSE    Fix problem with the menu in biuld 40 
  IF ALLTRIM(cPop_Levl) <> '01'
    SET ORDER TO TAG AppPopBar DESCENDING            
    LOCATE FOR cApp_ID = lcMenuToUp AND cPad_Pos = lcCurPadPo AND cSub_Typ = "S" AND VAL(cPop_Levl) = 1 
    IF FOUND()
      lnCurBarPo = VAL(cBar_Pos)
    ENDIF
    SET ORDER TO TAG AppPopBar ASCENDING      
  ENDIF
  *SAMEH     SSE  FiX problem with the menu in build 40 
  
  *-- Scan all Custom menus file to append all custom childs for this Sub Menu.
  SELECT (TmpMenu)
  SCAN FOR cPad_Pos = lcCurPadPo AND cSub_Typ <> "S" AND VAL(cPop_Levl) = 1 
    SCATTER MEMVAR MEMO
    SELECT SycMenu
    APPEND BLANK
    GATHER MEMVAR MEMO
    lnCurBarPo = lnCurBarPo + 1
    lnCurPopPo = lnCurPopPo + 1
    lnCurSubPo = lnCurSubPo + 1
    REPLACE cBar_Pos WITH STRTRAN(STR(lnCurBarPo,2),' ','0') , ;
            cPop_Pos WITH STRTRAN(STR(lnCurPopPo,2),' ','0') , ;
            cSub_Pos WITH STRTRAN(STR(lnCurSubPo,2),' ','0')
  ENDSCAN
               
  *-- Finally append all the records to Master Menu file (SycMenu).
  SELECT SycMenu
  APPEND FROM (gcWorkDir + 'TmpEmpMn')
ENDIF  
SELECT (lcAlias)
*-- End of lpMenuPad.

*!***************************************************************************
*! Name      : MaOrdBrowA.
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 05/21/2002
*! Purpose   : Browse The Material Order header file sorted by account
*!***************************************************************************
*! Notes     : This program assumes that Order Header file is opened
*!***************************************************************************
*! Example   : DO MaOrdBrowA
*!***************************************************************************
*N000388,1 
PROCEDURE MaOrdBrowA

PARAMETERS XACCOUNT , llRetAlias , lcOrdrType
lcOrdrType = IIF(TYPE('lcOrdrType') <> 'C' .OR. EMPTY(lcOrdrType) , 'O' ,;
                 IIF(UPPER(lcOrdrType) = 'A' , '' , UPPER(lcOrdrType)))

IF TYPE('XORDER')='U'
 STORE '' TO XORDER
ENDIF

IF TYPE('XPOSEARCH')='U'
  XPOSEARCH = .F.
ENDIF

IF TYPE('XSTORE') = 'U'
  XSTORE = ''
ENDIF

IF XPOSEARCH
  DECLARE laValues[1]  && array to get values from browse
  STORE '' TO laValues
  lnOldWork = SELECT()
  SELECT MaSoHdr

  lnOldOrder = SYS(21)
  SET ORDER TO TAG ORDCUST
  
  =SEEK(xAccount+UPPER(xCustPO)+IIF(EMPTY(xStore),'',xStore))
  =SEEK(xAccount+UPPER(xCustPO))
  
  IF FOUND()
    DO CASE
      CASE !EMPTY(xStore) .AND. !EMPTY(lcOrdrType)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR Store = xStore .AND. cOrdType = lcOrdrType
      
      CASE !EMPTY(xStore)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR Store = xStore
      
      CASE !EMPTY(lcOrdrType)
        LOCATE REST;
              WHILE Account + UPPER(CustPO) = xAccount+UPPER(xCustPO);
              FOR cOrdType = lcOrdrType
      
    ENDCASE
  ENDIF
  
  SET ORDER TO &lnOldOrder
  
  IF _WINDOWS
    
    *N000388,1 If we need to display the season and division.
    *lcBrFields = [cMOrder:H="Order#",status:1:H="S",lcSesDesc=gfCodDes(Season,'SEASON'):H="Season",lcDivDesc=gfCodDes(cDivision,'CDIVISION'):H="Division",]+;
    *             [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
    *             [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
    *             [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
    *             [start:H="Start",Complete:H="Complete",Note1:7:H="Notes"]
    lcBrFields = [cMOrder:H="Order#",status:1:H="S",]+;
                 [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
                 [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
                 [:15:H="Name",FabOpen:H="Open.Qty.",FabOpenAmt:H="Open.Amt.",FabShip:H="Ship.Qty.",FabShipamt:H="Ship.Amt.",]+;
                 [start:H="Start",Complete:H="Complete",Note1:7:H="Notes"]
  ELSE
  
    *N000388,1 If we need to display the season and division.    
    *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",cDivision:H="DI",]+;
    *             [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
    *             [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
    *             [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
    *             [start:H="Start",Complete:H="Complete",Note1:6:H="Notes"]
    lcBrFields = [Order:H="Order#",status:1:H="S",]+;
                 [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
                 [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
                 [:15:H="Name",FabOpen:H="Open.Qty.",FabOpenAmt:H="Open.Amt.",FabShip:H="Ship.Qty.",FabShipamt:H="Ship.Amt.",]+;
                 [start:H="Start",Complete:H="Complete",Note1:6:H="Notes"]
  ENDIF

  IF FOUND()
    IF ARIABROW('FOR Account + UPPER(CustPO) + cOrdType + cMOrder = xAccount + UPPER(xCustPO)' +;
                 IIF(EMPTY(lcOrdrType) , "" , " .AND. cOrdType + cMOrder = lcOrdrType") ,;
                 IIF(EMPTY(xStore),""," .AND. Store = xStore") +;
                 "Material Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,'','','CMORDER','laValues')
      xOrder = laValues[1]
    ELSE
      STORE SPACE(6)  TO xOrder
    ENDIF
  ELSE
    =gfDialog('I','No Material Orders matching the selected criteria.')
    STORE SPACE(6) TO xOrder
  ENDIF  
  
  IF llRetAlias
    SELECT (lnOldWork)
  ENDIF
  
  RETURN xOrder
ELSE
  RETURN MaOrdBrow(@XACCOUNT , 'A' , @XORDER , llRetAlias ,;
                 IIF(EMPTY(lcOrdrType) , 'A' , lcOrdrType))
ENDIF
*-- End of MaOrdBrowA.

*!***************************************************************************
*! Name      : MaOrdBrowO
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 05/21/2002
*! Purpose   : Browse The Material Order header file sorted by Order
*!***************************************************************************
*! Notes     : This program assumes that Order Header file is opened
*!***************************************************************************
*! Example   : DO MaOrdBrowO
*!***************************************************************************
*N000388,1 
PROCEDURE MaOrdBrowO

PARAMETERS XORDER , llRetAlias , lcOrdrType

IF TYPE('XACCOUNT')='U'
 STORE '' TO XACCOUNT
ENDIF

RETURN MaOrdBrow(@XACCOUNT , 'O' , @XORDER , llRetAlias , lcOrdrType)
*-- End of MaOrdBrowO

*!***************************************************************************
*! Name      : MaOrdBrow
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 05/21/2002
*! Purpose   : Browse The Material Order header file.
*!***************************************************************************
*! Notes     : This program assumes that Order Header file is opened
*!***************************************************************************
*! Example   : DO MaOrdBrow
*!***************************************************************************
*N000388,1
PROCEDURE MaOrdBrow
PARAMETERS XACCOUNT , lcKey , Xorder , llRetAlias , lcOrdrType    && returns the account code of the customer selected

lcOrdrType = IIF(TYPE('lcOrdrType') <> 'C' .OR. EMPTY(lcOrdrType) , 'O' ,;
                 IIF(UPPER(lcOrdrType) = 'A' , '' , UPPER(lcOrdrType)))

PRIVATE lcBrFields,lnCurAlias,laData

DECLARE laData[2]  && array to get values from browse
DECLARE laOrdState[4,2]

laOrdState[1,1] = 'Open'
laOrdState[1,2] = 'O'
laOrdState[2,1] = 'Hold'
laOrdState[2,2] = 'H'
laOrdState[3,1] = 'Cancelled'
laOrdState[3,2] = 'X'
laOrdState[4,1] = 'Complete'
laOrdState[4,2] = 'C'
STORE '' TO laData
llWasSel=.T.
lnCurAlias = SELECT()
llBrowse = IIF(TYPE('llBrowse')='U',.T.,llBrowse) && variable to determine forcing browse or not
IF _WINDOWS
  
  *N000388,1 If we need to display the season and division.
  *lcBrFields = [cMOrder:H="Order#",status:1:H="S",lcDivDesc=gfCodDes(cDivision,'CDIVISION'):H="Division",]+;
  *             [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
  *             [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
  *             [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
  *             [start:H="Start",Complete:H="Complete",]+;
  *             [Note1:7:H="Notes"]
  lcBrFields = [cMOrder:H="Order#",status:1:H="S",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",FabOpen:H="Open.Qty.",FabOpenAmt:H="Open.Amt.",FabShip:H="Ship.Qty.",FabShipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",]+;
               [Note1:7:H="Notes"]
ELSE
  
  *N000388,1 If we need to display the season and division.
  *lcBrFields = [Order:H="Order#",status:1:H="S",Season:H="SE",cDivision:H="DI",]+;
  *             [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
  *             [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
  *             [:15:H="Name",Open:H="Open.Qty.",OpenAmt:H="Open.Amt.",Ship:H="Ship.Qty.",Shipamt:H="Ship.Amt.",]+;
  *             [start:H="Start",Complete:H="Complete",]+;
  *             [Note1:6:H="Notes"]
  lcBrFields = [Order:H="Order#",status:1:H="S",]+;
               [CustPo=IIF(multipo,'*Multi_PO*',custpo):H="Cust. P.O#",]+;
               [ACCOUNT:H="Acct",store=IIF(MULTI='Y','*Multi*',STORE):H="Store",Customer.stname]+;
               [:15:H="Name",FabOpen:H="Open.Qty.",FabOpenAmt:H="Open.Amt.",FabShip:H="Ship.Qty.",FabShipamt:H="Ship.Amt.",]+;
               [start:H="Start",Complete:H="Complete",]+;
               [Note1:6:H="Notes"]
ENDIF

IF !USED('Customer')
  =gfOpenFile(gcDataDir+'Customer',gcDataDir+'Customer','SH')
ENDIF

SELECT MaSoHdr
SET RELATION TO IIF(STORE=SPACE(8),'M'+ACCOUNT,'S'+ACCOUNT+STORE) INTO CUSTOMER
lcOrdOrder = TAG()
IF lcKey='A'
  SET ORDER TO TAG ORDACCT
ELSE
  SET ORDER TO TAG MaSoHdr
ENDIF  

IF lckey='A'  && called from cus. prog.
  IF !SEEK(xAccount)
    =gfDialog("I","No Material Orders have been found for account# "+xAccount+".") 
    IF !EMPTY(lcOrdOrder)
      SET ORDER TO TAG (lcOrdOrder)
    ELSE
      SET ORDER TO  
    ENDIF  
    SET RELATION TO
    IF llRetAlias
      SELECT (lnCurAlias)
    ENDIF  
    RETURN .F.
  ENDIF
ENDIF

IF llBrowse OR !SEEK(XACCOUNT)
  lnSoftSeek=RECNO(0)
  IF lnSoftSeek<>0 .AND. lnSoftSeek <= RECCOUNT("MaSoHdr")
  ELSE
    GO TOP
  ENDIF     
    lcPushB=IIF(lcKey="A",'',"Fi\<nd;;\<Descending;\<Filter;\!\<Select;\?\<Cancel")
    IF lcKey='A'
      llWasSel=ARIABROW([XACCOUNT + lcOrdrType]+' FOR STORE = IIF(EMPTY(xSTORE),"",xStore)',;
               "Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'cMOrder,Account',"laData")
    ELSE
      llWasSel=ARIABROW('lcOrdrType',"Orders",gnBrFSRow1, gnBrFSCol1, gnBrFSRow2, gnBrFSCol2,"",lcPushB,'cMOrder,ACCOUNT',"laData")
    ENDIF

    IF llWasSel
      XORDER    = laData[1]    
      XACCOUNT  = laData[2]
    ELSE
      XORDER = SPACE(6)
      XACCOUNT = SPACE(5)
    ENDIF  
ENDIF  
IF !EMPTY(lcOrdOrder)
  SET ORDER TO TAG (lcOrdOrder)
ELSE
  SET ORDER TO  
ENDIF  
SET RELATION TO
IF llRetAlias
  SELECT (lnCurAlias)
ENDIF  
RETURN llWasSel
*-- End of MaOrdBrowA.
*!***************************************************************************

*:***************************************************************************
*: Name       : lfvKeyValu 
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 03/18/2001
*: Purpose    : Function To check on the Activation key.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfvKeyValu  ()
*:***************************************************************************
*:
FUNCTION lfvKeyValu

*-- lccust_id   ==> Variable Hold the Customer Id.
*-- lccust_nam  ==> Variable Hold the Customer Name
*-- lcActKey    ==> Variable Hold the Activation Key.
*-- ldexpr_date ==> Variable Hold the Expiration Date.
*-- lcactplat   ==> Variable Hold the platform.
*-- Define needed Variables
STORE '' TO lccust_id , lccust_nam , lcActKey , lcactplat , lcSysActKy
STORE {} TO ldexpr_date

lcSaveDir = FullPath('')
    
*-- Check on the Path.
IF EMPTY(lcFilePath)
  SET DEFA TO &gcSysHome
  STORE FOPEN('ACT_KEY.BIN') TO file_handle       && Open the file      
ELSE
  SET DEFA TO &lcFilePath
  STORE FOPEN(lcFileName) TO file_handle       && Open the new file      
ENDIF
    
    
IF file_handle < 0
  *-- Message Text :- Can not open Activation Key file ! System will be terminated
  *-- Button Text  :- OK.
  llError = .T.
  lcErrMessage = 'Invalid Activation Key ! System will be terminated.'
  SET DEFAULT TO &lcSaveDir
  RELEASE lcSaveDir
  RETURN .T.
ENDIF  
  
STORE FSEEK(file_handle,12876) TO ifp_size	&& Move pointer to EOF
STORE FREAD(file_handle, 76)   TO lcstring  && Store to memory
IF EMPTY(lcstring)
  *-- Message Text :- Invalid Activation Key ! System will be terminated
  *-- Button Text  :- OK.
  llError = .T.
  lcErrMessage = 'Invalid Activation Key ! System will be terminated.'
  SET DEFAULT TO &lcSaveDir
  RELEASE lcSaveDir
  =FCLOSE(file_handle)
  RETURN .T.
ELSE
  llError = .F.
  *-- Get the Customer Id.
  lccust_id  = SUBSTR(lcstring,03,05)
      
  *-- Get the Customer Name.
  lccust_nam = SUBSTR(lcstring,08,030)
    
  *-- Get the Customer activation Key.
  lcActKey   = SUBSTR(lcstring,38,20)
    
  *-- Get the Customer expiration Date.
  ldexpr_date= IIF(EMPTY(SUBSTR(lcstring,58,10)),{},SUBSTR(lcstring,58,10))
    
  *-- Get the Customer Version Type.
  lcactplat  = SUBSTR(lcstring,68,04)
    
  *-- Get the Customer sys(2007) for the current record.    
  lcSysActKy = SUBSTR(lcstring,72,05)
    
  lComparSys = SYS(2007,'NADABDXMLX'+lccust_nam+lcActKey+ldexpr_date+lcactplat)
  
  SET DEFAULT TO &lcSaveDir
  RELEASE lcSaveDir
  =FCLOSE(file_handle)
ENDIF

    
gcCompName  = lccust_nam
gcAct_Key   = lcActKey
gcLicence   = ''
IF  lcSysActKy <> lComparSys
  *-- Message Text :- Invalid Activation Key ! System will be terminated
  *-- Button Text  :- OK.
  llError = .T.
  lcErrMessage = 'Invalid Activation Key ! System will be terminated.'
  RETURN .T.
ENDIF


*-- this Code For Expiration Date
PRIVATE lcOldSyDat
lcOldSyDat = SET ('DATE')
SET DATE TO AMERICAN
IF ALLTRIM(lcactplat) = 'E' .AND. DATE() > CTOD(ldexpr_date)
  llError = .T.
  lcErrMessage = 'Sorry, your Aria version has expired and the system will be terminated. Please contact Aria Sales departement.'
  Set Date To &lcOldSyDat
  RETURN .T.
ENDIF
Set Date To &lcOldSyDat

*-- Save the New File.
IF !EMPTY(lcFilePath)
  lcOldSafty = SET('SAFETY')
  SET SAFETY OFF 
  Copy File &lcNewFile To (gcSysHome+'Act_Key.bin')
  SET SAFETY &lcOldSafty
ENDIF  

*-- End OF lfvKeyValu 
*:***************************************************************************
*: Name       : gfllrelog
*: Developer  : Abdou Elgendy [ABD]
*: Date       : 10/01/2002
*: Purpose    : Function To call the logain screen only.
*:***************************************************************************
*: Calls      : None.
*:***************************************************************************
*: Parameters : None.
*:***************************************************************************
*: Returns    : None.
*:***************************************************************************
*: Example    : = lfvKeyValu  ()
*:***************************************************************************
*: Due to 301874,1
FUNCTION gfllrelog
Private llsyclogo
IF _WINDOWS
  IF !USED('syclogo')
    SELECT 0
    USE(gcSysHome+"syclogo")
    llsyclogo = .T.
 ENDIF
ENDIF

** tmi ** media **
*llReLogIn = .F. 
*llUserChan = .F. 
*DIME laUsr_Pass[8]
** tmi ** media ** 

DO SYLOGIN.SPR
CLEAR READ

IF llsyclogo
  USE IN syclogo
ENDIF
  
RETURN .T.
*-- End OF gfllrelog
*: Due to 301874,1
*:***************************************************************************

*B606496,1 AMH the new gfSheetItem function [Start]
*!*************************************************************
*! Name      : gfSheetItem
*! Developer : Wael Aly Mohamed
*! Date      : 01/01/1996
*! Purpose   : Generate, Modify or Delete cost sheet items for style
*!*************************************************************
*! Calls     : gfGetMemVar,gfModalGen,gfItemMask,gpAdStyWar,gpAdFabWar,lfSelDyelot
*!*************************************************************
*! Parameters: lcTranType : Transaction type   ('M'-'I'-'T')
*!             lcTicketNo : Ticket number
*!             lcLinkCode : WIP Link code
*!             lcItem     : Style/Fabric
*!             lcColor    : Color
*!             lnLineNo   : Ticket line number
*!             lcDyelot   : Dyelot
*!             lcStyWare  : Default Style Issue Warehouse
*!             lcMatWare  : Default Fabric Issue Warehouse
*!             laQty      : Quantity array
*!             lcTmpBom   : Style Cost Sheet file name
*!             lcTktSheet : Cost sheet header file name
*!             lcDetFile  : Cost sheet detailed file name
*!             lcOprHdr   : Operation header file name
*!             lcLastOpr  : Last Operation
*!             lnPrice    : Purchase Price
*!             lnEst1     : Estimated cost 1
*!             lnEst2     : Estimated cost 2
*!             lnEst3     : Estimated cost 3
*!             lnEst4     : Estimated cost 4
*!             lnEst5     : Estimated cost 5
*!             lcTmpName  : Temp name needed to arrange new fabric dyelots
*!             llBackOnly : If .T. update all records in background.
*!*************************************************************
*! Returns   :  None
*!*************************************************************
*! Example   :  =gfSheetItem('M','000001','DEFDEF','ITEMD001','',0,'Dyelot',;
*!                           'WARE1',@laQty,100,'BOM','CTKTBOM','BOMLINE',;
*!                           'MFGOPRHD','000001',0,0,0,0,0)
*!:************************************************************************
*! Modifications:
*B607081,1 ARH 03/23/2003 Closed the curor lcCostElem used on the function to avoid getting
*B607081,1 ARH            the open file dialog in case of big POs
*!:************************************************************************

FUNCTION gfSheetItem
PARAMETERS lcTranType,lcTicketNo,lcLinkCode,lcItem,lcColor,lnLineNo,lcDyelot,;
           lcStyWare,lcMatWare,laQty,lcTmpSheet,lcTktSheet,lcDetFile,lcOprHdr,;
           lcLastOpr,lnPrice,lnEst1,lnEst2,lnEst3,lnEst4,lnEst5,lcTmpName,llBackOnly
PRIVATE    lcMjrMsk,lcMjrHdr,lcNMjrMsk,laItemSeg,lcClrMsk,lnClrPos,lcItemFile,;
           llDyelot,lcScale,lcItemType,lnTranQty,lcSizes,lnCount,lcCstClr,lnUnitPri,;
           lcCstItm,llContinue,laMfgRFld,lnLastSeq,lnSizePos,lcTmpBomSh,laReq,;
           lcContCode,lcContName,lcOperSeq,llInHouse,llMfgOpr,lnLeadTime

*B606496,1 AMH Create cursor to update pieces only when get a new cost element [Start]
*PRIVATE    lcMfgGlAcnt,lcExSign,lcUntSin,lnAlias,lcPriceCur,lnPriceRate,;
           lnPriceUnit,lcDutyCur,lnDutyRate,lnDutyUnit,lcTranStat

PRIVATE    lcMfgGlAcnt,lcExSign,lcUntSin,lnAlias,lcPriceCur,lnPriceRate,;
           lnPriceUnit,lcDutyCur,lnDutyRate,lnDutyUnit, lcCostElem,lnOldTrnQt
lcCostElem = gfTempName()
CREATE CURSOR (lcCostElem) (cTrType C(1), cType C(1), cItem C(19), cIClr C(6),;
                            cMFGCode C(6), cDyelot C(10), cSizes C(8))
INDEX ON cTrType+cType+CItem+CIclr+cMFGCode+cDyelot TAG (lcCostElem) OF (lcCostElem)
*B606496,1 AMH [End]

PRIVATE lcTranLett
*khm1
*lcTranLett = IIF(lcTranType $ "IMT",lcTranType ,"I")
lcTranLett = IIF(lcTranType $ "IMTD",lcTranType ,"I")
*khm1

STORE 1   TO lnPriceRate,lnPriceUnit,lnDutyRate,lnDutyUnit
STORE '/' TO lcExSign,lcUntSin
IF lcTranType = 'I' 
  =SEEK('P'+lcTicketNo,'POSHDR')
  lcPriceCur  = IIF(EMPTY(POSHDR.cPriceCur),gcBaseCurr,POSHDR.cPriceCur)
  lnPriceRate = IIF(POSHDR.nPriceRat=0,1,POSHDR.nPriceRat)
  lnPriceUnit = IIF(POSHDR.nCurrUnit=0,1,POSHDR.nCurrUnit)
  lcDutyCur   = IIF(EMPTY(POSHDR.cDutyCur),gcBaseCurr,POSHDR.cDutyCur)
  lnDutyRate  = IIF(POSHDR.nDutyRat=0,1,POSHDR.nDutyRat)
  lnDutyUnit  = IIF(POSHDR.nDCurUnit=0,1,POSHDR.nDCurUnit)
ENDIF
STORE ''  TO M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC
=gfGetMemVar('M_WAREHOUSE,M_DYELOT,M_MATDYE,M_USEEXSSC',gcAct_Comp)
lcMjrMsk  = gfItemMask("PM")
lcMjrHdr  = gfItemMask("HM")
lcNMjrMsk = gfItemMask("PN")
lcItmMsk  = gfItemMask("PI")
=gfOpenFile(gcDataDir+'BOM',gcDataDir+'BOM','SH')
IF !SEEK(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),lcTmpSheet)
  *E300725,1 Message : 38031
  *E300725,1 Cost sheet not found for style: xxx cannot generate cutting 
  *E300725,1 ticket cost sheet
  *E300725,1 Button : 00000
  *E300725,1 Ok
  =gfModalGen('TRM38031B00000','ALERT',IIF(lcTranType='T','Fabric: ',lcMjrHdr+':')+;
              ALLTRIM(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))))+;
              '|'+IIF(lcTranType='M','cutting ticket',IIF(lcTranType='I','purchase order','order')))
  RETURN(.F.)
ENDIF
lnAlias = SELECT()
DECLARE laMfgRFld[7,2],laItemSeg[1],laReq[8]
STORE '' TO lcContCode,lcContName,lcOperSeq,llInHouse,llMfgOpr,lnLeadTime,lcMfgGlAcnt
laMfgRFld[1,1] = 'CCONTCODE'
laMfgRFld[1,2] = 'lcContCode'
laMfgRFld[2,1] = 'CCONTNAME'
laMfgRFld[2,2] = 'lcContName'
laMfgRFld[3,1] = 'COPERSEQ'
laMfgRFld[3,2] = 'lcOperSeq'
laMfgRFld[4,1] = 'LINHOUSE'
laMfgRFld[4,2] = 'llInHouse'
laMfgRFld[5,1] = 'LMFGOPR'
laMfgRFld[5,2] = 'llMfgOpr'
laMfgRFld[6,1] = 'LEADTIME'
laMfgRFld[6,2] = 'lnLeadTime'
laMfgRFld[7,1] = 'GLACCOUNT'
laMfgRFld[7,2] = 'lcMfgGlAcnt'

=gfItemMask(@laItemSeg)
FOR lnCount = 1 TO ALEN(laItemSeg,1)
  IF laItemSeg[lnCount,1]='C'
    lcClrMsk = laItemSeg[lnCount,3]
    lnClrPos = laItemSeg[lnCount,4]
  ENDIF
  IF laItemSeg[lnCount,1]='S'
    lnSizePos = laItemSeg[lnCount,4]
  ENDIF
ENDFOR
lnLastSeq = 0
IF !EMPTY(lcLastOpr)
  =gfRltFld(lcLastOpr,@laMfgRFld,'MFGCODE')
  lnLastSeq = VAL(LEFT(lcOperSeq,2))
ENDIF
STORE 0 TO lnEst1,lnEst2,lnEst3,lnEst4,lnEst5,lnFEst1,lnFEst2,lnFEst3,lnFEst4,lnFEst5
lcItemFile = IIF(lcTranType='T','Fabric','Style')
llDyelot   = SEEK(lcItem+ALLTRIM(lcColor),lcItemFile) .AND. &lcItemFile..cDye_Flg='Y'
lcScale    = IIF(lcTranType='T','',Style.Scale)
llContinue = .T. 

=gfOpenFile(gcDataDir+'Ctktbom',gcDataDir+'Ctktbom','SH')
=gfOpenFile(gcDataDir+'BomLine',gcDataDir+'BomLine','SH')
=gfOpenFile(gcDataDir+'MFGOPRHD',gcDataDir+'MFGOPRHD','SH')

SET ORDER TO TAG Ctktbom  IN (lcTktSheet)
SET ORDER TO TAG BomLine  IN (lcDetFile)
SET ORDER TO TAG MFGOPRHD IN (lcOprHdr)

lcTmpBomSh = gfTempName()
SELECT BOM
=AFIELDS(laFileStru)
CREATE TABLE (gcWorkDir+lcTmpBomSh) FROM ARRAY laFileStru
*E303074,1 TMI 02/20/2012 [Start] force change file format to fox2.6
=lfCrFox2x()
*E303074,1 TMI 02/20/2012 [End  ] 
INDEX ON typ+item+iclr+citmmajor+citmmask TAG (lcTmpBomSh)
SELECT (lcTmpSheet)
=SEEK(PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19))
SCAN REST WHILE cItmMajor = PADR(IIF(lcTranType='T',lcItem,SUBSTR(lcItem,1,LEN(lcMjrMsk))),19)
  SCATTER MEMVAR MEMO
  IF cCatGTyp='S' .AND. M_USEEXSSC .AND. !EMPTY(MSZCROSREF) .AND. ;
     SUBSTR(ALLTRIM(Item),lnSizePos) = STRTRAN(SUBSTR(lcItmMsk,lnSizePos),'X','*')
    FOR lnCount = 1 TO MEMLINES(MSZCROSREF)
      lcLine = MLINE(MSZCROSREF,lnCount)
      IF SUBSTR(lcLine,1,3) <> lcScale
        LOOP
      ENDIF
      m.Item = PADR(SUBSTR(m.Item,1,lnSizePos-1)+SUBSTR(lcLine,AT('~',lcLine)+1,3),19)
      IF !SEEK(m.typ+m.item+m.iclr+m.citmmajor+m.citmmask,lcTmpBomSh)
        INSERT INTO (lcTmpBomSh) FROM MEMVAR
      ENDIF
    ENDFOR
  ELSE
    INSERT INTO (lcTmpBomSh) FROM MEMVAR
  ENDIF
ENDSCAN

IF USED('STYLE')
  SELECT STYLE
  lcStyFIlt = SET('FILTER')
  SET FILTER TO
ENDIF

lcGrade = ''
IF lcTranType <> 'T'
  =SEEK(lcItem,'Style')
  lcGrade = Style.cStyGrade
ELSE
  =SEEK(lcItem+lcColor,'Fabric')
  lcGrade = Fabric.cFabGrade
ENDIF

IF lcTranType = 'I' OR lcTranType = 'D'
  *--Update Bom cost elements depend on cost in P/O.
  =lfUpdPOBom() 
ENDIF

*-- Flag to check if the message already appeares dont display it again.
llMsgDispd = .F.

SELECT (lcTmpBomSh)
SCAN
  *--MAN Added IF EMPTY(cCatGTyp) .OR. EMPTY(Typ)
  IF EMPTY(cCatGTyp) .OR. EMPTY(Typ)
    IF !llMsgDispd
      *--One or more cost items does not have a proper cost tyoe.
      *--Message : 38171
      =gfModalgen("INM38171B00000","ALERT",cItmMask)
      llMsgDispd = .T.
    ENDIF
    LOOP
  ENDIF
  
  IF !LIKE(STRTRAN(IIF(lcTranType='T',LEFT(cItmMask,6),cItmMask),'*','?'),IIF(lcTranType='T',lcColor,lcItem)) .OR. ;
     (!EMPTY(MSIZES) .AND. ATCLINE(lcScale+'~',MSIZES)=0) .OR. ;
     (!EMPTY(MSZCROSREF) .AND. ATCLINE(lcScale+',',MSZCROSREF)=0)     
    LOOP
  ENDIF
  lcItemType = Typ
  IF EMPTY(MSIZES)
    lnTranQty = laQty[9]
    lcSizes   = '1,2,3,4,5,6,7,8'
  ELSE
    lcSizes = SUBSTR(MLINE(MSIZES,ATCLINE(lcScale+'~',MSIZES)),5)
    lnTranQty = 0
    FOR lnCount = 1 TO 8
      lnTranQty = lnTranQty + IIF(STR(lnCount,1) $ lcSizes,laQty[lnCount],0)
    ENDFOR
  ENDIF
  STORE '' TO lcCstClr,lcCstItm,lcCmSizes
  lcCstItmDye = SPACE(10)
  DO CASE
    CASE cCatGTyp='S'
      lcCmSizes='12345678'
      FOR lnCount = 1 TO 8
        laReq[lnCount]=laQty[lnCount]
      ENDFOR
      lcCstItm=''
      FOR lnCount = 1 TO LEN(ITEM)
        IF SUBSTR(ITEM,lnCount,1)='*'
          lcCstItm = lcCstItm + SUBSTR(lcItem,lnCount,1)
        ELSE
          lcCstItm = lcCstItm + SUBSTR(ITEM,lnCount,1)
        ENDIF
      ENDFOR
      IF !SEEK(lcCstItm,'Style')
        LOOP
      ENDIF
      lcCsItmSc = Style.Scale
      =SEEK(lcItem,'Style')
      IF !EMPTY(MSZCROSREF)
        lcCmSizes = ''
        STORE 0 TO laReq
        FOR lnCount = 1 TO MEMLINES(MSZCROSREF)
          lcLine = MLINE(MSZCROSREF,lnCount)
          IF SUBSTR(lcLine,1,3) = lcScale .AND. SUBSTR(lcLine,7,3)=lcCsItmSc
            laReq[VAL(SUBSTR(lcLine,11,1))] = laReq[VAL(SUBSTR(lcLine,11,1))]+;
            laQty[VAL(SUBSTR(lcLine,5,1))]
            lcCmSizes = lcCmSizes + SUBSTR(lcLine,11,1)
          ENDIF
        ENDFOR
      ENDIF
      IF M_WAREHOUSE='Y' .AND. !EMPTY(lcStyWare) .AND. ;
         !SEEK(lcCstItm+lcStyWare+SPACE(10),'STYDYE')
        *E300725,1 Message : 38029
        *E300725,1 Style xxxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        
        *E300935,4 adjust condition to update without message if llBackOnly is .T.
        *E300935,4 IF gfModalGen('QRM38029B38001','ALERT','Style: '+ALLTRIM(lcCstItm)+'|'+lcStyWare) = 1
        IF llBackOnly OR gfModalGen('QRM38029B38001','ALERT','Style: '+ALLTRIM(lcCstItm)+'|'+lcStyWare) = 1
          DO gpAdStyWar WITH lcCstItm,SPACE(10),lcStyWare
        ENDIF   
      
      ENDIF
      IF !EMPTY(lcStyWare) AND M_DYELOT='Y' .AND. SEEK(lcCstItm,'Style') .AND. Style.cDye_Flg='Y'

        SELECT (lcDetFile)
        =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')

        lcCstItmDye = IIF(FOUND(),&lcDetFile..Dyelot,lcDyelot)
        
        IF SEEK(lcCstItm+lcStyWare+SPACE(10),'STYDYE') AND ;
          (EMPTY(lcCstItmDye) OR !SEEK(lcCstItm+lcStyWare+lcCstItmDye,'StyDye'))
          =gfSelDyelot(lcTranType,'S',lcItem,lcColor,lcStyWare,@lcCstItmDye,lcCstItm,'','',llBackOnly)
        ENDIF
      ENDIF

    CASE INLIST(cCatGTyp,'F','T')
      lcCstItm = SUBSTR(Item,1,7)
      IF IClr = '******'
        lcCstClr = IIF(lcTranType='T',lcColor,SUBSTR(lcItem,lnClrPos,LEN(lcClrMsk)))
      ELSE
        lcCstClr = IClr
      ENDIF
      IF (cCatGTyp='F' OR Trim_Invt) AND !SEEK(lcCstItm+lcCstClr,'FABRIC')
        LOOP
      ENDIF

      *B606997,1 Seek with 6 character for color. [Begin]
      *IF (cCatGTyp='F' .OR. Trim_Invt) .AND. M_WAREHOUSE='Y' .AND. ;
      *   !EMPTY(lcMatWare) .AND. ;
      *   !SEEK(lcCstItm+lcCstClr+lcMatWare+SPACE(10),'FABDYE')
      IF (cCatGTyp='F' .OR. Trim_Invt) .AND. M_WAREHOUSE='Y' .AND. ;
         !EMPTY(lcMatWare) .AND. ;
         !SEEK(PADR(lcCstItm,7)+PADR(lcCstClr,6)+PADR(lcMatWare,6)+SPACE(10),'FABDYE')
      *B606997,1 Seek with 6 character for color. [End]
       
        *E300725,1 Message : 38029
        *E300725,1 Item/Color xxxxx/xxxx is not assigned to warehouse xxxx
        *E300725,1 Button : 38001
        *E300725,1 Add Cancel
        
        *E300935,4 adjust condition to update without message if llBackOnly is .T.
        *E300935,4 IF gfModalGen('QRM38029B38001','ALERT','Item/Color: '+ALLTRIM(lcCstItm)+'/'+ALLTRIM(lcCstClr)+'|'+lcMatWare) = 1
        IF llBackOnly OR gfModalGen('QRM38029B38001','ALERT','Item/Color: '+ALLTRIM(lcCstItm)+'/'+ALLTRIM(lcCstClr)+'|'+lcMatWare) = 1
          DO gpAdFabWar WITH lcCstItm,lcCstClr,SPACE(10),lcMatWare
        ENDIF   
      ENDIF
      IF !EMPTY(lcMatWare) AND (cCatGTyp='F' OR Trim_Invt) AND M_MATDYE='Y' AND ;
         SEEK(lcCstItm+lcCstClr,'Fabric') .AND. Fabric.cDye_Flg='Y' 

        SELECT (lcDetFile)
        =SEEK(lcTranLett +'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
        LOCATE REST WHILE ;
        cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
        lcTranLett +'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
        FOR cSizes = STRTRAN(lcSizes,',','')

        lcCstItmDye = IIF(FOUND(),&lcDetFile..Dyelot,lcDyelot)

        *B606997,1 Seek with 6 character for color. [Begin]
        *IF SEEK(lcCstItm+lcCstClr+lcMatWare+SPACE(10),'FABDYE') AND ;
        *  (EMPTY(lcCstItmDye) OR !SEEK(lcCstItm+lcCstClr+lcMatWare+lcCstItmDye,'FabDye'))
        IF SEEK(lcCstItm+lcCstClr+lcMatWare+SPACE(10),'FABDYE') AND ;
          (EMPTY(lcCstItmDye) OR !SEEK(PADR(lcCstItm,7)+PADR(lcCstClr,6)+PADR(lcMatWare,6)+lcCstItmDye,'FabDye'))
          *B606997,1 Seek with 6 character for color. [End]
  
          *E300935,4 Adjust calling with background parameter (llBackOnly)
          *E300935,4 =gfSelDyelot(lcTranType,'F',lcItem,lcColor,lcMatWare,@lcCstItmDye,lcCstItm,lcCstClr,lcTmpName)
          =gfSelDyelot(lcTranType,'F',lcItem,lcColor,lcMatWare,@lcCstItmDye,lcCstItm,lcCstClr,lcTmpName,llBackOnly)
        ENDIF
      ENDIF
    CASE cCatGTyp='M'
      =gfRltFld(&lcTmpBomSh..MfgCode,@laMfgRFld,'MFGCODE')
      IF llMfgOpr .AND. !SEEK(lcTranLett+lcTicketNo+&lcTmpBomSh..MfgCode,lcOprHdr)
        lcOperSeq = LEFT(lcOperSeq,2)
        IF VAL(lcOperSeq) > lnLastSeq
          lnLastSeq = VAL(lcOperSeq)
          lcLastOpr = &lcTmpBomSh..MfgCode
        ENDIF
        INSERT INTO (lcOprHdr) (cIMTYp,cTktNo,cOprCode,cOperSeq,cContCode,cContName,lInHouse,nNxtLotNo);
        VALUES (lcTranLett,lcTicketNo,&lcTmpBomSh..MfgCode,lcOperSeq,lcContCode,lcContName,llInHouse,1)
      ENDIF
      IF lcTranType = 'I'
        lcExSign = gfGetExSin(@lcUntSin,lcDutyCur)
      ENDIF  
    CASE cCatGTyp='P'
      lcExSign = gfGetExSin(@lcUntSin,lcPriceCur)
    CASE !INLIST(cCatGTyp,'S','F','T') AND lcTranType = 'I'
      lcExSign = gfGetExSin(@lcUntSin,lcDutyCur)
  ENDCASE
  SELECT (lcTktSheet)
  IF !SEEK(lcTranLett+lcTicketNo+&lcTmpBomSh..Typ+PADR(lcCstItm,19)+;
     PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode+lcCstItmDye)
    APPEND BLANK
    REPLACE CutTkt    WITH lcTicketNo    ,;
            cIMTyp    WITH lcTranLett    ,;
            cCatGTyp  WITH &lcTmpBomSh..cCatGTyp  ,;
            TRIM_INVT WITH &lcTmpBomSh..TRIM_INVT ,;
            cWareCode WITH IIF(cCatGTyp='S',lcStyWare,IIF(cCatGTyp='F' OR ;
                           (cCatGTyp='T' AND TRIM_INVT),lcMatWare,'')) ,;
            Link_Code WITH lcLinkCode            ,;
            cOprCode  WITH &lcTmpBomSh..cOprCode ,;
            TYP       WITH &lcTmpBomSh..Typ      ,;
            ITEM      WITH lcCstItm              ,;
            ICLR      WITH lcCstClr              ,;
            MfgCode   WITH &lcTmpBomSh..MfgCode  ,;
            cOprCode  WITH &lcTmpBomSh..cOprCode ,;
            DESC      WITH &lcTmpBomSh..Desc     ,;
            Dyelot    WITH lcCstItmDye           ,;
            UOM       WITH &lcTmpBomSh..UOM      ,;
            DATE      WITH gdSysDate             ,;
            WIDTH     WITH IIF(cCatGTyp='F' OR (cCatGTyp='T' AND TRIM_INVT),FABRIC.WIDTH,'') 
    IF lcTranType = 'M'
      REPLACE CMARKER WITH &lcTmpBomSh..cMarker
    ENDIF
  ENDIF

  SELECT (lcDetFile)
  =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
  LOCATE REST WHILE ;
  cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
  lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
  PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
  FOR cSizes = STRTRAN(lcSizes,',','')
  llFoundRec = FOUND()         
  SELECT (lcTktSheet)

  *B606496,1 AMH Update pieces only when get a new cost element [Start]
  IF SEEK('A'+&lcTmpBomSh..Typ+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode+;
                  lcCstItmDye,lcCostElem)
    SELECT (lcCostElem)
    LOCATE REST WHILE cTrType+cType+CItem+CIclr+cMFGCode+cDyelot = 'A'+&lcTmpBomSh..Typ+;
                      PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode+lcCstItmDye;
                  FOR cSizes = STRTRAN(lcSizes,',','')
    IF !FOUND()
      SELECT (lcTktSheet)
      REPLACE Pieces  WITH Pieces  + lnTranQty
      INSERT INTO (lcCostElem) (cTrType,cType,cItem,cIClr,cMFGCode,cDyelot,cSizes);
                           VALUES ('A',&lcTmpBomSh..Typ,PADR(lcCstItm,19),PADR(lcCstClr,6),;
                                       &lcTmpBomSh..MfgCode,lcCstItmDye,STRTRAN(lcSizes,',',''))
    ENDIF
  ELSE
    REPLACE Pieces  WITH Pieces  + lnTranQty
    INSERT INTO (lcCostElem) (cTrType,cType,cItem,cIClr,cMFGCode,cDyelot,cSizes);
                         VALUES ('A',&lcTmpBomSh..Typ,PADR(lcCstItm,19),PADR(lcCstClr,6),;
                                     &lcTmpBomSh..MfgCode,lcCstItmDye,STRTRAN(lcSizes,',',''))
  ENDIF
  SELECT (lcTktSheet)
  REPLACE Req_Qty WITH Req_Qty + lnTranQty * &lcTmpBomSh..nBomTotQty ,;
          UntQty  WITH IIF(Pieces<>0,Req_Qty/Pieces,0)
  lnUntQty = IIF(lnTranQty=0,UNTQTY,EVALUATE(lcTmpBomSh+'.nBomTotQty'))
  *B606496,1 AMH [End]
  
  *--If tranQty was zero take it from pieces.
  *--to make sure that the cost was updated.
  *--Read lnTotCost and lnFTotCost depend on lnTTranQty insted of lnTranQty.
  lnTTranQty = lnTranQty
  IF lnTranQty = 0
    lnTTranQty = Pieces
  ENDIF 
  DO CASE
    CASE cCatGTyp = 'P'
      lnTotCost  = lnPrice * lnTTranQty &lcExSign lnPriceRate &lcUntSin lnPriceUnit
      lnFTotCost = lnPrice * lnTTranQty 
    CASE &lcTmpBomSh..nPercent > 0
      lnTotCost  = lnPrice*lnTTranQty*(&lcTmpBomSh..nPercent/100) &lcExSign lnPriceRate &lcUntSin lnPriceUnit
      lnFTotCost = lnPrice*lnTTranQty*(&lcTmpBomSh..nPercent/100)
    CASE cCatGTyp = 'S'
      lnTotCost  = Style.TotCost * lnTTranQty * &lcTktSheet..UntQty        
      lnFTotCost = lnTotCost
    CASE cCatGTyp = 'F' OR (cCatGTyp='T' AND TRIM_INVT)
      lnTotCost  = Fabric.CostBuy/Fabric.Conv * lnTTranQty * lnUntQty      
      lnFTotCost = lnTotCost
    OTHERWISE
      lnTotCost  = &lcTmpBomSh..TotCost * lnTTranQty &lcExSign lnDutyRate &lcUntSin lnDutyUnit
      lnFTotCost = &lcTmpBomSh..TotCost * lnTTranQty
  ENDCASE
  IF lnTranQty=0
    REPLACE Est_Cost WITH IIF(Est_Cost=0,lnTotCost,Est_Cost)
  ELSE
    REPLACE Est_Cost WITH Est_Cost + lnTotCost
  ENDIF
  REPLACE UntCost  WITH IIF(Req_Qty<>0,Est_Cost/Req_Qty,0)

  lnEst&lcItemType = lnEst&lcItemType  + lnTotCost
  lnFEst&lcItemType= lnFEst&lcItemType + lnFTotCost
  IF &lcTmpBomSh..cCatGTyp = 'S'
    FOR lnCount = 1 TO 8
      lcCount = STR(lnCount,1)
      REPLACE REQ_QTY&lcCount WITH REQ_QTY&lcCount+laReq[lnCount]*&lcTktSheet..UntQty
    ENDFOR
  ENDIF
  REPLACE cCompSizes WITH lcCmSizes 
  =gfAdd_Info(lcTktSheet)
  
  IF Pieces = 0 AND !llBackOnly
    DELETE
  ENDIF
  SELECT (lcTmpBomSh)
  DO CASE
    CASE &lcTmpBomSh..CCATGTYP = 'P'
      lnUnitPri = lnPrice
    CASE INLIST(&lcTmpBomSh..CCATGTYP,'M','D')

      IF &lcTmpBomSh..nPercent > 0
        lnUnitPri  = lnPrice*(&lcTmpBomSh..nPercent/100)
      ELSE
        lnUnitPri = &lcTmpBomSh..UntCost
      ENDIF  
    CASE INLIST(&lcTmpBomSh..CCATGTYP,'F','T') .AND. SEEK(SUBSTR(lcCstItm,1,7)+lcCstClr,'Fabric')
      lnUnitPri = Fabric.CostBuy/Fabric.Conv
    OTHERWISE
      lnUnitPri = &lcTktSheet..UntCost
  ENDCASE
  SELECT (lcDetFile)
  =SEEK(lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
        PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode)
  LOCATE REST WHILE ;
  cimtyp+ctype+ctktno+STR(lineno,6)+cbomtyp+style+sclr+item+iclr+mfgcode=;
  lcTranLett+'1'+lcTicketNo+STR(lnLineNo,6)+&lcTmpBomSh..Typ+PADR(lcItem,19)+;
  PADR(lcColor,6)+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcTmpBomSh..MfgCode ;
  FOR cSizes = STRTRAN(lcSizes,',','')
  IF !FOUND()         
    *!B602124,1 Update Cost item dyelot in the BOMLINE file
    APPEND BLANK
    REPLACE cIMTyp     WITH lcTranLett     ,;
            cTktNo     WITH lcTicketNo     ,;
            LineNo     WITH lnLineNo       ,;
            cStyGrade  WITH lcGrade        ,;
            Style      WITH lcItem         ,;
            SClr       WITH lcColor        ,;
            cBomTyp    WITH &lcTmpBomSh..Typ,;
            cType      WITH '1'            ,;
            cCatGTyp   WITH &lcTmpBomSh..cCatGTyp   ,;
            cOprCode   WITH &lcTmpBomSh..cOprCode   ,;
            UnitQty    WITH &lcTmpBomSh..nBomTotQty ,;
            UnitCost   WITH lnUnitPri      ,;
            Item       WITH lcCstItm       ,;
            IClr       WITH lcCstClr       ,;
            MfgCode    WITH &lcTmpBomSh..MfgCode    ,;
            Dyelot     WITH lcCstItmDye ,;
            cSizes     WITH STRTRAN(lcSizes,',','') ,;
            cCompSizes WITH lcCmSizes
    REPLACE cCostStat WITH &lcTmpBomSh..cCostStat,;
            nPercent   WITH &lcTmpBomSh..nPercent
  ENDIF

  IF lnTranQty = 0
     REPLACE ItemAmt  WITH ItemQty*lnUnitPri ,;
             UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)            
  ELSE
    
    *B606496,1 AMH Update pieces only when get a new cost element [Start]
    *REPLACE StyQty   WITH StyQty  + lnTranQty ,;
            ItemQty  WITH ItemQty + lnTranQty* IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,UnitQty)  ,;
            UnitQty  WITH IIF(StyQty=0,0,ItemQty/StyQty) ,;
            ItemAmt  WITH ItemAmt + lnTranQty * IIF(lcTranStat="H",&lcTmpBomSh..nBomTotQty,UnitQty) * lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)

    IF SEEK('B'+&lcDetFile..cBomTyp+PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcDetFile..MfgCode+;
                 lcCstItmDye,lcCostElem)
      SELECT (lcCostElem)
      LOCATE REST WHILE cTrType+cType+CItem+CIclr+cMFGCode+cDyelot = 'B'+&lcDetFile..cBomTyp+;
                        PADR(lcCstItm,19)+PADR(lcCstClr,6)+&lcDetFile..MfgCode+lcCstItmDye;
                    FOR cSizes = STRTRAN(lcSizes,',','')
      IF !FOUND()
        SELECT (lcDetFile)
        REPLACE StyQty   WITH StyQty  + lnTranQty
        INSERT INTO (lcCostElem) (cTrType,cType,cItem,cIClr,cMFGCode,cDyelot,cSizes);
                          VALUES ('B',&lcDetFile..cBomTyp,PADR(lcCstItm,19),PADR(lcCstClr,6),;
                                      &lcDetFile..MfgCode,lcCstItmDye,STRTRAN(lcSizes,',',''))
      ENDIF
    ELSE
      REPLACE StyQty   WITH StyQty  + lnTranQty
      INSERT INTO (lcCostElem) (cTrType,cType,cItem,cIClr,cMFGCode,cDyelot,cSizes);
                        VALUES ('B',&lcDetFile..cBomTyp,PADR(lcCstItm,19),PADR(lcCstClr,6),;
                                    &lcDetFile..MfgCode,lcCstItmDye,STRTRAN(lcSizes,',',''))
    ENDIF
    SELECT (lcDetFile)
    REPLACE ItemQty  WITH ItemQty + lnTranQty* &lcTmpBomSh..nBomTotQty  ,;
            UnitQty  WITH IIF(StyQty=0,0,ItemQty/StyQty) ,;
            ItemAmt  WITH ItemAmt + lnTranQty * &lcTmpBomSh..nBomTotQty * lnUnitPri ,;
            UnitCost WITH IIF(ItemQty=0,0,ItemAmt/ItemQty)
    *B606496,1 AMH [End]
           
  ENDIF

  IF StyQty = 0 AND !llBackOnly
    DELETE
  ENDIF
ENDSCAN
IF llContinue
  DO CASE
    CASE lcTranType='M' .AND. SEEK(lcTicketNo,'CUTTKTH')  .AND. CUTTKTH.Status # 'H'
      SELECT CUTTKTH
      =RLOCK()
      REPLACE CLASTOPR   WITH lcLastOpr ,;
              NEST_COST1 WITH NEST_COST1 + lnEst1 ,;
              NEST_COST2 WITH NEST_COST2 + lnEst2 ,;
              NEST_COST3 WITH NEST_COST3 + lnEst3 ,;
              NEST_COST4 WITH NEST_COST4 + lnEst4 ,;
              NEST_COST5 WITH NEST_COST5 + lnEst5
      UNLOCK
    CASE lcTranType$'DI' .AND. SEEK(IIF(lcTranType='I','P','D')+lcTicketNo,'POSHDR') .AND. POSHDR.Status='O'
      SELECT POSHDR
      =RLOCK()
      REPLACE CLASTOPR WITH lcLastOpr ,;
              NICOST1  WITH NICOST1 + lnEst1 ,;
              NICOST2  WITH NICOST2 + lnEst2 ,;
              NICOST3  WITH NICOST3 + lnEst3 ,;
              NICOST4  WITH NICOST4 + lnEst4 ,;
              NICOST5  WITH NICOST5 + lnEst5 ,;
              NFCOST1  WITH NFCOST1 + lnFEst1 ,;
              NFCOST2  WITH NFCOST2 + lnFEst2 ,;
              NFCOST3  WITH NFCOST3 + lnFEst3 ,;
              NFCOST4  WITH NFCOST4 + lnFEst4 ,;
              NFCOST5  WITH NFCOST5 + lnFEst5
      UNLOCK
    CASE lcTranType='T' .AND. SEEK(lcTicketNo,'MMFGORDH') .AND. MMFGORDH.Status='O'
      SELECT MMFGORDH
      =RLOCK()
      REPLACE CLASTOPR   WITH lcLastOpr ,;
              NEST_COST1 WITH NEST_COST1 + lnEst1 ,;
              NEST_COST2 WITH NEST_COST2 + lnEst2 ,;
              NEST_COST3 WITH NEST_COST3 + lnEst3 ,;
              NEST_COST4 WITH NEST_COST4 + lnEst4
      UNLOCK
  ENDCASE
ENDIF
IF USED('STYLE')
  SELECT STYLE
  SET FILTER TO &lcStyFIlt
ENDIF
USE IN (lcTmpBomSh)

ERASE (gcWorkDir+lcTmpBomSh+'.DBF')
ERASE (gcWorkDir+lcTmpBomSh+'.CDX')
ERASE (gcWorkDir+lcTmpBomSh+'.FPT')

*B607081,1 ARH 03/23/2003 (Start) Closed the curor used on the function to avoid getting the open file dialog 
*B607081,1 ARH            in case of big POs
USE IN (lcCostElem)
*B607081,1 ARH 03/23/2003 (End)

SELECT (lnAlias)
RETURN(llContinue)

*!***************************************************************************
*! Name      : gfGetSeq
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 01/26/2003
*! Purpose   : Get the next sequence number.
*!***************************************************************************
*! Example   : =gfGetSeq()
*!***************************************************************************
*! Notes     : This function was written by MAN.
*!***************************************************************************
*B606902,1
FUNCTION gfGetSeq
PARAMETER lnSeq,cChr
PRIVATE lcSPrefix , lnCharASCI , lnI , lcAlias
lcAlias = ALIAS()
SELECT Sequence
lcSPrefix = ""
IF !(cChr = CHR(0))
  lnCharASCI = ASC(cChr)
  IF MOD(lnCharASCI,26) = 0
    lcChar = "Z"
    lnCharPos = lnCharASCI/26
  ELSE
    lnCharPos = INT(lnCharASCI/26)+1
    lcChar =  chr(mod(lnCharASCI,26)+64)
  ENDIF  
  FOR lnI = 1 TO lnCharPos - 1
    lcSPrefix = lcSPrefix + "Z"
  ENDFOR
  lcSPrefix = lcSPrefix + lcChar

*++NAD
ELSE
 lcChar =""
*++NAD
ENDIF
IF lnSeq = VAL(REPLICATE("9",lnRetLen-LEN(lcSPrefix)))
  IF EMPTY(cChr)
    lcSPrefix = "A"
    *REPLACE cSeq_Chr WITH CHR(1)
    lcChrToUpd = CHR(1)
  ELSE
    IF lcChar = "Z"
      lcSPrefix = lcSPrefix + "A"
    ELSE
      lcSPrefix = LEFT(lcSPrefix,LEN(lcSPrefix)-1) + CHR(ASC(lcChar)+1)
    ENDIF       
    *REPLACE cSeq_Chr WITH CHR(ASC(cSeq_Chr)+1)
    lcChrToUpd = CHR(ASC(cSeq_Chr)+1)
  ENDIF  
  lnSeq = 0
ELSE
  lnSeq = lnSeq + 1
ENDIF

*lnSeq = lnSeq + 1
*REPLACE nSeq_No with lnSeq
*? lcSPrefix+PADL(lnSeq,lnRetLen-LEN(lcSPrefix),"0")

lnRetVal = lnSeq
lcExtraStr = lcSPrefix

IF !EMPTY(lcAlias)
  SELECT (lcAlias)
ENDIF
*-- End of gfGetSeq.
*E302121,1 Ability to lock users from getting into Aria27 [Start]
*!*****************************************************************************************
*! Name      : gfLockSys
*! Developer : Hesham - Hesham El Sheltawi
*! Date      : 04/15/2003 
*! Purpose   : Lock the system to prevent any user to log into the system
*! Entry no. : E302121,1 
*!*****************************************************************************************
*!
FUNCTION gfLockSys
  PRIVATE llLockSys,lcCurAlias,llSuccess
  llLockSys = !glLockSys
  lcCurAlias = ALIAS()
  llSuccess = .F.
  lnBar = BAR()
  lcPop = POPUP()
  =gfSysOpen(gcSysHome+'SYCINST')
  SELECT sycinst 
  IF llLockSys
    IF RLOCK("SYCINST")
      REPLACE lLockSys WITH .T.
      FLUSH()
      llSuccess = .T.
    ELSE
      =gfDialog("?",'System is locked by the administrator. Please try later',"\?\!\<Ok")
    ENDIF
  ELSE
    IF RLOCK("SYCINST")
      REPLACE sycinst.lLockSys WITH .F.
      UNLOCK IN SYCINST
      llSuccess = .T.
    ENDIF
  ENDIF
  IF !EMPTY(lcCurAlias)
    SELECT (lcCurAlias)
  ENDIF  
  IF llSuccess
    glLockSys = sycinst.lLockSys
    SET MARK OF BAR lnBar OF (lcPop) glLockSys
  ENDIF   
*E302121,1 Hesham (End)
*E302566,1 MMT 01/12/2009 Change paths for SAAS [sTART]
*!*************************************************************
*! Name      : gfCallForm
*! Developer : MARIAM MAZHAR [MMT]
*! Date      : 01/12/2009
*! Purpose   : Function to call forms instead of DO FORM
*!*************************************************************
*! Parameters:
*! lcFormName : The form to be called Name
*! lcModuleID : Module that form existing in
*! lcWithParam: WITH Paramters
*! lcToParam  : TO Paramters
*!*************************************************************
FUNCTION gfCallForm
PARAMETERS lcFormName,lcModuleID,lcWithParam,lcToParam



IF TYPE('lcModuleID') = 'C'
  IF GCMULTIINST AND FILE(gcCScrDir+lcModuleID+'\'+lcFormName+'.SCX')
    IF TYPE('lcWithParam') = 'C'
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcCScrDir +lcModuleID+'\'+lcFormName+'.SCX' WITH &lcWithParam TO &lcToParam
      ELSE
        DO FORM gcCScrDir +lcModuleID+'\'+lcFormName+'.SCX' WITH &lcWithParam 
      ENDIF   
    ELSE
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcCScrDir +lcModuleID+'\'+lcFormName+'.SCX' TO &lcToParam
      ELSE
        DO FORM gcCScrDir +lcModuleID+'\'+lcFormName+'.SCX'       
      ENDIF   
    ENDIF    
  ELSE
    IF TYPE('lcWithParam') = 'C'
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcScrDir+lcModuleID+'\'+lcFormName+'.SCX' WITH &lcWithParam TO &lcToParam
      ELSE
        DO FORM gcScrDir+lcModuleID+'\'+lcFormName+'.SCX' WITH &lcWithParam 
      ENDIF   
    ELSE
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcScrDir+lcModuleID+'\'+lcFormName+'.SCX' TO &lcToParam
      ELSE
        DO FORM gcScrDir+lcModuleID+'\'+lcFormName+'.SCX'      
      ENDIF   
    ENDIF    
  ENDIF   
ELSE
 IF GCMULTIINST AND FILE(gcCScrDir+lcFormName+'.SCX')
    IF TYPE('lcWithParam') = 'C'
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcCScrDir +lcFormName+'.SCX' WITH &lcWithParam TO &lcToParam
      ELSE
        DO FORM gcCScrDir +lcFormName+'.SCX' WITH &lcWithParam 
      ENDIF   
    ELSE
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcCScrDir+lcFormName+'.SCX' TO &lcToParam
      ELSE
        DO FORM gcCScrDir +lcFormName+'.SCX'       
      ENDIF   
    ENDIF    
  ELSE
    IF TYPE('lcWithParam') = 'C'
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcScrDir+lcFormName+'.SCX' WITH &lcWithParam TO &lcToParam
      ELSE
        DO FORM gcScrDir+lcFormName+'.SCX' WITH &lcWithParam 
      ENDIF   
    ELSE
      IF  TYPE('lcToParam') = 'C'
        DO FORM gcScrDir+lcFormName+'.SCX' TO &lcToParam
      ELSE
        DO FORM gcScrDir+lcFormName+'.SCX'      
      ENDIF   
    ENDIF    
  ENDIF    
ENDIF 
*E302566,1 MMT 01/12/2009 Change paths for SAAS [eND]



*********************************************************************************************************
*
*  FUNCTION lfUpdClnts
*  
*********************************************************************************************************
*E302878,1 TMI 03/24/2011 [Start] 
FUNCTION lfUpdClnts
PRIVATE lnSlct

lnSlct = SELECT(0)

lcSafe = SET('SAFE')
lcPDIALOG = SET('CPDIALOG')

SET CPDIALOG OFF
SET SAFE OFF

IF !FILE(SYS(5)+CURDIR()+'clients.dbf')
  
  RENAME Xclients.dbf TO clients.dbf

  USE ( SYS(5)+CURDIR() + 'clients.dbf') EXCL
  ZAP
  APPEND BLANK
  REPLACE CCLIENTID  WITH 'ARIA' ;
          CCLIENTNAM WITH 'ARIA' ;
          CDATAPATH  WITH SYS(5)+CURDIR()
ELSE
  
  ERASE (SYS(5)+CURDIR()+'Xclients.dbf')
            
ENDIF          

SET CPDIALOG &lcPDIALOG 
SET SAFE &lcSafe 

SELECT (lnSlct)

*T20110704.0013 (Task ID)- 1st run program TMI 09/13/2011 [End  ] 


************************************************************
*! Name      : lfCrFox2x
*! Developer : TMI - Tarek Mohamed Ibrahim
*! Date      : 02/20/2012
*! Purpose   : force creating fox2x format
************************************************************
FUNCTION lfCrFox2x
LOCAL lcFile,lcFileA,lcChr
lcChr = '__X'
lcFileA = ALIAS()
lcFile = JUSTPATH(DBF())+'\'+JUSTstem(DBF())
COPY TO (lcFile+lcChr) fox2x
USE IN &lcFileA
ERASE (lcFile+'.*')
RENAME (lcFile+lcChr+'.*') TO (lcFile+'.*')
USE (lcFile) EXCLUSIVE 
 *- End of lfCrFox2x.