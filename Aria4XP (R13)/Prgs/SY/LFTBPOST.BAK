*:************************************************************************
*:  Program File: ARIA4XP\PRGS\SY\LFTBPOST.PRG
*:  Module      : General Ledger
*:  Desc.       : posting process
*:  System      : Aria 4XP
*:  Developer   : TMI - Tarek Mohamed Ibrahim
*:  Date        : 04/06/2012
*:  Reference   : *E303167,1 
*:************************************************************************
*  This function requires the following files to opened before
*  being called : GLSETUP.DBF
*                 SYCFISHD.DBF
*                 SYCFSPRD.DBF
*                 SYUUSER.DBF    && to get the user name 
*                 GLACBALS.DBF
*                 GLACCHAR.DBF
*                 GLBATCH.DBF 
*                 GLTRNSHD.DBF 			 		
*                 GLTRNSDT.DBF
*
*  If posting a single transactions : 
*     GLTRNSHD must be the selected file upon entry and 
*     the file pointer should be pointing to this transaction. 
*  If posting a single batches      : 
*     GLBATCH  must be the selected file upon entry and
*     the file pointer should be pointing to this batch.
*
*  Parameters  : lcTrOrBat,lcTempFile,lcBatType,lcTempBals,
*                lcAct_Comp,lcDataDir  
*   lcTrOrBat  : is given one of two values : "Transaction", or
*                "Batch", according to the calling program.
*   lcTempFile : name of the temporary file holding the
*                transactions or batches number in case of
*                multiple transactions or batches posting.
*                If posting only one transcation  or batch, it is
*                given a NULL value ("").
*                It consists of only one field giving the
*                batch or transaction number. 
*   lcBatType  : In case of batch posting, it gives the type of
*                the posted batch(es) as follows :
*              - "Beginning"    : for beginning balances batch(es)
*              - "Nonbeginning" : for non beginning balances
*                                 batch(es)
*              - "Closing"      : for closing year balances 
*                                 batch(es)
*   lcTempBals : If posting from reports, this parameter contains
*                the name of a temporary file to contain a
*                copy of the balances file (GLACBALS) that
*                is to be used for reporting instead of the 
*                actual balances file.    
*  lcAct_Comp  : if not empty, holds the company ID
*                else, use the current value of gcAct_Comp variable.
*  lcDataDir   : if not empty, holds the data directory path
*                else, use the current value of gcDataDir variable.
*  Returns     : if no batches or transactions are posted, 
*                returns 0
*                else, returns the number of posted transcations
*                or batches.      
*  Called from : This function is called from several programs
*                as follows :
*   
*   - The (single) transaction posting screen :
*     (Transactions->Single transaction menu option) 
*       call lfTBPost("Transaction") 
*
*   - The (multiple) transaction maintenance screen :
*     (Transactions->Posting->Single transaction menu option) 
*       call lfTBPost("Transaction",lcTempFile) 
*
*   - The (single) journal batches screen :
*     (Transactions->Batches->Journal batches menu option)  
*       call lfTBPost("Batch","","Nonbeginning")
*
*   - The (single) beginning balances batches screen :
*     (Transactions->Batches->Beginning balance batches menu option) 
*       call lfTBPost("Batch","","Beginning") 
*
*   - The (multiple) journal batches maintenance screen :
*     (Transactions->Posting->Journal batches menu option) 
*       call lfTBPost("Batch",lcTempFile,"NonBeginning") 
*
*   - The (multiple) beginning balances batches maintenance screen :
*     (Transactions->Posting->Beginning balance batches menu option)     
*       call lfTBPost("Batch",lcTempFile,"Beginning") 
*
*   - The year end closing balances batches process screen :
*       call lfTBPost("Batch",lcTempFile,"Closing","",lcAct_Comp,lcDataDir) 
*
*   - Reports :
*       call lfTBPost("Batch",lcTempFile,<type of batch>,lcTempBals) 
*  Calls       : GLPOSTNG.SPR
**********************************************************************************************
*! Modifications
*! B610233,1 HIA, 02/10/2013 Aria4xp - GL - Posting Journal BATCH - ERROR ON posting specific BATCH [T20130207.0003]
**********************************************************************************************
PARAMETERS loFormSet,lcTrOrBat,lcTempFile,lcBatType,lcTempBals,lcAct_Comp,lcDataDir,llFromReb
#INCLUDE R:\Aria4xp\PRGS\sy\lftbpost.H
*N000682,1 12/12/2012 TMI Globlization changes[Start] Define the language related
lcHeaderFile  = ' '
IF oAriaApplication.oActivelang.cLang_ID <> "EN"
  lcHeaderFile = ADDBS(UPPER(ALLTRIM(oAriaApplication.LangPath))) + "PRGS\sy\lftbpost_H.XML"
  loFormSet.HeaderAlias = oAriaApplication.GetClassHeaderFile(lcHeaderFile)
ENDIF
*N000682,1 12/12/2012 TMI Globlization changes[Start]

*N000682,1 12/14/12 TMI Globlization changes[Start] 
lcLANG_GLTPOST_WILL_NOT_BE_POSTED = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_GLTPOST_WILL_NOT_BE_POSTED,oAriaApplication.GetHeaderText("LANG_GLTPOST_WILL_NOT_BE_POSTED",lcHeaderFile))
lcLANG_Batch = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_Batch,oAriaApplication.GetHeaderText("LANG_Batch",lcHeaderFile))
lcLANG_Posting_process_is_terminated = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_Posting_process_is_terminated,oAriaApplication.GetHeaderText("LANG_Posting_process_is_terminated",lcHeaderFile))
lcLANG_Batch_No = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_Batch_No,oAriaApplication.GetHeaderText("LANG_Batch_No",lcHeaderFile))
lcLANG_of_Batch_No = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_of_Batch_No,oAriaApplication.GetHeaderText("LANG_of_Batch_No",lcHeaderFile))
lcLANG_Transaction_No = IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_Transaction_No,oAriaApplication.GetHeaderText("LANG_Transaction_No",lcHeaderFile))
*N000682,1 12/14/12 TMI Globlization changes[End  ] 

PRIVATE lcBatchNo, lcTranNo, lcPrnt_Cmp, llTBReport
*** Global variables used by this module, coming from
*** the calling module are :
*** - lcAcsMask    : account code structure mask.     
*** - lcCurr_Yer   : current fiscal year (character)
*** - lnCurr_Yer   : current fiscal year (numeric)
*** - lcSJ_Def     : default source journal
*** - gcUser_ID    : current user ID
*** - gcAct_Appl   : current active application
*** - gcSysHome    : system files directory path
*** - gcWorkDir    : work directory path


*** Variable declaration :
*- Add fiscal calendar and account code structure file openings
*-  data files required by the module
DIMENSION laReqFiles[10, 2]    

laReqFiles[1,1]    ='GLSETUP'
laReqFiles[2,1]    ='GLACCHAR'
laReqFiles[3,1]    ='GLACBALS'
laReqFiles[4,1]    ='GLBATCH'
laReqFiles[5,1]    ='GLTRNSHD'
laReqFiles[6,1]    ='GLTRNSDT'

laReqFiles[7,1]    ='FISHD'
laReqFiles[8,1]    ='FSPRD'
laReqFiles[9,1]    ='GLPTRNHD'
laReqFiles[10,1]    ='GLPTRNDT'

lcPostSess         = ''      && the posting session number 
lcRetActMj         = ''      && defaule retained earnings account code
lcRetAccnt         = ''      && retained earnings account code
lcSusActMj         = ''      && suspense account code
lcCostCntr         = ''      && Cost center for the account
lcTmpCstCt         = ''      && Temporary cost center variable
lcCurAlias         = ''      && current work aria according to the 
                             && calling program.
lcCurArea          = ''      && holds the current work area within
                             && a function 
lcUserName         = ''      && Current user name

lcAcctCode         = ''      && current record's account code value
lcFisfYear         = ''      && current record's year value 
lcFieldNam         = ''      && field name of lcTempFile temporary
                             && file passed to this module from
                             && the caling program.
lcDrOrCr           = ''      && 'D'ebit or 'C'redit according to the 
                             &&  result of calculations on debit/credit
                             &&  amounts.
lcPWinTit1         = ''      && browse screen title1
lcPWinTit2         = ''      && browse screen title2
lcBWinTitl         = ''      && browse window title

lcBatchNo          = ''      && holds the current batch number  
lcNext_Yer         = ''      && holds the next fiscal year value
lcPrev_Yer         = ''      && holds the previous fiscal year value
lcLastPrd          = ''      && holds the last period of the previous
                             && fiscal year
lcBatchNo          = ''      && holds the current batch number
lcTranNo           = ''      && holds the current transaction number
lcClosNo           = ''      && holds the closing entry number.
lcTBToPost         = ''      && in case of single transaction 
                             && or batch posting, it holds the batch
                             && and transaction numbers 
lcOldTBTyp         = ''      && holds the old value of lcTrOrBat
                             && if posting closing entries
lcOldBType         = ''      && holds the old value of lcBatType
                             && if posting closing entries                         

lcPBrwFlds         = ''      && browse fields string
lcPBrwCond         = ''      && browse 'FOR' clause condition                            
lcTBFltExp         = ''      && holds the calling program's filter
                             && expression, if any.
                             
*** Temporary file names :
lc_SumEnt1         = ''      && holds all amounts to be posted for
                             && transcation(s) or batch(es)
lc_SumEnt2         = ''      && holds all amounts to be posted for
                             && transcation(s) or batch(es) created
                             && during the session for closing balances
                             && batches.
lc_ActRepl         = ''      && holds all the accounts codes that are
                             && to be replaced by the 'suspense' account
lc_ClosEnt         = ''      && holds all the closing entries generated
                             && during the session in the case of closing
                             && balances batches. 
lc_Batches         = ''      && holds the batches created during the session.
lc_TransHd         = ''      && holds the transactions created during the session.
lc_TransDt         = ''      && holds the transaction details created during the 
                             && session.
lc_TmpBals         = ''      && temporary file name to hold the records 
                             && belonging to an account for the three
                             && years of the posting window
lc_AcBals          = ''      && alias name to be used for openning
                             && GLACBALS.DBF 'again' in another work area  
lc_AcChar          = ''      && alias name to be used for openning
                             && GLACCHAR.DBF 'again' in another work area  
lc_BrowCur         = ''      && alias name to be used for a cursor used
                             && if the program is called from reports, 
                             && to hold the dummy posted batches, or 
                             && transactions information.

*** Tag name and tag expressions varaiables :
lcAcCharTg         = ''      && Master tag of GLACCHAR file before
                             && setting its order.
lcAcBalsTg         = ''      && Master tag of GLACBALS file before
                             && setting its order.
lcAcBalsEx         = ''      && Index expression of the current GLACBALS
                             && tag setting (to be set during session)
lcBatchTg          = ''      && Master tag of GLBATCH file before
                             && setting its order.
lcBatchEx          = ''      && Index expression of the current GLBATCH
                             && tag setting (to be set during session)
lcTrnsHdTg         = ''      && Master tag of GLTRNSHD file before
                             && setting its order.
lcTrnsHdEx         = ''      && Index expression of the current GLTRNSHD
                             && tag setting (to be set during session)
lcTrnsDtTg         = ''      && Master tag of GLTRNSDT file before
                             && setting its order.
lcTrnsDtEx         = ''      && Index expression of the current GLTRNSDT
                             && tag setting (to be set during session)
lcFscPrdTg         = ''      && Master tag of SYCFSPRD file before
                             && setting its order.
lcFscPrdEx         = ''      && Index expression of the current SYCFSPRD
                             && tag setting (to be set during session)
lcFscHdTg          = ''      && Master tag of SYCFISHD file before
                             && setting its order.
lcFscHdEx          = ''      && Index expression of the current SYCFISHD
                             && tag setting (to be set during session)

lnTBPosted         = 0       && holds the number of posted transactions
                             && or batches
lnTotalDr          = 0       && holds the total debit
lnTotalCr          = 0       && holds the total credir
lnBatTotDr         = 0       && holds the total debit of a batch
lnBatTotCr         = 0       && holds the total credit of a batch
lnCurRecrd         = 0       && holds the current record number of the
                             && calling program. 
lnAmount           = 0       && calculated debit or credit amount
lnAddAmnt          = 0       && used for previous year income statements
                             && calculations
lnOrgAmnt          = 0       && used for previous year income statements
                             && calculations
lnAmntWdth         = 0       && field width of GLACBALS.nAcbClBal
lnAcctWdth         = 0       && field width of GLACCHAR.cAcctCode
lnBtNoWdth         = 0       && field width of GLBATCH.cBatchNo
lnTrNoWdth         = 0       && field width of GLTRNSHD.cTranNo
lnTotRecs          = 0       && total number of records used for
                             && the thermometer       
lnThermRec         = 0       && record counter for the thermometer

ldCurrDate         = {}      && holds the current date 
ldLastPFDt         = {}      && holds the last date of the last period
                             && in the previous fiscal year

llTBReport         = .F.     && .T. if posting reports, .F. otherwise
llOneRec           = .F.     && Single (.T.) or Multiple (.F) posting
llPosted           = .F.     && .T. if posted at least one transaction,
                             && .F. otherwise.           
llContinue         = .T.     && used only in the case of multiple
                             && batch posting, indicates whether
                             && posting of other batches is to be
                             && continued or not if a batch is
                             && found to be invalid for posting.
llTryLock          = .F.     && .T. if locking attempt is successful,
                             && to proceed with posting, .F.
                             && otherwise
llBatVld           = .F.     && is returned to the calling function with 
                             && .T. if the batch is found to be valid for 
                             && posting, otherwise, .F. 
llTransVld         = .F.     && is returned to the calling fucntion with 
                             && .T. if the transaction is found to be valid
                             && valid for posting, and its entries are
                             && summarized, otherwise , .F. 
llOldOneRc         = .F.     && holds the old value of llOldOneRc
                             && if posting closing entries                               
llPrntPost         = .F.     && .T. if a report of the posted batches
                             && or transaction is printed by the
                             && user. 

gcWorkDir = oAriaApplication.WorkDir
gcUser_ID = oAriaApplication.User_ID
gcAct_Appl = oAriaApplication.User_ID

*** Variables initialization :

*** IF parameter lcTrOrBat is defined(sent), get its first character 
*** that shows whether what's being posted is 'T'ransaction(s)
*** or 'B'atches, otherwise, initialize it to 'T'ransactions. 
lcTrOrBat          = IIF(TYPE('lcTrOrBat')='C',;
                         UPPER(LEFT(lcTrOrBat,1)),'T')
                         
*** llOneRec is .T. if posting a single transaction or
*** batch in the case of which, parameter lcTempFile that
*** holds the file name in case of multiple posting will
*** normally be empty.Otherwise, it is .F.
llOneRec           = IIF(TYPE('lcTempFile')='C';
                        .AND.!EMPTY(lcTempFile),.F.,.T.) 

*** IF parameter lcBatType is defined(sent), get its first character 
*** showing the type of batch(es) to be posted whether :
*** 'N'ormal    : non beginning balances batch(es)
*** 'B'eginning : beginning balances batch(es)                        
*** 'C'losing   : closing year batch(es)
*** Otherwise, initialize it to 'N'ormal.                         
lcBatType           = IIF(TYPE('lcBatType')='C',;
                         UPPER(LEFT(lcBatType,1)),'N')

*** If called from closing, the parent company is passed as a parameter
*** and is itself the parent company,
*** otherwise, gcPrnt_Cmp variable holds the ID of the parent
*** company of the active company,hence
*** lcPrnt_Cmp variable holds the ID of the parent company that is
*** to be used in all fiscal calendar manipulation.  
lcPrnt_Cmp = IIF(TYPE('lcAct_Comp')='C' .AND. !EMPTY(lcAct_Comp),;
                       lcAct_Comp, oAriaApplication.PrntCompanyID)
                       

*** IF parameter lcTempBals is defined (passed), indicate
*** that the calling program is a report, hence, set
*** reports flag 
llTBReport         = TYPE('lcTempBals')='C'.AND.;
                          !EMPTY(lcTempBals)


*** IF parameter lcAct_Comp is defined (passed), use it
*** for the active company ID, otherwise, use the 
*** global variable gcAct_Comp value 
lcAct_Comp         = IIF(TYPE('lcAct_Comp')='C'.AND.;
                          !EMPTY(lcAct_Comp), ;
                          lcAct_Comp, oAriaApplication.ActiveCompanyID)

*** IF parameter lcDataDir is defined (passed), use it
*** for the data directory path, otherwise, use the 
*** global variable gcDataDir value 
lcDataDir         = IIF(TYPE('lcDataDir')='C'.AND.;
                          !EMPTY(lcDataDir), ;
                          lcDataDir, oAriaApplication.DataDir)


*** Save the current work area environment
lcCurAlias         = ALIAS()
lnCurRecrd         = RECNO()

IF llOneRec 
  *** If posting a transaction, store the batch number and the
  *** transaction number.
  *** If posting a batch, store the batch number
  lcTBToPost         = IIF(lcTrOrBat = 'T',;
                           GLTRNSHD.cBatchNo+GLTRNSHD.cTranNo,;
                           GLBATCH.cBatchNo)
ENDIF        

*** Get the current user name


IF !USED('SYUUSER')
  =gfOpenTable(oAriaApplication.SysPath+'SYUUSER','CUSER_ID','SH')
ENDIF 


lcUserName         = LOOKUP(SYUUSER.cUsr_Name,oAriaApplication.User_ID,;
                            SYUUSER.cUser_ID,'cUser_ID')
*** Current date value
ldCurrDate         = DATE()

*** Note : for 'Closing batches posting', 
***        called from 'Closing' year program
*** By the time the posting module is called, the posting
*** window is already changed as follows
***   
***     Old posting window            New posting window
***      'P'revious year      --->       History 
***      'C'urrent  year      --->       'P'revious year
***      'N'ext     year      --->       'C'urrent  year
***    ( create a new year ) 
***    ( to follow         )  --->       'N'ext     year  
*** In this case, the value stored in variables 'lcCurr_Yer', and
*** 'lnCurr_Yer' should contain the current year of the new posting window.    

* Current year
lcCurr_Yer = STR(loFormSet.lnCurr_Yer,4)


*** Previous fiscal year
lcPrev_Yer         = STR(loFormSet.lnCurr_Yer - 1,4)
*** Next fiscal year
lcNext_Yer         = STR(loFormSet.lnCurr_Yer + 1,4)

*** Open data files if not already in use


SELECT FISHD

*** Get the current tag 
lcFscHdTg = SYS(22)
*** Set the order of the file to tag 'COMPFYEAR' and get its index 
*** expression for later use.
SET ORDER TO TAG COMPFYEAR

*** Current index expression for tag 'COMPFYEAR' is : 
*** cComp_ID + cFisFYear 
lcFscHdEx           = SYS(14,VAL(SYS(21)))
*** Last period in the previous fiscal year of the parent company.
IF SEEK(lcPrev_Yer,'FISHD')

  lcLastPrd        = FISHD.cFisNoPrd
  
ENDIF

SELECT FSPRD

*** Get the current tag 
lcFscPrdTg          = SYS(22)
*** Set the order of the file to tag 'COMFYRPRDI' and get its index 
*** expression for later use.
SET ORDER TO TAG COMFYRPRDI
*** Current index expression for tag 'COMFYRPRDI' is : 
*** cComp_ID + cFisFYear + cFspPrdId
lcFscPrdEx = SYS(14,VAL(SYS(21)))
*** Last date of the last period in the previous fiscal year of the parent
*** company
IF SEEK(lcPrev_Yer+lcLastPrd,'FSPRD')

  ldLastPFDt = FSPRD.dFspPEnDt
  
ENDIF

*** Set thermometer variables:
lcVldTB            = IIF(lcTrOrBat='T','Validating transaction No. ',;
                                   'Validating batch No. ')
lcPstTB            = IIF(lcTrOrBat='T','Posting transactions...',;
                                   IIF(lcBatType='B',;
                                   'Posting beginning balance batches...',;
                                   'Posting batches...')) 

lnTotRecs          = IIF(llOneRec,3,RECCOUNT(lcTempFile)*2+1)
lnThermRec         = 0 


*** I 
*** Check that this program is used by one user. 

*** II
*** III
*** 1. Check that the retained earnings account (GLSETUP.cSetRetMj) 
***    is setup in the GlSetup file (GLSETUP.DBF), and found
***    in the chart of accounts file (GLACCHAR.DBF)       

*** Set the tag of GLACCHAR to ACCTCODE 
SELECT GLACCHAR

*** Get the current tag 
lcAcCharTg         = SYS(22)

*** Set the order of the file to tag 'ACCTCODE' and get its index 
*** expression for later use.
SET ORDER TO TAG ACCTCODE

SELECT GLSETUP

GO TOP

lcRetActMj         = ALLTRIM(GLSETUP.cSetRetMj)

*** If the field is setup
IF !EMPTY(lcRetActMj)

  *** Prepare the default retained earnings account code according to
  *** the account code mask (lcAcsMask) as well as the field content
  lcRetActMj       = lcRetActMj +;
                     STRTRAN(SUBSTR(ALLTRIM(loFormSet.lcAcsMask),LEN(lcRetActMj)+1),'9','0') +;
                     REPLICATE(' ',FSIZE('cAcctCode','GLACCHAR')-loFormSet.lnAcsSegSz)
  
  *** Look for the retained earnings account code into the chart
  *** of accounts file (GLACCHAR.DBF)
  IF !SEEK(lcRetActMj,'GLACCHAR')
    *** If the retained eranings account code is not found in the chart
    *** of accounts file (GLACCHAR), present the following message, 
    *** reset environment and return 0

    *** Reset tags to their original settings
    SELECT GLACCHAR
    IF EMPTY(lcAcCharTg)
      SET ORDER TO
    ELSE
      SET ORDER TO TAG (lcAcCharTg)
    ENDIF      

    *** Reset calling environment
    SELECT (lcCurAlias)
    IF llOneRec
      =gfObj_Lock(.F.)
    ENDIF

    *** Message : "    The default retained earnings account does not   "
    ***           "    exist in the chart of accounts file.             " 
    ***           "      You have to add the default retained earnings  "
    ***           "    account before ð.                          "
    ***           "                        < OK >                       "   
    
    
    *Don't display message on line and it to the log file if called from rebalance.
    IF llFromReb
      DECLARE laRebMsg[5]
      laRebMsg[1] = " "
      laRebMsg[2] = "The default retained earnings account does not exist in "
      laRebMsg[3] = "the chart of accounts file. You have to add the default "
      laRebMsg[4] = "retained earnings account before ð "
      laRebMsg[5] = " "
      =lfVryRport()
    ELSE
    
      *N000682,1 12/26/12 TMI Globlization changes[Start] 
      *=gfModalGen('TRM02127B00000','Dialog','posting')
      =gfModalGen('TRM02127B00000','Dialog',IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_posting,oAriaApplication.GetHeaderText("LANG_posting",lcHeaderFile)))
      *N000682,1 12/26/12 TMI Globlization changes[End  ] 
    ENDIF
    RETURN 0
  ENDIF  

ELSE
  *** If the field is empty, present the following message, 
  *** reset environment and return 0

  *** Reset tags to their original settings
  SELECT GLACCHAR
  IF EMPTY(lcAcCharTg)
    SET ORDER TO
  ELSE
    SET ORDER TO TAG (lcAcCharTg)
  ENDIF      

  *** Reset calling environment
  SELECT (lcCurAlias)
  IF llOneRec
    =gfObj_Lock(.F.)
  ENDIF

  *** Message : "    You have to setup the retained earnings account  "
  ***           "    major in the GL setup before ð.                  " 
  ***           "                    < OK >                           "   
  * Don't display message on line and it to the log file if called from rebalance.
  IF llFromReb
    DECLARE laRebMsg[4]
    laRebMsg[1] = " "
    laRebMsg[2] = "You have to setup the retained earnings account "
    laRebMsg[3] = "major in the GL setup before posting."
    laRebMsg[4] = " "    
    =lfVryRport()  
  ELSE
  
    *N000682,1 12/26/12 TMI Globlization changes[Start] 
    *=gfModalGen('TRM02126B00000','Dialog','posting')
    =gfModalGen('TRM02126B00000','Dialog',IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_posting,oAriaApplication.GetHeaderText("LANG_posting",lcHeaderFile)))    
    *N000682,1 12/26/12 TMI Globlization changes[End  ] 
  ENDIF
  RETURN 0
ENDIF    


*** 2. Check that the suspense account (GLSETUP.cSetSusMj) 
***    is setup in the GlSetup file (GLSETUP.DBF), and found
***    in the chart of accounts file (GLACCHAR.DBF)       
lcSusActMj         = ALLTRIM(GLSETUP.cSetSusMj)

*** If the field is setup
IF !EMPTY(lcSusActMj)

  *** Prepare the suspense account code according to
  *** the account code mask (lcAcsMask) as well as the field content
  lcSusActMj       = lcSusActMj +;
                     STRTRAN(SUBSTR(ALLTRIM(loFormSet.lcAcsMask),LEN(lcSusActMj)+1),'9','0')+;
                     REPLICATE(' ',FSIZE('cAcctCode','GLACCHAR')-loFormSet.lnAcsSegSz)

  *** Look for the suspense account code into the chart
  *** of accounts file (GLACCHAR.DBF)
  IF !SEEK(lcSusActMj,'GLACCHAR')
    
    *** If the suspense account code is not found in the chart
    *** of accounts file (GLACCHAR), present the following message 
    *** and return 0
    *** Reset tags to their original settings
    SELECT GLACCHAR
    IF EMPTY(lcAcCharTg)
      SET ORDER TO
    ELSE
      SET ORDER TO TAG (lcAcCharTg)
    ENDIF      

    *** Reset calling environment
    SELECT (lcCurAlias)
    IF llOneRec
      =gfObj_Lock(.F.)
    ENDIF
    
    *** Message : "    The default suspense account does not            "
    ***           "    exist in the chart of accounts file.             " 
    ***           "      You have to add the default suspense           "
    ***           "    account before ð.                          "
    ***           "                     < OK >                          "   
    *Don't display message on line and it to the log file if called from rebalance. 
    IF llFromReb
      DECLARE laRebMsg[5]
      laRebMsg[1] = " "
      laRebMsg[2] = " The default suspense account does not exist in the "
      laRebMsg[3] = " chart of accounts file. "
      laRebMsg[4] = " You have to add the default suspense account before posting. "
      laRebMsg[5] = " "
      =lfVryRport()
    ELSE  
      *N000682,1 12/26/12 TMI Globlization changes[Start] 
      *=gfModalGen('TRM02129B00000','Dialog','posting')
      =gfModalGen('TRM02129B00000','Dialog',IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_posting,oAriaApplication.GetHeaderText("LANG_posting",lcHeaderFile)))      
      *N000682,1 12/26/12 TMI Globlization changes[End  ] 
    ENDIF
    RETURN 0
  ENDIF  

ELSE
  *** If the field is empty, present the following message, and return
  *** 0

  *** Reset tags to their original settings
  SELECT GLACCHAR
  IF EMPTY(lcAcCharTg)
    SET ORDER TO
  ELSE
    SET ORDER TO TAG (lcAcCharTg)
  ENDIF      

  *** Reset calling environment
  SELECT (lcCurAlias)
  IF llOneRec
    =gfObj_Lock(.F.)
  ENDIF
  
  *** Message : "    You have to setup the suspense account           "
  ***           "    major in the GL setup before ð.                  " 
  ***           "                    < OK >                           "   
  *Don't display message on line and it to the log file if called from rebalance. 
  IF llFromReb
    DECLARE laRebMsg[4]
    laRebMsg[1] = " "
    laRebMsg[2] = " You have to setup the suspense account "
    laRebMsg[3] = " major in the GL setup before posting."
    laRebMsg[4] = " "
    =lfVryRport()
  ELSE
    *N000682,1 12/26/12 TMI Globlization changes[Start] 
    *=gfModalGen('TRM02128B00000','Dialog','posting')
    =gfModalGen('TRM02128B00000','Dialog',IIF(oAriaApplication.oActivelang.cLang_ID = "EN",LANG_posting,oAriaApplication.GetHeaderText("LANG_posting",lcHeaderFile)))    
    *N000682,1 12/26/12 TMI Globlization changes[End  ] 
  ENDIF
  RETURN 0
ENDIF    


*** IV : 
*** IV : 1. Temporary file creation 
*** For all the created files, openned 'AGAIN' files, or files
*** openned by this module, check if the file is successfully
*** openned in the respective work area. If at least one of
*** the files cannot be openned, terminate the posting process
*** and return 0.  

*** Get the field widths as follows :
*** Numeric field 'nAmount' form year end closing balance field 
***     in the balances file (as an example)  GLACBALS.nAcBClBal
*** Account code width from 'GLACCHAR.cAcctCode'
*** Batch number width from 'GLBATCH.cBatchNo'
*** Transaction number from 'GLTRNSHD.cTranNo'

lnAmntWdth         = FSIZE('nAcBClBal','GLACBALS') 
lnAcctWdth         = FSIZE('cAcctCode','GLACCHAR')
lnBtNoWdth         = FSIZE('cBatchNo','GLBATCH') 
lnTrNoWdth         = FSIZE('cTranNo','GLTRNSHD') 

*** Summarize entries_1 (lc_SumEnt1) and Summarize entries_2
*** (lc_SumEnt2) have the following file structure :
*** field name    Type       Width      Decimal   Comment
*** cAcctCode       C      lnAcctWdth     --   
*** cFisFYear       C          4          --   
*** cFspPrdId       C          2          --   
*** nDrAmount       N       lnAmntWdth     2  
*** nCrAmount       N       lnAmntWdth     2  
*** llComplete      L   

lc_SumEnt1         = gfTempName()
CREATE TABLE &gcWorkDir.&lc_SumEnt1 ;
	(cAcctCode C(lnAcctWdth), cFisFYear C(4), cFspPrdId C(2),;
	 nDrAmount N(lnAmntWdth,2),nCrAmount N(lnAmntWdth,2), llComplete L)
	 
IF !lfFileUsed(lc_SumEnt1)
  RETURN 0
ENDIF
  
*** Prepare an index tag to be used in relation setting.
*** The index expression is 'Account code + year + period'  	

SELECT (lc_SumEnt1)
INDEX ON cAcctCode + cFisFYear + cFspPrdId TAG AccYrPrd
SET ORDER TO TAG AccYrPrd

lc_SumEnt2         = gfTempName()
CREATE TABLE &gcWorkDir.&lc_SumEnt2 ;
	(cAcctCode C(lnAcctWdth), cFisFYear C(4), cFspPrdId C(2),;
	 nDrAmount N(lnAmntWdth,2),nCrAmount N(lnAmntWdth,2), llComplete L)

IF !lfFileUsed(lc_SumEnt2)
  RETURN 0
ENDIF

*** Prepare an index tag to be used for seeking
*** The index expression is 'Account code + year + period'  	

SELECT (lc_SumEnt2)
INDEX ON cAcctCode + cFisFYear + cFspPrdId TAG AccYrPrd
SET ORDER TO TAG AccYrPrd


*** Account replacements file (lc_ActRepl) has the following
*** file structure :
*** field name    Type       Width      Decimal   Comment
*** cBatchNo        C      lnBtNoWdth     --   
*** cTranNo         C      lnTrNoWdth     --   
*** cAcctCode       C      lnAcctWdth     --   

lc_ActRepl         = gfTempName()
CREATE TABLE &gcWorkDir.&lc_ActRepl;
	(cBatchNo C(lnBtNoWdth), cTranNo C(lnTrNoWdth),;
	    cAcctCode C(lnAcctWdth))

IF !lfFileUsed(lc_ActRepl)
  RETURN 0
ENDIF

*** Prepare an index tag to be used in relation setting.
*** The index expression is 'batch no. + transaction no. + account code' 

SELECT (lc_ActRepl)
INDEX ON cBatchNo + cTranNo + cAcctCode TAG BatTrnAct
SET ORDER TO TAG BatTrnAct

*** IV: 2. Open the following files, if not already in use
*** Open GLACBALS.DBF file again in another work area,lc_AcBals
*** to be used in relation setting
lc_AcBals          = gfTempName()
SELECT 0
USE &lcDataDir.GLACBALS AGAIN ALIAS &lc_AcBals ORDER ACCYRPRD 
IF !lfFileUsed(lc_AcBals)
  RETURN 0
ENDIF

*** If posting to a dummy balances files, ( from reports),
*** recreate the dummy balances file (lcTempBals) if it does 
*** not already exists as follows
IF llTBReport
  IF !USED(lcTempBals)
    COPY STRUCTURE TO &gcWorkDir.&lcTempBals WITH CDX  
    USE &gcWorkDir.&lcTempBals EXCL IN 0 ORDER TAG ACCYRPRD
    IF !lfFileUsed(lcTempBals)
      RETURN 0 
    ENDIF
  ENDIF

  *** In case of reporting, create a name for a cursor to be used for
  *** displaying dummy posted batches or transactions in a browse.
  lc_BrowCur = gfTempName()

ELSE
  *** Otherwise, if actually posting, 
  *** Create a name for the temporary file to hold a backup
  *** of the balances to be modified while posting and create
  *** the file as well ( created for recovery purpose )
  lc_TmpBals         = gfTempName()
  COPY STRUCTURE TO &gcWorkDir.&lc_TmpBals
  USE &gcWorkDir.&lc_TmpBals EXCL IN 0
  IF !lfFileUsed(lc_TmpBals)
    RETURN 0
  ENDIF

  *** Closing entries file (lc_ClosEnt) has the following file structure :
  *** field name    Type       Width      Decimal   Comment
  *** cCostCntr       C      lnAcctWdth     --       same as cAcctCode
  *** cAcctCode       C      lnAcctWdth     --   
  *** nAmount         N      lnAmntWdth      2 
  *** cDrOrCr         C          1          --   debit 'D', or credit 'C'

  lc_ClosEnt         = gfTempName()
  CREATE TABLE &gcWorkDir.&lc_ClosEnt;
	 (cCostCntr C(lnAcctWdth), cAcctCode C(lnAcctWdth),;
	   nAmount N(lnAmntWdth,2), cDrOrCr C(1))

  IF !lfFileUsed(lc_ClosEnt)
    RETURN 0
  ENDIF

  SELECT (lc_ClosEnt)
  INDEX ON cCostCntr + cAcctCode TAG CostCtAcct
  SET ORDER TO TAG CostCtAcct

  *** Temporary batches file (lc_Batches) has the same structure as
  *** the batches file (GLBATCH.DBF)
  lc_Batches         = gfTempName()
  SELECT GLBATCH
  COPY STRUCTURE TO &gcWorkDir.&lc_Batches
  USE &gcWorkDir.&lc_Batches EXCL IN 0
  IF !lfFileUsed(lc_Batches)
    RETURN 0
  ENDIF

  *** Temporary transactions header file (lc_TransHd) has the same 
  *** structure as the transactions header file (GLTRNSHD.DBF)
  lc_TransHd         = gfTempName()
  SELECT GLTRNSHD
  COPY STRUCTURE TO &gcWorkDir.&lc_TransHd
  USE &gcWorkDir.&lc_TransHd EXCL IN 0
  IF !lfFileUsed(lc_TransHd)
    RETURN 0
  ENDIF

  *** Temporary transactons details file (lc_TransDt) has the same   
  *** structure as the transactions details file (GLTRNSDT.DBF)
  lc_TransDt         = gfTempName()
  SELECT GLTRNSDT
  COPY STRUCTURE TO &gcWorkDir.&lc_TransDt
  USE &gcWorkDir.&lc_TransDt EXCL IN 0
  IF !lfFileUsed(lc_TransDt)
    RETURN 0
  ENDIF

ENDIF

*** Open GLACCHAR.DBF file again in another wotk area,lc_AcChar
*** to be used in relation setting
lc_AcChar          = gfTempName()
USE &lcDataDir.GLACCHAR AGAIN ALIAS &lc_AcChar ORDER ACCTCODE IN 0
IF !lfFileUsed(lc_AcChar)
  RETURN 0
ENDIF

*** V : Establishment of relations :

*** Setting the appropriate tags for the files associated in the 
*** relations (except those already set)

SELECT GLACBALS
*** Get the current tag 
lcAcBalsTg         = SYS(22)
*** Set the order of the file to tag 'ACCTCODE' and get its index 
*** expression for later use.
SET ORDER TO TAG ACCYRPRD
*** Current index expression for tag 'ACCYRPRD' is : 
*** cAcctCode+cFisFYEar+cFspPrdId
lcAcBalsEx          = SYS(14,VAL(SYS(21)))

SELECT GLBATCH
*** Get the current tag 
lcBatchTg          = SYS(22)
*** Check if a filter is set from the calling program
IF lcTrOrBat = 'B'
  *** Store the filter expression if any, so as to reset the
  *** filter on exit.
  lcTBFltExp       = FILTER()
  *** If a filter is set from a calling program, remove it
  IF !EMPTY(lcTBFltExp)
    SET FILTER TO 
    GO TOP
  ENDIF
ENDIF  
*** Set the order of the file to tag 'BATCHNO' and get its index 
*** expression for later use.
SET ORDER TO TAG BATCHNO
*** Current index expression for tag 'BATCHNO' is : 
*** cBatchNo
lcBatchEx           = SYS(14,VAL(SYS(21)))

SELECT GLTRNSHD
*** Get the current tag 
lcTrnsHdTg          = SYS(22)
*** Check if a filter is set from the calling program
IF lcTrOrBat = 'T'
  *** Store the filter expression if any, so as to reset the
  *** filter on exit.
  lcTBFltExp       = FILTER()
  *** If a filter is set from a calling program, remove it
  IF !EMPTY(lcTBFltExp)
    SET FILTER TO 
    GO TOP
  ENDIF
ENDIF  
*** Set the order of the file to tag 'BATCHTRN' and get its index 
*** expression for later use.
SET ORDER TO TAG BATCHTRN
*** Current index expression for tag 'BATCHTRN' is : 
*** cBatchNo + cTranNo
lcTrnsHdEx           = SYS(14,VAL(SYS(21)))

SELECT GLTRNSDT
*** Get the current tag 
lcTrnsDtTg          = SYS(22)
*** Set the order of the file to tag 'BATCHTRN' and get its index 
*** expression for later use.
SET ORDER TO TAG BATCHTRN
*** Current index expression for tag 'BATCHTRN' is : 
*** cBatchNo + cTranNo + cAcctCode 
lcTrnsDtEx           = SYS(14,VAL(SYS(21)))

*** Setting of relations :
*** Set a relation between GLTRNSHD (parent) and GLTRNSDT (child)
*** on batch no. + transaction no.
SELECT GLTRNSHD
SET RELATION TO cBatchNo + cTranNo INTO GLTRNSDT ADDITIVE  

  *** Set a relation between GLTRNSDT (parent) and the following files
  *** as follows :
  SELECT GLTRNSDT

    *** a. SYCFSPPRD (child) on Active company + year + period 

    SET RELATION TO cTrnpYr + cTrnpPrd INTO FSPRD ADDITIVE
    

    *** b. lc_AcBals (copy of GLACBALS) (child) 
    ***    on account code + year + period 
    SET RELATION TO cAcctCode + cTrnpYr + cTrnpPrd ;
                 INTO (lc_AcBals) ADDITIVE
                 
    *** c. lc_AcChar (copy of GLACCHAR) (child) on account code                  
    SET RELATION TO cAcctCode INTO (lc_AcChar) ADDITIVE             
                 
    *** d. lc_ActRepl (child) 
    ***    on batch no. + transaction no. + account code 
    SET RELATION TO cBatchNo + cTranNo + cAcctCode ;
                 INTO (lc_ActRepl) ADDITIVE
    
    *** e. lc_SumEnt1 (child) on account code + year + period
    SET RELATION TO cAcctCode + cTrnpYr + cTrnpPrd ;
                 INTO (lc_SumEnt1) ADDITIVE
        

    *** Set a relation between (lc_SumEnt1) (parent) and the following 
    *** files as follows :
    SELECT (lc_SumEnt1)
      
      *** a. GLACCHAR (child) on account code                         
      SET RELATION TO cAcctCode INTO GLACCHAR ADDITIVE
      
      *** b. GLACBALS (ot lcTempBals) on account code + year + period
      IF !llTBReport
          SET RELATION TO cAcctCode + cFisFYear + cFspPrdId ;
                   INTO GLACBALS ADDITIVE
      ELSE
         SET RELATION TO cAcctCode + cFisFYear + cFspPrdId ;
                   INTO (lcTempBals) ADDITIVE
      ENDIF
       

*** Set a relation between (lc_SumEnt2) (parent) and the following 
*** files as follows :
SELECT (lc_SumEnt2)
      
  *** a. GLACCHAR (child) on account code                         
  SET RELATION TO cAcctCode INTO GLACCHAR ADDITIVE

  *** b. GLACBALS (ot lcTempBals) on account code + year + period
  IF !llTBReport
    SET RELATION TO cAcctCode + cFisFYear + cFspPrdId ;
               INTO GLACBALS ADDITIVE
  ELSE
    SET RELATION TO cAcctCode + cFisFYear + cFspPrdId ;
               INTO (lcTempBals) ADDITIVE
  ENDIF

*** VI : Proceed with the posting operation
*** Reset total debit and total credit
lnTotalDr          = 0 
lnTotalCr          = 0 

*** Initialize the posting session number with blank
lcPostSess         = ''

*** Reset the posting return flag 
llPosted           = .F.     

oProgress = NEWOBJECT('ariaprogressbar',oAriaApplication.classdir+'utility.vcx')

*** Attempt to lock the following files :
*** GLACBALS.DBF, GLBATCH.DBF, GLTRNSHD.DBF, GLTRNSDT.DBF,
*** If not called from reports :
*** GLPTRNHD.DBF, GLPTRNDT.DBF

*** If locking attempt fails for at least one file, do not
*** proceed with the posting process, and exit to the calling
*** program
IF lfTBLock()
  *** Restore environment 
  SELECT (lcCurAlias)
  IF llOneRec  
    GO lnCurRecrd
  ENDIF
  
  DO CASE
  
    *** Posting a single transaction
    CASE lcTrOrBat = 'T' .AND. llOneRec

      *** The current work area should be GLTRNSHD from
      *** the calling program
      SELECT GLTRNSHD
      
      *** If the transaction is valid for posting
      lnThermRec   = lnthermRec + 1
      =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+GLTRNSHD.cTranNo)

      IF lfVld_Summ()
      
        *** Call the posting program with lc_SumEnt1 file.
        *** Update the 'Posted' flag as you come back 

        lnThermRec   = lnthermRec + 1
        =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+ GLTRNSHD.cTranNo)
        llPosted   = IIF(llTBReport, lfRepPost(lc_SumEnt1,.T.), ;
                                     lfPost(lc_SumEnt1));
                     .OR. llPosted
        
        *** Increment the 'posted transactions' counter by one.
        IF llPosted
          lnTBPosted = lnTBPosted + 1  
        ENDIF  
      ENDIF  
    *** Posting multiple transactions
    CASE lcTrOrBat = 'T' .AND. !llOneRec
    
      *** Set a relation between the temporary file (lcTempFile) 
      *** holding the transaction number of the transactions to be 
      *** posted (parent) and GLTRNSHD (child) on transaction no.
      SELECT (lcTempFile)
    
      *** Prepare the relation expression
      *** Transactions not belonging to a certain batch (as in this case)
      *** are always given a batch number of '000000', so this batch no
      *** value is used as the first part of the relational expression,
      *** the second part being the field name of lcTempFile corresponding
      *** to the transaction number such that the relation is on
      *** batch no. + transaction no.
      lcFieldNam     = "'" + REPLICATE('0',lnBtNoWdth) +;
                       "'" + "+"+FIELD(1)
      SET RELATION TO &lcFieldNam INTO GLTRNSHD ADDITIVE
    
      *** Scan all transactions approved for posting, contained in
      *** lcTempFile (all of them are approved for posting, collected
      *** from the calling program)

      SCAN
      
        *** If the transaction is valid for posting
        lnThermRec   = lnthermRec + 1
        =lfThermo(lnTotRecs, lnThermRec, lcPstTB,;
                  lcVldTB+ &lcTempFile..cTranNo)

        IF lfVld_Summ()
      
          *** Call the posting program with lc_SumEnt1 file.
          *** Update the 'Posted' flag as you come back 
          lnThermRec   = lnthermRec + 1
          =lfThermo(lnTotRecs, lnThermRec, lcPstTB,;
                    lcVldTB+ &lcTempFile..cTranNo)
          llPosted = IIF(llTBReport, lfRepPost(lc_SumEnt1,.T.), ;
                                      lfPost(lc_SumEnt1));
                      .OR. llPosted
           
          *** Increment the 'posted transactions' counter by one.
          IF llPosted
            lnTBPosted = lnTBPosted + 1  
            *** If called from reports :
            *** Update posted field of temporary file with 'P' for
            *** posted if a field exists for that purpose.
            IF llTBReport .AND. FCOUNT(lcTempFile)>1 
              SELECT (lcTempFile)
              lcPstdFld = FIELD(2,lcTempFile)
              REPLACE &lcTempFile..&lcPstdFld. WITH 'P'    
            ENDIF  
          ENDIF  
        ENDIF

        *** Reset total debit and total credit
        lnTotalDr      = 0 
        lnTotalCr      = 0 

        SELECT (lcTempFile)
      ENDSCAN  
        
      *** Reset the current relation
      SET RELATION OFF INTO GLTRNSHD
  
    *** Posting a single batch
    CASE lcTrOrBat = 'B' .AND. llOneRec
  
      *** Set a relation between the calling database file (GLBATCH)
      *** and GLTRNSHD (child) on batch no.
      SELECT GLBATCH
      
      SET RELATION TO cBatchNo INTO GLTRNSHD ADDITIVE
    
      *** If the batch is valid for posting

      lnThermRec   = lnthermRec + 1
      =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+ GLBATCH.cBatchNo)

      IF lfVld_Bat()
      
        *** Call the posting program with lc_SumEnt1 file.
        *** Update the 'Posted' flag as you come back.

        lnThermRec   = lnthermRec + 1
        =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+ GLBATCH.cBatchNo)
        llPosted   = IIF(llTBReport, lfRepPost(lc_SumEnt1,.T.), ;
                                     lfPost(lc_SumEnt1));
                     .OR. llPosted
        
        *** Increment the 'posted batches' counter by one.
        IF llPosted
          lnTBPosted = lnTBPosted + 1  
        ENDIF  
      ENDIF  
    
      *** Reset the current relation
      SELECT GLBATCH
      SET RELATION OFF INTO GLTRNSHD
   
    *** Posting multiple batches
    CASE lcTrOrBat = 'B' .AND. !llOneRec
     
      *** Set a relation bewteen the calling database (GLBATCH)
      *** (parent) and GLTRNSHD (child) on batch no.
      SELECT GLBATCH
      SET RELATION TO cBatchNo INTO GLTRNSHD ADDITIVE  
     
      *** Set a relation between the temporary file (lcTempFile) 
      *** holding the batch number of the batches to be posted
      *** (parent) and GLBATCH (child) on batch no.
      SELECT (lcTempFile)
    
      *** Get the relation expression which is :
      *** '00000..' (according to the field size) which is the batch  
      *** no. given to the transactions not belonging to any batch
      *** + transaction number field given in lcTempfile
    
      lcFieldNam     = FIELD(1)
      SET RELATION TO &lcFieldNam INTO GLBATCH ADDITIVE
    
      *** Set continue flag (llContinue)
      llContinue     = .T.
    
      *** Scan all batches approved for posting, contained in
      *** lcTempFile (all of them are approved for posting, collected
      *** from the calling program) while llContinue is .T.
    
      GO TOP
      SCAN WHILE llContinue
      
        *** Validate the current batch

        lnThermRec   = lnthermRec + 1
        =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+ &lcTempFile..cBatchNo)

        llContinue   = lfVld_Bat()  
    
        *** Note that non beginning balance batches are posted 
        *** one by one, while beginning balance batches are all
        *** posted at the same time.
        
        *** If posting beginning balances batches, and at least
        *** one batch is found to be invalid, the posting process
        *** is terminated, 
        *** else, the posting process continues with the rest
        *** of the batches. 
      
        *** If the batch is valid, and batches to be posted are
        *** non beginning balances batches, proceed
        IF llContinue .AND. lcBatType<>'B'
        
          *** Call the posting program with lc_SumEnt1
          *** Update the 'Posted' flag as you come back

          lnThermRec   = lnthermRec + 1
          =lfThermo(lnTotRecs, lnThermRec, lcPstTB,lcVldTB+ &lcTempFile..cBatchNo)

          llPosted  = IIF(llTBReport, lfRepPost(lc_SumEnt1,.T.), ;
                                     lfPost(lc_SumEnt1));
                      .OR. llPosted
          
          *** Increment the 'posted batches' counter by one.
          IF llPosted
            lnTBPosted = lnTBPosted + 1  
            *** If called from reports :
            *** Update posted field of temporary file with 'P' for
            *** posted if a field exists for that purpose.
            IF llTBReport .AND. FCOUNT(lcTempFile)>1
              SELECT (lcTempFile)
              lcPstdFld = FIELD(2,lcTempFile)
              REPLACE &lcTempFile..&lcPstdFld. WITH 'P'    
            ENDIF  
          ENDIF  
        ENDIF
      
        *** If posting non beginning balance batches and the current
        *** batch is found to be invalid for posting (llContinue = .F.)
        *** Reset llContinue to continue posting the rest of the batches,
        *** or,
        *** If posting beginning balance batches and the current batch
        *** is found to be invalid for posting (llContinue = .F.)
        *** exit the loop to terminate the posting process.
        llContinue   = lcBatType <> 'B' .OR. llContinue

        SELECT (lcTempFile)        
      ENDSCAN 
  
      *** If posting beginning balance batches, and all the batches 
      *** are valid 
      IF llContinue .AND. lcBatType = 'B'
      
        *** Check if all its transactions are balanced        
        IF lnTotalDr <> lnTotalCr .OR. ;
           (lnTotalDr = 0 .AND. lnTotalCr = 0)
          *** If total debit is not equal to total credit, or
          *** Both of them are equal to 0, terminate the posting process,
          *** unlock any locked files and present the following message
          
          =lfTBUnLock()
          
          *** Message : " Total debit is not equal to total credit   "
          ***           " for all beginning balances batch(es). Posting "
          ***           " process is terminated                    "
          ***                               < OK >
          * Don't display message on line and it to the log file if called from rebalance. 
          IF llFromReb
            DECLARE laRebMsg[5]
            laRebMsg[1] = " "
            laRebMsg[2] = " Total debit is not equal to total credit  "
            laRebMsg[3] = " for all beginning balances batch(es). Posting"
            laRebMsg[4] = " process is terminated."
            laRebMsg[5] = " "
            =lfVryRport()
          ELSE        
          
            =gfModalGen('TRM02132B00000','Dialog')
            
          ENDIF
        ELSE
        
          *** If transactions are balanced, call the posting 
          *** program with lc_SumEnt1 file.      
          *** Update the 'Posted' flag as you come back.

          lnThermRec   = lnthermRec + 1
          =lfThermo(lnTotRecs, lnThermRec, "Posting beginning balances batches...","")

          llPosted = IIF(llTBReport, lfRepPost(lc_SumEnt1,.T.), ;
                                     lfPost(lc_SumEnt1));
                     .OR. llPosted

          *** In case of posting multiple beginning balance
          *** batches, if the posting process is successful,
          *** the number of posted batches is the total number
          *** of batches in the temporary file (lcTempFile)
          IF llPosted
            lnTBPosted = RECCOUNT(lcTempFile)
            *** If called from reports :
            *** Update posted field of temporary file with 'P' for
            *** posted if a field exists for that purpose.
            IF llTBReport .AND. FCOUNT(lcTempFile)>1
              SELECT (lcTempFile)
              lcPstdFld = FIELD(2,lcTempFile)
              REPLACE ALL &lcTempFile..&lcPstdFld. WITH 'P'    
            ENDIF  
          ENDIF  
        ENDIF
      ENDIF  
    
    
      *** Reset the current relations
      SELECT (lcTempFile)
      SET RELATION OFF INTO GLBATCH
  
      SELECT GLBATCH
      SET RELATION OFF INTO GLTRNSHD
  
  ENDCASE

  =lfThermo(lnTotRecs, lnTotRecs,"","")
  oProgress = NULL

  
  *** If no transactions at all are posted, unlock any locked files, 
  *** clean up and return 0
  IF !llPosted
    =lfTBUnLock()
    =lfTBClean()
    RETURN 0
  ENDIF    

  *** VII:
  *** If actually posting, 
  *** Call the Create closing entries batches program if closing
  *** entries are available
  *** 
  IF RECCOUNT(lc_SumEnt2) > 0
    *** If posting for reports, adjust parameters, and
    *** call the report posting function with lc_SumEnt2
    IF llTBReport
      *** Save old parameters
      llOldOneRc   = llOneRec
      lcOldTBTyp   = lcTrOrBat 
      lcOldBType   = lcBatType  
      *** Modify the following variables as follows :
      *** Single batch posting
      llOneRec     = .T.    
      lcTrOrBat    = 'B'
      *** of type "year end 'C'losing" 
      lcBatType    = 'C' 
    
      llPosted     = lfRepPost(lc_SumEnt2, .F.) .OR. llPosted
      
      *** Restore old parameters
      llOneRec     = llOldOneRc
      lcTrOrBat    = lcOldTBTyp
      lcBatType    = lcOldBType
 
    ELSE
      llPosted     = IIF(RECCOUNT(lc_ClosEnt) > 0,;
                          lfCreatCls(),.F.) .OR. llPosted 
    ENDIF
  ENDIF
  
  *** Unlock any locked files
  =lfTBUnLock()
  
  *** VIII :
  *** Give the user a list of all posted batch(es) or transaction(s)
  *** and if GLSETUP.lSetForAt is .T. (this field is true if the user
  *** must get a printed report after posting), force the user print
  *** this report( to printer or to file)
  
  *** If called from a report, do not present the browse 
  IF llPosted
    =lfBrowPost()
  ENDIF

  *** IX :
  *** Clean up as you return to the calling program, and return
  *** the number of posted transactions or batches
  =lfTBClean()
  RETURN lnTBPosted

*** If locking attempt fails for at least one file, return
ELSE
  *** Unlock any locked files and clean up as you return 
  *** to the calling program
  =lfTBUnLock()
  =lfTBClean()

  RETURN 0
ENDIF
  
*!**************************************************************************
*!
*!      Function : lfVld_Bat
*!
*!**************************************************************************
*
FUNCTION lfVld_Bat
PRIVATE lcStartPrd, lcEndPrd, lcFisYear, llNotVoid

*** lcStartPrd  : start period of the batch.
*** lcEndPrd    : end period of the batch.
*** lcFisYear   : fiscal year of the batch.

llNotVoid          = .T.    && .T. if all entries are Voided

*** Checking for the total debit and total credit is normally
*** done in the transaction's validation phase (lfVld_Summ), but
*** If all the transactions are 'V'oided, this check
*** will not be passed, hence, use flag llNotVoid to indicate
*** whether this check is passed or not
*** The case of posting a batch having all its transactions
*** as 'V'oided is prohibited. This check is just for safety.
STORE 0 TO lnBatTotDr,lnBatTotCr

*** Initialize llBatVld to .F. (i.e. batch is invalid) 
llBatVld           = .T.

*** If posting non beginning batch(es), zap all the data in the
*** Summarize_entries (lc_SumEnt1) file, if any, to be ready
*** for the new entries, as well as the data in the accounts
*** replacement file (lc_ActRepl)

IF lcBatType <> 'B'
  SELECT (lc_SumEnt1)
  ZAP

  SELECT (lc_ActRepl)
  ZAP

  SELECT GLBATCH
ENDIF  

*** Scan all the transactions in this batch except those marked as
*** 'V'oid (cBatStat='V') 
IF GLBATCH.cBatStat <> 'V'

  *** 1. Check that the current batch has corresponding entries
  *** Although posting an empty batch is prohibited by the other
  *** programs, this check is just for safety.
  IF EOF('GLTRNSHD') 
    *** If the batch has no entries, present the following message
    *** Message : "     ð No. ð has no entries.  ð.     "
    ***                               < OK > 
    *** If posting beginning balances batches or a single batch, 
    *** terminate posting and unlock any locked files
    IF llOneRec .OR. lcBatType = 'B' 
      =lfTBUnLock()
    ENDIF  
    *Don't display message on line and it to the log file if called from rebalance. 
    IF llFromReb  
      DECLARE laRebMsg[4]
      laRebMsg[1] = " "
      laRebMsg[2] = "Batch No. "+GLBATCH.cBatchNo +" has no entries."
      *N000682,1 12/14/12 TMI Globlization changes[Start] 
      *laRebMsg[3] = IIF(lcBatType = 'B','Posting process is terminated','Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+' will not be posted')
      laRebMsg[3] = IIF(lcBatType = 'B','Posting process is terminated','Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
      *N000682,1 12/14/12 TMI Globlization changes[End  ] 
      laRebMsg[4] = " "
      =lfVryRport()
    ELSE
    
      *N000682,1 12/14/12 TMI Globlization changes[Start] 
      *=gfModalGen('TRM02131B00000','Dialog','Batch'+'|'+;
                  ALLTRIM(GLBATCH.cBatchNo)+'|'+;
                  IIF(lcBatType = 'B','Posting process is terminated',;
                  'Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+' will not be posted'))) *X*
      =gfModalGen('TRM02131B00000','Dialog',lcLANG_Batch+'|'+;
                  ALLTRIM(GLBATCH.cBatchNo)+'|'+;
                  IIF(lcBatType = 'B',lcLANG_Posting_process_is_terminated,;
                  lcLANG_Batch_No+ ALLTRIM(GLBATCH.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED)))
      *N000682,1 12/14/12 TMI Globlization changes[End  ] 
    ENDIF
    *** Return to the calling program with a .F. for invalid batch
    RETURN .F.
  ENDIF  

  *** 2. If posting nonbeginning balance batch(es) :
  *** a. Check that the number of periods included in the batch 
  ***    do not exceed the GL setup for the maximum number of 
  ***    periods within a batch posting window (GLSETUP.nSetBatPW),  

  IF lcBatType <> 'B' .AND. SEEK('','FSPRD')
  
    GO TOP IN GLSETUP

    SELECT FSPRD

    LOCATE REST FOR BETWEEN(GLBATCH.dBatPBeg, ;
                            FSPRD.dFspPBgDt, FSPRD.dFspPEnDt)

    lcStartPrd     = FSPRD.cFspPrdId
    lcFisYear      = FSPRD.cFisFYear
    
    *** Get the end Period for the batch

    LOCATE REST FOR BETWEEN(GLBATCH.dBatPEnd, ;
                            FSPRD.dFspPBgDt, FSPRD.dFspPEnDt)
    
    lcEndPrd       = FSPRD.cFspPrdId
  
    
    
    IF INT(VAL(lcEndPrd) - VAL(lcStartPrd) + 1) > GLSETUP.nSetBatPW
      IF llOneRec
        =lfTBUnLock()
      ENDIF  
      *** Message  : "   Batch No. ð includes posting to ð period(s).   "
      ***            "   The GL setup indicates a maximum of ð periods  "
      ***            "   for the batch posting window. ð.               "
      ***                          < OK > 
      *Don't display message on line and it to the log file if called from rebalance. 
      IF llFromReb
        DECLARE laRebMsg[6]
        laRebMsg[1] = " "
        laRebMsg[2] = "Batch No."+ALLTRIM(GLBATCH.cBatchNo)+" includes posting to "+ALLTRIM(STR(INT(VAL(lcEndPrd) - VAL(lcStartPrd) + 1),2))+" period(s)."
        laRebMsg[3] = "The GL setup indicates a maximum of "+ALLTRIM(STR(GLSETUP.nSetBatPW,2)) +" periods"
        laRebMsg[4] = " for the batch posting window."
        *N000682,1 12/14/12 TMI Globlization changes[Start] 
        *laRebMsg[5] = IIF(llOneRec,'Posting process is terminated','Batch No. ' + ALLTRIM(GLBATCH.cBatchNo)+' will not be posted')
        laRebMsg[5] = IIF(llOneRec,'Posting process is terminated','Batch No. ' + ALLTRIM(GLBATCH.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
        *N000682,1 12/14/12 TMI Globlization changes[End  ] 
        laRebMsg[6] = " "
        =lfVryRport()
      ELSE
      
        *N000682,1 12/14/12 TMI Globlization changes[Start] 
        *=gfModalGen('TRM02206B00000', 'Dialog',;
                    ALLTRIM(GLBATCH.cBatchNo) + '|' + ; 
                    ALLTRIM(STR(INT(VAL(lcEndPrd) - VAL(lcStartPrd) + 1),2))+ '|' + ;
                    ALLTRIM(STR(GLSETUP.nSetBatPW,2)) + '|' + ;
                    IIF(llOneRec, 'Posting process is terminated', ;
                    'Batch No. ' + ALLTRIM(GLBATCH.cBatchNo) + ;
                    ' will not be posted'))
        =gfModalGen('TRM02206B00000', 'Dialog',;
                    ALLTRIM(GLBATCH.cBatchNo) + '|' + ; 
                    ALLTRIM(STR(INT(VAL(lcEndPrd) - VAL(lcStartPrd) + 1),2))+ '|' + ;
                    ALLTRIM(STR(GLSETUP.nSetBatPW,2)) + '|' + ;
                    IIF(llOneRec, lcLANG_Posting_process_is_terminated, ;
                    lcLANG_Batch_No + ALLTRIM(GLBATCH.cBatchNo) + ;
                    lcLANG_GLTPOST_WILL_NOT_BE_POSTED))
        *N000682,1 12/14/12 TMI Globlization changes[End  ]                     
      ENDIF
      *** Return to the calling program with a .F. for invalid batch
      RETURN .F.
      
    ELSE
      
      *** b. Hence, check that all the periods within the current batch's
      ***    posting begin date, and batch posting end date are not
      ***    locked. 
    
      IF SEEK(lcFisYear+lcStartPrd,'FSPRD')  
      
        *** Scan all the following Periods-Years (the current included)
        *** until the Periods-Years of the batch posting end date,

        SCAN REST WHILE &lcFscPrdEx. <= lcFisYear + lcEndPrd;
                 .AND. llBatVld

          llBatVld = !FSPRD.lFspLocks       
          lcLkdPrd = FSPRD.cFspPrdId + '-' + FSPRD.cFisFYear
          
        ENDSCAN
      ENDIF
      
      *** If the batch contained at least one locked period, terminate
      *** posting this batch and present the following message. 
      IF !llBatVld
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        *** Message  : "    Batch No. ð includes posting to 
        ***                      locked period ð. ð.
        ***                          < OK >
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = "Batch No. "+ALLTRIM(GLBATCH.cBatchNo)+" includes posting to "
          laRebMsg[3] = "locked period "+lcLkdPrd+"." 
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *laRebMsg[4] = IIF(llOneRec,'Posting process is terminated','Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+' will not be posted.')
          laRebMsg[4] = IIF(llOneRec,'Posting process is terminated','Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+' will not be posted.')
          *N000682,1 12/14/12 TMI Globlization changes[End  ] 
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *=gfModalGen('TRM02200B00000', 'Dialog', ALLTRIM(GLBATCH.cBatchNo) + ;
                      '|' + lcLkdPrd + '|' + ;
                      IIF(llOneRec, 'Posting process is terminated', ;
                      'Batch No. '+ ALLTRIM(GLBATCH.cBatchNo)+' will not be posted'))
          =gfModalGen('TRM02200B00000', 'Dialog', ALLTRIM(GLBATCH.cBatchNo) + ;
                      '|' + lcLkdPrd + '|' + ;
                      IIF(llOneRec, lcLANG_Posting_process_is_terminated, ;
                      lcLANG_Batch_No+ ALLTRIM(GLBATCH.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED))
          *N000682,1 12/14/12 TMI Globlization changes[End  ] 
        ENDIF
        *** Return to the calling program with a .F. for invalid batch
        RETURN .F.
      ENDIF  
    ENDIF  
  ENDIF
  
  
  SELECT GLBATCH
  
  IF !EOF()
    GO RECNO()
  ENDIF  
  
  *** Get the current batch number
  lcBatchNo        = GLBATCH.cBatchNo
  
  SELECT GLTRNSHD
  
  SCAN REST FOR GLTRNSHD.cTrnStat<>'V' WHILE &lcTrnsHdEx. = lcBatchNo ;
            .AND. llBatVld
    
    *** Validate each transaction by calling the Summarize_Entry
    *** function,lfVld_Summ().If one transaction is false, the batch 
    *** posting is terminated. llBatVld stores the result of the 
    *** transaction validation. 
    llBatVld         = lfVld_Summ()  

    *** Indicate that there is at least one nonVoid transaction
    llNotVoid          = .F.    
    
    *** If validating batches other than 'B'eginning balance batch(es),
    *** reset the total debit and total credit variables for each 
    *** transaction.
    IF lcBatType <> 'B'   
      lnTotalDr      = 0
      lnTotalCr      = 0
    ENDIF
  ENDSCAN
  
  SELECT GLBATCH
ELSE
  llBatVld         = .F.
ENDIF

IF llBatVld .AND. ((lnTotalDr <> lnTotalCr) .OR.;
    (lnTotalDr = 0 .AND. lnTotalCr = 0)) 

  IF lcBatType='B'

    *** If posting a single beginning balance batch, posting is terminated
    *** if the total debit and total credit do not balance.
    *** If posting other types of batches, lfVld_Summ() handles them. 

    IF llOneRec 
      *** If the beginning balance batch is unbalanced, unlock any locked
      *** files, present the following message, and terminate posting
      *** Message : " Total debit is not equal to total credit for all  "
      ***           " beginning balances batches.Posting  process is    "
      ***           " terminated                                        "
      ***                               < OK >
      =lfTBUnLock()
      
      
      IF llFromReb
        DECLARE laRebMsg[5]
        laRebMsg[1] = " "
        laRebMsg[2] = " Total debit is not equal to total credit for all  "
        laRebMsg[3] = " beginning balances batches.Posting  process is    "
        laRebMsg[4] = " terminated.                                       "
        laRebMsg[5] = " "
        =lfVryRport()
      ELSE
      
        =gfModalGen('TRM02132B00000','Dialog')
      ENDIF
      llBatVld     = .F.
  
    ENDIF 
  ELSE
    IF llNotVoid 
        
      *** If the batch is unbalanced, or both totals are equal to
      *** zero, present the following message and return .F.
      *** Message :    " ð is out of balance.  "
      ***              " ð will not be posted.               "
      ***                       < OK >
      IF llOneRec
        =lfTBUnLock()
      ENDIF  
      
      IF llFromReb
        DECLARE laRebMsg[4]
        laRebMsg[1] = " "
        laRebMsg[2] = "Batch No. "+GLBATCH.cBatchNo+" is out of balance."
        *N000682,1 12/14/12 TMI Globlization changes[Start] 
        *laRebMsg[3] = "Batch No. "+GLBATCH.cBatchNo+" will not be posted."
        laRebMsg[3] = "Batch No. "+GLBATCH.cBatchNo+" will not be posted."
        *N000682,1 12/14/12 TMI Globlization changes[End  ] 
        laRebMsg[4] = " "
       =lfVryRport()
      ELSE 
      
        *N000682,1 12/26/12 TMI Globlization changes[Start] 
        *=gfModalGen("TRM02143B00000","Dialog",;
                  "Batch No. " + GLBATCH.cBatchNo+"|"+;
                  "Batch No. " + GLBATCH.cBatchNo)
        =gfModalGen("TRM02143B00000","Dialog",;
                  lcLANG_Batch_No +' '+ GLBATCH.cBatchNo+"|"+;
                  lcLANG_Batch_No +' '+ GLBATCH.cBatchNo)                  
        *N000682,1 12/26/12 TMI Globlization changes[End  ] 
      ENDIF
      llBatVld   = .F.    
    ENDIF
  ENDIF  
ENDIF

RETURN llBatVld           


*!**************************************************************************
*!
*!      Function : lfVld_Summ
*!
*!**************************************************************************
*
FUNCTION lfVld_Summ
*** Save current work area


lcCurArea          = ALIAS()


*** If posting transaction(s), zap all the data in the
*** Summarize_entries (lc_SumEnt1) file, if any, to be ready
*** for the new entries, as well as the data in the accounts
*** replacement file (lc_ActRepl)
IF lcTrOrBat='T'
  SELECT (lc_SumEnt1)
  ZAP
  
  SELECT (lc_ActRepl)
  ZAP
  
  SELECT (lcCurArea)
ENDIF  

*** Check that the current transaction has corresponding entries
*** If posting 'T'ransactions, although saving an empty transaction 
*** is prohibited by other programs, this check is just for safety.
IF EOF('GLTRNSDT') 
  *** If the transaction has no entries, present the following message
  *** Message : "     ð No. ð has no entries.  ð.     "
  ***                               < OK > 
  *** If posting beginning balances batches, terminate posting, 
  *** and aunlock any locked files. 
  IF lcBatType = 'B'
    =lfTBUnLock()
  ENDIF  
  
  IF llFromReb
    DECLARE laRebMsg[4]
    laRebMsg[1] = " "
    laRebMsg[2] = "Transaction No. "+ALLTRIM(GLTRNSHD.cTranNo)+IIF(lcTrOrBat = 'B'," of Batch No. "+ALLTRIM(GLTRNSHD.cBatchNo),"")+" has no entries."
    *N000682,1 12/14/12 TMI Globlization changes[Start] 
    *laRebMsg[3] =  IIF(lcTrOrBat='T','Transaction No. '+ ALLTRIM(GLTRNSHD.cTranNo)+' will not be posted',;
                   IIF(lcBatType = 'B','Posting process is terminated','Batch No. '+ ALLTRIM(GLTRNSHD.cBatchNo)+' will not be posted'))
    laRebMsg[3] =  IIF(lcTrOrBat='T','Transaction No. '+ ALLTRIM(GLTRNSHD.cTranNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED,;
                   IIF(lcBatType = 'B','Posting process is terminated','Batch No. '+ ALLTRIM(GLTRNSHD.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED))
    *N000682,1 12/14/12 TMI Globlization changes[End  ] 
    laRebMsg[4] = " "
    =lfVryRport()
  ELSE
  
    *N000682,1 12/14/12 TMI Globlization changes[Start] 
    *=gfModalGen('TRM02131B00000','Dialog',;
                'Transaction'+'|'+ALLTRIM(GLTRNSHD.cTranNo)+;
                IIF(lcTrOrBat = 'B'," of Batch No. "+ALLTRIM(GLTRNSHD.cBatchNo),"")+;
                '|'+;
                IIF(lcTrOrBat = 'T','Transaction No. '+ ALLTRIM(GLTRNSHD.cTranNo)+;
                ' will not be posted',;
                IIF(lcBatType = 'B','Posting process is terminated',;
                'Batch No. '+ ALLTRIM(GLTRNSHD.cBatchNo)+' will not be posted')))
    =gfModalGen('TRM02131B00000','Dialog',;
                'Transaction'+'|'+ALLTRIM(GLTRNSHD.cTranNo)+;
                IIF(lcTrOrBat = 'B',lcLANG_of_Batch_No+" "+ALLTRIM(GLTRNSHD.cBatchNo),"")+;
                '|'+;
                IIF(lcTrOrBat = 'T',lcLANG_Transaction_No+' '+ ALLTRIM(GLTRNSHD.cTranNo)+;
                lcLANG_GLTPOST_WILL_NOT_BE_POSTED,;
                IIF(lcBatType = 'B',lcLANG_Posting_process_is_terminated,;
                lcLANG_Batch_No+' '+ ALLTRIM(GLTRNSHD.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED)))
    *N000682,1 12/14/12 TMI Globlization changes[End  ]                 
  ENDIF 
  RETURN .F.
ENDIF  

   
*** Set return flag 
llTransVld         = .T.

*** Condsidering that the record pointer in the GLTRNSHD is pointing
*** to the correct transaction, then just selecting GLTRNSDT work
*** area also points to the first entry belonging to this transaction
*** with the rest of its entries following, hence,

lcBatchNo          = GLTRNSHD.cBatchNo
lcTranNo           = GLTRNSHD.cTranNo

SELECT GLTRNSDT

DO CASE
  
  *** Case validating transactions belonging to beginning balances 
  *** batch(es)
  CASE lcBatType='B'
    
    *** Scan all entries belonging to this transaction
    SCAN REST WHILE &lcTrnsDtEx. = lcBatchNo + lcTranNo
    
      *** 1. Check if the transaction date falls within the begin
      ***    and end date of the batch
      IF !BETWEEN(GLTRNSDT.dTrnPDate,;
            GLBATCH.dBatPBeg,GLBATCH.dBatPEnd)
        *** If the transaction date is out ot the batch window
        *** (start date, end date), present the following message,
        *** exit from the loop and return  .F. 
        *** Message : "   Transaction No. ð's date is out of batch No.  "
        ***           "            ð's posting window. ð.            "
        ***                          < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = "Transaction No. "+GLTRNSHD.cTranNo+"'s date is out of batch No. " 
          laRebMsg[3] = GLTRNSHD.cBatchNo+" 's posting window."
          laRebMsg[4] = " Posting process is terminated"
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02150B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+GLTRNSHD.cBatchNo+'|'+;
                       'Posting process is terminated')
          =gfModalGen("TRM02150B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+GLTRNSHD.cBatchNo+'|'+;
                       lcLANG_Posting_process_is_terminated)
          *N000682,1 12/26/12 TMI Globlization changes[End  ]                        
        ENDIF
        llTransVld = .F.
        EXIT
      ENDIF   
      
      
      *** 2. Check that the posting year and period exist in the
      ***    fiscal periods file (SYCFSPRD.DBF)
      
      IF EOF('FSPRD')
    
        *** If the posting year and period are not found in the 
        *** file, present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Period ð is not found in the fiscal
        ***           "    year details. ð.
        ***                              < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = "Period "+GLTRNSDT.cTrnpPrd+"-"+GLTRNSDT.cTrnpYr+ " is not found in the fiscal "
          laRebMsg[3] = "year details."
          laRebMsg[4] = "Posting process is terminated "
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02135B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       'Posting process is terminated')
          =gfModalGen("TRM02135B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       lcLANG_Posting_process_is_terminated)
          *N000682,1 12/26/12 TMI Globlization changes[End  ] 
        ENDIF
        llTransVld = .F.
        EXIT
      ELSE
        *** If they exist, check that the transaction date
        *** falls in the transaction's year/period.
        
        IF !BETWEEN(GLTRNSDT.dTrnPDate,;
            FSPRD.dFspPBgDt,FSPRD.dFspPEnDt) 
            
          *** If it does not fall in the specified period, present
          *** the following message, exit from the loop and 
          *** return .F.
          *** Message : " Transaction No. ð's posting date does not " 
          ***           "  fall in its posting period ð. ð.     " 
          ***                       < OK >    
          =lfTBUnLock()
          
          IF llFromReb
            DECLARE laRebMsg[5]
            laRebMsg[1] = " "
            laRebMsg[2] = " Transaction No. "+GLTRNSDT.cTranNo+ " 's posting date does not "
            laRebMsg[3] = " fall in its posting period "+GLTRNSDT.cTrnpPrd+"-"+GLTRNSDT.cTrnpYr
            laRebMsg[4] = " Posting process is terminated "
            laRebMsg[5] = " "
            =lfVryRport()
          ELSE        
          
            *N000682,1 12/26/12 TMI Globlization changes[Start] 
            *=gfModalGen("TRM02201B00000","Dialog",;
                         GLTRNSDT.cTranNo + '|'+;
                         GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                         'Posting process is terminated')
            =gfModalGen("TRM02201B00000","Dialog",;
                         GLTRNSDT.cTranNo + '|'+;
                         GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                         lcLANG_Posting_process_is_terminated)
            *N000682,1 12/26/12 TMI Globlization changes[End  ] 
          ENDIF               
          llTransVld = .F.
          EXIT
        ENDIF   
      ENDIF  
  
      *** 3. Check if the year of the transaction is within the
      ***    posting window
      IF !BETWEEN(GLTRNSDT.cTrnPYr,lcPrev_Yer,lcNext_Yer)
        *** If it is not,present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Transaction No. ð's date is   "
        ***           "    out of the posting window. ð."
        ***                              < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Transaction No."+ GLTRNSHD.cTranNo + "'s date is   "
          laRebMsg[3] = " out of the posting window. "
          laRebMsg[4] = " Posting process is terminated. "
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02151B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+;
                       'Posting process is terminated')
          =gfModalGen("TRM02151B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+;
                       lcLANG_Posting_process_is_terminated)
          *N000682,1 12/26/12 TMI Globlization changes[End  ] 
        ENDIF               
        llTransVld = .F.
        EXIT
      ENDIF   
 
      *** 4. check if the date of the transaction is before the beginning  
      ***    balance date if that is not allowed in the GL setup.
      ***    GLSETUP.lSetPBBBd = .T. if posting is allowed before the
      ***                        beginning balance date
      IF GLTRNSDT.dTrnPDate < GLSETUP.dSetBBDat; 
         .AND. !GLSETUP.lSetPBBBD
        *** If the transaction date is before the beginning balance
        *** date, not being allowed from the GL setup,
        *** present the following message, and return with .F.
        ***  Message :    " Transaction No. ð's posting date falls     "
        ***               " before the beginning balance date. ð. "
        ***                           < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Transaction No. " +  GLTRNSHD.cTranNo + "'s posting date falls     "
          laRebMsg[3] = " before the beginning balance date."
          laRebMsg[4] = " Posting process is terminated. "
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *=gfModalGen('TRM02133B00000','Dialog',;
                       GLTRNSHD.cTranNo+'|'+'Posting process is terminated' )
          =gfModalGen('TRM02133B00000','Dialog',;
                       GLTRNSHD.cTranNo+'|'+lcLANG_Posting_process_is_terminated )
          *N000682,1 12/26/12 TMI Globlization changes[End  ]                        
        ENDIF               
        llTransVld = .F.
        EXIT
       ENDIF             
         
      *** 5. Check that the current account in this entry is found
      ***    in the chart of accounts file.
      IF EOF(lc_AcChar)
        *** If account is not found in the chart of accounts
        *** file, present the following message, exit from the loop 
        *** and return .F. 
         *** Message : "    Transaction No. ð includes account ð which is "
         ***           "    not found in the chart of accouts file.       "      
         ***           "    Posting process is terminated.                "
         ***                               < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Transaction No. "+GLTRNSHD.cTranNo+ " includes account "+ALLTRIM(GLTRNSDT.cAcctCode)+" which is "
          laRebMsg[3] = " not found in the chart of accouts file.       "
          laRebMsg[4] = " Posting process is terminated.                "
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE    
        
          =gfModalGen("TRM02136B00000","Dialog",;
                      GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode))  
        ENDIF              
        llTransVld = .F.
        EXIT
      ELSE
      
        *** Check that the current account is an active one.  
        IF &lc_AcChar..cSegActiv ='I'
          *** If account is inactive ('I') present the following message,
          *** exit from the loop and return .F. 
          *** Message : "    Transaction No. ð has account ð which is  "
          ***           "    inactive. Posting process is terminated   " 
          ***                               < OK >
          =lfTBUnLock()
          
          IF llFromReb
            DECLARE laRebMsg[4]
            laRebMsg[1] = " "
            laRebMsg[2] = " Transaction No. " + GLTRNSHD.cTranNo + " has account " + ALLTRIM(GLTRNSDT.cAcctCode) + " which is "
            laRebMsg[3] = " inactive. Posting process is terminated."
            laRebMsg[4] = " "
            =lfVryRport()
          ELSE 
          
            =gfModalGen("TRM02139B00000","Dialog",;
                         GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode))
          ENDIF              
          llTransVld = .F.
          EXIT
        ENDIF   
      
        *** Check that the current account is allowed for posting.
        *Prevent posting only when the transaction origrinated in GL
         IF &lc_AcChar..cSegAlPos ='N' AND GLTRNSHD.cSrcModul = "GL"
           *** If account is not allowed for posting ('N') present the 
           *** following message, exit from the loop and return .F. 
           *** Message : "    Transaction No. ð includes account ð which is "
           ***           "    not allowed for posting from the GL.          "
           ***           "    Posting process is terminated                 "
           ***                               < OK >
           =lfTBUnLock()
           
           IF llFromReb
             DECLARE laRebMsg[5]
             laRebMsg[1] = " "
             laRebMsg[2] = " Transaction No. " + GLTRNSDT.cTranNo + " includes account " + ALLTRIM(GLTRNSDT.cAcctCode) + " which is "
             laRebMsg[3] = " not allowed for posting from the GL. "
             laRebMsg[4] = " Posting process is terminated                 "
             laRebMsg[5] = " "
             =lfVryRport()
           ELSE
           
             =gfModalGen("TRM02141B00000","Dialog",;
                          GLTRNSDT.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode))
           ENDIF              
           llTransVld = .F.
           EXIT
         ENDIF   
       ENDIF
      
      *** 6. Check that the current account code, year and period exist 
      ***    in the balances file (GLACBALS.DBF), alias (lc_AcBals)
      IF EOF(lc_AcBals)
        *** If the current account code,year and period are not found in 
        *** the file, present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Period ð for account code ð is not     "
        ***           "    found in the balances file. ð.         "
        ***                              < OK >
        =lfTBUnLock()
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Period " +GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+" for account code "+ALLTRIM(GLTRNSDT.cAcctCode)+" is not "
          laRebMsg[3] = " found in the balances file. "
          laRebMsg[4] = " Posting process is terminated."
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02138B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                       'Posting process is terminated')
          =gfModalGen("TRM02138B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                       lcLANG_Posting_process_is_terminated)
          *N000682,1 12/26/12 TMI Globlization changes[End  ] 
        ENDIF
        llTransVld = .F.
        EXIT
      ENDIF   

      *** If all the previous checks are passed successfully,
      *** update total debit and total credit values.
      
      IF GLTRNSDT.cDrOrCr = 'D'
        lnTotalDr = lnTotalDr + GLTRNSDT.nAmount
      ELSE 
        lnTotalCr = lnTotalCr + GLTRNSDT.nAmount        
      ENDIF

      *** Then call the update summarize_entries function

      =lfUpd_Summ(.F.)
    ENDSCAN
    
  *** Case validating transactions belonging to any other type whether
  *** - Single or multiple transactions.
  *** - Single non beginning, or closing balance batches    
  OTHERWISE                                

    *** Scan all entries belonging to this transaction
    SCAN REST WHILE &lcTrnsDtEx. = lcBatchNo + lcTranNo
    
      *** Update total debit and total credit values.
      IF GLTRNSDT.cDrOrCr = 'D'
        lnTotalDr = lnTotalDr + GLTRNSDT.nAmount
      ELSE
        lnTotalCr = lnTotalCr + GLTRNSDT.nAmount        
      ENDIF
 
      *** 1. If posting batches, check if the transaction date 
      ***    falls within the begin and end date of the batch
      IF lcTrOrBat='B' .AND. !BETWEEN(GLTRNSDT.dTrnPDate,;
            GLBATCH.dBatPBeg,GLBATCH.dBatPEnd)
        *** If the transaction date is out ot the batch window
        *** (start date, end date), present the following message,
        *** exit from the loop and return  .F. 
        *** Message : "   Transaction No. ð's date is out of batch No.  "
        ***           "            ð's posting window. ð.            "
        ***                          < OK >
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Transaction No. "+GLTRNSHD.cTranNo+ "'s date is out of batch No. "
          laRebMsg[3] = GLTRNSHD.cBatchNo+" 's posting window."
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *laRebMsg[4] = 'Batch No. '+GLTRNSHD.cBatchNo+ ' will not be posted'
          laRebMsg[4] = 'Batch No. '+GLTRNSHD.cBatchNo+ lcLANG_GLTPOST_WILL_NOT_BE_POSTED
          *N000682,1 12/14/12 TMI Globlization changes[End  ] 
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE 
        
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02150B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+GLTRNSHD.cBatchNo+'|'+;
                       'Batch No. '+GLTRNSHD.cBatchNo+ ' will not be posted')
          =gfModalGen("TRM02150B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+GLTRNSHD.cBatchNo+'|'+;
                       lcLANG_Batch_No+' '+GLTRNSHD.cBatchNo+ lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
          *N000682,1 12/14/12 TMI Globlization changes[End  ]                        
        ENDIF
        llTransVld = .F.
        EXIT
      ENDIF   
      
      *** 2. Check that the posting year and period exist in the
      ***    fiscal periods file (SYCFSPRD.DBF)

      IF EOF('FSPRD')
        *** If the posting year and period are not found in the 
        *** file, present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Period ð is not found in the fiscal
        ***           "    year details. ð.
        ***                              < OK >
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Period "+GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+ "is not found in the fiscal "
          laRebMsg[3] = " year details."
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *laRebMsg[4] =  IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.'
          laRebMsg[4] =  IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.'
          *N000682,1 12/14/12 TMI Globlization changes[End  ] 
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE 
        
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02135B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,;
                       'Batch No. ' + GLTRNSHD.cBatchNo)+;
                       ' will not be posted') 
          =gfModalGen("TRM02135B00000","Dialog",;
                       GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                       IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+ GLTRNSHD.cTranNo,;
                       lcLANG_Batch_No+' ' + GLTRNSHD.cBatchNo)+;
                       lcLANG_GLTPOST_WILL_NOT_BE_POSTED) 
          *N000682,1 12/14/12 TMI Globlization changes[End  ]                        
        ENDIF
                  
        llTransVld = .F.
        EXIT
      ELSE
        *** If they exist , check that the transaction date
        *** falls in the transaction's period-year.
        
        IF !BETWEEN(GLTRNSDT.dTrnPDate,;
            FSPRD.dFspPBgDt,FSPRD.dFspPEnDt) 
            
          *** If it does not fall in the specified period, present
          *** the following message, exit from the loop and 
          *** return .F.
          *** Message : " Transaction No. ð 's posting date does not fall  " 
          ***           "    in its posting period ð. ð.      " 
          ***                       < OK >    
          =lfTBUnLock()
          
          IF llFromReb
            DECLARE laRebMsg[5]
            laRebMsg[1] = " "
            laRebMsg[2] = " Transaction No. "+GLTRNSHD.cTranNo+" 's posting date does not fall  "
            laRebMsg[3] = " in its posting period "+GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr
            *N000682,1 12/14/12 TMI Globlization changes[Start] 
            *laRebMsg[4] = IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.' 
            laRebMsg[4] = IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.' 
            *N000682,1 12/14/12 TMI Globlization changes[End  ] 
            laRebMsg[5] = " "
            =lfVryRport()
          ELSE
          
            *N000682,1 12/14/12 TMI Globlization changes[Start] 
            *=gfModalGen("TRM02201B00000","Dialog",;
                         GLTRNSHD.cTranNo + '|'+;
                         GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                         IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,;
                         'Batch No. ' + GLTRNSHD.cBatchNo)+;
                         ' will not be posted') 
            =gfModalGen("TRM02201B00000","Dialog",;
                         GLTRNSHD.cTranNo + '|'+;
                         GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                         IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+ GLTRNSHD.cTranNo,;
                         lcLANG_Batch_No+' ' + GLTRNSHD.cBatchNo)+;
                         lcLANG_GLTPOST_WILL_NOT_BE_POSTED) 
            *N000682,1 12/14/12 TMI Globlization changes[End  ]                          
          ENDIF
          llTransVld = .F.
          EXIT
        ELSE

          *** If it is, check if the period-year is locked.
          *** SYCFSPRD.lFspLocks is .T. if the period is locked :
          IF FSPRD.lFspLocks
        
            *** If the period is locked, present the following message,
            *** exit from the loop and return .F.
            *** Message   : "     Period ð is locked. You cannot post   "
            ***             "     any transactions to this period.      "
            ***             "     Transaction No. ð's posting date falls      "
            ***             "     in this period. ð.                    "
            ***                        < OK >
            IF llOneRec
              =lfTBUnLock()
            ENDIF  
            
            IF llFromReb
              DECLARE laRebMsg[7]
              laRebMsg[1] = " "
              laRebMsg[2] = " Period "+GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+" is locked. You cannot post   "
              laRebMsg[3] = " any transactions to this period.      "
              laRebMsg[4] = " Transaction No. "+ GLTRNSDT.cTranNo +"'s posting date falls"
              laRebMsg[5] = " in this period."
              *N000682,1 12/14/12 TMI Globlization changes[Start] 
              *laRebMsg[6] = IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.' 
              laRebMsg[6] = IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,'Batch No. ' + GLTRNSHD.cBatchNo)+' will not be posted.' 
              *N000682,1 12/14/12 TMI Globlization changes[End  ] 
              laRebMsg[7] = " "
              =lfVryRport()
            ELSE 
            
              *N000682,1 12/14/12 TMI Globlization changes[Start] 
              *=gfModalGen("TRM02134B00000","Dialog",;
                           GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                           GLTRNSDT.cTranNo+'|'+;
                           IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,;
                           'Batch No. ' + GLTRNSHD.cBatchNo)+;
                           ' will not be posted') 
              =gfModalGen("TRM02134B00000","Dialog",;
                           GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                           GLTRNSDT.cTranNo+'|'+;
                           IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+ GLTRNSHD.cTranNo,;
                           lcLANG_Batch_No+' ' + GLTRNSHD.cBatchNo)+;
                           lcLANG_GLTPOST_WILL_NOT_BE_POSTED) 
              *N000682,1 12/14/12 TMI Globlization changes[End  ]                            
            ENDIF
            llTransVld = .F.
            EXIT
          ENDIF 
        ENDIF  
      ENDIF   
 
      *** 3. Check if the year of the transaction is within the
      ***    posting window
      IF !BETWEEN(GLTRNSDT.cTrnPYr,lcPrev_Yer,lcNext_Yer)
        *** If it is not,present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Transaction No. ð's date is   "
        ***           "    out of the posting window. ð."
        ***                              < OK >
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        
        IF llFromReb
          DECLARE laRebMsg[5]
          laRebMsg[1] = " "
          laRebMsg[2] = " Transaction No. "+GLTRNSHD.cTranNo+"'s date is  "
          laRebMsg[3] = " out of the posting window.                      "
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *laRebMsg[4] = IIF(lcTrOrBat='T','Transaction No. ' + GLTRNSHD.cTranNo,'Batch No. '+ GLTRNSHD.cBatchNo)+' will not be posted.'
          laRebMsg[4] = IIF(lcTrOrBat='T','Transaction No. ' + GLTRNSHD.cTranNo,'Batch No. '+ GLTRNSHD.cBatchNo)+' will not be posted.'
          *N000682,1 12/14/12 TMI Globlization changes[End  ] 
          laRebMsg[5] = " "
          =lfVryRport()
        ELSE
        
          *N000682,1 12/14/12 TMI Globlization changes[Start] 
          *=gfModalGen("TRM02151B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+;
                       IIF(lcTrOrBat='T',;
                       'Transaction No. ' + GLTRNSHD.cTranNo,;
                       'Batch No. '+ GLTRNSHD.cBatchNo)+;
                       ' will not be posted')
          =gfModalGen("TRM02151B00000","Dialog",;
                       GLTRNSHD.cTranNo+'|'+;
                       IIF(lcTrOrBat='T',;
                       lcLANG_Transaction_No+' ' + GLTRNSHD.cTranNo,;
                       lcLANG_Batch_No+' '+ GLTRNSHD.cBatchNo)+;
                       lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
          *N000682,1 12/14/12 TMI Globlization changes[End  ]                        
        ENDIF
        llTransVld = .F.
        EXIT
      ENDIF   
 
      *** 4. Check if the date of the transaction is before the beginning  
      ***    balance date if that is not allowed in the GL setup.
      *** GLSETUP.lSetPBBBd = .T. if posting is allowed before the
      ***                     beginning balance date
      IF GLTRNSDT.dTrnPDate < GLSETUP.dSetBBDat; 
         .AND. !GLSETUP.lSetPBBBD
        *** If the transaction date is before the beginning balance
        *** date, not being allowed from the GL setup,
        *** present the following message, and return with .F.
        ***  Message :    " Transaction No. ð's posting date falls     "
        ***               " before the beginning balance date. ð. "
        ***                           < OK >
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        *N000682,1 12/14/12 TMI Globlization changes[Start] 
        *=gfModalGen('TRM02133B00000','Dialog',;
              GLTRNSHD.cTranNo+'|'+;
               IIF(lcTrOrBat='T','Transaction No. '+GLTRNSHD.cTranNo,;
               'Batch No. '+GLTRNSHD.cBatchNo)+' will not be posted')
        =gfModalGen('TRM02133B00000','Dialog',;
              GLTRNSHD.cTranNo+'|'+;
               IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+GLTRNSHD.cTranNo,;
               lcLANG_Batch_No+' '+GLTRNSHD.cBatchNo)+lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
        *N000682,1 12/14/12 TMI Globlization changes[End  ]                
        llTransVld = .F.
        EXIT
      ENDIF             
  
      
      *** 5. Check that the current account in this entry is found
      ***    in the chart of accounts file.
      IF EOF(lc_AcChar)
        *** If account is not found in the chart of accounts
        *** file, present the following message, If the user 
        *** chooses to , exit from the loop and return .F. 
        *** Message : "    Account ð is not found in the chart of    "
        ***           "    accounts file. Do you wish to post to the  "
        ***           "    suspense account, or skip posting ð ?   "
        ***                        < Post >   < Skip >       
        *N000682,1 12/26/12 TMI Globlization changes[Start] 
        *IF gfModalGen("QRM02137B02017","Dialog",;
               ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
               IIF(lcTrOrBat='T','transaction No. '+GLTRNSHD.cTranNo,;
               'batch No. '+GLTRNSHD.cBatchNo))= 1
        IF gfModalGen("QRM02137B02017","Dialog",;
               ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
               IIF(lcTrOrBat='T',lcLANG_transaction_No+' '+GLTRNSHD.cTranNo,;
               lcLANG_batch_No+' '+GLTRNSHD.cBatchNo))= 1
          *N000682,1 12/26/12 TMI Globlization changes[End  ]  
          *** If the user selects 'Post' (return of message = 1) 
          *** call suspense account function
          =lfSusAcUpd()
          LOOP
          
        *** If the user selects 'Skip', exit the loop, 
        *** and return .F.
        ELSE   
          llTransVld = .F.
          EXIT
        ENDIF
      ELSE
      
        *** Check that the current account is an active one.  
        IF &lc_AcChar..cSegActiv ='I'
          *** If account is inactive ('I') present the following message,
          *** Message : "    Transaction No. ð includes account ð which is "
          ***           "    inactive. Do you wish to post to the          "
          ***           "    suspense account or skip posting ð ? " 
          ***                         < Post >   < Skip >      
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *IF gfModalGen("QRM02140B02017","Dialog",;
                 GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                 IIF(lcTrOrBat='T','transaction No. '+GLTRNSHD.cTranNo,;
                 'batch No. '+GLTRNSHD.cBatchNo))= 1
          IF gfModalGen("QRM02140B02017","Dialog",;
                 GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                 IIF(lcTrOrBat='T',lcLANG_transaction_No+' '+GLTRNSHD.cTranNo,;
                 lcLANG_batch_No+' '+GLTRNSHD.cBatchNo))= 1
             *N000682,1 12/26/12 TMI Globlization changes[End  ] 
          
            *** If the user selects 'Post' (return of message = 1) 
            *** call suspense account function
            =lfSusAcUpd()
            LOOP
          
          *** If the user selects 'Skip', exit the loop, 
          *** and return .F.
          ELSE   
            llTransVld = .F.
            EXIT
          ENDIF
        ENDIF   
      
        ***  Check that the current account is allowed for posting.
	    *Prevent posting only when the transaction origrinated in GL
        IF &lc_AcChar..cSegAlPos ='N' AND GLTRNSHD.cSrcModul = "GL"
          *** If account is not allowed for posting ('N') present the 
          *** following message
          *** Message : "    Transaction No. ð includes account ð which is  "
          ***           "    not allowed for posting from the GL.      "  
          ***           "    Do you wish to post to the suspense       "
          ***           "    account or skip posting ð ?          " 
          ***                         < Post >   < Skip >      
          *N000682,1 12/26/12 TMI Globlization changes[Start] 
          *IF gfModalGen("QRM02142B02017","Dialog",;
                 GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                 IIF(lcTrOrBat='T','transaction No. '+GLTRNSHD.cTranNo,;
                 'batch No. '+GLTRNSHD.cBatchNo))= 1
          IF gfModalGen("QRM02142B02017","Dialog",;
                 GLTRNSHD.cTranNo+'|'+ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                 IIF(lcTrOrBat='T',lcLANG_transaction_No+' '+GLTRNSHD.cTranNo,;
                 lcLANG_batch_No+' '+GLTRNSHD.cBatchNo))= 1
            *N000682,1 12/26/12 TMI Globlization changes[End  ] 
            *** If the user selects 'Post' (return of message = 1) 
            *** call suspense account function
            =lfSusAcUpd()
            LOOP
          
          *** If the user selects 'Skip', exit the loop, 
          *** and return .F.
          ELSE   
            llTransVld = .F.
            EXIT
          ENDIF
        ENDIF   
      ENDIF
      
      *** 6. Check that the current account code, year and period exist 
      ***    in the balances file (GLACBALS.DBF) alias (lc_AcBals)
      IF EOF(lc_AcBals)
        *** If the current account code,year and period are not found in 
        *** the file, present the following message, exit from the loop
        *** and return .F.
        *** Message : "    Period ð for account code ð  "
        ***           "    is not found in the balances file. ð.  "
        ***                              < OK >
        *N000682,1 12/14/12 TMI Globlization changes[Start] 
        *=gfModalGen("TRM02138B00000","Dialog",;
                     GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                     ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                     IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,;
                              'Batch No. ' + GLTRNSHD.cBatchNo)+;
                              ' will not be posted') 
        =gfModalGen("TRM02138B00000","Dialog",;
                     GLTRNSDT.cTrnpPrd+'-'+GLTRNSDT.cTrnpYr+'|'+;
                     ALLTRIM(GLTRNSDT.cAcctCode)+'|'+;
                     IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+ GLTRNSHD.cTranNo,;
                              lcLANG_Batch_No+' ' + GLTRNSHD.cBatchNo)+;
                              lcLANG_GLTPOST_WILL_NOT_BE_POSTED)
        *N000682,1 12/14/12 TMI Globlization changes[End  ]                               
        llTransVld = .F.
        
        EXIT
      ENDIF   

      
      *** Then call the update summarize_entries function
      =lfUpd_Summ(.F.)
    ENDSCAN

         
    *** Having passed through the above checks, check if the 
    *** transaction is balanced, or both total debits and creidts
    *** are equal to zeros.
    *** This check is not performed if posting 'S'tatistical batches
    *** since 
    
    IF llTransVld .AND. ;
    ((lcTrOrBat='B' .AND. GLBATCH.cBatType<>'S') .OR.;
    (lcTrOrBat='T' .AND. GLTRNSHD.cStandard='Y'))  
      *Allow posting transactions with a total
      *debit and total credit = 0. 
      *Hence, removed the related check.
      IF lnTotalDr <> lnTotalCr       && 
        *** If transaction is unbalanced, or both totals are equal to
        *** zero, present the following message and return .F.
        *** Message :    " ð is out of balance.  "
        ***              " ð will not be posted.               "
        ***                       < OK >
        IF llOneRec
          =lfTBUnLock()
        ENDIF  
        *N000682,1 12/26/12 TMI Globlization changes[Start] 
        *=gfModalGen("TRM02143B00000","Dialog",;
             "Transaction No. "+GLTRNSHD.cTranNo+'|'+;
              IIF(lcTrOrBat='T','Transaction No. '+ GLTRNSHD.cTranNo,;
                      'Batch No. ' + GLTRNSHD.cBatchNo))
        =gfModalGen("TRM02143B00000","Dialog",;
             lcLANG_Transaction_No+' '+GLTRNSHD.cTranNo+'|'+;
              IIF(lcTrOrBat='T',lcLANG_Transaction_No+' '+ GLTRNSHD.cTranNo,;
                      lcLANG_Batch_No+' ' + GLTRNSHD.cBatchNo))
         *N000682,1 12/26/12 TMI Globlization changes[End  ] 
        llTransVld = .F.    
      ENDIF
   ENDIF   
ENDCASE
                                    
SELECT (lcCurArea)
RETURN llTransVld                            

*!**************************************************************************
*!
*!      Function : lfUpd_Summ
*!
*!**************************************************************************
*
*  This function updates the 'nDrAmount' and 'nCrAmount' fields
*  in existing entries in the Summarize entries file, or appends 
*  a new entry to it if it does not already exist.
*  Parameters   : flag indicating whether updating the amounts
*                 of the current record (.F.), or its corresponding 
*                 suspense account record (.T.)    
*  Requirements : GLTRNSDT file pointer is on the current detail.  
*   
FUNCTION lfUpd_Summ
PARAMETERS llUpd_Sus


*** llUpd_Sus : name of the flag indicating whether to update the amounts
***             of the current record (.F.), or its corresponding 
***             suspense account record (.T.)    

*** If llUpd_Sus is .F.
*** Check if the current 'account code + year + period' of the
*** current entry already exists in the temporary file (lc_SumEnt1)
*** Note that GLTRNSDT is related (parent) to (lc_SumEnt1), 
*** else
*** Search for the 'suspense account value + year + period' of the
*** current record in (lc_SumEnt1)

*** In both cases, if a record is not found, insert a new one,
*** else, update the values of the existing one (the record pointer  
*** of (lc_SumEnt1) should be pointing to it then.

IF (!llUpd_Sus.AND.EOF(lc_SumEnt1)) .OR. ;
   (llUpd_Sus.AND.;
     !SEEK(lcSusActMj+GLTRNSDT.cTrnPYr+GLTRNSDT.cTrnPPrd,lc_SumEnt1))                  
  INSERT INTO (lc_SumEnt1);
  	(cAcctCode,cFisFYear,cFspPrdId,nDrAmount,nCrAmount,llComplete);
     VALUES(IIF(!llUpd_Sus,GLTRNSDT.cAcctCode,lcSusActMj),;
             GLTRNSDT.cTrnPYr,GLTRNSDT.cTrnPPrd,;
     IIF(GLTRNSDT.cDrOrCr='D',GLTRNSDT.nAmount,0),;
     IIF(GLTRNSDT.cDrOrCr='C',GLTRNSDT.nAmount,0),.F.)
ELSE
  *** lnAmount = nAmount of GLTRNSDT multiplied by 1 if it is a 'D'ebit
  ***             or -1 if it is 'Credit' , and added to  
  ***             (nAmount of lc_SummFile multiplied by 1 if it is a 'D'ebit
  ***             or -1 if it is 'Credit' , and added to)  
  *** Store the absolute value of the amount in the temporary file
  *** as well as the 'D'ebit/'C'redit field

  REPLACE &lc_SumEnt1..nDrAmount WITH &lc_SumEnt1..nDrAmount+;
                              IIF(GLTRNSDT.cDrOrCr='D',GLTRNSDT.nAmount,0);
          &lc_SumEnt1..nCrAmount WITH &lc_SumEnt1..nCrAmount+;
                              IIF(GLTRNSDT.cDrOrCr='C',GLTRNSDT.nAmount,0)
      
ENDIF  


*!**************************************************************************
*!
*!      Function : lfSusAcUpd
*!
*!**************************************************************************
*
*   This function updates the Account replacementtemporary file 
*   (lc_ActRepl) with batch, transaction, account to be replaced
*   with the suspense account
*
FUNCTION lfSusAcUpd


*** If current batch no. + transaction no. + account code 
*** does not exist in the accounts replacements file, add
*** a new record into the accounts replacements file with
*** the current batch no. + transaction no. + account code values.
IF EOF(lc_ActRepl)
  INSERT INTO (lc_ActRepl);
      (cBatchNo,cTranNo,cAcctCode);
     VALUES (GLTRNSDT.cBatchNo,GLTRNSDT.cTranNo,GLTRNSDT.cAcctCode )
ENDIF   

*** If the current 'account code + year + period' has been replaced
*** before, update its corresponding entry in the Summarize_Entries1
*** file (lc_SumEnt1), else, add a corresponding entry in (lc_Sument1)
*** This is accomplished by calling the folloeing function with
*** flag .T. 
=lfUpd_Summ(.T.)  
  
*!**************************************************************************
*!
*!      Function : lfPost
*!
*!**************************************************************************
*
*  This function performs the actual posting of amounts to the
*  main files, GLACBALS,GLTRNSHD,GLTRNSDT, and GLBATCH in case
*  of posting batch(es)
*  It also copies all the posted transactions (headers and details), as
*  well as all created year end closing entries posted transactions
*  (header and details) if any to the Posted transactions files
*  GLPTRNHD, GLPTRNDT
*  It returns .T. if the posting is successful.
*
FUNCTION lfPost
PARAMETERS lc_SumEnt

*** lc_SumEnt : is the file name containing the summary of all
***             the entries to be posted.It may be lc_SumEnt1,
***             or lc_SumEnt2 according to the calling function.  


*** Generate a posting session number if one has not already
*** been generated before.
IF EMPTY(lcPostSess)
  *** A new post session number is generated by calling the
  *** global function gfSequence, passing to it an ID : 'PSESSION',
  *** and a default value (1) to be used if no post session numbers
  *** have been created before.
  *** This is then padded with zeroes from the left

  lcPostSess       = gfSequence('CPOSTSESS' , lcAct_Comp)

ENDIF                          

*** If posting batches
*** - update the status fields (GLBATCH.cBatStat),(GLBATCH.cTrnStat),
***   with 'P'ost 
*** - update the posting progress status field (cPostProg) 
***   with 'B'egin posting, indicating that the posting operation 
***   has just begun in GLBATCH and GLTRNSHD files
*** - update the posting user name (cPostUser),the posting date  
***   (dPostDate), the posting time (cPostTime) and the posting
***   session number (cPostSess) fields in both files GLBATCH,
***   and GLTRNSHD     
IF lcTrOrBat = 'B'   
    
  *** single batch,or one of multiple non beginning balance batches  
  IF llOneRec .OR. (lcBatType<>'B')
      
    SELECT GLBATCH
      
    lcBatchNo    = GLBATCH.cBatchNo
    *** Update the current record of the batches file (GLBATCH)
    REPLACE GLBATCH.cBatStat  WITH 'P',;
            GLBATCH.lBatInd   WITH .F.,;
            GLBATCH.cPostSess WITH lcPostSess,;
            GLBATCH.cPostProg WITH 'B',;
            GLBATCH.cPostUser WITH gcUser_ID,;
            GLBATCH.dPostDate WITH ldCurrDate,;
            GLBATCH.cPostTime WITH gfGetTime()

    *** Refresh relation
    IF !EOF()
      GO RECNO()
    ELSE
      GO TOP
    ENDIF
        
    *** Update the corresponding records in the transactions
    *** header file (GLTRNSHD) except those transactions marked
    *** 'V'oid in the status field (GLTRNSHD.cTrnStat)
    SELECT GLTRNSHD
     
    REPLACE REST WHILE &lcTrnsHdEx = lcBatchNo;
             FOR GLTRNSHD.cTrnStat<>'V';
            GLTRNSHD.cTrnStat  WITH 'P',;
            GLTRNSHD.nTrnIndic WITH  0 ,;
            GLTRNSHD.cPostProg WITH 'B',;
            GLTRNSHD.cPostSess WITH lcPostSess,;
            GLTRNSHD.cPostUser WITH gcUser_ID,;
            GLTRNSHD.dPostDate WITH ldCurrDate,;
            GLTRNSHD.cPostTime WITH gfGetTime()

      
  *** if posting multiple beginning balance batches  
  ELSE

    *** Scan all the records of the temporary file,( batch numbers
    *** of the batches approved for posting), updating both GLBATCH,
    *** and GLTRNSHD file at every record. 
    SELECT (lcTempFile)
    GO TOP
    SCAN 

      SELECT GLBATCH
      lcBatchNo    = GLBATCH.cBatchNo
      *** Update the current record of the batches file (GLBATCH)
      REPLACE GLBATCH.cBatStat  WITH 'P',;
              GLBATCH.lBatInd   WITH .F.,;
              GLBATCH.cPostSess WITH lcPostSess,;
              GLBATCH.cPostProg WITH 'B',;
              GLBATCH.cPostUser WITH gcUser_ID,;
              GLBATCH.dPostDate WITH ldCurrDate,;
              GLBATCH.cPostTime WITH gfGetTime()

      SELECT GLTRNSHD
      *** Update the corresponding records in the transactions
      *** header file (GLTRNSHD) except those transactions marked
      *** 'V'oid in the status field (GLTRNSHD.cTrnStat)
      REPLACE REST WHILE GLTRNSHD.cBatchNo=lcBatchNo;
               FOR GLTRNSHD.cTrnStat<>'V';
              GLTRNSHD.cTrnStat  WITH 'P',;
              GLTRNSHD.nTrnIndic WITH  0 ,;              
              GLTRNSHD.cPostProg WITH 'B',;        
              GLTRNSHD.cPostSess WITH lcPostSess,;
              GLTRNSHD.cPostUser WITH gcUser_ID,;
              GLTRNSHD.dPostDate WITH ldCurrDate,;
              GLTRNSHD.cPostTime WITH gfGetTime()

      SELECT (lcTempFile)  
      
    ENDSCAN  
  ENDIF
  
*** If posting single, or one of multiple transactions
ELSE        
  
  *** Update the current record in the transactions header
  *** file (GLTRNSHD) 
  *** - update the status field (GLBATCH.cTrnStat) with 'P'ost 
  *** - update the posting user name (cPostUser),the posting date  
  ***   (dPostDate), the posting time (cPostTime) and the posting
  ***   session number (cPostSess) fields      

  SELECT GLTRNSHD
  REPLACE GLTRNSHD.cTrnStat  WITH 'P',;
          GLTRNSHD.nTrnIndic WITH  0 ,;
          GLTRNSHD.cPostSess WITH lcPostSess,;
          GLTRNSHD.cPostProg WITH 'B',;
          GLTRNSHD.cPostUser WITH gcUser_ID,;
          GLTRNSHD.dPostDate WITH ldCurrDate,;
          GLTRNSHD.cPostTime WITH gfGetTime()

ENDIF    
             
*** If account replacement file (lc_ActRepl) has records, replace
*** the account code field of GLTRNSDT file related to every corresponding 
*** record in lc_ActRepl file with the suspense account code, its 
*** value is already stored in variable lcSusActMj
IF RECCOUNT(lc_ActRepl) > 0 
  SELECT GLTRNSDT
  REPLACE ALL FOR !EOF(lc_ActRepl);
        GLTRNSDT.cAcctCode WITH lcSusActMj           
ENDIF             
  
*** Start updating the balances file (GLACBALS.DBF)
  
*** Scan all the records in the Summarized_Entries file for

SELECT (lc_SumEnt)
SCAN
  *** Get the current account code
  lcAcctCode     = &lc_SumEnt..cAcctCode
    
  *** Make a backup of all the records in the balances file
  *** (GLACBALS) that belong to this account for the three
  *** years of the posting window.
  SELECT * FROM &lcDataDir.GLACBALS;
  WHERE &lcAcBalsEx.= lcAcctCode;
    .AND. cFisfYear IN (lcPrev_Yer,lcCurr_Yer,lcNext_Yer);
  INTO DBF &gcWorkDir.&lc_TmpBals    
    
  SELECT (lc_SumEnt)
    
  *** Call the update balance file function to update this record
  =lfUpd_Bal(lc_SumEnt,'GLACBALS')
    
  *** Check for the previous years income statement entries 
  *** in the following case :
  *** - the account year in lc_SumEnt of the current record
  ***   is the previous fiscal year
  ***   .AND.
  *** - if posting transcation(s), or batch(es) with type 
  ***   'N'ormal,sub'L'edger or 'B'eginning balance according 
  ***   to the value stored in GLBATCH.cBatType
  ***  .AND.
  *** - the account type of an account belonging to the above
  ***   subset of transactions is in any of the following types :
  ***   'E'xpence,other 'I'ncome,'S'ales,'T'axes, and 'C'ost of
  ***   sales.

  IF (&lc_SumEnt..cFisfYear=lcPrev_Yer) ;
     .AND. (lcTrOrBat='T' .OR. GLBATCH.cBatType $ 'NBL');
      .AND. (LEFT(GLACCHAR.cTypeCode,1) $ 'EISTC')
        
    *** Call the function that handles previous year income
    *** statement entries
    =lfUpd_Cls(lc_SumEnt)    
  ENDIF    
        
  *** Update the llComplete field of lc_SumEnt with .T. 
  *** indicating that posting of this record is completed
  REPLACE &lc_SumEnt..llComplete WITH .T.
    
ENDSCAN
  
*** Set the posting progress field to 'E'nd posting
*** as the posting process has been succesful.
  
*** If posting batch(es)
IF lcTrOrBat = 'B'
    
  *** If posting a single batch or one of multiple non 
  *** beginning batches
  IF llOneRec .OR. lcBatType <> 'B'
       
    SELECT GLBATCH
    *** Refresh relation
    IF !EOF()
      GO RECNO()
    ELSE
      GO TOP
    ENDIF    

    *** Assuming that the record pointer in the batches
    *** file has not changed :
    lcBatchNo   = GLBATCH.cBatchNo
       
    REPLACE GLBATCH.cPostProg WITH 'E'
       
    SELECT GLTRNSHD
     
    SCAN REST WHILE &lcTrnsHdEx. = lcBatchNo;
                   FOR GLTRNSHD.cTrnStat<>'V'
      lcTranNo     = GLTRNSHD.cTranNo
       
      REPLACE GLTRNSHD.cPostProg WITH 'E'
       
      *** Copy the current transaction header to the posted transactions
      *** header file
      SCATTER MEMVAR
      INSERT INTO GLPTRNHD FROM MEMVAR
      SELECT GLTRNSDT   
      *** Copy the details of the current transaction to the posted 
      *** transactions details file
      SCAN REST WHILE &lcTrnsDtEx. = lcBatchNo+lcTranNo
     
        SCATTER MEMVAR
        *C200958,1 NNA 03/05/2008 (BEGIN) Trigger to get Apdist.cinvno and Apdist.cvendcode and save then in GLPTRNDT table
        IF ASCAN(loFormSet.laEvntTrig,PADR('GLPTRNDT',10))<>0
          =gfDoTriger(lcProgName,PADR('GLPTRNDT',10))
        ENDIF
        *C200958,1 NNA (END)
        
        INSERT INTO GLPTRNDT FROM MEMVAR
      ENDSCAN
         
      SELECT GLTRNSHD
    ENDSCAN  
  *** if posting multiple beginning balance batches
  ELSE   
      
    *** Scan all batches in the temporary file (lcTempFile)
    *** and update their related records in GLBATCH.DBF (same
    *** batch number) with cPostProg = 'E'nd posting in 
    *** GLBATCH and GLTRNSHD files
      
    SELECT (lcTempFile)
    GO TOP
    SCAN
      SELECT GLBATCH
      lcBatchNo  = GLBATCH.cBatchNo
      REPLACE GLBATCH.cPostProg WITH 'E'

      SELECT GLTRNSHD

      SCAN REST WHILE &lcTrnsHdEx. = lcBatchNo;
                 FOR GLTRNSHD.cTrnStat<>'V'
        lcTranNo     = GLTRNSHD.cTranNo
       
        REPLACE GLTRNSHD.cPostProg WITH 'E'
       
        *** Copy the current transaction header to the posted transactions
        *** header file
        SCATTER MEMVAR
        INSERT INTO GLPTRNHD FROM MEMVAR
       
        SELECT GLTRNSDT   
       
        *** Copy the details of the current transaction to the posted 
        *** transactions details file
        SCAN REST WHILE &lcTrnsDtEx. = lcBatchNo+lcTranNo
     
          SCATTER MEMVAR
          INSERT INTO GLPTRNDT FROM MEMVAR
        ENDSCAN
         
        SELECT GLTRNSHD
      ENDSCAN  
  
      SELECT (lcTempFile)
    ENDSCAN
    
  ENDIF

*** If posting transactions
ELSE
  SELECT GLTRNSHD

  *** Refresh relation
  IF !EOF()
    GO RECNO()
  ELSE
    GO TOP
  ENDIF

  lcBatchNo        = REPLICATE('0',lnBtNoWdth)
  lcTranNo         = GLTRNSHD.cTranNo
  REPLACE GLTRNSHD.cPostProg WITH 'E'  
  
  *** Copy the current transaction header to the posted transactions
  *** header file, and supply locking information as 'unlocked'.
  *** Since copying this record to the posted transaction headers file,
  *** occus while the record is locked, by the calling program, the
  *** copied locking information need to be updated.
  SCATTER MEMVAR
  m.lLok_Stat      = .F.
  m.cLok_User      = ''
  m.dLok_Date      = {}
  m.cLok_Time      = ''
  INSERT INTO GLPTRNHD FROM MEMVAR
  
  SELECT GLTRNSDT   
  
  *** Copy the details of the current transaction to the posted 
  *** transactions details file
  SCAN REST WHILE &lcTrnsDtEx. = lcBatchNo+lcTranNo
    SCATTER MEMVAR
    INSERT INTO GLPTRNDT FROM MEMVAR
  ENDSCAN
ENDIF

RETURN .T.
       

*!**************************************************************************
*!
*!      Function : lfRepPost
*!
*!**************************************************************************
*
*  This function performs posting of amounts to the dummy balance file
*  (lcTempBals). It is called only if called from reports instead of
*  the main posting function (lfPost()). It does not affect the 
*  main files GLACBALS, GLBATCH, GLTRNSHD, GLTRNSDT in any way.
*
FUNCTION lfRepPost
PARAMETERS lc_SumEnt, llClosEnt
*** lc_SumEnt : is the file name containing the summary of all
***             the entries to be posted.It may be lc_SumEnt1,
***             or lc_SumEnt2 according to the calling function.  
*** llClosEnt : If .T., handle previous year income statements,
***             if any are to be handled, else, skip this part.    

*** As you scan the summary file, get a copy of every
*** account's balances for the current posting window
*** from the actual balances file to the dummy balances file
*** (lcTempBals)
  
*** Scan all the records in the Summarized_Entries file for
SELECT (lc_SumEnt)
SCAN
  *** Get the current account code
  lcAcctCode     = &lc_SumEnt..cAcctCode
    
  *** Copy all the records in the balances file
  *** (GLACBALS) that belong to this account for the three
  *** years of the posting window.
  IF !SEEK(lcAcctCode,lcTempBals);
    .AND. SEEK(lcAcctCode+lcPrev_Yer,'GLACBALS')
    SELECT GLACBALS

    SCAN REST WHILE &lcAcBalsEx. <= lcacctcode + lcNext_Yer
      SCATTER MEMVAR MEMO
      INSERT INTO (lcTempBals);
              FROM MEMVAR
    ENDSCAN
  ENDIF
 
  SELECT (lc_SumEnt)
  IF !EOF()
    GO RECNO()
  ENDIF
  
  *** Call the update balance file function to update this record
  =lfUpd_Bal(lc_SumEnt,lcTempBals)
    
  *** If llClosEnt (.T.), 
  *** handle previous year income statements as follows :
  *** Check for the previous years income statement entries 
  *** in the following case :
  *** - the account year in lc_SumEnt of the current record
  ***   is the previous fiscal year
  ***   .AND.
  *** - if posting transcation(s), or batch(es) with type 
  ***   'N'ormal,sub'L'edger or 'B'eginning balance according 
  ***   to the value stored in GLBATCH.cBatType
  ***  .AND.
  *** - the account type of an account belonging to the above
  ***   subset of transactions is in any of the following types :
  ***   'E'xpence,other 'I'ncome,'S'ales,'T'axes, and 'C'ost of
  ***   sales.
   
  IF llClosEnt .AND. (&lc_SumEnt..cFisfYear=lcPrev_Yer) ;
     .AND. (lcTrOrBat='T' .OR. lcBatType $ 'NBL');
     .AND. (LEFT(GLACCHAR.cTypeCode,1) $ 'EISTC')

    *** Get the retained earnings account for the current account code
    *** 1. Get the cost center for the current account
    lcAcctCode     = IIF(' ' $ lcAcctCode,;
                     STRTRAN(&lc_SumEnt..cAcctCode,' ','-',1,1),;
                     PADR(lcAcctCode,LEN(lcAcctCode)+1,'-'))
    lnStartPos     = AT('-',lcAcctCode)         
    lcCostCntr     = SUBSTR(lcAcctCode,lnStartPos+1,;
                     AT('-',lcAcctCode,GLSETUP.nSetCostC)-lnStartPos-1)

    *** 2. Then build the corresponding retained earnings account code
    lcRetAccnt         = STUFF(lcRetActMj,lnStartPos+1,;
                         LEN(lcCostCntr),lcCostCntr)

    *** Check if the retained earnings account exists in the chart 
    *** of accounts file, if not, build another one from the preceeding
    *** cost center, and look for it in the charts of accounts file, 
    *** and so on 
    lcTmpCstCt         = lcCostCntr
    DO WHILE !SEEK(lcRetAccnt,lc_AcChar)
      lcTmpCstCt       = SUBSTR(lcTmpCstCt,1,RAt('-',lcTmpCstCt)-1)
      lcRetAccnt       = STUFF(lcRetActMj,lnStartPos+1,;
                         LEN(lcTmpCstCt),lcTmpCstCt)
    ENDDO

    *** Create Summerize_Entries2 temporary file (lc_Sument2) as follows :

    *** Look for the current account code + current year (which is
    *** the previous fiscal year) + last period in the previous fiscal
    *** year,
    *** If found, update it as follows, else append the current record
    *** to the file as shown. 
    IF SEEK(&lc_SumEnt..cAcctCode+&lc_SumEnt..cFisfYear+lcLastPrd,;
            lc_SumEnt2)

      REPLACE &lc_SumEnt2..nDrAmount WITH &lc_SumEnt2..nDrAmount + ;
                                          &lc_SumEnt..nCrAmount  , ;
              &lc_SumEnt2..nCrAmount WITH &lc_SumEnt2..nCrAmount + ;
                                      &lc_SumEnt..nDrAmount

    ELSE
      INSERT INTO (lc_SumEnt2);
        (cAcctCode, cFisFYear, cFspPrdId,nDrAmount,nCrAmount, llComplete);
         VALUES (&lc_SumEnt..cAcctCode, &lc_SumEnt..cFisfYear, lcLastPrd,;
                 &lc_SumEnt..nCrAmount,&lc_SumEnt..nDrAmount,.F.)
    ENDIF
 
    *** Look for the retained earnings account code + current year (which is
    *** the previous fiscal year) + last period in the previous fiscal
    *** year,
    *** If found, update it as follows, else append the current record
    *** to the file as shown. 

    IF SEEK(lcRetAccnt+&lc_SumEnt..cFisfYear+lcLastPrd,lc_SumEnt2)
      REPLACE &lc_SumEnt2..nDrAmount WITH &lc_SumEnt2..nDrAmount + ;
                                          &lc_SumEnt..nDrAmount  , ;
              &lc_SumEnt2..nCrAmount WITH &lc_SumEnt2..nCrAmount + ;
                                          &lc_SumEnt..nCrAmount
    ELSE

      INSERT INTO (lc_SumEnt2);
        (cAcctCode, cFisFYear, cFspPrdId,nDrAmount,nCrAmount, llComplete);
            VALUES (lcRetAccnt, &lc_SumEnt..cFisfYear, lcLastPrd,;
                    &lc_SumEnt..nDrAmount,&lc_SumEnt..nCrAmount,.F.)
    ENDIF
  ENDIF    
        
  *** Update the llComplete field of lc_SumEnt with .T. 
  *** indicating that posting of this record is completed
  REPLACE &lc_SumEnt..llComplete WITH .T.
  
ENDSCAN
RETURN .T.

*!**************************************************************************
*!
*!      Function : lfUpd_Bal
*!
*!**************************************************************************
*  This function performs the actual posting of amounts to the
*  balances file.It is called from lfPost or lfRepPost.
*  If called from lfPost, posting is directed to the main balances
*  file, 'GLACBALS'.
*  If called from lfRepPost, posting is directed to a dummy balances
*  file whose name is passed to this module as (lcTempBals) in
*  which case, none of the master files is affected in any way.
*  parameters 
*    lc_SumEnt     : name of the file containing the summary of entries
*                    (lc_SumEnt) 
*    lcBalFName    : name of the balances file to be updated  
*
FUNCTION lfUpd_Bal
PARAMETERS lc_SumEnt, lcBalFName

*** Save the current work area.
lcCurArea         = ALIAS()

SELECT (lcBalFName)

lcAcctCode         = &lc_SumEnt..cAcctCode
lcFisfYear         = &lc_SumEnt..cFisfYear

DO CASE
  *** Case posting transaction(s), or batch(es) of types 'N'ormal,
  *** 'S'tatistical, or sub'L'edger 
  CASE lcTrOrBat = 'T' .OR. GLBATCH.cBatType $ 'NSL'

      *** Update the current account code + year + period
      
      *** Update period to date debit field (GLACBALS.nAcBPtdDr)
      *** Update year to date debit field (GLACBALS.nAcBYtdDr)
      *** Update closing balance field (GLACBALS.nAcBClBal)      
      REPLACE &lcBalFName..nAcBPtdDr  WITH  &lcBalFName..nAcBPtdDr + ;
                                        &lc_SumEnt..nDrAmount,;
              &lcBalFName..nAcBYtdDr  WITH  &lcBalFName..nAcBYtdDr + ;
                                        &lc_SumEnt..nDrAmount,;
              &lcBalFName..nAcBPtdCr  WITH  &lcBalFName..nAcBPtdCr + ;
                                        &lc_SumEnt..nCrAmount,;
              &lcBalFName..nAcBYtdCr  WITH  &lcBalFName..nAcBYtdCr + ;
                                        &lc_SumEnt..nCrAmount,;
              &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                  (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
              &lcBalFName..cAdd_User  WITH  gcUser_ID,;
              &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
              &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
    
      *** Update the following periods for the same account code 
      *** and year
      IF !EOF()
        SKIP
        *** Update year to date debit field (GLACBALS.nAcBYtdDr)
        *** Update openning balance field (GLACBALS.nAcBOpBal)
        *** Update closing balance field (GLACBALS.nAcBClBal)      
        REPLACE REST  WHILE &lcAcBalsEx. = lcAcctCode+lcFisfYear;
                &lcBalFName..nAcBYtdDr  WITH  &lcBalFName..nAcBYtdDr + ;
                                          &lc_SumEnt..nDrAmount,;
                &lcBalFName..nAcBYtdCr  WITH  &lcBalFName..nAcBYtdCr + ;
                                          &lc_SumEnt..nCrAmount,;
                &lcBalFName..nAcBOpBal  WITH  &lcBalFName..nAcBOpBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount);
                &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
                &lcBalFName..cAdd_User  WITH  gcUser_ID,;
                &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
                &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
                   
        *** Update the following years for the same account code 
        *** if the current account type is 'A'ssets, 'L'iability,
        *** e'Q'uity, or statistical ('Y') 
        IF LEFT(GLACCHAR.cTypeCode,1) $ 'ALQY'
          *** Update openning balance field (GLACBALS.nAcBOpBal)      
          *** Update closing balance field (GLACBALS.nAcBClBal)      
          REPLACE REST WHILE &lcAcBalsEx. = lcAcctCode          ;
                &lcBalFName..nAcBOpBal  WITH  &lcBalFName..nAcBOpBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount);
                &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
                &lcBalFName..cAdd_User  WITH  gcUser_ID,;
                &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
                &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
        ENDIF
      ENDIF
    
  *** Case posting beginning balance batch(es)
  CASE lcTrOrBat = 'B' .AND. lcBatType = 'B'

      *** Update the current and the following periods for the same 
      *** account code and year
      
      *** Update openning balance field (GLACBALS.nAcBOpBal)            
      *** Update closing balance field (GLACBALS.nAcBClBal)            
      REPLACE REST WHILE &lcAcBalsEx. = lcAcctCode + lcFisfYear;   
              &lcBalFName..nAcBOpBal  WITH  &lcBalFName..nAcBOpBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount);
              &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
              &lcBalFName..cAdd_User  WITH  gcUser_ID,;
              &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
              &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
                   
      *** Update the following years for the same account code 
      *** if the current account type is 'A'ssets, 'L'iability,
      *** e'Q'uity, or statistical ('Y') 
      IF LEFT(GLACCHAR.cTypeCode,1) $ 'ALQY'
        *** Update openning balance field (GLACBALS.nAcBOpBal)      
        *** Update closing balance field (GLACBALS.nAcBClBal)      
        REPLACE REST WHILE &lcAcBalsEx. = lcAcctCode          ;
              &lcBalFName..nAcBOpBal  WITH  &lcBalFName..nAcBOpBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount);
              &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
              &lcBalFName..cAdd_User  WITH  gcUser_ID,;
              &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
              &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
      ENDIF
           
  *** Case posting year end closing entries batch(es) ('C')
  CASE lcTrOrBat = 'B' .AND. lcBatType = 'C'   

      *** Update the current account code + year + period
      
      *** Update closing balance field (GLACBALS.nAcBClBal)            
      REPLACE  &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal + ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
               &lcBalFName..cAdd_User  WITH  gcUser_ID,;
               &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
               &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
                   
      *** If the account type is e'Q'uity, update the following
      *** years for the same account.
      IF !EOF() .AND. LEFT(GLACCHAR.cTypeCode,1) = 'Q'
        *** Note : the current account code + year + period
        ***        in the case of 'C'losing year end batches
        ***        is always the last period in the year,
        ***        hence, the following years are the following
        ***        records as well. (There are no more periods for
        ***        this account for the same year)  
        SKIP

        *** Update openning balance field (GLACBALS.nAcBOpBal)            
        *** Update closing balance field (GLACBALS.nAcBClBal)            
        REPLACE REST WHILE &lcAcBalsEx. = lcAcctCode    ;
                &lcBalFName..nAcBOpBal  WITH  &lcBalFName..nAcBOpBal +    ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount);
                &lcBalFName..nAcBClBal  WITH  &lcBalFName..nAcBClBal +    ;
                   (&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
                &lcBalFName..cAdd_User  WITH  gcUser_ID,;
                &lcBalFName..dAdd_Date  WITH  ldCurrDate,;
                &lcBalFName..cAdd_Time  WITH  gfGetTime()                                      
     ENDIF

ENDCASE    

*** Restore the calling work area.
SELECT (lcCurArea)
  
  
*!**************************************************************************
*!
*!      Function : lfTBClean
*!
*!**************************************************************************
*
*  This function sets sll relations off, resets previous 
*  environment
* 
FUNCTION lfTBClean


*** Reset all relations
SELECT GLTRNSHD
SET RELATION OFF INTO GLTRNSDT 

SELECT GLTRNSDT

SET RELATION OFF INTO FSPRD 

*** b. lc_AcBAls (copy of GLACBALS) (child) 
SET RELATION OFF INTO (lc_AcBals) 
*** c. lc_AcChar (child) 
SET RELATION OFF INTO (lc_AcChar) 
*** d. lc_ActRepl (child) 
SET RELATION OFF INTO (lc_ActRepl) 
*** e. lc_SumEnt1 (child) 
SET RELATION OFF INTO (lc_SumEnt1) 
        
SELECT (lc_SumEnt1)
      
*** a. GLACCHAR (child) 
SET RELATION OFF INTO GLACCHAR 
*** b. GLACBALS (child) 
SET RELATION OFF INTO GLACBALS 

SELECT (lc_SumEnt2)
      
*** a. GLACCHAR (child) 
SET RELATION OFF INTO GLACCHAR 
*** b. GLACBALS (child) 
SET RELATION OFF INTO GLACBALS 


*** Reset the order of tags of all the 'S'elected files
*** to their original settings

SELECT GLACCHAR

IF EMPTY(lcAcCharTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcAcCharTg)
ENDIF      

SELECT GLACBALS

IF EMPTY(lcAcBalsTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcAcBalsTg)
ENDIF      

SELECT GLBATCH

IF EMPTY(lcBatchTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcBatchTg)
ENDIF      

*** Set previous filter, if one has been set from the calling program
IF lcTrOrBat = 'B' .AND. !EMPTY(lcTBFltExp)
  SET FILTER TO &lcTBFltExp.
ENDIF  

SELECT GLTRNSHD

IF EMPTY(lcTrnsHdTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcTrnsHdTg)
ENDIF      

*** Set previous filter, if one has been set from the calling program
IF lcTrOrBat = 'T' .AND. !EMPTY(lcTBFltExp)
  lcBatchNo = REPLICATE('0', lnBtNoWdth)
  SET FILTER TO &lcTBFltExp.
ENDIF  

SELECT GLTRNSDT

IF EMPTY(lcTrnsDtTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcTrnsDtTg)
ENDIF      

SELECT FSPRD

IF EMPTY(lcFscPrdTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcFscPrdTg)
ENDIF      

SELECT FISHD

IF EMPTY(lcFscHdTg)
  SET ORDER TO
ELSE
  SET ORDER TO TAG (lcFscHdTg)
ENDIF      

*** Close and/or erase files
=lfClsFiles()

*** Reset calling environment
SELECT (lcCurAlias)



*!**************************************************************************
*!
*!      Function : lfUpd_Cls
*!
*!**************************************************************************
*  Creates closing entries temporary files lc_SumEnt2, lc_ClosEnt to be
*  used in creating closing entries transactions, transaction details,
*  and batch
*  parameter       : name of the file containing the summary of entries
*                    (lc_SumEnt) 
*
FUNCTION lfUpd_Cls
PARAMETERS lc_SumEnt

*** Get the retained earnings account for the current account code
*** 1. Get the cost center for the current account

lcAcctCode         = IIF(' ' $ lcAcctCode,;
                     STRTRAN(&lc_SumEnt..cAcctCode,' ','-',1,1),;
                     PADR(lcAcctCode,LEN(lcAcctCode)+1,'-'))
lnStartPos         = AT('-',lcAcctCode)         
lcCostCntr         = SUBSTR(lcAcctCode,lnStartPos+1,;
                     AT('-',lcAcctCode,GLSETUP.nSetCostC)-lnStartPos-1)

*** 2. Then build the corresponding retained earnings account code
lcRetAccnt         = STUFF(lcRetActMj,lnStartPos+1,;
                     LEN(lcCostCntr),lcCostCntr)

*** Check if the retained earnings account exists in the chart
*** of accounts file, if not, build another one from the preceeding
*** cost center, and look for it in the charts of accounts file,
*** and so on 
lcTmpCstCt         = lcCostCntr
DO WHILE !SEEK(lcRetAccnt,lc_AcChar)
  lcTmpCstCt       = SUBSTR(lcTmpCstCt,1,RAt('-',lcTmpCstCt)-1)
  lcRetAccnt       = STUFF(lcRetActMj,lnStartPos+1,;
                     LEN(lcTmpCstCt),lcTmpCstCt)
ENDDO

*** Create Summerize_Entries2 temporary file (lc_Sument2) as follows :

*** Look for the current account code + current year (which is
*** the previous fiscal year) + last period in the previous fiscal
*** year,
*** If found, update it as follows, else append the current record
*** to the file as shown. 
IF SEEK(&lc_SumEnt..cAcctCode+&lc_SumEnt..cFisfYear+lcLastPrd,lc_SumEnt2)

  REPLACE &lc_SumEnt2..nDrAmount WITH &lc_SumEnt2..nDrAmount + ;
                                      &lc_SumEnt..nCrAmount  , ;
          &lc_SumEnt2..nCrAmount WITH &lc_SumEnt2..nCrAmount + ;
                                      &lc_SumEnt..nDrAmount

ELSE
  INSERT INTO (lc_SumEnt2);
   (cAcctCode, cFisFYear, cFspPrdId,nDrAmount,nCrAmount, llComplete);
   VALUES (&lc_SumEnt..cAcctCode, &lc_SumEnt..cFisfYear, lcLastPrd,;
          &lc_SumEnt..nCrAmount,&lc_SumEnt..nDrAmount,.F.)
ENDIF

*** Look for the retained earnings account code + current year (which is
*** the previous fiscal year) + last period in the previous fiscal
*** year,
*** If found, update it as follows, else append the current record
*** to the file as shown. 

IF SEEK(lcRetAccnt+&lc_SumEnt..cFisfYear+lcLastPrd,lc_SumEnt2)
  REPLACE &lc_SumEnt2..nDrAmount WITH &lc_SumEnt2..nDrAmount + ;
                                      &lc_SumEnt..nDrAmount  , ;
          &lc_SumEnt2..nCrAmount WITH &lc_SumEnt2..nCrAmount + ;
                                      &lc_SumEnt..nCrAmount
ELSE

  INSERT INTO (lc_SumEnt2);
   (cAcctCode, cFisFYear, cFspPrdId,nDrAmount,nCrAmount, llComplete);
   VALUES (lcRetAccnt, &lc_SumEnt..cFisfYear, lcLastPrd,;
          &lc_SumEnt..nDrAmount,&lc_SumEnt..nCrAmount,.F.)

ENDIF


*** Create closing entries temporary file (lc_ClosEnt) as follows :

*** Prepare cost center variable :
lcCostCntr         = PADR(lcCostCntr,lnAcctWdth,' ')

*** Look for the cost center value + current account code 
*** If found, update it as follows, else append the current record
*** to the file as shown. 

IF SEEK(lcCostCntr+&lc_SumEnt..cAcctCode,lc_ClosEnt)
   
  lnAddAmnt = IIF(&lc_ClosEnt..cDrOrCr='D',&lc_ClosEnt..nAmount,;
                                         0-&lc_ClosEnt..nAmount) +;
                  &lc_SumEnt..nCrAmount-&lc_SumEnt..nDrAmount
  REPLACE &lc_ClosEnt..nAmount WITH ABS(lnAddAmnt) ,;    
          &lc_ClosEnt..cDrOrCr WITH IIF(lnAddAmnt > 0,'D','C') 

ELSE
  INSERT INTO (lc_ClosEnt);  
   	(cCostCntr, cAcctCode, nAmount, cDrOrCr);
   	VALUES (lcCostCntr,&lc_SumEnt..cAcctCode,;
   	        ABS(&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
   	        IIF(&lc_SumEnt..nDrAmount > &lc_SumEnt..nCrAmount,'C','D'))

ENDIF

*** Look for the cost center value + retained earnings account code 
*** If found, update it as follows, else append the current record
*** to the file as shown. 

IF SEEK(lcCostCntr+lcRetAccnt,lc_ClosEnt)
  lnAddAmnt = IIF(&lc_ClosEnt..cDrOrCr='D',&lc_ClosEnt..nAmount,;
                                         0-&lc_ClosEnt..nAmount) +;
                  &lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount

  REPLACE &lc_ClosEnt..nAmount WITH ABS(lnAddAmnt),;    
          &lc_ClosEnt..cDrOrCr WITH IIF(lnAddAmnt > 0 ,'D','C')            

ELSE
  INSERT INTO (lc_ClosEnt);  
   	(cCostCntr, cAcctCode, nAmount, cDrOrCr);
   	VALUES (lcCostCntr,lcRetAccnt,;
   	        ABS(&lc_SumEnt..nDrAmount-&lc_SumEnt..nCrAmount),;
   	        IIF(&lc_SumEnt..nDrAmount > &lc_SumEnt..nCrAmount,'D','C'))
ENDIF

   	        
*!**************************************************************************
*!
*!      Function : lfCreatCls
*!
*!**************************************************************************
*  Creates a closing entries batch ,its transactions, and transaction 
*  details from the previously created temporary files lc_SumEnt2, 
*  lc_ClosEnt
*  parameter       : name of the file containing the summary of entries
*                    (lc_SumEnt) 
*
FUNCTION lfCreatCls
PRIVATE lcCurrDate
*** lcCurrDate : holds the current date

*** Closing entries are created as follows :
*** All of them are recorded in a single year end 'C'losing entries 
*** batch, under the same generated batch number.
*** Whenever the cost center is changed, a new transaction is created
*** and all the records belonging to the same cost center are considered
*** the details of this transaction

*** Build temporary files holding temporary transactions, transactions
*** details, and a created batch. 


lcCurrDate         = DTOC(ldCurrDate)

*** Initialize batch number variable.
lcBatchNo          = ''

*** Thermometer variables
lnTotRecs          = RECCOUNT(lc_ClosEnt)
lnThermRec         = 0

*** Reset batch's  total debit and total credit
lnBatTotDr         = 0
lnBatTotCr         = 0
  
SELECT (lc_ClosEnt)
GO TOP
  
lcTmpCstCt       = ''
  
SCAN
  *** If the cost center value is changed, record a new transaction 
  IF lcTmpCstCt <> &lc_ClosEnt..cCostCntr    

    *** Store the current cost center value.
    lcTmpCstCt     = &lc_ClosEnt..cCostCntr  
              
    *** Reset total debit and credit totals
    lnTotalDr    = 0
    lnTotalCr    = 0
      
  ENDIF
  

  *** Process all the records having the same cost center value.
  SCAN REST WHILE &lc_ClosEnt..cCostCntr=lcTmpCstCt

    *** Do not allow any line in the transaction details to have
    *** a rero amount, hence, filter out those records in the
    *** closing entries file with zero amounts.
    IF &lc_ClosEnt..nAmount <> 0.00
      
      *** Append a new line in the temporary transactions details file
                 
      SELECT (lc_TransDt)

      APPEND BLANK
      REPLACE cAcctCode WITH &lc_ClosEnt..cAcctCode,;
              cDrOrCr   WITH &lc_ClosEnt..cDrOrCr,; 
              nAmount   WITH &lc_ClosEnt..nAmount,;
              dTrnPDate WITH ldLastPFDt,;
              cTrnPYr   WITH lcPrev_Yer,;
              cTrnPPrd  WITH lcLastPrd,;
              cAdd_User WITH gcUser_ID,;
              dAdd_Date WITH ldCurrDate,;
              cAdd_Time WITH gfGetTime()
              
      SELECT (lc_ClosEnt)     
      IF &lc_ClosEnt..cDrOrCr = 'D'
        lnTotalDr  = lnTotalDr + &lc_ClosEnt..nAmount
      ELSE  
        lnTotalCr  = lnTotalCr + &lc_ClosEnt..nAmount
      ENDIF
    ENDIF  
  ENDSCAN
  
  *** SCAN..ENDSCAN increments the record pointer automatically,
  *** so, go back one record so as not to lose the last one.
  SKIP -1   
  
  *** Append a new line in the temporary transactions header file     
  
  *** Do not allow any line in the transaction header to have zero
  *** total debit or credit values, hence, 

  *** Checking total debit value is enough since both total
  *** values are equal.  
  IF lnTotalDr <> 0    

    *** Having checked that there are entries for this transaction
    *** and hence, a transaction header and a batch are to be created, 
    *** proceed with creation of a batch number, a transaction number 
    *** and a closing entry number.
    
    *** If a batch number hasn't already been created, 
    *** generate a new batch number by calling the global function
    *** gfSequence, passing to it an ID : 'BATCH', and a default value 
    *** (1) to be used if no batch numbers have been created before.
    *** This is then padded with zeroes from the left
    IF EMPTY(lcBatchNo)

      lcBatchNo    = gfSequence('CBATCHNO' , lcAct_Comp)
      
    ENDIF
    
    
    *** Generate a new transaction number by calling the global function
    *** gfSequence, passing to it an ID : 'TRANSACT', and a default value 
    *** (1) to be used if no transaction numbers have been created before.
    *** This is then padded with zeroes from the left

    lcTranNo       = gfSequence('CTRANNO' , lcAct_Comp)
    
    *** Generate a new closing entry number by calling the global function
    *** gfSequence, passing to it an ID : 'CLOSENT', and a default value 
    *** (1) to be used if no closing entry numbers have been created before.
    *** This is then padded with zeroes from the left

    lcClosNo       = gfSequence('CCLOSENT' , lcAct_Comp,;
								 '', '', 'CTRANNO')
    
    lnThermRec       = lnThermRec + 1  
    =lfThermo(lnTotRecs, lnThermRec,"Creating year end closing entries...",;
                "Closing entry No. "+lcClosNo )
   
    SELECT (lc_TransHd)

    APPEND BLANK
    REPLACE cBatchNo  WITH lcBatchNo,;
            cTranNo   WITH lcTranNo,;
            cTrnDesc  WITH 'Created by '+lcUserName,;
            cTrnRefer WITH 'YEC No ' + lcClosNo,;
            dTrnPDate WITH ldLastPFDt,; 
            cTrnPYr   WITH lcPrev_Yer,;
            cTrnPPrd  WITH lcLastPrd,;
            cTrnType  WITH 'Y',;
            cTrnStat  WITH 'Y',;
            cTrnRever WITH 'N',;
            nTrnTotDr WITH lnTotalDr,;
            nTrnTotCr WITH lnTotalCr,; 
            cSrcModul WITH gcAct_Appl,;
            cStandard WITH 'Y',;
            cSrcJrnl  WITH lcSJ_Def,;
            cComp_Id  WITH lcAct_Comp,; 
            cAdd_User WITH gcUser_ID,;
            dAdd_Date WITH ldCurrDate,;
            cAdd_Time WITH gfGetTime()
            
    SELECT (lc_TransDt)
    
    REPLACE ALL WHILE EMPTY(cBatchNo);
            cBatchNo  WITH lcBatchNo,;
            cTranNo   WITH lcTranNo,;
            cTrDtExp  WITH 'Closing entry No. '+lcClosNo      
                
  ENDIF
              
  SELECT (lc_ClosEnt)     
  
  *** Update total debit and credit values for the batch
  lnBatTotDr     = lnBatTotDr + lnTotalDr
  lnBatTotCr     = lnBatTotCr + lnTotalCr
  

ENDSCAN           

*** Having finished creating a transaction header and details, 
*** append a new record in the batches file.
*** Do not allow any batch to have zero total debit or credit 
*** values, 
*** If a batch has zero total debit and total credit, there
*** is no need to proceed with files creation, appending 
*** to master files, or posting 

*** Checking total debit value is enough since both total
*** values are equal.  

IF lnBatTotDr <> 0

  SELECT (lc_Batches)

  APPEND BLANK

  REPLACE cBatchNo  WITH lcBatchNo,;
          lBatInd   WITH .F.,;
          cBatStat  WITH 'Y',;
          cBatType  WITH 'C',; 
          cBatPYr   WITH lcPrev_Yer,;  
          dBatPBeg  WITH ldLastPFDt,;
          dBatPEnd  WITH ldLastPFDt,;   
          cBatRefer WITH 'YEC No ' + lcClosNo,;
          cBatDesc  WITH 'Prior year closing entries by '+lcUserName,;
          nBatCnTot WITH lnBatTotDr,;
          nBaTotDr  WITH lnBatTotDr,;
          nBaTotCr  WITH lnBatTotCr,;
          cSrcModul WITH gcAct_Appl,;
          cComp_Id  WITH lcAct_Comp,; 
          cAdd_User WITH gcUser_ID,;
          dAdd_Date WITH ldCurrDate,;
          cAdd_Time WITH gfGetTime()

  *** Append the newly created records to the master files as follows:
  *** Append the new batch to GLBATCH
  SELECT GLBATCH
  APPEND FROM &gcWorkDir.&lc_Batches
      
  *** Append the new transaction(s) to GLTRNSHD
  SELECT GLTRNSHD
  APPEND FROM &gcWorkDir.&lc_TransHd
  
  *** Append the new transaction(s)' details to GLTRNSDT
  SELECT GLTRNSDT
  APPEND FROM &gcWorkDir.&lc_TransDt
  

  *** Call the posting program with lc_SumEnt2 modifying
  *** Save old parameters
  llOldOneRc       = llOneRec
  lcOldTBTyp       = lcTrOrBat 
  lcOldBType       = lcBatType  
   
  *** Modify the following variables as follows :
  *** Single batch posting
  llOneRec         = .T.    
  lcTrOrBat        = 'B'
 
  *** of type "year end 'C'losing" 
  lcBatType        = 'C' 

  *** Point to the new batch in GLBATCH file to be posted
  SELECT GLBATCH
  
  *** Set a relation between the calling database file (GLBATCH)
  *** and GLTRNSHD (child) on Batch no.
  SET RELATION TO cBatchNo INTO GLTRNSHD ADDITIVE
  GO TOP
                  
  llPosted       = SEEK(lcBatchNo) .AND. lfPost(lc_SumEnt2)
 
  =lfThermo(lnTotRecs, lnTotRecs,"Creating year end closing entries...","") 
  
  SELECT GLBATCH
  SET RELATION OFF INTO GLTRNSHD
  
  *** Restore old parameters
  llOneRec       = llOldOneRc
  lcTrOrBat      = lcOldTBTyp
  lcBatType      = lcOldBType 

ENDIF
RETURN llPosted


*!**************************************************************************
*!
*!      Function : lfBrowPost
*!
*!**************************************************************************
*  Displays posted transactions or batches in a browse window,
*  and gives the user the option to get a printed report of 
*  the posting operation. 
*
FUNCTION lfBrowPost

*** If posting transactions 
IF lcTrOrBat = 'T'

  *** Fields to browse are :
  lcPBrwFlds       = "GLTRNSHD.cTranNo:H='Trans No':8,"+;
                     "GLTRNSHD.cTrnRefer:H='Reference':15,"+;
                     "GLTRNSHD.nTrnTotDr:H='Total debit':15,"+;          
                     "GLTRNSHD.nTrnTotCr:H='Total credit':15"

  *** If posting a single transaction
  IF llOneRec
    SELECT GLTRNSHD  
    *** Browse condition is :
    lcPBrwCond     = lcTrnsHdEx +'="'+lcTBToPost+'"'
    lcPBrwFlds     = lcPBrwFlds + " FOR " + lcPBrwCond
   
  *** If posting multiple transactions
  ELSE

    *** If not called from reports (actual posting)
    IF !llTBReport

      SELECT GLTRNSHD  
      *** Tag expression is cTrnStat + cBatchNo + cTranNo
      SET ORDER TO TAG TRANSTAT
      lcTrnsHdEx     = SYS(14,VAL(SYS(21)))     
      *** Browse condition : (Display only those transactions marked
      *** as 'P'osted during the current posting session)
      lcPBrwCond     = "&lcTrnsHdEx. ='P'.AND. cPostSess = lcPostSess"
      lcPBrwFlds     = lcPBrwFlds + " FOR " + lcPBrwCond

    *** If called from reports, creste a cursor holding the dummy
    *** posted transactions.
    ELSE  
      *** Get the field names of the temporary file.
      lcTrnNoFld     = FIELD(1,lcTempFile)
      lcPstdFld      = FIELD(2,lcTempFile)
                            

      SELECT &lcTempFile..&lcTrnNoFld, GLTRNSHD.cTrnRefer,; 
             GLTRNSHD.nTrnTotDr,GLTRNSHD.nTrnTotCr ;
             FROM &gcWorkDir.&lcTempFile,GLTRNSHD;
            WHERE (GLTRNSHD.cBatchNo + GLTRNSHD.cTranNo = ;
                  REPLICATE('0',lnBtNoWdth) + &lcTempFile..&lcTrnNoFld.) ;
              AND (&lcTempFile..&lcPstdFld. = 'P') ;
              INTO  CURSOR (lc_BrowCur)
      

      *** Browsed fields :
      lcPBrwFlds   = "&lc_BrowCur..&lcTrnNoFld:H='Trans No':8,"+;
                     "&lc_BrowCur..cTrnRefer:H='Reference':15,"+;
                     "&lc_BrowCur..nTrnTotDr:H='Total debit':15,"+;          
                     "&lc_BrowCur..nTrnTotCr:H='Total credit':15"


      SELECT (lc_BrowCur)
    ENDIF
  ENDIF

*** If posting batches
ELSE

  *** Fields to browse are :
  lcPBrwFlds       = "GLBATCH.cBatchNo:H='Batch No':8,"+;
                     "GLBATCH.cBatRefer:H='Reference':15,"+;
                     "GLBATCH.nBaTotDr:H='Total debit':15,"+;          
                     "GLBATCH.nBaTotCr:H='Total credit':15"
 
  *** If posting a single batch
  IF llOneRec

    SELECT GLBATCH
    *** Browse condition is :
    lcPBrwCond     = lcBatchEx+'="'+lcTBToPost+'"'
    lcPBrwFlds     = lcPBrwFlds + " FOR " + lcPBrwCond
    
  *** If posting multiple batches
  ELSE
    IF !llTBReport
      SELECT GLBATCH
      *** Tag expression is cBatStat + cBatchNo
      SET ORDER TO TAG BATSTAT
      lcBatchEx      = SYS(14,VAL(SYS(21)))     
      *** Browse condition : (Display only those batches marked as 'P'osted
      ***                     in the current posting session)      
      lcPBrwCond     = "&lcBatchEx. ='P'.AND. cPostSess = lcPostSess"
      lcPBrwFlds     = lcPBrwFlds + " FOR " + lcPBrwCond
      
    ELSE
      *** Get the field names of the temporary file.
      lcBatNoFld     = FIELD(1,lcTempFile)
      lcPstdFld      = FIELD(2,lcTempFile)
      
      SELECT &lcTempFile..&lcBatNoFld, GLBATCH.cBatRefer,; 
             GLBATCH.nBaTotDr, GLBATCH.nBaTotCr ;
             FROM &gcWorkDir.&lcTempFile,GLBATCH;
             WHERE GLBATCH.cBatchNo = &lcTempFile..&lcBatNoFld; 
              .AND. &lcTempFile..&lcPstdFld = 'P';
             INTO CURSOR (lc_BrowCur)  
      
      *** Browsed fields :
      lcPBrwFlds   = "&lc_BrowCur..&lcBatNoFld:H='Trans No':8,"+;
                     "&lc_BrowCur..cBatRefer:H='Reference':15,"+;
                     "&lc_BrowCur..nBaTotDr:H='Total debit':15,"+;          
                     "&lc_BrowCur..nBaTotCr:H='Total credit':15"
      SELECT (lc_BrowCur)

    ENDIF   
  ENDIF
ENDIF

lcPWinTit1       = IIF(llTBReport,'Posting Session',;
                       'Posting Session No. '+lcPostSess)

*** Posting window titles
lcPWinTit2       = IIF(lcTrOrBat = 'T',;
                       'Posted transaction','Posted batch')
IF !llOneRec .AND. lnTBPosted > 1
  lcPWinTit2     = lcPWinTit2+IIF(lcTrOrBat = 'T','s','es')
ENDIF

*** and its 'browse' window title
lcBWinTitl       = 'Posting details'  

lcRunScx = lfGetScx("GL\GLPOSTNG.scx")
DO FORM (lcRunScx) WITH loFormSet

*!**************************************************************************
*!
*!      Function : lfvPrntPst
*!
*!**************************************************************************
*  Valid function for push button 'Print' (pbPrntPst)
*
FUNCTION lfvPrntPst
*** This function is to be completed later.
llPrntPost         = .T.

*!**************************************************************************
*!
*!      Function : lfvClosPst
*!
*!**************************************************************************
*  Valid function for push button 'Close' (pbClosPst)
*
FUNCTION lfvClosPst




*!**************************************************************************
*!
*!       Function : lfTBLock
*!
*!***************************************************************************
* Attempt to lock all the files to be updated :
* GLACBALS.DBF, GLBATCH.DBF, GLTRNSHD.DBF, GLTRNSDT.DBF,
* (GLPTRNHD.DBF, GLPTRNDT.DBF if not called from reports)
* 
FUNCTION lfTBLock

IF llTBReport
  RETURN gfFLock("GLACBALS,GLBATCH,GLTRNSHD,GLTRNSDT",.T.)
ELSE
  RETURN gfFLock("GLACBALS,GLBATCH,GLTRNSHD,GLTRNSDT,GLPTRNHD,GLPTRNDT",.T.)
ENDIF


*!**************************************************************************
*!
*!       Function : lfTBUnLock
*!
*!***************************************************************************
*  Unlock all the locked files, if any
*
FUNCTION lfTBUnLock
*** Reset calling environment

SELECT (lcCurAlias)

*** Unlock any locked files
IF llTBReport
  =gfFLock("GLACBALS,GLBATCH,GLTRNSHD,GLTRNSDT",.F.)
ELSE
  =gfFLock("GLACBALS,GLBATCH,GLTRNSHD,GLTRNSDT,GLPTRNHD,GLPTRNDT",.F.)
ENDIF  

*!**************************************************************************
*!
*!       Function : lfTBOpnFls
*!
*!***************************************************************************
*  Checks if the files required for posting are already open, 
*  and opens any unused one.
FUNCTION lfTBOpnFls
*** Open the first six files
*** GLSETUP, GLACCHAR, CLACBALS, CLBATCH, GLTRNSHD, GLTRNSDT

FOR lnCount = 1 TO 8 
  IF !USED(laReqFiles[lnCount,1])
    USE &lcDataDir.&laReqFiles[lnCount,1] AGAIN IN 0
    IF !lfFileUsed(laReqFiles[lnCount,1])
      RETURN 0
    ENDIF  
    laReqFiles[lnCount,2] = .T.
  ENDIF
ENDFOR 

*** Open the next two files if not called from reports
*** (posted transactions header (GLPTRNHD) ), 
*** (posted transactions detail (GLPTRNDT) ), 
IF !llTBReport
  
  FOR lnCount = 9 TO 10 
    IF !USED(laReqFiles[lnCount,1])
      USE &lcDataDir.&laReqFiles[lnCount,1] AGAIN IN 0
      IF !lfFileUsed(laReqFiles[lnCount,1])
        RETURN 0
      ENDIF  
      laReqFiles[lnCount,2] = .T.
    ENDIF
  ENDFOR 
ENDIF  


*!**************************************************************************
*!
*!       Function : lfFileUsed
*!
*!***************************************************************************
*  Checks if a file is in use in the passed work area alias
*  If not, cleans up and terminates posting
*
FUNCTION lfFileUsed
PARAMETERS lcFileName
*** lcFileName : name of the file to be checked whether it is
***              in use (open) or not

*** If the file is openned in the respective work area, 
IF !USED(lcFileName)
  *** If it is not, present the following message, clean up,
  *** and terminate posting
  *** Message : "   Too many files are open. ð.            "
  ***                                < OK >      
  *N000682,1 12/26/12 TMI Globlization changes[Start] 
  *=gfModalGen('TRM02125B00000','Alert','Posting process is terminated')
  =gfModalGen('TRM02125B00000','Alert',lcLANG_Posting_process_is_terminated)
  *N000682,1 12/26/12 TMI Globlization changes[End  ] 


  *** Reset tags to their original settings
  IF USED('GLACCHAR')
    SELECT GLACCHAR
    IF EMPTY(lcAcCharTg)
      SET ORDER TO
    ELSE
      SET ORDER TO TAG (lcAcCharTg)
    ENDIF      
  ENDIF
  *** Close and/or erase used and/or created files
  =lfClsFiles()

  *** Reset calling environment
  SELECT (lcCurAlias)

  RETURN .F.
ELSE
  RETURN .T.
ENDIF

*!**************************************************************************
*!
*!       Function : lfClsFiles
*!
*!***************************************************************************
*  Close any files openned by this module, erases any created temporary 
*  files 
FUNCTION lfClsFiles

*** Close open data files
*** GLSETUP, GLACCHAR, CLACBALS, CLBATCH, GLTRNSHD, GLTRNSDT,
*** GLPTRNHD, GLPTRNDT
FOR lnCount = 1 TO 10 
  IF laReqFiles[lnCount,2] .AND. USED(laReqFiles[lnCount,1])
    USE IN &laReqFiles[lnCount,1]
  ENDIF
ENDFOR 

*** 2. Close (lc_AcBals) which is GLACBALS openned again
***    in another work area (lc_AcBAls)
IF USED(lc_AcBals)
  USE IN (lc_AcBals)
ENDIF  

*** 3. Close (lc_AcChar) which is GLACCHAR openned again
***   in another work area (lc_AcChar)
IF USED(lc_AcChar)
  USE IN (lc_AcChar)
ENDIF  

*** 4. Close all temporary files and cursors created by this module
IF USED(lc_SumEnt1)
  USE IN (lc_SumEnt1)
ENDIF  
IF USED(lc_SumEnt2)
  USE IN (lc_SumEnt2)
ENDIF  
IF USED(lc_ActRepl)
  USE IN (lc_ActRepl)
ENDIF  
IF USED(lc_ClosEnt)
  USE IN (lc_ClosEnt)
ENDIF  
IF USED(lc_Batches)
  USE IN (lc_Batches)
ENDIF  
IF USED(lc_TransHd)
  USE IN (lc_TransHd)
ENDIF  
IF USED(lc_TransDt)
  USE IN (lc_TransDt)
ENDIF  
IF USED(lc_TmpBals)
  USE IN (lc_TmpBals)
ENDIF  
IF USED(lc_BrowCur)
  USE IN (lc_BrowCur)
ENDIF  

*** Erase all temporary files and their indeces.   
ERASE &gcWorkDir.&lc_SumEnt1..dbf  
ERASE &gcWorkDir.&lc_SumEnt1..cdx  
ERASE &gcWorkDir.&lc_SumEnt2..dbf  
ERASE &gcWorkDir.&lc_SumEnt2..cdx  
ERASE &gcWorkDir.&lc_ActRepl..dbf  
ERASE &gcWorkDir.&lc_ActRepl..cdx  
ERASE &gcWorkDir.&lc_ClosEnt..dbf  
ERASE &gcWorkDir.&lc_ClosEnt..cdx
ERASE &gcWorkDir.&lc_Batches..dbf  
ERASE &gcWorkDir.&lc_TransHd..dbf  
ERASE &gcWorkDir.&lc_TransDt..dbf  
ERASE &gcWorkDir.&lc_TmpBals..dbf  

************************************************************
*! Name      : lfThermo
*! Developer : TMI - Tarek Mohamed Ibrahim
*! Date      : 04/06/2012
*! Purpose   : lfThermo
************************************************************
FUNCTION lfThermo
PARAMETERS lnTotRecs, lnThermRec, lcPstTB,lcTranNo
WITH oProgress
  .TotalProgress = lnTotRecs
  .lblFirstLabel.CAPTION = lcPstTB
  .lblSecondLabel.CAPTION = lcTranNo
  .CurrentProgress(lnThermRec)
  *.Top = loFormSet.Ariaform1.Top + 50
  .SHOW()
ENDWITH   

*- End of lfThermo.
************************************************************
*! Name      : lfGLPOSTING_SetProp
*! Developer : TMI - Tarek Mohamed Ibrahim
*! Date      : 05/06/2012
*! Purpose   : GLPOSTING properties setting 
************************************************************
FUNCTION lfGLPOSTING_SetProp
PARAMETERS loPostingFormSet
LOCAL i,lcI,lnDot,lnWidth,lnColon,lnQt1,lnQt2

loPostingFormSet.Ariaform1.Caption = lcBWinTitl
WITH loPostingFormSet.Ariaform1.grdGLPTRNHD
  .RecordSource = SUBSTR(lcPBrwFlds,1,AT('.',lcPBrwFlds)-1)
  FOR i = 1 TO 4
    lcI = STR(i,1)
    lnDot   = AT('.',lcPBrwFlds,i)+1
    lnColon = AT(':',lcPBrwFlds,i*2-1)
    lnWidth = lnColon - lnDot
    .Column&lcI..ControlSource = SUBSTR(lcPBrwFlds,lnDot,lnWidth)
    
    lnQt1 = AT("'",lcPBrwFlds,i*2-1)+1
    lnQt2 = AT("'",lcPBrwFlds,i*2)    
    lnWidth = lnQt2 - lnQt1
    .Column&lcI..Header1.Caption = SUBSTR(lcPBrwFlds,lnQt1,lnWidth)
    
  ENDFOR 
  
  lcFor = SUBSTR(lcPBrwFlds,AT(' FOR ',lcPBrwFlds)+5)
  SELECT (.RecordSource)
  SET FILTER TO &lcFor
  LOCATE
  
  .ReadOnly = .T.
ENDWITH 
*- End of lfGLPOSTING_SetProp.
************************************************************
*! Name      : lfPOSTNGFormCLose
*! Developer : TMI - Tarek Mohamed Ibrahim
*! Date      : 06/06/2012
*! Purpose   : POSTNG Form Close
************************************************************
FUNCTION lfPOSTNGFormCLose
PARAMETERS loPostingFormSet
*- do the update
LOCAL i,lnSlct
lnSlct = SELECT(0)

FOR i= 1 TO ALEN(oAriaApplication.laRemotetable)
  lcTbl = UPPER(oAriaApplication.laRemotetable[i].lcTableName)
  IF LEFT(lcTbl,2)<>'SY' AND USED(lcTbl)
    SELECT (lcTbl)
    WAIT WINDOW NOWAIT 'Updating the table : &lcTbl'
    
    gfTableUpdate()
    
  ENDIF
  
ENDFOR 
WAIT CLEAR 

*- close the form
SELECT (loPostingFormSet.Ariaform1.grdGLPTRNHD.RecordSource)
SET FILTER TO 
LOCATE

SELECT (lnSlct)

loPostingFormSet.Release
*- End of lfPOSTNGFormCLose.
