*!**************************************************************************
*! Name      : MBIMAIN.PRG
*! Developer : Hend Ghanem (HBG)
*! Date      : 08/19/2001
*! Purpose   : 
*! Reference : C#200217,1
*!**************************************************************************
*! Parameters: lcEvntFun -> Process event function name without 'lf..'  .
*!             lcFunPars -> Process function parameters, sent as a string.
*!**************************************************************************
*! Returns   : Logical value.
*!**************************************************************************
*!Modifications
*C200358,1 TMI 06/17/2002 Create a Quick Order Entry screen
*B606087,1 TMI 07/11/2002 Assure that Dyelot entred last is returned
*B606386,1 ABD 08/15/2002 Need to  use the TAB key to move between the fields 
*B606386,1 ABD            As this is the only easy way to operate - the fields on 
*B606386,1 ABD            top of the screen use the TAB key so it should 
*B606386,1 ABD            be standard for the whole screen.
*B606324,1 RAE 09/26/2002 Fix the values of ALO1 to ALO8 fields in STYLE and STYDYE files.
*B606725,1 ABD 12/25/2002 Fix bug that the ordhdr not updating with the add information
*B606959,1 ASH 02/16/2003 1- Double check that the piktkt opened with the right tag.
*B606959,4 ASH 05/06/2003 2- Double check that the pointer is at the right record in ORDHDR.
*B607116,1 ABD 05/04/2003 Ignore piktkt that hold Complete and Canncel Status from the browse.
*B607266,1 ABD 07/01/2003 ignore piktkt = '******'
*C037816,1 MHM 04/06/2004 Custom Bin Location For David Luke
*B122433,1 TMI 05/18/2004 Add season check
*E126905,1 EIH 04/11/2005 Update in new field 'CALLOCATB' by 'D'in case of allocated or picking from sales order  
*                         ' ' for cancel allocation or picking .
*B131513,1 NNA 03/23/2006 fix Bug that you cann't clear a line (Zero Qty) that because when you go to save,you
*B131513,1 NNA            find that the Qty returned again.

*!*****************************************************************************************
PARAMETER lcEvntFun,lcFunPars

lcFunPars  = IIF(TYPE('lcFunPars') = 'C',lcFunPars,'')
lcFunToRun = 'lf'+ALLT(lcEvntFun)+'('+lcFunPars+')'

*--Run the function.
llRetValue = EVAL(lcFunToRun)

RETURN llRetValue

*!***************************************************************
*! Name      : lfCHNGFRM
*! Developer : Hend Ghanem (HBG)
*! Date      : 08/19/2001
*! Purpose   : 
*!***************************************************************
*!
FUNCTION lfCHNGFRM

lcFormName = IIF(lcRpPrtFrm = 'D' ,lcOldForm , 'ALPKTKMD')

=gfCrtFrm(lcFormName,lcOGFormArr,llOGRefForm)
=lfRepPltFr(lcFormName)

*!**************************************************************************
*! Name      : lfComplExp
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 10/28/2001
*! Purpose   : To add the region to lcRpExp.
*!**************************************************************************
*! Example   : =lfComplExp()
*!**************************************************************************
*:C200240,1 , C200241,1
FUNCTION lfComplExp
IF !EMPTY(lcRegion)
  lcRpExp = lcRpExp + IIF(EMPTY(lcRpExp),""," AND ") + [Customer.Region $ lcRegion]
ENDIF
*-- End of lfComplExp

*!**************************************************************************
*! Name      : lfCheckReg
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 10/25/2001
*! Purpose   : To check for Region value if changed.
*!**************************************************************************
*! Example   : =lfCheckReg()
*!**************************************************************************
*:C200240,1 , C200241,1
FUNCTION lfCheckReg
lcRegion = ''
=ASORT(laRpTRegn)
FOR lnInd = 1 TO ALEN(laRpTRegn)
  lcRegion = lcRegion + PADR(laRpTRegn[lnInd],6) + SPACE(1)
ENDFOR
lcRegion = STRTRAN(ALLTRIM(lcRegion),' ',"|")

IF !llOGFltCh AND !(lcRegion == lcOldRegn)
  llOGFltCh = .T.
ENDIF
lcOldRegn = lcRegion
*-- End of lfCheckReg.

*!**************************************************************************
*! Name      : lfFillMovr
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 10/25/2001
*! Purpose   : To collect data for the region mover.
*!**************************************************************************
*! Example   : =lfFillMovr()
*!**************************************************************************
*:C200240,1 , C200241,1
FUNCTION lfFillMovr
PARAMETER lfDummy
lfDummy = .T.

DIMENSION laRpSRegn[1,1],laRpTRegn[1,1]
STORE '' TO laRpSRegn,laRpTRegn

*--The Region.
SELECT CODES
LOCATE
SELECT DISTINCT cCode_NO + ' - ' + cDiscRep ;
FROM CODES ;
WHERE cDefCode + cFld_Name + cCode_No + cDiscRep + cRltd_Nam = "NREGION" ;
AND crltField = 'N';
INTO ARRAY laRpSRegn

RETURN lfDummy
*-- End of lfFiLLMovr.

*!**************************************************************************
*! Name      : lfvRegion
*! Developer : Sameh Saiid Ezzat (SSE)
*! Date      : 10/25/2001
*! Purpose   : To open the region mover.
*!**************************************************************************
*! Example   : =lfvRegion()
*!**************************************************************************
*:C200240,1 , C200241,1
FUNCTION lfvRegion
PARAMETER lfDummy
lfDummy = .T.

= gfMover(@laRpSRegn,@laRpTRegn,'Region',.T.,'')
RETURN lfDummy
*-- End of lfvRegion.

*!***************************************************************
*! Name      : lfSavScr
*! Developer : Mohamed Shokry Mohamed (MHM)
*! Date      : 10/21/2001
*! Purpose   : Save screen
*!***************************************************************
*!C200236,1
FUNCTION lfSavScr
PRIVATE llAddToSO

DECLARE laDivType[1,2] 
lcDivType = ''
**- Array to get the Division Type 
laDivType[1,1] = 'CDIVTYPE'     
laDivType[1,2] = 'lcDivType'

=gfRltFld(laData[15],@laDivType,'CDIVISION')
llAddToSO  = gfGetMemVar('M_ADD_SO')   && setting For Add to existing SO
llEDITToSO = gfGetMemVar('M_EDIT_SO')  && setting For EDIT to existing SO

*C037816,1 MHM 04/06/2004 consedr Bin Location Concept in saving Piktkt[Start]
llUseBin  = gfGetMemVar('M_DLUSEBIN')   && setting For Add bin location Yes/No
IF TYPE("llUseBin") = "U"
  llUseBin = .F.
ELSE
  IF EMPTY(llUseBin)
    llUseBin = .F.
  ENDIF  
ENDIF
*C037816,1 MHM [End]

*--open piktkt file
=IIF('AL' $ gcCmpModules,gfOpenFile(gcDataDir+'PikTkt',gcDataDir+'PikTkt','SH'),.T.)

*-- update piktkt yes or no
llUpPkTk = .F.

IF laScrMode[4]
  DO CASE
      CASE lcDivType = 'I'                  && Inquire
        *--Would you like to allocate sales order?
        *--   <YES>-->1     <NO>-->2
        IF gfModalGen('QRM32097B32000','DIALOG') = 2
          RETURN .F.
        ENDIF
        llUpPkTk = .T.
     CASE lcDivType = 'N' OR EMPTY(lcDivType)        && Never, Use the normal way for saving SO
       RETURN .F.
  ENDCASE
  SELECT (lcOrdLine)
  lcOldOrd = ORDER()
  SET ORDER TO 
  lnRecNo = RECNO()
  SCAN
    REPLACE PIK1   WITH QTY1    ,;
            PIK2   WITH QTY2    ,;
            PIK3   WITH QTY3    ,;
            PIK4   WITH QTY4    ,;
            PIK5   WITH QTY5    ,;
            PIK6   WITH QTY6    ,;
            PIK7   WITH QTY7    ,;
            PIK8   WITH QTY8    ,;
            TotPik WITH TotQTY  
  ENDSCAN
  SET ORDER TO &lcOldOrd
  GOTO lnRecNo
  *--Check for llAddToSO
  IF llAddToSO AND !llMultiSt 
    lcPiktkt=lfBrowse()
  ELSE
    lcPiktkt =''
  ENDIF
  *--End check
ELSE
  *200236,4 [Start]
  IF lcDivType = 'N' OR EMPTY(lcDivType)        && Never, Use the normal way for Editing SO
    RETURN .F.
  ENDIF
  *200236,4 [End]

  *--Would you like to allocate existing sales order?
  *--   <YES>-->1     <NO>-->2
  IF llEditToSo AND gfModalGen('QRM32098B32000','DIALOG') = 1
    llEditToSo = .T.    && Add to existing Pick Ticket
  ELSE
    llEditToSo = .F.   && Generate new Pick Ticket
  ENDIF
  *--if in edit mode will check 
  *--1 - if normal SO and we add to new line
  *--2 - we add to picked SO
  SELECT (lcOrdLine)
  lnRecNo = RECNO()
  lcPiktkt1 = ''
  LOCATE FOR Store = m.Store AND !EMPTY(PikTkt)
  IF FOUND()
    lcPiktkt1 = piktkt
    m.pikdate = pikdate 
    m.picked  = picked  
  ENDIF
  
  *200236,5 MHM [Start]
  IF !llEDITToSo 
    RETURN .F.
  ENDIF
  *200236,5 MHM [End]
  
  IF EMPTY(lcPiktkt1)             && means normal SO
    *200236,5 MHM [Start]
    *IF !llEDITToSo 
    *  RETURN .F.
    *ENDIF
    *200236,5 MHM [End]

    lcPiktkt =''
    
    *C200236,4 to update QTY in case of multi store and store not found[start]
    SCAN FOR Store = m.Store
      *- Check the Date of pick tcket in case of addning new line. 
      REPLACE PIK1   WITH QTY1      ,;
              PIK2   WITH QTY2      ,;
              PIK3   WITH QTY3      ,;
              PIK4   WITH QTY4      ,;
              PIK5   WITH QTY5      ,;
              PIK6   WITH QTY6      ,;
              PIK7   WITH QTY7      ,;
              PIK8   WITH QTY8      ,;
              TotPik WITH TotQTY  
    ENDSCAN
    *C200236,4 [End]
  ELSE
    lcPiktkt = &lcOrdLine..piktkt            && picked SO
    SCAN FOR Store = m.Store
      
      *- Check the Date of pick tcket in case of addning new line. 
      
      REPLACE piktkt  WITH lcPiktkt ,;
              pikdate WITH m.pikdate,;
              Picked WITH .T.       ,;
              PIK1   WITH QTY1      ,;
              PIK2   WITH QTY2      ,;
              PIK3   WITH QTY3      ,;
              PIK4   WITH QTY4      ,;
              PIK5   WITH QTY5      ,;
              PIK6   WITH QTY6      ,;
              PIK7   WITH QTY7      ,;
              PIK8   WITH QTY8      ,;
              TotPik WITH TotQTY  
    ENDSCAN
  ENDIF  
  llUpPkTk = .T.
ENDIF
*- If we are in the edit mode.
IF laScrMode[3]
  DO CASE
    CASE laData[5] <> OrdHdr.STATUS .AND. laData[5] = "O" .AND. ASCAN(laEvntTrig , PADR('CHG_OPN',10)) <> 0
      llReturn = gfDoTriger('SOORD',PADR('CHG_OPN',10))
    CASE laData[5] <> OrdHdr.STATUS .AND. laData[5] = "H" .AND. ASCAN(laEvntTrig , PADR('CHG_HLD',10)) <> 0
      llReturn = gfDoTriger('SOORD',PADR('CHG_HLD',10))
    OTHERWISE
      DECLARE laOrdInfo[1]
      =gfSubStr(ALLTRIM(lcScFields) , @laOrdInfo , ',')
      llModOrd = .F.
      SELECT OrdHdr
      FOR lnOrdCnt = 1 TO ALEN(laOrdInfo)
        IF EVALUATE(laOrdInfo[lnOrdCnt]) <> laData[lnOrdCnt]
          llModOrd = .T.
          EXIT
        ENDIF
      ENDFOR
      IF llModOrd .AND. ASCAN(laEvntTrig , PADR('MOD_ORD',10)) <> 0
        llReturn = gfDoTriger('SOORD',PADR('MOD_ORD',10))
      ENDIF
  ENDCASE
ENDIF

*- get the oreder number in case of manual or sequence order.
laData[1] = IIF((llContinue AND !EMPTY(laData[1])) OR laScrMode[3],laData[1],;
            IIF(laSetups[6,2]='Y',lfGtOrder(),gfSequence('ORDER','','',laData[15])))
lcCurrOrd = laData[1]

IF llBomVarnt .AND. laScrMode[4] 
  SELECT (lcOrdLine)
  lnRecNo = RECNO()
  GO TOP

  IF ASCAN(laEvntTrig , PADR('DOSCRN',10)) <> 0
    SELECT (lcT_BomVar)
    REPLACE ALL cCost_Id WITH laData[1]
  ELSE
    SCAN
      SELECT (lcT_BomVar)
      REPLACE ALL cCost_Id WITH laData[1] ;
      FOR cIdType+cCost_ID+STR(LineNo,6)="SO"+ &lcOrdLine..Order+STR(&lcOrdLine..LineNo,6)
    ENDSCAN  
  ENDIF  

  IF BETWEEN(lnRecNo, 1, RECCOUNT())
    GO lnRecNo
  ENDIF
  *-delete any record without order no and pack The temp file 
  SELECT (lcT_BomVar)
  DELETE FOR EMPTY(cCost_Id)
  PACK
ENDIF

*-- If the function was not called from EDI
IF !llFromEDI

  =gfSavSess('SOORD', lcFiles, @laVariables,lcSession)
  SELECT UnCmSess
  =SEEK('O'+PADR('SOORD',10)+gcUser_id+lcSession)

  REPLACE cCurrObj WITH 'pbSav'
ENDIF    && End of IF !llFromEDI

SELECT (lcOrdHdr)
lcEdiOrd = Order
=RLOCK()
REPLACE Order WITH laData[1]
UNLOCK
SHOW GET laData[1] DISABLE
*-- update the allocated quantity in case we come in edit mode.
IF lcOrdType='O' .AND. laData[5]<>'B' .AND. laScrMode[3] .AND. USED(lcAlocated)
  SET ORDER TO TAG 'CUTPKORD' IN (lcAlocated)
  SELECT (lcAlocated)
  GO TOP
  IF !EOF()
    WAIT 'Updating alocated quantity...' WINDOW NOWAIT
    IF 'PO' $ gcCmpModules  && if we have style purchase order.
      =gfOpenFile(gcDataDir+'POSHDR',gcDataDir+'POSHDR','SH')
      =gfOpenFile(gcDataDir+'POSLN',gcDataDir+'POSLN','SH')
    ENDIF
    IF 'MF' $ gcCmpModules && if we have munf. module.
      =gfOpenFile(gcDataDir+'CUTTKTH',gcDataDir+'CUTTKTH','SH')
      =gfOpenFile(gcDataDir+'CUTTKTL',gcDataDir+'CUTLIN','SH')
    ENDIF
    =gfOpenFile(gcDataDir+'CUTPICK',gcDataDir+'CUTPKORD','SH')
    
    PRIVATE lcOrdLnOrd , lnOrdLnRec
    SELECT (lcOrdLine)
    lnOrdLnRec = RECNO()
    lcOrdLnOrd = TAG()
    SET ORDER TO TAG OrdLine    
    
    SELECT (lcAlocated)
    DO WHILE !EOF()
      lcKey = TRANCD+CTKTNO+CTKTLINENO+ORDER+STYLE+CORDLINE
      SCAN REST WHILE TRANCD+CTKTNO+CTKTLINENO+ORDER+STYLE+CORDLINE = lcKey
        lcHdrAlo = IIF(TranCd='1','CutTktH','PosHdr')
        lcDetAlo = IIF(TranCd='1','CutTktL','PosLn')
        =SEEK(lcKey,'CUTPICK')
        SCATTER MEMVAR
        SELECT (lcHdrAlo)
        =SEEK(IIF(m.TranCd='1',m.CTKTNO,'P'+m.CTKTNO))
        =RLOCK()
        IF &lcAlocated..nSteps < 1
          REPLACE TotOrd WITH TotOrd - CUTPICK.TotQty + m.TotQty
          SELECT (lcAlocated)
          =RLOCK()
          REPLACE nSteps WITH 1
          UNLOCK
          SELECT (lcHdrAlo)
        ENDIF
        IF !EMPTY(&lcAlocated..cUpdSizes) .AND. &lcAlocated..nSteps < 2

          PRIVATE lnQtyUpd , lnLoop , lcLoopStr , lnUpdSNo
          lnQtyUpd = CutPick.TotQty  
          lnUpdSNo = LEN(ALLTRIM(&lcAlocated..cUpdSizes))
          FOR lnLoop = 1 TO lnUpdSNo 
            lcLoopStr = SUBSTR(&lcAlocated..cUpdSizes,lnLoop,1)
            lcLoopStr = ALLTRIM(lcLoopStr)
            lnQtyUpd = lnQtyUpd - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr
          ENDFOR
          
          IF m.TranCd = '1'
            REPLACE Pcs_Bud WITH Pcs_Bud - CUTPICK.TotQty + lnQtyUpd ,;
                    Pcs_Opn WITH Pcs_Opn - CUTPICK.TotQty + lnQtyUpd
          ELSE
            REPLACE nStyOrder WITH nStyOrder - CUTPICK.TotQty + lnQtyUpd ,;
                    Open      WITH Open  - CUTPICK.TotQty + lnQtyUpd
          ENDIF

          IF SEEK(&lcAlocated..Style,'Style')
            PRIVATE lnLoop , lcLoopStr
            FOR lnLoop = 1 TO lnUpdSNo
              lcLoopStr = SUBSTR(&lcAlocated..cUpdSizes,lnLoop,1)
              lcLoopStr = ALLTRIM(lcLoopStr)
              SELECT Style
              =RLOCK()
              REPLACE WIP&lcLoopStr WITH WIP&lcLoopStr - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ;
                      TOTWIP WITH TOTWIP - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ;
                      NWO&lcLoopStr WITH NWO&lcLoopStr - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ; 
                      NTOTWO WITH NTOTWO - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr
              UNLOCK
            ENDFOR
          ENDIF  

          IF SEEK(lcOrdType+&lcAlocated..Order+STR(ALLTRIM(&lcAlocated..cOrdLine),6),lcOrdLine) AND ;
             SEEK(&lcAlocated..Style + &lcOrdLine..cWareCode  ,'StyDye')

            PRIVATE lnLoop , lcLoopStr
            FOR lnLoop = 1 TO lnUpdSNo
              lcLoopStr = SUBSTR(&lcAlocated..cUpdSizes,lnLoop,1)
              lcLoopStr = ALLTRIM(lcLoopStr)
              SELECT StyDye
              =RLOCK()
              REPLACE WIP&lcLoopStr WITH WIP&lcLoopStr - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ;
                      TOTWIP WITH TOTWIP - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ;
                      NWO&lcLoopStr WITH NWO&lcLoopStr - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr , ; 
                      NTOTWO WITH NTOTWO - CutPick.Qty&lcLoopStr + &lcAlocated..Qty&lcLoopStr
              UNLOCK
            ENDFOR
          ENDIF  

          SELECT (lcAlocated)
          =RLOCK()
          REPLACE nSteps WITH 2
          UNLOCK
          SELECT (lcHdrAlo)
        ENDIF
        UNLOCK
        SELECT (lcDetAlo)
        =SEEK(IIF(m.TranCd='2','P','')+m.CTKTNO+m.Style+m.cTktLineNo+'1')
        =RLOCK()
        IF &lcAlocated..nSteps < 3
          REPLACE ORD1   WITH ORD1   - CUTPICK.Qty1   + m.Qty1 ,;
                  ORD2   WITH ORD2   - CUTPICK.Qty2   + m.Qty2 ,;
                  ORD3   WITH ORD3   - CUTPICK.Qty3   + m.Qty3 ,;
                  ORD4   WITH ORD4   - CUTPICK.Qty4   + m.Qty4 ,;
                  ORD5   WITH ORD5   - CUTPICK.Qty5   + m.Qty5 ,;
                  ORD6   WITH ORD6   - CUTPICK.Qty6   + m.Qty6 ,;
                  ORD7   WITH ORD7   - CUTPICK.Qty7   + m.Qty7 ,;
                  ORD8   WITH ORD8   - CUTPICK.Qty8   + m.Qty8 ,;
                  TOTORD WITH TOTORD - CUTPICK.TotQty + m.TotQty
          SELECT (lcAlocated)
          =RLOCK()
          REPLACE nSteps WITH 3
          UNLOCK
          SELECT (lcDetAlo)
        ENDIF
        IF !EMPTY(&lcAlocated..cUpdSizes) .AND. &lcAlocated..nSteps < 4
          
          REPLACE Qty1   WITH IIF('1' $ &lcAlocated..cUpdSizes,Qty1-CUTPICK.Qty1+m.Qty1,Qty1) ,;
                  Qty2   WITH IIF('2' $ &lcAlocated..cUpdSizes,Qty2-CUTPICK.Qty2+m.Qty2,Qty2) ,;
                  Qty3   WITH IIF('3' $ &lcAlocated..cUpdSizes,Qty3-CUTPICK.Qty3+m.Qty3,Qty3) ,;
                  Qty4   WITH IIF('4' $ &lcAlocated..cUpdSizes,Qty4-CUTPICK.Qty4+m.Qty4,Qty4) ,;
                  Qty5   WITH IIF('5' $ &lcAlocated..cUpdSizes,Qty5-CUTPICK.Qty5+m.Qty5,Qty5) ,;
                  Qty6   WITH IIF('6' $ &lcAlocated..cUpdSizes,Qty6-CUTPICK.Qty6+m.Qty6,Qty6) ,;
                  Qty7   WITH IIF('7' $ &lcAlocated..cUpdSizes,Qty7-CUTPICK.Qty7+m.Qty7,Qty7) ,;
                  Qty8   WITH IIF('8' $ &lcAlocated..cUpdSizes,Qty8-CUTPICK.Qty8+m.Qty8,Qty8) ,;
                  TotQty WITH TotQty - CUTPICK.TotQty + lnQtyUpd                  

          SELECT (lcAlocated)
          =RLOCK()
          REPLACE nSteps WITH 4
          UNLOCK
          SELECT (lcDetAlo)
        ENDIF
        UNLOCK
        SELECT CUTPICK
        =RLOCK()
        IF m.TOTQTY = 0
          DELETE
        ELSE
          =RLOCK()
          GATHER MEMVAR
          UNLOCK
        ENDIF
        UNLOCK
      ENDSCAN
    ENDDO
    =IIF('PO' $ gcCmpModules,gfCloseFile('POSHDR')  AND gfCloseFile('POSLN'),.T.)
    =IIF('MF' $ gcCmpModules,gfCloseFile('CUTTKTH') AND gfCloseFile('CUTTKTL'),.T.)
    =gfCloseFile('CUTPICK')

    SELECT (lcOrdLine)
    SET ORDER TO TAG &lcOrdLnOrd
    IF BETWEEN(RECNO(),1,RECCOUNT())
      GOTO lnOrdLnRec
    ENDIF
  ENDIF
ENDIF
=gfOpenFile(gcDataDir+'icStyHst',gcDataDir+'Styhst','SH') 
=gfOpenFile(gcDataDir+'ORDCANLN',gcDataDir+'ORDCANLN','SH') 
IF lcOrdType='O' AND laScrMode[4] AND !EMPTY(&lcOrdHdr..cFromOrder) AND ;
  ('PO' $ gcCmpModules .OR. 'MF' $ gcCmpModules)
  =gfOpenFile(gcDataDir+'CUTPICK',gcDataDir+'CUTORD','SH')
ENDIF

IF lcOrdType='O' .AND. laData[5]<>'B' .AND. laScrMode[3]
  SELECT (lcOrdLine)
  SCAN
    IF Picked .AND. SEEK(PikTkt,'PikTkt')
      SELECT PikTkt
      SET ORDER TO TAG Ordpik
      SCAN FOR Order+Piktkt = EVAL(lcOrdHdr+'.Order')
        =RLOCK() 
        REPLACE CustPo WITH laData[4]
        UNLOCK
      ENDSCAN  
      SET ORDER TO TAG Piktkt
    ENDIF
  ENDSCAN
ENDIF

SELECT ORDLINE
SET RELATION TO
SELECT (lcOrdLine)
SET DELETE OFF
SET ORDER TO TAG 0
LOCATE
WAIT 'Updating order lines...' WINDOW NOWAIT
lcUntSin = ''
lcExRSin = gfGetExSin(@lcUntSin, laData[33])

*200236,5 MHM Define array to store old data of pik [Start]
DIMENSION laOldAlo[9]
STORE 0 TO laOldAlo
*200236,5 MHM [Start]

STORE 0 TO lnCancel,lnCancelAmt,lnCanBulk
lnLineCount=IIF(SEEK(lcOrdType+laData[1],'ORDHDR'),ORDHDR.LastLine,0)

*200236,5 remove falg and make it per file to check updating [start]
*SCAN FOR IIF(OrdHdr.Status='B',.T.,Flag='M' .OR. (Flag='N' .AND. !DELETED() .AND. TotQty > 0))
*B131513,1 NNA 03/23/2006 (Begin) in my Case totqty=0 because user cleared all Qty but the flag field='M' so I seek for
*B131513,1 NNA            Flag='M' .OR. TotQty > 0
*SCAN FOR IIF(OrdHdr.Status='B',.T., !DELETED() .AND. TotQty > 0)
SCAN FOR IIF(OrdHdr.Status='B',.T.,Flag='M' .OR. TotQty > 0)
*B131513,1 NNA (End)

*200236,5 [end]
  *-- Decrease Depleted bulk orders from warehouse Ordered Quantity 
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5] <> 'B' .AND. !DELETED() .AND. ;
  *   (laScrMode[4] .OR. OrdHdr.Status='B') .AND. nSteps < 1 .AND. ;
  *  SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'OrdLine') .AND.;
  *  SEEK(OrdLine.Style+OrdLine.cWareCode+SPACE(10),'StyDye')

  IF lcOrdType='O' .AND. laData[5] <> 'B' .AND. !DELETED() .AND. ;
     (laScrMode[4] .OR. OrdHdr.Status='B') .AND. nSteps < 1 .AND. ;
    SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'OrdLine') .AND.;
    SEEK(OrdLine.Style+OrdLine.cWareCode+SPACE(10),'StyDye') AND (Flag$'MN')

    SELECT StyDye
    =RLOCK('StyDye')
    REPLACE Ord1 WITH Ord1 - MIN(OrdLine.Qty1,&lcOrdLine..Qty1),;
            Ord2 WITH Ord2 - MIN(OrdLine.Qty2,&lcOrdLine..Qty2),;
            Ord3 WITH Ord3 - MIN(OrdLine.Qty3,&lcOrdLine..Qty3),;
            Ord4 WITH Ord4 - MIN(OrdLine.Qty4,&lcOrdLine..Qty4),;
            Ord5 WITH Ord5 - MIN(OrdLine.Qty5,&lcOrdLine..Qty5),;
            Ord6 WITH Ord6 - MIN(OrdLine.Qty6,&lcOrdLine..Qty6),;
            Ord7 WITH Ord7 - MIN(OrdLine.Qty7,&lcOrdLine..Qty7),;
            Ord8 WITH Ord8 - MIN(OrdLine.Qty8,&lcOrdLine..Qty8),;
            TotOrd WITH Ord1+Ord2+Ord3+Ord4+Ord5+Ord6+Ord7+Ord8
            
    UNLOCK IN 'StyDye'
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 1
    UNLOCK
  ENDIF

  *-- Update Warehouse Ordered Quantity
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5]<>'B' .AND. nSteps < 2 .AND. ;
  *   SEEK(Style+&lcOrdLine..cWareCode+SPACE(10),'StyDye')
  IF lcOrdType='O' .AND. laData[5]<>'B' .AND. nSteps < 2 .AND. ;
     SEEK(Style+&lcOrdLine..cWareCode+SPACE(10),'StyDye') AND (Flag$'MN')
  *200236,5 [End]
  
    =SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine')

    *--If style was changed in the same line, don't update by subtract old
    *--and add new because it is a different style, you should subtract
    *--from old style and add to new style.
    llStyChgd = (&lcOrdLine..Style<>OrdLine.Style)
    IF llStyChgd
      =lfOrdQUpd('STYDYE')
    ELSE
      
      *-- For modified order line : Substract order original quantity and add order new quantity
      *-- For deleted lines       : Substract order original quantity
      *-- For orders that was bid : Add order quantity 
      SELECT StyDye                           
      =RLOCK('StyDye')
      REPLACE Ord1   WITH Ord1   - IIF(OrdHdr.Status='B',0,OrdLine.Qty1)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty1,0),;
              Ord2   WITH Ord2   - IIF(OrdHdr.Status='B',0,OrdLine.Qty2)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty2,0),;
              Ord3   WITH Ord3   - IIF(OrdHdr.Status='B',0,OrdLine.Qty3)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty3,0),;
              Ord4   WITH Ord4   - IIF(OrdHdr.Status='B',0,OrdLine.Qty4)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty4,0),;
              Ord5   WITH Ord5   - IIF(OrdHdr.Status='B',0,OrdLine.Qty5)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty5,0),;
              Ord6   WITH Ord6   - IIF(OrdHdr.Status='B',0,OrdLine.Qty6)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty6,0),;
              Ord7   WITH Ord7   - IIF(OrdHdr.Status='B',0,OrdLine.Qty7)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty7,0),;
              Ord8   WITH Ord8   - IIF(OrdHdr.Status='B',0,OrdLine.Qty8)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty8,0),;
              TotOrd WITH TotOrd - IIF(OrdHdr.Status='B',0,OrdLine.TotQty)+;
                                   IIF(!DELETED(lcOrdLine),&lcOrdLine..TotQty,0)
      UNLOCK IN 'StyDye'
    ENDIF
    SELECT (lcOrdLine)
    =RLOCK()    
    REPLACE nSteps WITH 2
    UNLOCK
  ENDIF

  *-- Decrease Depleted bulk orders from Style Ordered Quantity 
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5]<>'B' .AND. !DELETED() .AND. ;
  *   (laScrMode[4] .OR. OrdHdr.Status='B') .AND. nSteps < 3 .AND.;
  *   SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'ORDLINE') .AND. ;
  *   SEEK(OrdLine.Style,'Style')
  IF lcOrdType='O' .AND. laData[5]<>'B' .AND. !DELETED() .AND. ;
     (laScrMode[4] .OR. OrdHdr.Status='B') .AND. nSteps < 3 .AND.;
     SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'ORDLINE') .AND. ;
     SEEK(OrdLine.Style,'Style') AND (Flag$'MN')
  *200236,5 [End]

    SELECT Style 
    =RLOCK('Style')
    REPLACE Ord1   WITH Ord1 - MIN(OrdLine.Qty1,&lcOrdLine..Qty1),;
            Ord2   WITH Ord2 - MIN(OrdLine.Qty2,&lcOrdLine..Qty2),;
            Ord3   WITH Ord3 - MIN(OrdLine.Qty3,&lcOrdLine..Qty3),;
            Ord4   WITH Ord4 - MIN(OrdLine.Qty4,&lcOrdLine..Qty4),;
            Ord5   WITH Ord5 - MIN(OrdLine.Qty5,&lcOrdLine..Qty5),;
            Ord6   WITH Ord6 - MIN(OrdLine.Qty6,&lcOrdLine..Qty6),;
            Ord7   WITH Ord7 - MIN(OrdLine.Qty7,&lcOrdLine..Qty7),;
            Ord8   WITH Ord8 - MIN(OrdLine.Qty8,&lcOrdLine..Qty8),;
            TotOrd WITH Ord1+Ord2+Ord3+Ord4+Ord5+Ord6+Ord7+Ord8
    UNLOCK IN 'Style'
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 3
    UNLOCK
  ENDIF

  *-- Update Style Ordered Quantity 
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' AND laData[5]<>'B' AND nSteps < 4 AND SEEK(Style,'Style')
  *  =SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine')
  IF lcOrdType='O' AND laData[5]<>'B' AND nSteps < 4 AND SEEK(Style,'Style')
    =SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine')AND (Flag$'MN')
  *200236,5 ,[end]

    *--If style was changed in the same line, don't update by subtract old
    *--and add new because it is a different style, you should subtract
    *--from old style and add to new style.
    llStyChgd = (&lcOrdLine..Style<>OrdLine.Style)
    IF llStyChgd
      =lfOrdQUpd('STYLE')
    ELSE

      *-- For modified order line : Substract order original quantity and add order new quantity
      *-- For deleted lines       : Substract order original quantity
      *-- For orders that was bid : Add order quantity 
      SELECT Style
      =RLOCK('Style')
      REPLACE  Ord1   WITH Ord1   - IIF(OrdHdr.Status='B',0,OrdLine.Qty1)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty1,0),;
               Ord2   WITH Ord2   - IIF(OrdHdr.Status='B',0,OrdLine.Qty2)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty2,0),;
               Ord3   WITH Ord3   - IIF(OrdHdr.Status='B',0,OrdLine.Qty3)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty3,0),;
               Ord4   WITH Ord4   - IIF(OrdHdr.Status='B',0,OrdLine.Qty4)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty4,0),;
               Ord5   WITH Ord5   - IIF(OrdHdr.Status='B',0,OrdLine.Qty5)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty5,0),;
               Ord6   WITH Ord6   - IIF(OrdHdr.Status='B',0,OrdLine.Qty6)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty6,0),;
               Ord7   WITH Ord7   - IIF(OrdHdr.Status='B',0,OrdLine.Qty7)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty7,0),;
               Ord8   WITH Ord8   - IIF(OrdHdr.Status='B',0,OrdLine.Qty8)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..Qty8,0),;
               TotOrd WITH TotOrd - IIF(OrdHdr.Status='B',0,OrdLine.TotQty)+;
                                    IIF(!DELETED(lcOrdLine),&lcOrdLine..TotQty,0)
      UNLOCK IN 'Style'
    ENDIF  
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 4
    UNLOCK
  ENDIF

  *-- Cancel Depleted bulk orders Quantity 
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5] <> 'B' .AND. ;
  *   (laScrMode[4] .OR. OrdHdr.Status='B') .AND. !DELETED() .AND. ;
  *   SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'OrdLine')
  IF lcOrdType='O' .AND. laData[5] <> 'B' .AND. ;
     (laScrMode[4] .OR. OrdHdr.Status='B') .AND. !DELETED() .AND. ;
     SEEK(lcOrdType+cFromOrder+STR(BulkLineNo,6),'OrdLine') .AND. (Flag$'MN')
  *200236,5 [End]
  
    lnCanBulk = MIN(OrdLine.Qty1,Qty1)+MIN(OrdLine.Qty2,Qty2)+;
                MIN(OrdLine.Qty3,Qty3)+MIN(OrdLine.Qty4,Qty4)+;
                MIN(OrdLine.Qty5,Qty5)+MIN(OrdLine.Qty6,Qty6)+;
                MIN(OrdLine.Qty7,Qty7)+MIN(OrdLine.Qty8,Qty8)
    lnCancel    = lnCancel    + lnCanBulk
    lnCancelAmt = lnCancelAmt + lnCanBulk*OrdLine.Price
    lnOpmAmnt = lnCanBulk*OrdLine.Price &lcExRSin laData[34] &lcUntSin laData[50]

    *-- Decrease Depleted bulk orders Quantity & Amount in the Style History file
    IF SEEK(Style+lcBulkYear,'icStyHst') .AND. &lcOrdLine..nSteps < 5
      lnOrdAmt = lnOpmAmnt &lcExRSin laData[34] &lcUntSin laData[50]
      SELECT icStyHst
      =RLOCK()
      REPLACE nOrdQty&lcBulkPrd WITH nOrdQty&lcBulkPrd - lnCanBulk ,;
              nOrdQty           WITH nOrdQty           - lnCanBulk ,;
              nOrdAmt&lcBulkPrd WITH nOrdAmt&lcBulkPrd - lnOrdAmt  ,;
              nOrdAmt           WITH nOrdAmt           - lnOrdAmt
      UNLOCK
      SELECT (lcOrdLine)
      =RLOCK()
      REPLACE nSteps WITH 5
      UNLOCK
    ENDIF
    
    *-- Update Bulk order line open and book quantity
    IF nSteps < 6
      =RLOCK('ORDLINE')
      SELECT ORDLINE
      =RLOCK()
      REPLACE Qty1   WITH MAX(Qty1-&lcOrdLine..Qty1,0),;
              Qty2   WITH MAX(Qty2-&lcOrdLine..Qty2,0),;
              Qty3   WITH MAX(Qty3-&lcOrdLine..Qty3,0),;
              Qty4   WITH MAX(Qty4-&lcOrdLine..Qty4,0),;
              Qty5   WITH MAX(Qty5-&lcOrdLine..Qty5,0),;
              Qty6   WITH MAX(Qty6-&lcOrdLine..Qty6,0),;
              Qty7   WITH MAX(Qty7-&lcOrdLine..Qty7,0),;
              Qty8   WITH MAX(Qty8-&lcOrdLine..Qty8,0),;
              Totqty WITH Qty1+Qty2+Qty3+Qty4+Qty5+Qty6+Qty7+Qty8

      REPLACE Book1   WITH MAX(Book1-&lcOrdLine..Book1,0),;
              Book2   WITH MAX(Book2-&lcOrdLine..Book2,0),;
              Book3   WITH MAX(Book3-&lcOrdLine..Book3,0),;
              Book4   WITH MAX(Book4-&lcOrdLine..Book4,0),;
              Book5   WITH MAX(Book5-&lcOrdLine..Book5,0),;
              Book6   WITH MAX(Book6-&lcOrdLine..Book6,0),;
              Book7   WITH MAX(Book7-&lcOrdLine..Book7,0),;
              Book8   WITH MAX(Book8-&lcOrdLine..Book8,0),;
              TotBook WITH Book1+Book2+Book3+Book4+Book5+Book6+Book7+Book8

      UNLOCK IN 'ORDLINE'
      SELECT (lcOrdLine)
      =RLOCK()
      REPLACE nSteps WITH 6
      UNLOCK
    ENDIF
  ENDIF
  
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5]<>'B' .AND. laScrMode[3] .AND. ;
  *   Picked .AND. SEEK(PikTkt,'PikTkt')
  IF lcOrdType='O' .AND. laData[5]<>'B' .AND. laScrMode[3] .AND. ;
     Picked .AND. SEEK(PikTkt,'PikTkt').AND. (Flag$'MN')
  *200236,5 [End]
  
    SELECT PikTkt
    =RLOCK() 
    REPLACE Store  WITH &lcOrdLine..Store ,;
            CustPo WITH &lcOrdLine..CustPo

    UNLOCK
    SELECT (lcOrdLine)
  ENDIF
  =SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine')

  *-- Update orders Quantity & Amount in the Style History file
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' .AND. laData[5]<>'B' .AND. SEEK(Style+lcGlYear,'icStyHst') .AND. ;
  *   &lcOrdLine..nSteps < 7
  IF lcOrdType='O' .AND. laData[5]<>'B' .AND. SEEK(Style+lcGlYear,'icStyHst') .AND. ;
     &lcOrdLine..nSteps < 7 .AND. (Flag$'MN')
  *200236,5 [End]
  
    lnOrdAmt = ;
    IIF(DELETED(lcOrdLine),0,&lcOrdLine..TotQty*&lcOrdLine..Price &lcExRSin laData[34] &lcUntSin laData[50]) - ;
    IIF(laScrMode[4] OR OrdHdr.Status='B',0,OrdLine.TotQty*OrdLine.Price &lcExRSin OrdHdr.nExRate &lcUntSin OrdHdr.nCurrUnit)
    SELECT icStyHst
    =RLOCK()
    REPLACE nOrdQty&lcGlPeriod WITH nOrdQty&lcGlPeriod - ;
            IIF(OrdHdr.Status='B',0,OrdLine.TotQty) + ;
            IIF(DELETED(lcOrdLine),0,&lcOrdLine..TotQty) ,;
            nOrdQty WITH nOrdQty- IIF(OrdHdr.Status='B',0,OrdLine.TotQty) + ;
            IIF(DELETED(lcOrdLine),0,&lcOrdLine..TotQty) ,;
            nOrdAmt&lcGlPeriod WITH nOrdAmt&lcGlPeriod + lnOrdAmt ,;
            nOrdAmt WITH nOrdAmt + lnOrdAmt
    UNLOCK
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 7
    UNLOCK
  ENDIF

  *-- Check if any C/Ts have been assigned to the bulk order.
  *-- If any, Release allocation from the bulk order and allocate them
  *-- to the newly received distribution order.
  SELECT (lcOrdLine)
  
  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' AND laScrMode[4] AND 'MF' $ gcCmpModules AND ;
  *   !EMPTY(&lcOrdHdr..cFromOrder) .AND. &lcOrdLine..nSteps < 9
  IF lcOrdType='O' AND laScrMode[4] AND 'MF' $ gcCmpModules AND ;
     !EMPTY(&lcOrdHdr..cFromOrder) .AND. &lcOrdLine..nSteps < 9 .AND. (Flag$'MN')
  *200236,5 [End]
  
    SCATTER FIELDS ;
            Qty1,Qty2,Qty3,Qty4,Qty5,Qty6,Qty7,Qty8,TotQty TO laDistQty
    SELECT CUTPICK
    =SEEK('1'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6))
    SCAN REST ;
         WHILE TRANCD+ORDER+CORDLINE='1'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6) ;
         AND laDistQty[1]+laDistQty[2]+laDistQty[3]+laDistQty[4]+;
             laDistQty[5]+laDistQty[6]+laDistQty[7]+laDistQty[8] >0

      m.CtktLineNo = CtktLineNo
      m.CtktNo = CtktNo
      m.Cut1 = Qty1
      m.Cut2 = Qty2
      m.Cut3 = Qty3
      m.Cut4 = Qty4
      m.Cut5 = Qty5
      m.Cut6 = Qty6
      m.Cut7 = Qty7
      m.Cut8 = Qty8
      =RLOCK()            
      REPLACE Qty1   WITH MAX(Qty1-laDistQty[1],0) ,;
              Qty2   WITH MAX(Qty2-laDistQty[2],0) ,;
              Qty3   WITH MAX(Qty3-laDistQty[3],0) ,;
              Qty4   WITH MAX(Qty4-laDistQty[4],0) ,;
              Qty5   WITH MAX(Qty5-laDistQty[5],0) ,;
              Qty6   WITH MAX(Qty6-laDistQty[6],0) ,;
              Qty7   WITH MAX(Qty7-laDistQty[7],0) ,;
              Qty8   WITH MAX(Qty8-laDistQty[8],0) ,;
              TotQty WITH Qty1+Qty2+Qty3+Qty4+Qty5+Qty6+Qty7+Qty8
      UNLOCK 
      IF TotQty = 0
        DELETE
      ENDIF
      m.Cut1 = MIN(m.Cut1,laDistQty[1])
      m.Cut2 = MIN(m.Cut2,laDistQty[2])
      m.Cut3 = MIN(m.Cut3,laDistQty[3])
      m.Cut4 = MIN(m.Cut4,laDistQty[4])
      m.Cut5 = MIN(m.Cut5,laDistQty[5])
      m.Cut6 = MIN(m.Cut6,laDistQty[6])
      m.Cut7 = MIN(m.Cut7,laDistQty[7])
      m.Cut8 = MIN(m.Cut8,laDistQty[8])
      m.TotCut = m.Cut1+m.Cut2+m.Cut3+m.Cut4+m.Cut5+m.Cut6+m.Cut7+m.Cut8
      lnRecNo  = RECNO('CUTPICK')
      SELECT CUTPICK
      SET ORDER TO TAG CUTPKORD

      IF !SEEK('1'+m.CtktNo+m.cTktLineNo+laData[1]+&lcOrdLine..STYLE+STR(&lcOrdLine..LINENO,6))
        INSERT INTO 'CUTPICK' ;
        (CTKTNO,CTKTLINENO,TRANCD,ORDER,CORDLINE,STYLE) VALUES ;
        (m.CTKTNO,m.cTktLineNo,'1',laData[1],STR(&lcOrdLine..LineNo,6),&lcOrdLine..STYLE)
      ENDIF   

      REPLACE Qty1   WITH Qty1   + m.Cut1 ,;
              Qty2   WITH Qty2   + m.Cut2 ,;
              Qty3   WITH Qty3   + m.Cut3 ,;
              Qty4   WITH Qty4   + m.Cut4 ,;
              Qty5   WITH Qty5   + m.Cut5 ,;
              Qty6   WITH Qty6   + m.Cut6 ,;
              Qty7   WITH Qty7   + m.Cut7 ,;
              Qty8   WITH Qty8   + m.Cut8 ,;
              TotQty WITH TotQty + m.TotCut
      SET ORDER TO TAG CUTORD
      GOTO lnRecNo
      SELECT (lcOrdLine)
      =RLOCK()
      REPLACE Cut1   WITH Cut1+m.Cut1 ,;
              Cut2   WITH Cut2+m.Cut2 ,;
              Cut3   WITH Cut3+m.Cut3 ,;
              Cut4   WITH Cut4+m.Cut4 ,;
              Cut5   WITH Cut5+m.Cut5 ,;
              Cut6   WITH Cut6+m.Cut6 ,;
              Cut7   WITH Cut7+m.Cut7 ,;
              Cut8   WITH Cut8+m.Cut8 ,;
              TotCut WITH Cut1+Cut2+Cut3+Cut4+Cut5+Cut6+Cut7+Cut8
      UNLOCK
      SELECT (lcOrdHdr)
      =RLOCK()
      REPLACE TotCut WITH TotCut + m.TotCut
      UNLOCK
      IF SEEK('O'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6),'ORDLINE')
        SELECT ORDLINE
        =RLOCK()
        REPLACE Cut1   WITH MAX(Cut1-m.Cut1,0) ,;
                Cut2   WITH MAX(Cut2-m.Cut2,0) ,;
                Cut3   WITH MAX(Cut3-m.Cut3,0) ,;
                Cut4   WITH MAX(Cut4-m.Cut4,0) ,;
                Cut5   WITH MAX(Cut5-m.Cut5,0) ,;
                Cut6   WITH MAX(Cut6-m.Cut6,0) ,;
                Cut7   WITH MAX(Cut7-m.Cut7,0) ,;
                Cut8   WITH MAX(Cut8-m.Cut8,0) ,;
                TotCut WITH Cut1+Cut2+Cut3+Cut4+Cut5+Cut6+Cut7+Cut8
        UNLOCK
        IF SEEK('O'+&lcOrdHdr..cFromOrder,'ORDHDR')
          SELECT ORDHDR
          =RLOCK()
          REPLACE TotCut WITH MAX(TotCut - m.TotCut,0)
          UNLOCK
        ENDIF
      ENDIF
      laDistQty[1] = laDistQty[1] - m.Cut1
      laDistQty[2] = laDistQty[2] - m.Cut2
      laDistQty[3] = laDistQty[3] - m.Cut3
      laDistQty[4] = laDistQty[4] - m.Cut4
      laDistQty[5] = laDistQty[5] - m.Cut5
      laDistQty[6] = laDistQty[6] - m.Cut6
      laDistQty[7] = laDistQty[7] - m.Cut7
      laDistQty[8] = laDistQty[8] - m.Cut8
    ENDSCAN
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 9
    UNLOCK
  ENDIF
  *-- Check if any POs have been assigned to the bulk order.
  *-- If any, Release allocation from the bulk order and allocate them
  *-- to the newly received distribution order.
  SELECT (lcOrdLine)

  *200236,5 Add falg and make it per file to check updating [start]
  *IF lcOrdType='O' AND laScrMode[4] AND 'PO' $ gcCmpModules .AND. ;
  *   !EMPTY(&lcOrdHdr..cFromOrder) AND &lcOrdLine..nSteps < 10
  IF lcOrdType='O' AND laScrMode[4] AND 'PO' $ gcCmpModules .AND. ;
     !EMPTY(&lcOrdHdr..cFromOrder) AND &lcOrdLine..nSteps < 10 .AND. (Flag$'MN')
  *200236,5 [End]
    
    SCATTER FIELDS ;
            Qty1,Qty2,Qty3,Qty4,Qty5,Qty6,Qty7,Qty8,TotQty TO laDistQty
    SELECT CUTPICK
    =SEEK('2'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6))
    SCAN REST ;
         WHILE TRANCD+ORDER+CORDLINE='2'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6) ;
         AND laDistQty[1]+laDistQty[2]+laDistQty[3]+laDistQty[4]+;
             laDistQty[5]+laDistQty[6]+laDistQty[7]+laDistQty[8] >0

      m.CtktLineNo = CtktLineNo
      m.CtktNo = CtktNo
      m.Cut1 = Qty1
      m.Cut2 = Qty2
      m.Cut3 = Qty3
      m.Cut4 = Qty4
      m.Cut5 = Qty5
      m.Cut6 = Qty6
      m.Cut7 = Qty7
      m.Cut8 = Qty8
      =RLOCK()            
      REPLACE Qty1   WITH MAX(Qty1-laDistQty[1],0) ,;
              Qty2   WITH MAX(Qty2-laDistQty[2],0) ,;
              Qty3   WITH MAX(Qty3-laDistQty[3],0) ,;
              Qty4   WITH MAX(Qty4-laDistQty[4],0) ,;
              Qty5   WITH MAX(Qty5-laDistQty[5],0) ,;
              Qty6   WITH MAX(Qty6-laDistQty[6],0) ,;
              Qty7   WITH MAX(Qty7-laDistQty[7],0) ,;
              Qty8   WITH MAX(Qty8-laDistQty[8],0) ,;
              TotQty WITH Qty1+Qty2+Qty3+Qty4+Qty5+Qty6+Qty7+Qty8
      UNLOCK 
      IF TotQty = 0
        DELETE
      ENDIF
      m.Cut1 = MIN(m.Cut1,laDistQty[1])
      m.Cut2 = MIN(m.Cut2,laDistQty[2])
      m.Cut3 = MIN(m.Cut3,laDistQty[3])
      m.Cut4 = MIN(m.Cut4,laDistQty[4])
      m.Cut5 = MIN(m.Cut5,laDistQty[5])
      m.Cut6 = MIN(m.Cut6,laDistQty[6])
      m.Cut7 = MIN(m.Cut7,laDistQty[7])
      m.Cut8 = MIN(m.Cut8,laDistQty[8])
      m.TotCut = m.Cut1+m.Cut2+m.Cut3+m.Cut4+m.Cut5+m.Cut6+m.Cut7+m.Cut8
      lnRecNo  = RECNO('CUTPICK')
      SELECT CUTPICK
      SET ORDER TO TAG CUTPKORD


      IF !SEEK('2'+m.CtktNo+m.cTktLineNo+laData[1]+&lcOrdLine..STYLE+STR(&lcOrdLine..LINENO,6))
        INSERT INTO 'CUTPICK' ;
        (CTKTNO,CTKTLINENO,TRANCD,ORDER,CORDLINE,STYLE) VALUES ;
        (m.CTKTNO,m.cTktLineNo,'2',laData[1],STR(&lcOrdLine..LineNo,6),&lcOrdLine..STYLE)
      ENDIF
      REPLACE Qty1   WITH Qty1   + m.Cut1 ,;
              Qty2   WITH Qty2   + m.Cut2 ,;
              Qty3   WITH Qty3   + m.Cut3 ,;
              Qty4   WITH Qty4   + m.Cut4 ,;
              Qty5   WITH Qty5   + m.Cut5 ,;
              Qty6   WITH Qty6   + m.Cut6 ,;
              Qty7   WITH Qty7   + m.Cut7 ,;
              Qty8   WITH Qty8   + m.Cut8 ,;
              TotQty WITH TotQty + m.TotCut
      SET ORDER TO TAG CUTORD
      GOTO lnRecNo
      SELECT (lcOrdLine)
      =RLOCK()
      REPLACE Cut1   WITH Cut1+m.Cut1 ,;
              Cut2   WITH Cut2+m.Cut2 ,;
              Cut3   WITH Cut3+m.Cut3 ,;
              Cut4   WITH Cut4+m.Cut4 ,;
              Cut5   WITH Cut5+m.Cut5 ,;
              Cut6   WITH Cut6+m.Cut6 ,;
              Cut7   WITH Cut7+m.Cut7 ,;
              Cut8   WITH Cut8+m.Cut8 ,;
              TotCut WITH Cut1+Cut2+Cut3+Cut4+Cut5+Cut6+Cut7+Cut8
      UNLOCK
      SELECT (lcOrdHdr)
      =RLOCK()
      REPLACE TotCut WITH TotCut + m.TotCut
      UNLOCK
      IF SEEK('O'+&lcOrdHdr..cFromOrder+STR(&lcOrdLine..BulkLineNo,6),'ORDLINE')
        SELECT ORDLINE
        =RLOCK()
        REPLACE Cut1   WITH MAX(Cut1-m.Cut1,0) ,;
                Cut2   WITH MAX(Cut2-m.Cut2,0) ,;
                Cut3   WITH MAX(Cut3-m.Cut3,0) ,;
                Cut4   WITH MAX(Cut4-m.Cut4,0) ,;
                Cut5   WITH MAX(Cut5-m.Cut5,0) ,;
                Cut6   WITH MAX(Cut6-m.Cut6,0) ,;
                Cut7   WITH MAX(Cut7-m.Cut7,0) ,;
                Cut8   WITH MAX(Cut8-m.Cut8,0) ,;
                TotCut WITH Cut1+Cut2+Cut3+Cut4+Cut5+Cut6+Cut7+Cut8
        UNLOCK
        IF SEEK('O'+&lcOrdHdr..cFromOrder,'ORDHDR')
          SELECT ORDHDR
          =RLOCK()
          REPLACE TotCut WITH MAX(TotCut - m.TotCut,0)
          UNLOCK
        ENDIF
      ENDIF
      laDistQty[1] = laDistQty[1] - m.Cut1
      laDistQty[2] = laDistQty[2] - m.Cut2
      laDistQty[3] = laDistQty[3] - m.Cut3
      laDistQty[4] = laDistQty[4] - m.Cut4
      laDistQty[5] = laDistQty[5] - m.Cut5
      laDistQty[6] = laDistQty[6] - m.Cut6
      laDistQty[7] = laDistQty[7] - m.Cut7
      laDistQty[8] = laDistQty[8] - m.Cut8
    ENDSCAN
    SELECT (lcOrdLine)
    =RLOCK()
    REPLACE nSteps WITH 10
    UNLOCK
  ENDIF
   
  SCATTER MEMVAR MEMO

  m.Start    = laData[9]
  m.Complete = IIF(!llCDPerL .OR. EMPTY(m.Complete),laData[10],m.Complete )
  m.Flag     = SPACE(1)

  *200236,5 MHM save old piked data [Start]
  laOldAlo[1] = ORDLINE.PIK1
  laOldAlo[2] = ORDLINE.PIK2
  laOldAlo[3] = ORDLINE.PIK3
  laOldAlo[4] = ORDLINE.PIK4
  laOldAlo[5] = ORDLINE.PIK5
  laOldAlo[6] = ORDLINE.PIK6
  laOldAlo[7] = ORDLINE.PIK7
  laOldAlo[8] = ORDLINE.PIK8
  laOldAlo[9] = ORDLINE.TOTPIK
  *200236,5 MHM save old piked data [End]
  *--If multi add new one
  SELECT ORDLINE
  lcOldOrd = ORDER()
  SET ORDER TO Ordlinst
  llnotfound = .F.
  IF !SEEK(&lcOrdLine..cordtype +&lcOrdLine..order + &lcOrdLine..store+m.style)
    llnotfound =.T.
  ENDIF
  SET ORDER TO &lcOldOrd
  SELECT (lcOrdLine)

  m.Order    = laData[1]
  DO CASE
    CASE !llFromEDI AND !DELETED() .AND. !SEEK(lcOrdType+laData[1]+STR(LineNo,6),'OrdLine')
      lnLineCount=lnLineCount+1
      m.LineNo = lnLineCount
      *--not found and have piktkt
      IF llnotfound .AND. !EMPTY(lcPiktkt)
        m.LineNo = ordhdr.lastline + 1
      ENDIF
      INSERT INTO ORDLINE FROM MEMVAR
      IF SEEK(lcOrdType+laData[1],'ORDHDR')
        SELECT ORDHDR
        REPLACE LastLine WITH lnLineCount
      ENDIF
    CASE (llFromEDI .AND. SEEK('T'+Order+STR(LineNo,6),'OrdLine') ) .OR. ;
         (!llFromEDI AND !DELETED() .AND. SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine'))
      m.cOrdType = IIF(llFromEDI,'O',m.cOrdType)
      lnLineCount = IIF(llFromEDI,m.LineNo,lnLineCount)
      SELECT ORDLINE
      
      IF llMFDsPrc .OR. llPODsPrc
        lnOldPrc = Price 
        lnOldQty = TotQty
        GATHER MEMVAR MEMO
        lnOldQty = IIF(llUpdAlo,TotQty,lnOldQty)
        =lfUpdtPoCT(Order,Style,STR(LineNo,6),TotQty,Price,lnOldPrc,lnOldQty,.F.)
      ELSE
        GATHER MEMVAR MEMO
      ENDIF
      
    CASE DELETED() .AND. SEEK(lcOrdType+Order+STR(LineNo,6),'OrdLine')
      SELECT ORDLINE

      lcOrder  = Order
      lclineNo = STR(LineNo,6)
      lcStyle  = Style
      lnTotQty = 0
      lnPrice  = 0
      lnOldPrc = Price
      lnOldQty = TotQty
      DELETE
      IF llMFDsPrc .OR. llPODsPrc
        =lfUpdtPoCT(lcOrder,lcStyle,lclineNo,lnTotQty,lnPrice,lnOldPrc,lnOldQty,.T.)      
      ENDIF
  ENDCASE
  
  SELECT (lcOrdLine)

  =RLOCK()
  *200236,5 MHM Retrive old piked data [Start]
  *REPLACE Order  WITH laDAta[1] ,;
  *          LineNo WITH m.LineNo
  *=SEEK(ORDLINE.cOrdType+ORDLINE.Order+STR(ORDLINE.LineNo,6))
  REPLACE Order  WITH laDAta[1] ,;
          LineNo WITH m.LineNo,;
          Pik1   WITH laOldAlo[1],; 
          Pik2   WITH laOldAlo[2],; 
          Pik3   WITH laOldAlo[3],; 
          Pik4   WITH laOldAlo[4],; 
          Pik5   WITH laOldAlo[5],; 
          Pik6   WITH laOldAlo[6],; 
          Pik7   WITH laOldAlo[7],; 
          Pik8   WITH laOldAlo[8],; 
          TOTPIK WITH laOldAlo[9] 
          
  *200236,5 MHM  [End]
  UNLOCK
  
ENDSCAN

SELECT ORDLINE
IF SEEK(lcOrdType+laData[1])
  IF laData[7]
    REPLACE REST Start WITH laData[9] , Complete WITH IIF(llCDPerL,Complete,laData[10]) ;
                 WHILE cOrdType+Order=lcOrdType+laData[1]
  ELSE                
    REPLACE REST Start WITH laData[9] , Complete WITH IIF(llCDPerL,Complete,laData[10]) , ;
                 CustPo WITH laData[4] WHILE cOrdType+Order=lcOrdType+laData[1]
  ENDIF               
ENDIF

IF llBomVarnt
  =gfTmp2Mast('BOMVAR' , lcT_BomVar , 'Update the style positions for the order lines...')
ENDIF
 
=gfCloseFile('icStyHst')
=gfCloseFile('ORDCANLN')

IF lcOrdType='O' AND laScrMode[4] AND !EMPTY(&lcOrdHdr..cFromOrder) AND ;
  ('PO' $ gcCmpModules .OR. 'MF' $ gcCmpModules)
  =gfCloseFile('CUTPICK')
ENDIF

SET DELETE ON
WAIT 'Updating order header...' WINDOW NOWAIT

=gfOpenFile(gcDataDir+'arCusHst',gcDataDir+'Acthst','SH')

SELECT ORDHDR

IF !llFromEDI .AND. !SEEK(lcOrdType+laData[1])
  *ash1
  *INSERT INTO ORDHDR (cOrdType,Order) VALUES (lcOrdType,laData[1])
  APPEND BLANK 
  REPLACE cOrdType WITH lcOrdType ,;
          Order    WITH laData[1]
ENDIF
IF llFromEDI .AND. SEEK('T'+lcEdiOrd)
  REPLACE cOrdType WITH 'O' ,;
          Order    WITH laData[1]
ENDIF

*B606959,4 ASH 05/06/2003 (Begin) Assign the current order to a variable.
lctstord=ladata[1]
*B606959,4 ASH 05/06/2003 (End)

*-- Update orders Quantity & Amount in the Customer History file
IF lcOrdType='O' .AND. laData[5]<>'B' .AND. SEEK(laData[2]+lcGlYear,'arCusHst') .AND. ;
   &lcOrdHdr..nSteps < 1
  lnOrdAmt = laData[42] &lcExRSin laData[34] &lcUntSin laData[50] - ;
  IIF(laScrMode[4] OR OrdHdr.Status='B',0,OrdHdr.OpenAmt &lcExRSin OrdHdr.nExRate &lcUntSin OrdHdr.nCurrUnit)
  SELECT arCusHst
  =RLOCK()
  REPLACE nOrdQty&lcGlPeriod WITH nOrdQty&lcGlPeriod -;
            IIF(OrdHdr.Status='B',0,OrdHdr.Open) + laData[41],;
          nOrdQty WITH nOrdQty -;
            IIF(OrdHdr.Status='B',0,OrdHdr.Open) + laData[41],;
          nOrdAmt&lcGlPeriod WITH nOrdAmt&lcGlPeriod + lnOrdAmt ,;
          nOrdAmt WITH nOrdAmt + lnOrdAmt
  UNLOCK
  SELECT (lcOrdHdr)
  =RLOCK()
  REPLACE nSteps WITH 1
  UNLOCK
ENDIF


IF lcOrdType='O' .AND. laData[5]<>'B' .AND. laScrMode[4] .AND. ;
   SEEK(lcOrdType+&lcOrdHdr..cFromOrder,'OrdHdr')
  *-- Add bulk orders approve Amount in the header of new order from bulk order .
  SELECT (lcOrdHdr)
  =RLOCK()
  REPLACE APPRAMT  WITH MIN(&lcOrdHdr..OPENAMT,ORDHDR.APPRAMT)
  UNLOCK

  *-- Decrease bulk orders approve Amount in the header of bulk order.
  SELECT ORDHDR
  =RLOCK()
  REPLACE APPRAMT  WITH MAX(0,APPRAMT - &lcOrdHdr..OPENAMT)
  UNLOCK
ENDIF

IF lcOrdType='O' .AND. laData[5]<>'B' .AND. (laScrMode[4] .OR. OrdHdr.Status='B') .AND. ;
   SEEK(lcOrdType+&lcOrdHdr..cFromOrder,'OrdHdr')

  *-- Decrease bulk orders depleted Quantity & Amount in the Customer History file
  IF &lcOrdHdr..nSteps < 2 .AND. SEEK(laData[2]+lcBulkYear,'arCusHst')
    lnOrdAmt = lnCancelAmt &lcExRSin laData[34] &lcUntSin laData[50]
    SELECT arCusHst
    =RLOCK()
    REPLACE nOrdQty&lcBulkPrd WITH nOrdQty&lcBulkPrd - lnCancel ,;
            nOrdQty           WITH nOrdQty           - lnCancel ,;
            nOrdAmt&lcBulkPrd WITH nOrdAmt&lcBulkPrd - lnOrdAmt ,;
            nOrdAmt           WITH nOrdAmt           - lnOrdAmt
    UNLOCK
    SELECT (lcOrdHdr)
    =RLOCK()
    REPLACE nSteps WITH 2
    UNLOCK
  ENDIF
  IF &lcOrdHdr..nSteps < 3
    SELECT ORDHDR
    =RLOCK('ORDHDR')

    IF BULK = 'Y'
      REPLACE Book      WITH Book      - lnCancel   ,;
              BookAmt   WITH BookAmt   - lnCancelAmt,;
              Open      WITH Book      - Cancel     ,;
              Openamt   WITH Bookamt   - Cancelamt  ,;
              Status    WITH IIF(OrdHdr.Open = 0 ,'X',OrdHdr.Status)
   
    ELSE
      REPLACE Cancel    WITH Cancel    + lnCancel   ,;
              Cancelamt WITH Cancelamt + lnCancelAmt,;
              Open      WITH Book      - Cancel     ,;
              Openamt   WITH Bookamt   - Cancelamt  ,;
              Status    WITH IIF(OrdHdr.Open = 0 ,'X',OrdHdr.Status)
    ENDIF
    UNLOCK IN 'ORDHDR'
    SELECT (lcOrdHdr)
    =RLOCK()
    REPLACE nSteps WITH 3
    UNLOCK
  ENDIF  
  IF OrdHdr.Status='X' .AND. &lcOrdHdr..nSteps < 4 .AND. ;
    SEEK('M'+OrdHdr.Account,'Customer')
    SELECT Customer
    =RLOCK('Customer')
    REPLACE nBulk WITH nBulk - 1
    UNLOCK IN 'Customer'
    SELECT (lcOrdHdr)
    =RLOCK()
    REPLACE nSteps WITH 4
    UNLOCK
  ENDIF
ENDIF

=gfCloseFile('arCusHst')
IF lcOrdType='O' AND laData[5]<>'B' AND (laScrMode[4] OR OrdHdr.Status='B') AND ;
   &lcOrdHdr..Bulk='Y' AND &lcOrdHdr..nSteps < 5 AND SEEK('M'+laData[2],'Customer')
  SELECT Customer
  =RLOCK()
  REPLACE nBulk WITH nBulk + 1
  UNLOCK
  SELECT (lcOrdHdr)
  =RLOCK()
  REPLACE nSteps WITH 5
  UNLOCK
ENDIF
SELECT ORDHDR
*B606959,4 ASH 05/06/2003 (Begin) Double check that the pointer is at the correct record in ORDHDR.
FLUSH
IF !SEEK(lcOrdType+laData[1]) 
  IF !SEEK(lcOrdType+lctstord)
    lcFilHandl = FCREAT('&gcWorkDir.SOAL.txt')
    =FPUTS(lcFilHandl,ORDER('ORDHDR'))
    =FPUTS(lcFilHandl,lcOrdType)
    =FPUTS(lcFilHandl,laData[1])
    =FPUTS(lcFilHandl,lcTstOrd)
    Wait Window 'Please send ' + gcWorkDir + 'SOAL.TXT to attachments@aria.com.eg'
    =FCLOSE(lcFilHandl)
    RETURN .F.
  ENDIF
ENDIF
*B606959,4 ASH 05/06/2003 (End)
IF !EOF()
  =RLOCK()
  laData[5] = IIF(laData[41] = 0  ,IIF(laData[37]>0,'C','X'),laData[5])

  GATHER FROM laData FIELDS &lcScFields

  REPLACE cOrdType   WITH lcOrdType ,;
          LastLine   WITH lnLineCount  ,;
          cFromOrder WITH &lcOrdHdr..cFromOrder ,;
          StName     WITH IIF(laData[51],lcShipName,SPACE(30)) ,;
          cAddress1  WITH IIF(laData[51],lcShipAdd1,SPACE(30)) ,;
          cAddress2  WITH IIF(laData[51],lcShipAdd2,SPACE(30)) ,;
          cAddress3  WITH IIF(laData[51],lcShipAdd3,SPACE(30)) ,;
          cAddress4  WITH IIF(laData[51],lcShipAdd4,SPACE(30)) ,;
          cAddress5  WITH IIF(laData[51],lcShipAdd5,SPACE(30)) ,;
          TotCut     WITH &lcOrdHdr..TotCut                    ,;
          APPRAMT    WITH &lcOrdHdr..APPRAMT 

  UNLOCK
ENDIF

*-- If the function was not called from EDI
IF !llFromEDI
  
  SELECT unCmSess
  =SEEK('O'+PADR('SOORD',10)+gcUser_id+lcSession)
  REPLACE STATUS WITH 'C'
  UNLOCK
  llContinue = .F.
  UNLOCK 
  
ENDIF    && End of IF !llFromEDI

WAIT CLEAR 
IF laScrMode[4] AND !llFromEDI
  *-- Message : 32045
  *-- Order has been saved as xxxxxx
  *-- Button : 00000 
  *-- Ok
  =gfModalGen('INM32045B00000','DIALOG',IIF(lcOrdType='C','Contract','Order')+'|'+laData[1])

ENDIF
SET ORDER TO TAG 'ORDLINE' IN (lcOrdLine)

IF !llFromEDI AND lcOrdType='O' AND 'EB' $ gcCmpModules
  =gfOpenFile(gcDataDir+'EDIACPRT',gcDataDir+'ACCFACT','SH')
  =gfOpenFile(gcDataDir+'EDIPD',gcDataDir+'PARTTRANS','SH')
  =gfOpenFile(gcDataDir+'EDITRANS',gcDataDir+'TYPEKEY','SH')

  IF SEEK('A'+laData[2],'EDIACPRT') AND SEEK(EDIACPRT.cPartCode+'855','EDIPD')
    SELECT EDITRANS
    IF !SEEK('855'+PADR(laData[1],20)+'A'+laData[2])
      INSERT INTO 'EDITRANS' (cEdiTrnTyp,Key,Type,cPartner) VALUES ;
      ('855',laData[1],'A',laData[2])
    ENDIF
    REPLACE cStatus WITH 'N'
    =gfAdd_Info('EDITRANS')
  ENDIF 
  =gfCloseFile('EDIACPRT')
  =gfCloseFile('EDIPD')
  =gfCloseFile('EDITRANS')
ENDIF

PRIVATE llChanged
llChanged = .F.

IF &lcOrdHdr..lFromWeb AND 'CR' $ gcCmpModules AND &lcOrdHdr..cOrdType = "T" AND &lcOrdHdr..Status $ 'HO' AND lcOldStats = 'B'
  IF SEEK("T"+&lcOrdHdr..Order,'OrdLine')
    SELECT OrdLine

    DO WHILE SEEK("T"+&lcOrdHdr..Order,'OrdLine')
      =RLOCK()
      REPLACE cOrdType WITH "O"
      UNLOCK      
    ENDDO
    
    IF SEEK('T'+&lcOrdHdr..Order,'OrdHdr')
      SELECT OrdHdr
      =RLOCK()
      REPLACE cOrdType WITH "O"
      
      llChanged = .T.
      
      UNLOCK
    ENDIF
  ENDIF    

  *-- Get the Memory Variables without checking for the CRM module.
  =gfOpenFile(gcDataDir+'CRMesag',gcDataDir+'TransType','SH')
  APPEND BLANK
  =gfAdd_Info('CRMesag')
  REPLACE cTransType WITH 'O' , cTransNo WITH &lcOrdHdr..Order , lApprove WITH .T. , ;
          cMailFrom WITH gfGetMemVar('M_NOTEMAIL') , dTransDate WITH gdSysDate, cMailTo WITH ;
          IIF(SEEK('M'+&lcOrdHdr..Account,'Customer'),EVALUATE('Customer.' + gfGetMemVar('M_CONFMAIL')),'') , ;
          cMsgSubjct WITH "Your Sales Order# " + &lcOrdHdr..Order + ' has been approved.' , ; 
          cLetterId WITH gfGetMemVar('M_SOAPR') , lSent WITH .F.
  =gfCloseFile('CRMesag')  
    
ENDIF

IF llChanged
  llWebOrdUp = .T.
ENDIF  
*--in case of always or inquire and choose yes
IF lcDivType = 'A' OR llUpPkTk 
  SELECT(lcOrdLine)
  REPLACE ALL picked WITH .T.
  LOCATE
  =lfSavPkTk(lcPiktkt,lcOrdLine)
ENDIF   

SELECT ORDHDR

*B606725,1 ABD - Fix bug that the ordhdr not updating with the add information.  [Begin]
IF laScrMode[4]
  =gfAdd_Info('ORDHDR')
ENDIF  
*B606725,1 ABD - [End]

RETURN .T.

*!*************************************************************
*! Name      : lfOrdQUpd                         
*! Developer : Mohamed Shokry (MHM)
*! Date      : 11/01/2001
*! Purpose   : Update style orderd quantity in case of order
*!             line style was changed.
*!*************************************************************
*! Calls     : lfSavScr
*!*************************************************************
*! Parameters: lcFlToUpd-> Alias to update (STYLE or STYDYE).
*!*************************************************************
*! Returns   :  None.
*!*************************************************************
*!C200236,1
FUNCTION lfOrdQUpd
PARA lcFlToUpd

*--Update New Style.
SELECT (lcFlToUpd)
=RLOCK()
REPLACE Ord1   WITH Ord1   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty1),;
        Ord2   WITH Ord2   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty2),;
        Ord3   WITH Ord3   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty3),;
        Ord4   WITH Ord4   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty4),;
        Ord5   WITH Ord5   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty5),;
        Ord6   WITH Ord6   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty6),;
        Ord7   WITH Ord7   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty7),;
        Ord8   WITH Ord8   + IIF(OrdHdr.Status='B',0,&lcOrdLine..Qty8),;
        TotOrd WITH TotOrd + IIF(OrdHdr.Status='B',0,&lcOrdLine..TotQty)
UNLOCK

*--Update Old Style.
=SEEK(OrdLine.Style+IIF(lcFlToUpd='STYLE','',OrdLine.cWareCode+SPACE(10)),lcFlToUpd)

=RLOCK()
REPLACE Ord1   WITH Ord1   - IIF(OrdHdr.Status='B',0,OrdLine.Qty1),;
        Ord2   WITH Ord2   - IIF(OrdHdr.Status='B',0,OrdLine.Qty2),;
        Ord3   WITH Ord3   - IIF(OrdHdr.Status='B',0,OrdLine.Qty3),;
        Ord4   WITH Ord4   - IIF(OrdHdr.Status='B',0,OrdLine.Qty4),;
        Ord5   WITH Ord5   - IIF(OrdHdr.Status='B',0,OrdLine.Qty5),;
        Ord6   WITH Ord6   - IIF(OrdHdr.Status='B',0,OrdLine.Qty6),;
        Ord7   WITH Ord7   - IIF(OrdHdr.Status='B',0,OrdLine.Qty7),;
        Ord8   WITH Ord8   - IIF(OrdHdr.Status='B',0,OrdLine.Qty8),;
        TotOrd WITH TotOrd - IIF(OrdHdr.Status='B',0,OrdLine.TotQty)
UNLOCK
RETURN

*!*************************************************************
*! Name      : lfUpdtPoCT
*! Developer : Mohamed Shokry (MHM)
*! Date      : 11/01/2001
*! Purpose   : update selling price in po/ct lines
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Parameters: lcOrder	---> sales order no
*!             LcStyle  ---> Style COde
*!             lcLineNo ---> sales order line no
*!             lnTotQty ---> new qty
*!             lnPrice  ---> new price
*!             lnOldPrc ---> old price 
*!             lnOldQty ---> old qty
*!			   llRecDel ---> record is deleted (remove line)
*!*************************************************************
*! Returns   : None
*!*************************************************************
*! Example   : =lfUpdtPoCT()
*!*************************************************************
*!C200236,1
FUNCTION lfUpdtPoCT
PARAMETER  lcOrder,LcStyle,lcLineNo,lnQty,lnPrice,lnOldPrc,lnOldQty,llRecDel

=gfOpenFile(gcDataDir+'CUTPICK',gcDataDir+'CUTORD','SH')
=gfOpenFile(gcDataDir+'POSLN',gcDataDir+'POSLN','SH')
=gfOpenFile(gcDataDir+'CUTTKTL',gcDataDir+'CUTTKTLS','SH')
SELECT CUTPICK
IF SEEK('2'+lcOrder+lcLineNo)
  *-- there are a po generated from curr. sales order
  SCAN REST WHILE TranCd+Order+Cordline = '2'+LcOrder+lcLineNo
    lnGenQty   = TotQty					&& generated qty
    lnGenPerc  = TotQty/lnOldQty  		&& genereted percent
    lnCtktNo   = CtktNo					&& PO number
    lnTotQty   = INT(lnQty*lnGenPerc)     && new generated qty 
    IF SEEK('P'+lnCtktNo+lcStyle,'POSLN')	
      *-- new selling price = --> curr selling price * total qty
      *--                     --> - oldprice * old qty generated 
      *--					  --> + newprice * new generated qty
      *-- 					  --> / total qty - old qty generated + new generated qty
      IF llRecDel
        lnNewPrc = ((POSLN.nSelPrice*POSLN.TotQty)-(lnOldPrc*lnGenQty));
                   /(POSLN.TotQty-lngenqty)
      ELSE
        lnNewPrc = ((POSLN.nSelPrice*POSLN.TotQty)-(lnOldPrc*lnGenQty)+;
                    (lnPrice*lnTotQty)) / (POSLN.TotQty-lngenqty+lnTotQty)
      ENDIF
      lnNewPrc = IIF(BETWEEN(lnNewPrc,-999999999.99,999999999.99),lnNewPrc,0)
      =SEEK(STYLE,'STYLE')
      lnTotCost= nEcost1+nEcost2+nEcost3+nEcost4+nEcost5
      lnRotSub    = IIF(llStyMark,lnTotCost,lnNewPrc)
      lnGrosMrgn = IIF(lnRotSub=0,0,((lnNewPrc - lnTotCost)/lnRotSub)*100)
      REPLACE POSLN.nSelPrice  WITH lnNewPrc ,;
              POSLN.nGrosMrgn  WITH lnGrosMrgn
    ENDIF
  ENDSCAN  
ENDIF
SELECT CUTPICK
IF SEEK('1'+lcOrder+lcLineNo)
  *-- there are a CT generated from curr. sales order
  SCAN REST WHILE TranCd+Order+Cordline = '1'+LcOrder+lcLineNo
    lnGenQty   = TotQty					&& generated qty
    lnGenPerc  = TotQty/lnOldQty  		&& genereted percentg
    lnCtktNo   = CtktNo					&& PO number
    lnTotQty   = INT(lnQty*lnGenPerc)   && new generated qty 
    IF SEEK(lcStyle+lnCtktNo+'1','CUTTKTL')
      *-- new selling price = --> curr selling price * total qty
      *--                     --> - oldprice * old qty generated 
      *--					  --> + newprice * new generated qty
      *-- 					  --> / total qty - old qty generated + new generated qty
      IF llRecDel
        lnNewPrc = ((CUTTKTL.nSelPrice*CUTTKTL.TotQty)-(lnOldPrc*lnGenQty));
                   /(CUTTKTL.TotQty-lngenqty)
      ELSE
        lnNewPrc = ((CUTTKTL.nSelPrice*CUTTKTL.TotQty)-(lnOldPrc*lnGenQty)+;
                   (lnPrice*lnTotQty)) / (CUTTKTL.TotQty-lngenqty+lnTotQty)
      ENDIF
      lnNewPrc = IIF(BETWEEN(lnNewPrc,-999999999.99,999999999.99),lnNewPrc,0)
      =SEEK(STYLE,'STYLE')
      lnRotSub   = IIF(llStyMark,Style.TotCost,lnNewPrc)
      lnGrosMrgn = IIF(lnRotSub=0,0,((lnNewPrc - Style.TotCost)/lnRotSub)*100)
      REPLACE CUTTKTL.nSelPrice  WITH lnNewPrc ,;
              CUTTKTL.nGrosMrgn  WITH lnGrosMrgn
    ENDIF
  ENDSCAN
ENDIF

*!*************************************************************
*! Name      : lfSavPkTk
*! Developer : Mohamed Shokry (MHM)
*! Date      : 10/21/2001
*! Purpose   : Save Order Piktkt Information
*!*************************************************************
*! Calls     : 
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Returns   :  None.
*!*************************************************************
*! Example   :  =lfSavPkTk()
*!*************************************************************
*!C200236,1
FUNCTION lfSavPkTk
PARAMETER lcPikTktNo,lc_TmpOrdL
PRIVATE lcPikTktNo, lcChgPkTKt, lnCurTag ,llNotPiked,lnOldTag

*B606959,1 ASH 02/16/2003 (Begin) To make sure that this is the correct tag.
lnOldTag = 0
SELECT PikTkt
lnOldTag = INT(VAL(SYS(21)))
SET ORDER TO TAG OrdPik
*B606959,1 ASH 02/16/2003 (End)

SELECT ORDLINE
SET RELATION OFF INTO (lc_TmpOrdL)
lnCurTag = VAL(SYS(21))
SET ORDER TO TAG ORDLINE
SELECT (lc_TmpOrdL)
SET ORDER TO TAG ORDLINST
SET RELATION TO cOrdType+order+STR(lineno,6) INTO ORDLINE ADDITIVE
LOCATE

STORE ' ' TO lcChgPkTKt
STORE .F. TO llNotPiked
*--We initialize the variable as it is piked
llGenPkTk = .T.

SCAN
  SCATTER MEMVAR MEMO
  DO CASE
    CASE llGenPkTk  ;
      .AND. ORDLINE.PikTkt = REPLICATE("*",FSIZE("PIKTKT"))
      IF lcChgPkTKt <> m.Order + m.Store + m.cWareCode 
        lcChgPkTKt = m.Order + m.Store + m.cWareCode 
        lcPikTktNo = lfGetPkTkt(m.Order, laData[15], m.Store, m.cWareCode)
      ENDIF               
      IF !SEEK(m.Order + lcPikTktNo, 'PIKTKT')
        INSERT INTO PIKTKT;
             (Piktkt, Account, Store, Order, Date, cWareCode, CustPo, Status);
             VALUES;
            (lcPikTktNo, laData[2], m.Store, m.Order, gdSysDate, m.cWarecode,IIF(ORDHDR.MultiPO,Ordline.CustPo,ORDHDR.CustPo), 'O')            
        =gfAdd_Info('PIKTKT')
      ENDIF  

      *-- Update ORDLINE
      SELECT ORDLINE
      REPLACE PikTkt  WITH lcPikTktNo,;
      		  PikDate WITH PIKTKT.Date

    CASE Picked
      *-- If this is a new pick, generate a new picking ticket

      *C200236,4 if not available stoke [Start]
      *-- Update ORDLINE
      =lfStkAvail()
      IF &lc_TmpOrdL..TotPik = 0
        llNotPiked = .T.
        *--if no stoke avaialbe then ampty all
        SELECT ORDLINE
        REPLACE TotPik  WITH 0  ,;
                piktkt  WITH '' ,;
                pikdate WITH {},;
                Picked WITH .F. ,;
                Pik1   WITH 0,;
                Pik2   WITH 0,;
                Pik3   WITH 0,;
                Pik4   WITH 0,;
                Pik5   WITH 0,;
                Pik6   WITH 0,;
                Pik7   WITH 0,;
                Pik8   WITH 0
        
        *E126905,1 EIH 04/11/2005 [Begin] Case of picking .
        REPLACE cAllocatBy  WITH  IIF( TotPik > 0 , 'D' , ' ')
        *E126905,1 EIH 04/11/2005 [End]
        
        LOOP              
      ENDIF        

      *C200236,4 if not available stoke [End]
      IF ORDHDR.Multi = "Y" AND (lcChgPkTKt <> m.Order + m.Store + m.cWareCode)
        lcPikTktNo = ''
      ENDIF
      IF !ORDLINE.Picked AND EMPTY(lcPikTktNo)
        *-- Generate a different picking ticket per store/warehouse
        IF llGenPkTk 
          IF lcChgPkTKt <> m.Order + m.Store + m.cWareCode 
            lcChgPkTKt = m.Order + m.Store + m.cWareCode 
            lcPikTktNo = IIF(EMPTY(m.Piktkt),;
                         lfGetPkTkt(m.Order, laData[15], m.Store, m.cWareCode),;
                      m.PikTkt)
          ENDIF               
          IF !SEEK(m.Order + lcPikTktNo, 'PIKTKT')
            INSERT INTO PIKTKT;
            (Piktkt, Account, Store, Order, Date, cWareCode, CustPo, Status);
            VALUES;
            (lcPikTktNo, laData[2], m.Store, m.Order, gdSysDate, m.cWarecode,IIF(ORDHDR.MultiPO,Ordline.CustPo,ORDHDR.CustPo), 'O')                
            =gfAdd_Info('PIKTKT')
          ENDIF  
        ELSE
          lcPikTktNo = REPLICATE("*", FSIZE("PIKTKT","PIKTKT"))
    	  SET ORDER TO TAG PIKTKT IN PIKTKT
 	  	  IF !SEEK(lcPikTktNo, 'PIKTKT')
            INSERT INTO PIKTKT (Piktkt) VALUES (lcPikTktNo)
            =gfAdd_Info('PIKTKT')
          ENDIF  
          SET ORDER TO TAG ORDPIK IN PIKTKT
 	  	ENDIF
   	  ENDIF	
   	  
      *-- Update allocated and ordered quantities in STYDYE
      *-- Update Warehouse record in STYDYE file.
      SELECT STYDYE
      *B606324,1 RAE Fix the values of ALO1 to ALO8 fields in STYLE and STYDYE files. [start]      
      *IF SEEK(m.Style + laData[31] + SPACE(10))
      IF SEEK(m.Style + m.cWarecode + SPACE(10))
        *REPLACE Alo1   WITH MAX(Alo1 + IIF(Stk1-Alo1> ORDLINE.Pik1,ORDLINE.Pik1,Stk1-Alo1),0),;
                Alo2   WITH MAX(Alo2 + IIF(Stk2-Alo2> ORDLINE.Pik2,ORDLINE.Pik2,Stk2-Alo2),0),;
                Alo3   WITH MAX(Alo3 + IIF(Stk3-Alo3> ORDLINE.Pik3,ORDLINE.Pik3,Stk3-Alo3),0),;
                Alo4   WITH MAX(Alo4 + IIF(Stk4-Alo4> ORDLINE.Pik4,ORDLINE.Pik4,Stk4-Alo4),0),;
                Alo5   WITH MAX(Alo5 + IIF(Stk5-Alo5> ORDLINE.Pik5,ORDLINE.Pik5,Stk5-Alo5),0),;
                Alo6   WITH MAX(Alo6 + IIF(Stk6-Alo6> ORDLINE.Pik6,ORDLINE.Pik6,Stk6-Alo6),0),;
                Alo7   WITH MAX(Alo7 + IIF(Stk7-Alo7> ORDLINE.Pik7,ORDLINE.Pik7,Stk7-Alo7),0),;
                Alo8   WITH MAX(Alo8 + IIF(Stk8-Alo8> ORDLINE.Pik8,ORDLINE.Pik8,Stk8-Alo8),0),;
   		        TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                            Alo5 + Alo6 + Alo7 + Alo8
         
      REPLACE Alo1  WITH MAX(Alo1 + IIF(Stk1-Alo1> (ORDLINE.Pik1-laOldAlo[1]),(ORDLINE.QTY1-laOldAlo[1]),Stk1-Alo1),0),;
              Alo2  WITH MAX(Alo2 + IIF(Stk2-Alo2> (ORDLINE.Pik2-laOldAlo[2]),(ORDLINE.QTY2-laOldAlo[2]),Stk2-Alo2),0),;
              Alo3  WITH MAX(Alo3 + IIF(Stk3-Alo3> (ORDLINE.Pik3-laOldAlo[3]),(ORDLINE.QTY3-laOldAlo[3]),Stk3-Alo3),0),;
              Alo4  WITH MAX(Alo4 + IIF(Stk4-Alo4> (ORDLINE.Pik4-laOldAlo[4]),(ORDLINE.QTY4-laOldAlo[4]),Stk4-Alo4),0),;
              Alo5  WITH MAX(Alo5 + IIF(Stk5-Alo5> (ORDLINE.Pik5-laOldAlo[5]),(ORDLINE.QTY5-laOldAlo[5]),Stk5-Alo5),0),;
              Alo6  WITH MAX(Alo6 + IIF(Stk6-Alo6> (ORDLINE.Pik6-laOldAlo[6]),(ORDLINE.QTY6-laOldAlo[6]),Stk6-Alo6),0),;
              Alo7  WITH MAX(Alo7 + IIF(Stk7-Alo7> (ORDLINE.Pik7-laOldAlo[7]),(ORDLINE.QTY7-laOldAlo[7]),Stk7-Alo7),0),;
              Alo8  WITH MAX(Alo8 + IIF(Stk8-Alo8> (ORDLINE.Pik8-laOldAlo[8]),(ORDLINE.QTY8-laOldAlo[8]),Stk8-Alo8),0),;
   		      TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                          Alo5 + Alo6 + Alo7 + Alo8

      *B606324,1 RAE [end]
      ENDIF      
      *-- If dyelots, update dyelot record in STYDYE file
      *--laSetups[14,1] use dyelot Y/N

      *B606324,1 RAE Fix the values of ALO1 to ALO8 fields in STYLE and STYDYE files. [start]      
      *IF laSetups[14,1] = 'Y' .AND. STYLE.cDye_flg = 'Y' .AND.;
        SEEK(m.Style + laData[31] + ORDLINE.Dyelot, 'STYDYE')

      IF laSetups[14,1] = 'Y' .AND. STYLE.cDye_flg = 'Y' .AND.;
        SEEK(m.Style + m.cWarecode + ORDLINE.Dyelot, 'STYDYE')
        *REPLACE Alo1   WITH MAX(Alo1 + IIF(Stk1-Alo1> ORDLINE.Pik1,ORDLINE.Pik1,Stk1-Alo1),0),;
                Alo2   WITH MAX(Alo2 + IIF(Stk2-Alo2> ORDLINE.Pik2,ORDLINE.Pik2,Stk2-Alo2),0),;
                Alo3   WITH MAX(Alo3 + IIF(Stk3-Alo3> ORDLINE.Pik3,ORDLINE.Pik3,Stk3-Alo3),0),;
                Alo4   WITH MAX(Alo4 + IIF(Stk4-Alo4> ORDLINE.Pik4,ORDLINE.Pik4,Stk4-Alo4),0),;
                Alo5   WITH MAX(Alo5 + IIF(Stk5-Alo5> ORDLINE.Pik5,ORDLINE.Pik5,Stk5-Alo5),0),;
                Alo6   WITH MAX(Alo6 + IIF(Stk6-Alo6> ORDLINE.Pik6,ORDLINE.Pik6,Stk6-Alo6),0),;
                Alo7   WITH MAX(Alo7 + IIF(Stk7-Alo7> ORDLINE.Pik7,ORDLINE.Pik7,Stk7-Alo7),0),;
                Alo8   WITH MAX(Alo8 + IIF(Stk8-Alo8> ORDLINE.Pik8,ORDLINE.Pik8,Stk8-Alo8),0),;
      		    TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                                Alo5 + Alo6   + Alo7 + Alo8

      REPLACE Alo1  WITH MAX(Alo1 + IIF(Stk1-Alo1> (ORDLINE.Pik1-laOldAlo[1]),(ORDLINE.QTY1-laOldAlo[1]),Stk1-Alo1),0),;
              Alo2  WITH MAX(Alo2 + IIF(Stk2-Alo2> (ORDLINE.Pik2-laOldAlo[2]),(ORDLINE.QTY2-laOldAlo[2]),Stk2-Alo2),0),;
              Alo3  WITH MAX(Alo3 + IIF(Stk3-Alo3> (ORDLINE.Pik3-laOldAlo[3]),(ORDLINE.QTY3-laOldAlo[3]),Stk3-Alo3),0),;
              Alo4  WITH MAX(Alo4 + IIF(Stk4-Alo4> (ORDLINE.Pik4-laOldAlo[4]),(ORDLINE.QTY4-laOldAlo[4]),Stk4-Alo4),0),;
              Alo5  WITH MAX(Alo5 + IIF(Stk5-Alo5> (ORDLINE.Pik5-laOldAlo[5]),(ORDLINE.QTY5-laOldAlo[5]),Stk5-Alo5),0),;
              Alo6  WITH MAX(Alo6 + IIF(Stk6-Alo6> (ORDLINE.Pik6-laOldAlo[6]),(ORDLINE.QTY6-laOldAlo[6]),Stk6-Alo6),0),;
              Alo7  WITH MAX(Alo7 + IIF(Stk7-Alo7> (ORDLINE.Pik7-laOldAlo[7]),(ORDLINE.QTY7-laOldAlo[7]),Stk7-Alo7),0),;
              Alo8  WITH MAX(Alo8 + IIF(Stk8-Alo8> (ORDLINE.Pik8-laOldAlo[8]),(ORDLINE.QTY8-laOldAlo[8]),Stk8-Alo8),0),;
   		      TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                          Alo5 + Alo6 + Alo7 + Alo8

      *B606324,1 RAE [end]
	  ENDIF	  
      *-- Update the style  record in STYLE file.
      SELECT STYLE      
      *B606324,1 RAE Fix the values of ALO1 to ALO8 fields in STYLE and STYDYE files. [start]
      *REPLACE Alo1   WITH MAX(Alo1 + IIF(Stk1-Alo1> ORDLINE.Pik1,ORDLINE.Pik1,Stk1-Alo1),0),;
               Alo2   WITH MAX(Alo2 + IIF(Stk2-Alo2> ORDLINE.Pik2,ORDLINE.Pik2,Stk2-Alo2),0),;
               Alo3   WITH MAX(Alo3 + IIF(Stk3-Alo3> ORDLINE.Pik3,ORDLINE.Pik3,Stk3-Alo3),0),;
               Alo4   WITH MAX(Alo4 + IIF(Stk4-Alo4> ORDLINE.Pik4,ORDLINE.Pik4,Stk4-Alo4),0),;
               Alo5   WITH MAX(Alo5 + IIF(Stk5-Alo5> ORDLINE.Pik5,ORDLINE.Pik5,Stk5-Alo5),0),;
               Alo6   WITH MAX(Alo6 + IIF(Stk6-Alo6> ORDLINE.Pik6,ORDLINE.Pik6,Stk6-Alo6),0),;
               Alo7   WITH MAX(Alo7 + IIF(Stk7-Alo7> ORDLINE.Pik7,ORDLINE.Pik7,Stk7-Alo7),0),;
               Alo8   WITH MAX(Alo8 + IIF(Stk8-Alo8> ORDLINE.Pik8,ORDLINE.Pik8,Stk8-Alo8),0),;
      	       TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                           Alo5 + Alo6   + Alo7 + Alo8                      
 
      REPLACE Alo1  WITH MAX(Alo1 + IIF(Stk1-Alo1> (ORDLINE.Pik1-laOldAlo[1]),(ORDLINE.QTY1-laOldAlo[1]),Stk1-Alo1),0),;
              Alo2  WITH MAX(Alo2 + IIF(Stk2-Alo2> (ORDLINE.Pik2-laOldAlo[2]),(ORDLINE.QTY2-laOldAlo[2]),Stk2-Alo2),0),;
              Alo3  WITH MAX(Alo3 + IIF(Stk3-Alo3> (ORDLINE.Pik3-laOldAlo[3]),(ORDLINE.QTY3-laOldAlo[3]),Stk3-Alo3),0),;
              Alo4  WITH MAX(Alo4 + IIF(Stk4-Alo4> (ORDLINE.Pik4-laOldAlo[4]),(ORDLINE.QTY4-laOldAlo[4]),Stk4-Alo4),0),;
              Alo5  WITH MAX(Alo5 + IIF(Stk5-Alo5> (ORDLINE.Pik5-laOldAlo[5]),(ORDLINE.QTY5-laOldAlo[5]),Stk5-Alo5),0),;
              Alo6  WITH MAX(Alo6 + IIF(Stk6-Alo6> (ORDLINE.Pik6-laOldAlo[6]),(ORDLINE.QTY6-laOldAlo[6]),Stk6-Alo6),0),;
              Alo7  WITH MAX(Alo7 + IIF(Stk7-Alo7> (ORDLINE.Pik7-laOldAlo[7]),(ORDLINE.QTY7-laOldAlo[7]),Stk7-Alo7),0),;
              Alo8  WITH MAX(Alo8 + IIF(Stk8-Alo8> (ORDLINE.Pik8-laOldAlo[8]),(ORDLINE.QTY8-laOldAlo[8]),Stk8-Alo8),0),;
   		      TotAlo WITH Alo1 + Alo2 + Alo3 + Alo4 + ;
                          Alo5 + Alo6 + Alo7 + Alo8
      *B606324,1 RAE [end]        
      
      *-- Update ORDLINE
      SELECT ORDLINE
      lcCrPkTkt   = ORDLINE.PikTkt
      m.PikTkt = IIF(EMPTY(lcPikTktNo),lcCrPkTkt,lcPikTktNo)
      m.PikDate = IIF(m.PikTkt <> "******", PIKTKT.Date, gdSysDate)
      m.Start = laData[9]
      *C037816,1 MHM 04/06/2004 Svae data to Bin Location files[Start]
      IF llUseBin
        =lfALSAVAUT()
      ENDIF
      SELECT ORDLINE
      *C037816,1 MHM [End]
      GATHER MEMVAR MEMO
      *C200236,4 if not available stoke [Start]
      REPLACE PIK1   WITH &lcOrdLine..PIK1 ,;
              PIK2   WITH &lcOrdLine..PIK2 ,;
              PIK3   WITH &lcOrdLine..PIK3 ,;
              PIK4   WITH &lcOrdLine..PIK4 ,;
              PIK5   WITH &lcOrdLine..PIK5 ,;
              PIK6   WITH &lcOrdLine..PIK6 ,;
              PIK7   WITH &lcOrdLine..PIK7 ,;
              PIK8   WITH &lcOrdLine..PIK8 ,;
              TotPik WITH &lcOrdLine..TotPik
      *C200236,4 if not available stoke [End]
      *E126905,1 EIH 04/11/2005 [Begin] Case of picking .
      REPLACE cAllocatBy      WITH  IIF( TotPik > 0 , 'D' , ' ')
      *E126905,1 EIH 04/11/2005 [End]
      
  ENDCASE
ENDSCAN
*--200236,5 we Remove Message according to tomy mail [Start]
*IF llNotPiked
*  *--32099  massage : "There is no stock available for one or more sizes 
*  *--32099  on some lines. Cannot allocate these lines." 
*  *--32099                  <Ok>
*  = gfModalGen('QRM32099B00000','DIALOG','some lines'+"|"+'allocate these lines.')
*ENDIF
*200236,5 [end]
  *-- Restore relations
SELECT (lc_TmpOrdL)
SET RELATION TO
SET ORDER TO TAG ORDLINE
SELECT ORDLINE
SET RELATION TO cOrdType + Order + STR(LineNo,6) INTO (lc_TmpOrdL) ADDITIVE
SET ORDER TO (lnCurTag)
*B606959,1 ASH 02/16/2003 (Begin) Restore the original tag.
SELECT PikTkt
SET ORDER TO lnOldTag
*B606959,1 ASH 02/16/2003 (End)

SELECT ORDHDR

*!*************************************************************
*! Name      : lfBrowse
*! Developer : Mohamed Shokry (MHM)
*! Date      : 10/22/2001  
*! Purpose   : Browse PikTkt #
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Parameters: 
*!*************************************************************
*! Returns   :  None.
*!*************************************************************
*! Example   :  =lfBrowse()
*!*************************************************************
*!C200236,1
FUNCTION lfBrowse
PRIVATE lcBrFields,lcAlias,  lnStyOrd, lnAlias,laGtData,;
        lnBrHSRow1, lnBrHSCol1, lnBrHSRow2, lnBrHSCol2 ,lcPiktk
DECLARE laGtData[3] && array to get values from browse
laGtData     = ' '
llBrowse   = IIF(TYPE('llBrowse')='U',.F.,llBrowse) && variable to determine forcing browse or not
lnBrHSRow1 = gnBrFSRow1
lnBrHSCol1 = gnBrFSCol1
lnBrHSRow2 = gnBrHSRow1
lnBrHSCol2 = gnBrHSCol1
lcTitle    = "Orders/PikTkt "
STORE '' TO lcPiktk
lcBrFields = [PIKTKT :R :H= 'Piktkt#' , ACCOUNT :R :H= 'Account', STORE :R :H= 'Store' ,] +;
             [ORDER :R :H= 'Order' , DATE :R :H= 'Date', ] +;
             [CWARECODE :R :H= 'Location' , CUSTPO :R :H= 'Customer PO' , STATUS = IIF(STATUS = 'O' , 'Open' , IIF(STATUS = 'H' ,'On Hold',IIF(STATUS = 'C','Complete', IIF(STATUS = 'K','Packed','Pulled')))) :R :H= 'Status  ']

lnAlias    = SELECT()
*--get account and store
lcAccot = laData[2]
lcStore = laData[3]

SELECT PIKTKT
lcOldOrdFlt = FILTER()
SET RELATION TO 'O'+order INTO ORDHDR ADDITIVE

*B607116,1 ABD - Ignore piktkt that hold Complete and Canncel Status from the browse. [Begin]
*SET FILTER TO (lcAccot = ACCOUNT .AND. STORE=lcStore .AND. prtflag <> 'P' .AND. ;
*               ORDHDR.Multi <>'Y' .AND. Status<>'X' .AND. laData[15]=ALLTRIM(ORDHDR.cDivision))
*B607266,1 ABD - ignore piktkt = '******'. [Begin]
*SET FILTER TO (lcAccot = ACCOUNT .AND. STORE=lcStore .AND. prtflag <> 'P' .AND. ;
               ORDHDR.Multi <>'Y' .AND. !(Status $ 'XC') .AND. laData[15]=ALLTRIM(ORDHDR.cDivision))
SET FILTER TO (lcAccot = ACCOUNT .AND. STORE=lcStore .AND. prtflag <> 'P' .AND. ;
               ORDHDR.Multi <>'Y' .AND. !(Status $ 'XC') .AND. laData[15]=ALLTRIM(ORDHDR.cDivision) ;
               .AND. PIKTKT # '******' .AND. !EMPTY(PIKTKT))
*B607266,1 ABD - [End]
*B607116,1 ABD - [End]

LOCATE

IF EOF()
  SET FILTER TO &lcOldOrdFlt 
  SET RELATION OFF INTO ORDHDR 
  RETURN ''
ENDIF

llWasSel= ARIABROW([FOR ACCOUNT = lcAccot AND STORE =lcStore AND prtflag <> 'P'],lcTitle,;
          lnBrHSRow1, lnBrHSCol1, lnBrHSRow2, lnBrHSCol2,'','','PikTkt,ORDER',"laGtData")
IF llWasSel
  lcPiktk = laGtData[1]
  laData[1] = laGtData[2]
ELSE
  XDYELOT= SPACE(10)
ENDIF  
IF !EMPTY(lcPiktk)
  STORE .F. TO laScrMode
  laScrMode[3] = .T.
ENDIF

*--Restore old data
SET FILTER TO &lcOldOrdFlt 
SET RELATION OFF INTO ORDHDR 

IF !EMPTY(laData[1])
  SELECT OrdLine
  lcoldOrdr = ORDER()
  SET ORDER TO Ordlinst
  
  =SEEK('O'+laData[1] , 'OrdHdr')
  SELECT (lcOrdLine)
  lcOldOrd = ORDER()
  SET ORDER TO 
  lnRecNo = RECNO()
  LOCATE
  =SEEK(cordtype+laData[1]+store,'ORDLINE')
  laData[35] = laData[35] + OrdHdr.Book
  laData[36] = laData[36] + OrdHdr.BookAmt
  laData[41] = laData[41] + OrdHdr.Open
  laData[42] = laData[42] + OrdHdr.OpenAmt
  laData[5]  =  OrdHdr.STATUS
  lnLineNo   = OrdHdr.LastLine 
  m.piktkt   = ordline.piktkt 
  m.pikdate  = ordline.pikdate
  m.picked   = ordline.picked

  SCAN
    REPLACE Order   WITH laData[1] ,;
            LineNo  WITH lnLineNo+1 ,;
            piktkt  WITH ordline.piktkt ,;
            pikdate WITH ordline.pikdate,;
            picked  WITH ordline.picked
    lnLineNo = lnLineNo+1        
    IF SEEK(cordtype+order+store+style,'ORDLINE')
      =SEEK(cordtype+order,'ORDHDR')
      SCATTER MEMVAR MEMO
      m.qty1 = m.qty1+ordline.qty1
      m.qty2 = m.qty2+ordline.qty2
      m.qty3 = m.qty3 +ordline.qty3
      m.qty4 = m.qty4 +ordline.qty4
      m.qty5 = m.qty5 +ordline.qty5
      m.qty6 = m.qty6 +ordline.qty6
      m.qty7 = m.qty7 +ordline.qty7
      m.qty8 = m.qty8 +ordline.qty8
      m.Totqty   = m.Totqty +ordline.Totqty
      m.Book1    = m.Book1+ordline.Book1
      m.Book2    = m.Book2+ordline.Book2
      m.Book3    = m.Book3+ordline.Book3
      m.Book4    = m.Book4+ordline.Book4
      m.Book5    = m.Book5+ordline.Book5
      m.Book6    = m.Book6+ordline.Book6
      m.Book7    = m.Book7+ordline.Book7
      m.Book8    = m.Book8+ordline.Book8
      m.TotBook  = m.TotBook +ordline.TotBook
      m.LineNo   = ordline.LineNo
      GATHER MEMVAR MEMO
    ENDIF
    REPLACE Picked WITH .T. ,;
            PIK1   WITH QTY1    ,;
            PIK2   WITH QTY2    ,;
            PIK3   WITH QTY3    ,;
            PIK4   WITH QTY4    ,;
            PIK5   WITH QTY5    ,;
            PIK6   WITH QTY6    ,;
            PIK7   WITH QTY7    ,;
            PIK8   WITH QTY8    ,;
            TotPik WITH TotQTY  
  ENDSCAN
  SET ORDER TO &lcOldOrd
  GOTO lnRecNo
  SELECT OrdLine
  SET ORDER TO &lcoldOrdr
ELSE
  SELECT (lcOrdLine)
  
  lcOldOrd = ORDER()
  SET ORDER TO 
  lnRecNo = RECNO()
  LOCATE
  SCAN
    REPLACE PIK1   WITH QTY1    ,;
            PIK2   WITH QTY2    ,;
            PIK3   WITH QTY3    ,;
            PIK4   WITH QTY4    ,;
            PIK5   WITH QTY5    ,;
            PIK6   WITH QTY6    ,;
            PIK7   WITH QTY7    ,;
            PIK8   WITH QTY8    ,;
            TotPik WITH TotQTY  
  ENDSCAN
  SET ORDER TO &lcOldOrd
  GOTO lnRecNo
ENDIF

SELECT (lnAlias)
RETURN lcPiktk

*!*************************************************************
*! Name      : lfGetPkTkt                      
*! Developer : Mohamed Shokry (MHM)
*! Date      : 11/01/2001
*! Purpose   : Get a picking ticket for the sended order no.
*!*************************************************************
*! Calls      : None
*!*************************************************************
*! Passed parameters : lcOrdNo
*!*************************************************************
*! Returns           :  None
*!*************************************************************
*! Example           :  =lfGetPkTkt(lcOrdNo , OrdHdr.Division)
*!*************************************************************
*! Modifications     :
*!*************************************************************
*!C200236,1
FUNCTION lfGetPkTkt

PARAMETERS lcOrdNo , lcDivision , lcStore , lcWareCode , lnAskType

IF TYPE('lnAskType') $ 'UL' 
  lnAskType = 0
ENDIF

PRIVATE lcOrdNo   , lcDivision , lcCurAlias , lcPikTkt , ;
        llOpnPkTk , lnOldTag   , lnRecPkTk  , laPikNo  , lcExact , llAskUser

llAskUser = (lnAskType = 0)
*-- Save the exact setting.
lcExact = SET("EXACT")

*-- Define array hold the piktkts no. , status , printed or not.
DECLARE laPikNo[1]

*-- Save the current alias.
lnCurAlias = SELECT()

*-- Initialize the needed variables.
STORE ""  TO laPikNo , lcPikTkt
STORE .F. TO llOpnPkTk
STORE 0   TO lnOldTag   , lnRecPkTk

SELECT PikTkt
lnOldTag = INT(VAL(SYS(21)))
SET ORDER TO TAG OrdPik
*-- Save the current record no. if the file was open.
lnRecPkTk = RECNO("PikTkt")

SELECT PikTkt
IF SEEK(lcOrdNo , "PikTkt") 
  LOCATE REST WHILE Order = lcOrdNo;
         FOR !(PikTkt.Status $ "CX") .AND. ;
         Store = lcStore .AND. cWareCode = lcWareCode        
  IF FOUND()       

    *-- If there was any piktkts created for any of the 
    *-- current order lines.
    laPikNo[ALEN(laPikNo,1)] = Piktkt.piktkt + " " + ;
              IIF(Piktkt.prtflag="P","Yes","No ") + SPACE(5) + ;
              IIF(Piktkt.status $ "O ","Open   ",IIF(Piktkt.status="H" , "On hold" , SPACE(7))) + ;
              " " + DTOC(PikTkt.Date)
    SKIP
    IF EOF()
      SKIP -1
    ENDIF
    SCAN REST WHILE PikTkt.Order + PikTkt.PikTkt = lcOrdNo ;
                FOR !(PikTkt.Status $ "CX") .AND. Store = lcStore .AND. cWareCode = lcWareCode
   
      *-- Set excat to off.
      SET EXACT OFF
      IF ASCAN(laPikNo , PikTkt.PikTkt) = 0
      
        IF !EMPTY(laPikNo[ALEN(laPikNo,1)])
        
          DIMENSION laPikNo[ALEN(laPikNo,1)+1]

        ENDIF    && End of IF

        laPikNo[ALEN(laPikNo,1)] = Piktkt.piktkt + " " + ;
                IIF(Piktkt.prtflag="P","Yes","No ") + SPACE(5) + ;
                IIF(Piktkt.status $ "O ","Open   ",IIF(Piktkt.status="H" , "On hold" , SPACE(7))) + ;
                " " + DTOC(PikTkt.Date)
      ENDIF
      *-- Restore the excat setting.
      SET EXACT &lcExact
    ENDSCAN
    IF ALEN(laPikNo,1) > 1
      lsPikLst = 1
      
      IF llAskUser
        DO ALPIKLST.SPR
      ELSE && Add new pick tickt.
        =lfvGetPik(2)
      ENDIF
      
    ELSE
      *** There is Picking ticket no. : {laPikNo[1]}.     ***
      *** Do you wish to assign a new picking ticket no.? ***
      *** < Add > - < New > ***

      lnAskType = IIF(lnAskType=0,gfModalGen("TRM44011B44000","DIALOG" , SUBSTR(laPikNo[1],1,6)),lnAskType)
      
      IF lnAskType = 1
      
        lcPikTkT = SUBSTR(laPikNo[1],1,6)
      ELSE  
        lcPikTkT = gfSequence('PIKTKT', '', '', lcDivision)
      ENDIF
    ENDIF
  ELSE
    *-- If the order no. not found in the PikTkt file, create new piktkt.
    lcPikTkT = gfSequence('PIKTKT', '', '', lcDivision)
  ENDIF
ELSE
  *-- If the order no. not found in the PikTkt file, create new piktkt.
  lcPikTkT = gfSequence('PIKTKT', '', '', lcDivision)
ENDIF

  *-- If the file was opened in this session, close it.
SELECT PikTkt
SET ORDER TO lnOldTag
*-- File was opened in previous session, Set the opinter to th right record.
IF lnRecPkTk > 0 .AND. lnRecPkTk <= RECCOUNT("PikTkt")
  GOTO lnRecPkTk
ENDIF

*-- Restore the exact setting.
SET EXACT &lcExact
*-- Restore the old alias.
SELECT (lnCurAlias)
*-- Return with the selected picking ticket no.
RETURN lcPikTkt
*-- end of lfGetPkTkt. GFMOD


*!*************************************************************
*! Name      : lfStkAvail
*! Developer : Mohamed Shokry (MHM)
*! Date      : 11/01/2001
*! Purpose   : Check Stoke Availability
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Parameters: A picking ticket number
*!*************************************************************
*! Returns   :  None.
*!*************************************************************
*! Example   :  =lfStkAvail()
*!*************************************************************
*!C200236,4
FUNCTION lfStkAvail
PRIVATE lcStr, lnCurAlias , lnStkValue
PRIVATE lnCount &&Tmi 07/15/2002
STORE 0 TO lnStkAvail , lnStkValue

lnCurAlias = SELECT(0)
SELECT STYDYE
FOR lnCount = 1 TO SCALE.Cnt
  lcStr = STR(lnCount,1)
  lnStkValue = STYDYE.Stk&lcStr - STYDYE.Alo&lcStr + &lc_TmpOrdL..pik&lcStr
  
  IF lnStkValue <= 0 
    REPLACE &lc_TmpOrdL..pik&lcStr WITH 0 
  ELSE
    IF ( lnStkValue < OrdLine.pik&lcStr)  
      REPLACE &lc_TmpOrdL..pik&lcStr WITH lnStkValue 
    ELSE
      REPLACE &lc_TmpOrdL..pik&lcStr WITH OrdLine.pik&lcStr 
    ENDIF  

    lnStkAvail = lnStkAvail +&lc_TmpOrdL..pik&lcStr
  ENDIF
  
ENDFOR
REPLACE &lc_TmpOrdL..Totpik WITH lnStkAvail 

SELECT (lnCurAlias)

*!*************************************************************
*! Name      : lfToDoMbi
*! Developer : Ahmed Maher (AMH)
*! Date      : 01/28/2002
*! Purpose   : Run the To Do Screen after login the system
*!*************************************************************
*! Calls     : None
*!*************************************************************
*! Parameters: None
*!*************************************************************
*! Returns   : None.
*!*************************************************************
*! Example   : =lfToDoMbi()
*!*************************************************************
*!C200249,7
FUNCTION lfToDoMbi

IF !EMPTY(SYUUSER.CUSR_DCOM) .AND. !EMPTY(SYUUSER.CUSR_DMDL)
  =gfOpenFile(gcDataDir+'STYCRPLN',gcDataDir+'STYCRPUSER','SH')
  =gfOpenFile(gcSysHome+'SYSCHDUL',gcSysHome+'CSEQNUM','SH')
  =gfOpenFile(gcDataDir+'ORDHDR',gcSysHome+'ORDHDR','SH')
  =gfOpenFile(gcDataDir+'POSHDR',gcSysHome+'POSHDR','SH')
  =gfOpenFile(gcDataDir+'APVENDOR',gcSysHome+'VENCODE','SH')
  =gfOpenFile(gcDataDir+'CUSTOMER',gcSysHome+'CUSTOMER','SH')
  SELECT STYCRPLN
  IF SEEK(gcUser_ID)
    SCAN REST WHILE CUSER_ID+STYLE+CSTYTYPE+PO+CCRPTMPCOD+STR(NLINENO,4) = gcUser_ID
      IF cAdUsrSchd = 'N' .AND. EMPTY(dApproved) .AND.;
         BETWEEN(dRequired,gdSysDate,gdSysDate + SYUUSER.NPROMDAYS - 1)
        IF CSTYTYPE = 'P'
          =SEEK('P'+PO,'POSHDR')
          =SEEK(POSHDR.VENDOR,'APVENDOR')
        ELSE
          =SEEK('O'+PO,'ORDHDR')
          =SEEK('M'+ORDHDR.ACCOUNT,'CUSTOMER')
        ENDIF
        SELECT SYSCHDUL
        APPEND BLANK
        REPLACE CSEQNUMBER WITH gfSequence('CSEQNUMBER'),;
                CUSER_ID   WITH gcUser_ID,;
                CCONTTYPE  WITH IIF(STYCRPLN.CSTYTYPE='P','V','C'),;
                CCONT_ID   WITH IIF(STYCRPLN.CSTYTYPE='P',POSHDR.VENDOR,ORDHDR.ACCOUNT),;
                CONTACT    WITH IIF(STYCRPLN.CSTYTYPE='P',APVENDOR.CVENCOMP,CUSTOMER.STNAME),;
                CPHONE     WITH IIF(STYCRPLN.CSTYTYPE='P',APVENDOR.CPHONENO,CUSTOMER.PHONE1),;
                CTRANTYPE  WITH 'T',;
                DTRANDATE  WITH gdSysDate,;
                CTRANTIME  WITH gfGetTime(),;
                CCOMPLETED WITH 'N',;
                CCOMP_ID   WITH gcAct_Comp,;
                PO         WITH STYCRPLN.PO,;
                STYLE      WITH STYCRPLN.STYLE,;
                CCRPTHOPR  WITH STYCRPLN.CCRPTHOPR,;
                CTASKRESN  WITH 'Required by ' + DTOC(STYCRPLN.DREQUIRED)
        SELECT STYCRPLN
        REPLACE CADUSRSCHD WITH 'Y',;
                CSEQNUMBER WITH SYSCHDUL.CSEQNUMBER
      ENDIF
      IF !EMPTY(dApproved) .AND. !EMPTY(cSeqNumber) .AND. SEEK(cSeqNumber,'SYSCHDUL')
        REPLACE SYSCHDUL.CCOMPLETED WITH 'Y'
      ENDIF
    ENDSCAN
  ENDIF
  USE IN STYCRPLN
  USE IN SYSCHDUL
  USE IN ORDHDR
  USE IN POSHDR
  USE IN APVENDOR
  USE IN CUSTOMER
  =gfOpenFile(gcSysHome+'SYCMENU',gcSysHome+'PROSS_ID','SH')
  IF SEEK('TASKLST   ')
    DO gpMenuBar WITH CMSTR_NAM , VAL(CBAR_POS)
  ENDIF
  USE IN SYCMENU
ENDIF
*--end of lfToDoMbi

*!***************************************************************
*! Name      : lfUpdDyelt  
*! Developer : Hend Ghanem (HBG)
*! Date      : 03/18/2002
*! Purpose   : Update Dyelot field in ORDLINE
*!***************************************************************
*!C200285,1
FUNCTION lfUpdDyelt

*--- setting in IC Module 'Dyelots used'
IF (gfGetMemVar('M_DYELOT') = 'Y') 
  m.Dyelot = ""
  *B606087,1 TMI [Start] Assure that Dyelot entred last is returned
  *SELECT Dyelot , MAX(Dadd_Date) FROM STYDYE WHERE Style + cWarecode + Dyelot =;
                                                   m.Style + laData[31];
                                             .AND. TotStk > 0 INTO ARRAY laDyelot
  RELEASE laDyelot
  SELECT Dyelot FROM STYDYE WHERE Style + cWarecode + Dyelot = ;
                                  m.Style + laData[31] .AND. !EMPTY(Dyelot) .AND. TotStk > 0 ;
                                  ORDER BY Dadd_Date DESC INTO ARRAY laDyelot
  *B606087,1 TMI [End  ]                                              
  IF TYPE('laDyelot[1,1]') <> "U"
    m.Dyelot = laDyelot[1,1]
  ENDIF  
ENDIF

*:**************************************************************************
*:* Name        : lfQkOrdEnt                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/17/2002
*:* Purpose     : Open Quick order entry screen
*:***************************************************************************
*:* Called from : soord
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfQkOrdEnt()
*:***************************************************************************
FUNCTION lfQkOrdEnt
PRIVATE laSize,laTot,m.Style,m.TotQty,m.Desc1,m.Gros_Price,m.Disc_Pcnt,m.Price,m.Comm1,;
        lcScrTtl,lcDet_Ttl,lnClrLen,lnClrPos,lcTempCur,lcTempNote,lcAlias,lnDMarker ,;
        lcQkWin0,lcQkWin1,lcQkWin2,lcQkWin3,lcOldValue,lcSepart,lcItemPct,laExtSz,lcOrd,llEdit,;
        llChang,laStyClQty,llDifPrice

*-- laSize   :Array to Hold Sizes descriptions for the current style scale
*-- laTot    :Array to hold Column sum and nTotal field sum
*-- m.Style  :Style
*-- m.TotQty :Total qty - check qty
*-- m.Desc1  :Description
*-- m.Gros_Price:Gross price
*-- m.Disc_Pcnt :Dicount percent
*-- m.Price
*-- m.Comm1
*-- lcScrTtl
*-- lcDet_Ttl
*-- lnClrLen
*-- lnClrPos
*-- lcTempCur
*-- lcTempNote
*-- lcAlias
*-- lnDMarker
*-- lcQkWin0
*-- lcQkWin1
*-- lcQkWin2
*-- lcQkWin3
*-- lcOldValue
*-- lcSepart
*-- lcItemPct
*-- laExtSz
*-- lcOrd
*-- llEdit
*-- llChang        
*-- laStyClQty : Array hold Style-Color Qty - usefull in edited styles, 0 in added ones
        
SELECT (lcOrdLine)
SCATTER MEMVAR BLANK
DIMENSION laSize[16],laTot[1,2],laExtSz[1,2],laStyClQty[1,3]
STORE '' TO laSize,lcOldValue
STORE 0 TO laTot,lnClrLen,lnClrPos,m.Gros_Price,m.Price,m.Disc_Pcnt
STORE 1 TO lnDMarker
STORE .F. TO llEdit,llChang,llDifPrice
lcItemPct = gfItemMask('PI')
lcSepart  = SUBSTR(lcItemPct,lnMajorLen+1,1)
*-- Get color position and color length 
=lfGetClrD()

lcScrTtl  = 'Quick Sales Order Entry Screen.'
lcDet_Ttl = 'Quick Lines entry screen'

lcQkWin0    = gftempname()     &&Temp name for Windows.
lcQkWin1    = gftempname()     &&Temp name for Windows.
lcQkWin2    = gftempname()     &&Temp name for Windows.
lcQkWin3    = gftempname()     &&Temp name for Windows.
lcTempCur   = gfTempName()     && Cursor holds qty /color/size
lcTempNote  = gfTempName()     && Cursor holds Notes

PUSH KEY
 
ON KEY LABEL ALT+B ACTIVATE WINDOW (lcDet_Ttl)
*B606386,1 ABD - Close the local tab and let the standered tab work. [Begin]
*ON KEY LABEL TAB   DO lptab 
*B606386,1 ABD - [End]

ON KEY LABEL BACKTAB DO lpBacktab 

lcAlias = SELECT(0)

lcOrd = ORDER(lcOrdLine)   
SET ORDER TO ORDLINST IN (lcOrdLine)
*--CORDTYPE+ORDER+STORE+STYLE+STR(LINENO,6)

*-- Create temp files
=lfCrtTmp()   
DO (gcScrDir+'SO\QuickOrd.SPX')
POP KEY

SELECT (lcOrdLine)
SET ORDER TO &lcOrd IN (lcOrdLine)
GO BOTTOM

SELECT (lcAlias)
*-- end of lfQkOrdEnt.

*:**************************************************************************
*:* Name        : lfCrtTmp                                     *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/20/2002
*:* Purpose     : Create temp file to browse
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfCrtTmp()
*:***************************************************************************
FUNCTION lfCrtTmp
PRIVATE lnCount

CREATE TABLE (gcWorkDir+lcTempNote) (NOTE_MEM M)
APPEND BLANK

CREATE TABLE (gcWorkDir+lcTempCur) (LASTLINE C(1),STYMAJOR C(lnMajorLen),COLOR C(6),COLORDSC C(20),SZ1 N(5),;
             SZ2 N(5),SZ3 N(5),SZ4 N(5),SZ5 N(5),SZ6 N(5),SZ7 N(5),SZ8 N(5),SZ9 N(5),SZ10 N(5),;
             SZ11 N(5),SZ12 N(5),SZ13 N(5),SZ14 N(5),SZ15 N(5),SZ16 N(5),NTOTAL N(6))
INDEX ON LASTLINE+STYMAJOR+COLOR TAG (lcTempCur)

*-- end of lfCrtTmp.

*:**************************************************************************
*:* Name        : lfBrowLine                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/20/2002
*:* Purpose     : Browse Line fn
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfBrowLine()
*:***************************************************************************
FUNCTION lfBrowLine
PARAMETERS llGoTop

SELECT (lcTempCur)
IF llGoTop
  GO TOP
ENDIF  
  
lnDMarker  = RECNO()
lcBrowFlds = "cMarker =IIF(RECNO()=lnDMarker ,'>',' '):H=' ':R:1:W=.F.,"+;
             "COLORDSC :R :H=PADC('Colours',16) :W=.F.,"+;              
             "SZ1  :H=laSize[1]:"+lfLen(1) +":P='9999':V=lfvqFld('1'):W=lfwqFld(1),"+;
             IIF(EMPTY(laSize[2]),'',"SZ2  :H=laSize[2]:"+lfLen(2) +":P='9999':V=lfvqFld('2'):W=lfwqFld(2),")+;
             IIF(EMPTY(laSize[3]),'',"SZ3  :H=laSize[3]:"+lfLen(3) +":P='9999':V=lfvqFld('3'):W=lfwqFld(3),")+;
             IIF(EMPTY(laSize[4]),'',"SZ4  :H=laSize[4]:"+lfLen(4) +":P='9999':V=lfvqFld('4'):W=lfwqFld(4),")+;
             IIF(EMPTY(laSize[5]),'',"SZ5  :H=laSize[5]:"+lfLen(5) +":P='9999':V=lfvqFld('5'):W=lfwqFld(5),")+;
             IIF(EMPTY(laSize[6]),'',"SZ6  :H=laSize[6]:"+lfLen(6) +":P='9999':V=lfvqFld('6'):W=lfwqFld(6),")+;
             IIF(EMPTY(laSize[7]),'',"SZ7  :H=laSize[7]:"+lfLen(7) +":P='9999':V=lfvqFld('7'):W=lfwqFld(7),")+;
             IIF(EMPTY(laSize[8]),'',"SZ8  :H=laSize[8]:"+lfLen(8) +":P='9999':V=lfvqFld('8'):W=lfwqFld(8),")+;
             IIF(EMPTY(laSize[9]),'',"SZ9  :H=laSize[9]:"+lfLen(9) +":P='9999':V=lfvqFld('9'):W=lfwqFld(9),") 
lcBrowFlds = lcBrowFlds +;
             IIF(EMPTY(laSize[10]),'',"SZ10 :H=laSize[10]:"+lfLen(10)+":P='9999':V=lfvqFld('10'):W=lfwqFld(10),")+;   
             IIF(EMPTY(laSize[11]),'',"SZ11 :H=laSize[11]:"+lfLen(11)+":P='9999':V=lfvqFld('11'):W=lfwqFld(11),")+;
             IIF(EMPTY(laSize[12]),'',"SZ12 :H=laSize[12]:"+lfLen(12)+":P='9999':V=lfvqFld('12'):W=lfwqFld(12),")+;
             IIF(EMPTY(laSize[13]),'',"SZ13 :H=laSize[13]:"+lfLen(13)+":P='9999':V=lfvqFld('13'):W=lfwqFld(13),")+;
             IIF(EMPTY(laSize[14]),'',"SZ14 :H=laSize[14]:"+lfLen(14)+":P='9999':V=lfvqFld('14'):W=lfwqFld(14),")+;
             IIF(EMPTY(laSize[15]),'',"SZ15 :H=laSize[15]:"+lfLen(15)+":P='9999':V=lfvqFld('15'):W=lfwqFld(15),")+;
             IIF(EMPTY(laSize[16]),'',"SZ16 :H=laSize[16]:"+lfLen(16)+":P='9999':V=lfvqFld('16'):W=lfwqFld(16),")+;
             "NTOTAL :H='Total':R :P='999999'"

BROWSE FIELDS &lcBrowFlds;
       NOAPPEND ;
       NOCLEAR  ;
       NODELETE ;
       NOMENU   ;
       NOWAIT   ;
       SAVE     ;
       VALID :F lfvqBrow();       
       WHEN lfwBrowUp();
       TITLE lcDet_Ttl ;
       WINDOW (lcQkWin2) IN WINDOW (lcQkWin0)

*--- Notes
=lfRefresh(lcQkWin0)
=lfRefresh(lcDet_Ttl)

*-- end of lfBrowLine.

*:**************************************************************************
*:* Name        : lfwqFld                                         *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : When fn. for fields in temp browse
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfwqFld()
*:***************************************************************************
FUNCTION lfwqFld
PARAMETERS lnIndex
PRIVATE lcIndex
lcIndex = ALLTRIM(STR(lnIndex))
lcOldValue = SZ&lcIndex
*RETURN EMPTY(LASTLINE)
*-- end of lfwqFld.

*:**************************************************************************
*:* Name        : lfvqFld                                       *C200358,1
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : Valid fn. for fields in temp browse
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqFld()
*:***************************************************************************
FUNCTION lfvqFld
PARAMETERS lcIndex
PRIVATE lnLineTot,lnCount,lnRecno,m.AddSty,lnIncrm

SELECT (lcTempCur)
IF lcOldValue #  SZ&lcIndex
  *C200358,4 TMI [Start] Prevent update totals in total field
  IF !EMPTY(LASTLINE)
    REPLACE SZ&lcIndex WITH lcOldValue
    RETURN
  ENDIF
  *C200358,4 TMI [End  ] 

  IF SZ&lcIndex < 0
    *--Can not accept negative values
    =gfModalGen('TRM42000B40011','DIALOG')
    REPLACE SZ&lcIndex WITH lcOldValue
    RETURN
  ENDIF
  IF SZ&lcIndex > 999
    *--Can not exceed 999
    *-- 40171 :  cannot exceeds   
    =gfModalGen('TRM40171B00000','DIALOG','Size Quantity|999.')
    REPLACE SZ&lcIndex WITH lcOldValue
    RETURN
  ENDIF

  m.AddSty = STYMAJOR+lcSepart+SUBSTR(COLOR,1,lnClrLen)
  SELECT (lcTempCur)
  *-- Assign a style to a location if not
  lnIncrm = 0
  FOR lnCount = 1 TO ALEN(laExtSz,1)    
    IF lnIncrm<VAL(lcIndex) AND VAL(lcIndex)<=lnIncrm+laExtSz[lnCount,2]
      EXIT
    ENDIF
    lnIncrm = lnIncrm + laExtSz[lnCount,2]
  ENDFOR
  IF laSetups[5,2]='Y' .AND. !SEEK(m.AddSty+laExtSz[lnCount,1]+laData[31]+SPACE(10),'StyDye')
    *E300408,1 Message : 40012
    *E300408,1 Style/color xxx is not assigned to warehouse xxx
    *E300408,1 Button : 40002
    *E300408,1 Add Reenter
    IF gfModalGen('QRM40012B40002','ALERT',TRIM(m.AddSty+laExtSz[lnCount,1])+'|'+TRIM(laData[31]))=1
      DO gpAdStyWar WITH m.AddSty+laExtSz[lnCount,1],SPACE(10),laData[31]
    ELSE      
      REPLACE SZ&lcIndex WITH 0
      KEYBOARD '{LEFTARROW}'
      RETURN
    ENDIF
  ENDIF
  
  lnLineTot = 0 
  *--Line Total
  FOR lnCount = 1 TO 16
    lcCount = ALLTRIM(STR(lnCount))
    lnLineTot = lnLineTot + SZ&lcCount
  ENDFOR
  REPLACE NTOTAL WITH lnLineTot
  
  *-- Column and All Totals
  SELECT SUM(SZ&lcIndex),SUM(NTOTAL) FROM (lcTempCur) WHERE EMPTY(LASTLINE) INTO ARRAY laTot
  lnRecno = RECNO()
  GO BOTTOM
  REPLACE SZ&lcIndex WITH laTot[1,1],;
          NTOTAL     WITH laTot[1,2]

  llChang = .T.
  IF BETWEEN(lnRecno,1,RECCOUNT()-1)
    GOTO (lnRecno)
  ELSE
    GO TOP
  ENDIF  

  lcSavStat = IIF(llEdit OR laTot[1,2]>0,'ENABLE','DISABLE')
  SHOW GET pbSav &lcSavStat

ENDIF  
*-- end of lfvqFld.

*:**************************************************************************
*:* Name        : lfLen                                       *C200358,1
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : Return the width of the column
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfLen()
*:***************************************************************************
FUNCTION lfLen
PARAMETERS lnIndex
PRIVATE lnRet 
lnRet = IIF( LEN(laSize[lnIndex])<3 , 3 , LEN(laSize[lnIndex])+1 )
RETURN STR(lnRet,1)+IIF(!EMPTY(LASTLINE),":R ","")

*-- end of lfLen.

*:**************************************************************************
*:* Name        : lfvqBrow                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/20/2002
*:* Purpose     : Valid function for browse
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqBrow()
*:***************************************************************************
FUNCTION lfvqBrow
IF WONTOP() # lcDet_Ttl
  = gfStopBrow()
ENDIF

*:**************************************************************************
*:* Name        : lfwBrowUp                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/20/2002
*:* Purpose     : When function for browse
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfwBrowUp()
*:***************************************************************************
FUNCTION lfwBrowUp

lnDMarker = RECNO(lcTempCur)
SHOW WINDOW (lcDet_Ttl) REFRESH
*-- end of lfwBrowUp.

*:**************************************************************************
*:* Name        : lpTab                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/23/2002
*:* Purpose     : Tab fn.
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lpTab()
*:***************************************************************************
PROCEDURE lpTab

IF WONTOP() = lcDet_Ttl
  ACTIVATE WINDOW (lcQkWin3)
  _CUROBJ=OBJNUM(pbSav)  
ELSE
  _CUROBJ=_CUROBJ+1
ENDIF

*:**************************************************************************
*:* Name        : lpBacktab                                       *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : Backtab Trap fn.
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lpBacktab ()
*:***************************************************************************
FUNCTION lpBacktab 
IF RECCOUNT(lcTempCur) = 0
  DO CASE
    CASE WONTOP() = lcDet_Ttl
      ACTIVATE WINDOW (lcQkWin1)
    CASE WONTOP() = lcQkWin1
      ACTIVATE WINDOW (lcQkWin3)             
    CASE WONTOP() = lcQkWin3 
      ACTIVATE WINDOW (lcDet_Ttl)
  ENDCASE
ELSE
  IF WONTOP() = lcDet_Ttl
    ACTIVATE WINDOW (lcQkWin1)
    _CUROBJ=OBJNUM(m.Comm1)
  ELSE
    DO CASE
      CASE WONTOP() = lcQkWin1
        IF _CUROBJ = OBJNUM(m.TotQty)
          ACTIVATE WINDOW (lcQkWin3)
          _CUROBJ = OBJNUM(pbExit)
        ELSE
          IF llDifPrice
            IF _CUROBJ = OBJNUM(m.Comm1)
              _CUROBJ = OBJNUM(m.TotQty)
            ENDIF
            IF _CUROBJ = OBJNUM(m.TotQty)
              ACTIVATE WINDOW (lcQkWin3)
              _CUROBJ = OBJNUM(pbExit)             
            ENDIF
          ELSE
            _CUROBJ=_CUROBJ - 1
          ENDIF
        ENDIF
        
      CASE WONTOP() = lcQkWin3
        IF laTot[1,2]=0
          IF _CUROBJ = OBJNUM(pbClear)
            ACTIVATE WINDOW (lcDet_Ttl)
          ELSE
            _CUROBJ = OBJNUM(pbSav)
          ENDIF
        ELSE
          IF _CUROBJ = OBJNUM(pbSav)
            ACTIVATE WINDOW (lcDet_Ttl)
          ELSE
            _CUROBJ=_CUROBJ - 1
          ENDIF
        ENDIF
        
    ENDCASE
  ENDIF
ENDIF  
*-- end of lpBacktab .

*:**************************************************************************
*:* Name        : lfvClear                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/18/2002
*:* Purpose     : Clear valid fucntio for screen QkOrdEnt
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvClear()
*:***************************************************************************
FUNCTION lfvClear

STORE ' ' TO m.Style,m.Desc1,laSize
STORE 0  TO m.Price,m.TotQty,m.Disc_Pcnt,m.Gros_Price,m.Comm1,laTot
STORE  .F. TO llEdit,llChang

SHOW GET m.Style ENABLE 
SHOW GET m.Desc1 DISABLE
SHOW GET m.Price DISABLE
SHOW GET m.TotQty DISABLE
SHOW GET m.Disc_Pcnt DISABLE
SHOW GET m.Gros_Price DISABLE
SHOW GET m.Comm1 DISABLE
SHOW GET pbNote DISABLE
SHOW GET pbClear DISABLE
SHOW GET pbSav   DISABLE
_CUROBJ = OBJNUM(m.Style)

*--Clear notes
SELECT (lcTempNote)
REPLACE NOTE_MEM WITH ''

SELECT (lcTempCur)
ZAP   
=lfBrowLine()

*-- end of lfvClear.


*:**************************************************************************
*:* Name        : lfvQStyle                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/18/2002
*:* Purpose     : Valid funciton for m.QStyle field
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvQStyle()
*:***************************************************************************
FUNCTION lfvQStyle
PRIVATE lcAlias,lcGetSty,lcStat,lnIncrmnt,lnClrs,lnCount,lnJ,lcSeekSty,laSum,laSavStat,lcStyle
*--- Select
lcAlias = ALIAS()

IF MDOWN() .AND. !llBrowse
  RETURN
ENDIF

m.Style = PADR(ALLT(m.Style),lnMajorLen)


IF !EMPTY(m.Style) AND ('?' $ m.Style .OR. !SEEK(m.Style,'STYLE')))
  SELECT STYLE  
  lcGetSty = PADR(gfStyBrw("M" , m.Style , "" , .F.),lnMajorLen)
  llBrowse = .F.
  IF EMPTY(lcGetSty)
    m.Style = lcOldvalue
    _CUROBJ = OBJNUM(m.Style) 
    RETURN
  ELSE
    m.Style = lcGetSty
  ENDIF
ENDIF  

IF SEEK(m.Style,'Style')
  *E300408,1 Message : 32017
  *E300408,1 Style scale not found in the scale file. Cannot accept.
  *E300408,1 Button : 00000 
  *E300408,1 Ok

  *E300408,1 Message : 32018
  *E300408,1 This is a canceled style. Cannot accept.
  *E300408,1 Button : 00000 
  *E300408,1 Ok

  *E300408,1 Message : 32019
  *E300408,1 This style/color is on hold. 
  *E300408,1 Button : 32003
  *E300408,1 Accept Reenter

  *E300408,1 Message : 32020
  *E300408,1 Styles restricted to XXX!
  *E300408,1 Button : 00000
  *E300408,1 Ok

  *E300408,1 Message : 32021
  *E300408,1 Style XXX date is 
  *E300408,1 Button : 32003
  *E300408,1 Accept Reenter

  *B122433,1  TMI [Start] Add season check
  *IF (!SEEK('S'+Style.Scale,'Scale') .AND. ;
  *      gfModalGen('TRM32017B00000','ALERT')=1) ;
  * .OR. (Style.Status='X' .AND. ;
  *      gfModalGen('TRM32018B00000','ALERT')=1) ;
  * .OR. (Style.Status='H' .AND. ;
  *      gfModalGen('QRM32019B32003','ALERT')=2) ;
  * .OR. (Style.cDivision <> laData[15] .AND. ;
  *      gfModalGen('TRM32020B00000','ALERT','division '+ALLTRIM(laDivision[lnDivision,1]))=1) ;
  * .OR. (!EMPTY(Style.Start) .AND. Style.Start > laData[9] .AND. ;
  *      gfModalGen('QRM32021B32003','ALERT','start|'+DTOC(Style.Start))=2) ;
  * .OR. (!EMPTY(Style.SoldOut) .AND. Style.SoldOut < laData[9] .AND. ;
  *      gfModalGen('QRM40010B40001','ALERT','sold out|'+DTOC(Style.SoldOut))=2)  
  IF (!SEEK('S'+Style.Scale,'Scale') .AND. ;
        gfModalGen('TRM32017B00000','ALERT')=1) ;
   .OR. (Style.Status='X' .AND. ;
        gfModalGen('TRM32018B00000','ALERT')=1) ;
   .OR. (Style.Status='H' .AND. ;
        gfModalGen('QRM32019B32003','ALERT')=2) ;
   .OR. (Style.cDivision <> laData[15] .AND. ;
        gfModalGen('TRM32020B00000','ALERT','division '+ALLTRIM(laDivision[lnDivision,1]))=1) ;
   .OR. (!EMPTY(Style.Start) .AND. Style.Start > laData[9] .AND. ;
        gfModalGen('QRM32021B32003','ALERT','start|'+DTOC(Style.Start))=2) ;
   .OR. (!EMPTY(Style.SoldOut) .AND. Style.SoldOut < laData[9] .AND. ;
        gfModalGen('QRM40010B40001','ALERT','sold out|'+DTOC(Style.SoldOut))=2) ;
   .OR. IIF(ASCAN(laEvntTrig , PADR('STYLEVALID',10)) <> 0 AND TYPE('laSetups[15,2]')='L' AND laSetups[15,2] = .F.,.F.,(ALLTRIM(laData[14])<>'*' AND TRIM(Style.Season)<>'Y' AND Style.Season<>laData[14] .AND. ;
        gfModalGen('TRM32020B00000','ALERT','season '+ALLTRIM(laSeasons[lnSeason,1]))=1))        
  *B122433,1  TMI [End  ]  Add season check
  
    STORE lcOldvalue TO m.Style
    _CUROBJ = OBJNUM(m.Style)
    RETURN
  ENDIF
  
  *--Get style price according to ordered quantity
  PUSH KEY
  ON KEY
  m.lContract = lcOrdType<>'C' .AND. lfvContPri(m.Style,'m.Gros_Price','m.Price','m.Disc_Pcnt')
  IF !m.lContract
    lcStyle = STYLE.STYLE
    m.Gros_Price = MAX( lfGetprice(lcStyle,lcPriceLvl,m.TotQty) , 0 )
  ENDIF
  POP KEY

  m.Price    = m.Gros_Price
  m.Desc1    = Style.Desc1
  m.Comm1    = IIF(Style.Commission,laData[28],0)   &&The first commession 
  
  *-- Get Style discount percent and Calculate net price  
  IF !m.lContract
    *-- get the cDiscCode From stydye in every case
    lcDiscCode  = IIF(SEEK(m.Style+laData[31]+SPACE(10),'StyDye'),StyDye.cDiscCode,'')
    m.Disc_Pcnt = 0 
    IF !EMPTY(ALLTRIM(lcDiscCode))
      *-- Get the disecound related filed to now which 
      *-- type whole Sale Or Retail sale Or Both.
      DECLARE laDisType[1,2] , lastartDte[1,2] , laEndDate[1,2]
      STORE '' To lcDisType , ldstartDte ,ldEndDate
      *-- Array to get the Discount affect for DecCode.
      laDisType[1,1]  = 'CCOSTAFECT'
      laDisType[1,2]  = 'lcDisType'
      *-- Array to get the start date For DescCode.
      lastartDte[1,1] = 'START'
      lastartDte[1,2] = 'ldstartDte'
      *-- Array to get the end date For DescCode.
      laEndDate[1,1]  = 'DENDATE'
      laEndDate[1,2]  = 'ldEndDate'
      = gfRltFld(lcDiscCode , @laDisType, 'CDISCCODE')
      = gfRltFld(lcDiscCode, @lastartDte, 'CDISCCODE')
      = gfRltFld(lcDiscCode , @laEndDate, 'CDISCCODE')
      lnDisc_Pcnt = 0
      IF ALLTRIM(lcDisType) <> 'R' .AND. BETWEEN(laData[8],ldstartDte,ldEndDate)
        lnDisc_Pcnt = m.Disc_Pcnt
        =gfRltFld(lcDiscCode,@laDisRltFld,'CDISCCODE')
        m.Disc_Pcnt = lnDisc_Pcnt
      ENDIF
    ENDIF  
    m.Price     = m.Gros_Price*(100-m.Disc_Pcnt)/100  
  ENDIF 

  *C200358,4 TMI [Start] Show if there are more than one price for each scale
  PRIVATE laPrices,lcStyClr
  SELECT STYLE  
  lcStyClr = SUBSTR(STYLE,1,16)
  IF !llMulCurr .OR. laData[33]=gcBaseCurr
    SCATTER FIELDS PRICEA,PRICEB,PRICEC TO laPrices
    SCAN REST WHILE STYLE = lcStyClr
      llDifPrice = PRICEA <> laPrices[1] .OR. ;
                   PRICEB <> laPrices[2] .OR. ;
                   PRICEC <> laPrices[3]
      IF llDifPrice
        EXIT
      ENDIF             
      SCATTER FIELDS PRICEA,PRICEB,PRICEC TO laPrices             
    ENDSCAN
  ELSE
    SELECT STYPRICE
    LOCATE FOR STYLE=lcStyClr .AND. CCURRCODE = laData[33]
    SCATTER FIELDS PRICEA,PRICEB,PRICEC TO laPrices
    SCAN REST WHILE STYLE = lcStyClr FOR CCURRCODE = laData[33]
      llDifPrice = PRICEA <> laPrices[1] .OR. ;
                   PRICEB <> laPrices[2] .OR. ;
                   PRICEC <> laPrices[3]
      IF llDifPrice
        EXIT
      ENDIF             
      SCATTER FIELDS PRICEA,PRICEB,PRICEC TO laPrices             
    ENDSCAN
  ENDIF
  *C200358,4 TMI [End  ] Show if there are more than one price for each scale 
  
  ************************************************  
  
  lcStat = IIF(!EMPTY(m.Style),'ENABLE','DISABLE')
  SHOW GET pbClear &lcStat  
  
  *--Get Sizes  
  laSize = ''
  =SEEK(m.Style,'STYLE')
  lnScaleLen = gfGetMemVar('M_EXTWIDTH')     && Extended size Scale ID Length.
  m.SCALE = STYLE.SCALE
  SELECT Scale,CNT FROM SCALE WHERE Type+Scale='S'+SUBSTR(m.SCALE,1,lnScaleLen) ORDER BY 1 INTO ARRAY laExtSz
  SELECT SCALE
  =SEEK('S'+laExtSz[1],'SCALE')
  IF !EMPTY(SCALE.CDIM1)
    =gfModalGen('INM00000B00000',.F.,.F.,.F.,'This Style has scale with More than one dimension.')
    =lfvClear() 
    RETURN
  ENDIF

  *C200358,4 TMI [Start] 
  lnIncrmnt = 0
  FOR lnCount = 1 TO ALEN(laExtSz,1)
    lnIncrmnt = lnIncrmnt + laExtSz[lnCount,2]
  ENDFOR  
  IF lnIncrmnt > 16
    =gfModalGen('INM00000B00000',.F.,.F.,.F.,'This Style has scale with More than 16 Sizes.')
    =lfvClear() 
    RETURN
  ENDIF
  *C200358,4 TMI [End  ] 

  *C200358,4 TMI [Start] if style is entred befor , then ignor it  **07/16/2002
  IF SEEK(lcOrdType+laData[1]+laData[3]+m.Style,(lcOrdLine))
    *--This Style has entred on this order
    =gfModalGen('INM32029B00000','ALERT',IIF(lcOrdType='C','Contract','Order'))
    =lfvClear() 
    RETURN
  ENDIF
  *C200358,4 TMI [End  ] 
  
  lnIncrmnt = 0
  FOR lnCount = 1 TO ALEN(laExtSz,1)
    =SEEK('S'+laExtSz[lnCount,1],'SCALE')
    FOR lnJ = 1 TO laExtSz[lnCount,2]
      lcZ = STR(lnJ,1)
      laSize[lnIncrmnt+lnJ] = ALLTRIM(SCALE.Sz&lcZ)
    ENDFOR
    lnIncrmnt = lnIncrmnt + laExtSz[lnCount,2]
  ENDFOR
  
  *--Clear Notes (if any)
  SELECT (lcTempNote)
  REPLACE NOTE_MEM WITH ''
  
  *--Get Colors
  SELECT (lcTempCur)
  ZAP
  
  *--Create color array
  SELECT DISTINCT SUBSTR(STYLE.STYLE,lnClrPos,lnClrLen) FROM STYLE ;
    WHERE STYLE = PADR(m.Style,lnMajorLen) ;
    INTO ARRAY laClr  
  
  *--Add a line for each color
  PRIVATE lnMaxInd
  lnMaxInd = IIF(ALEN(laClr,1)>=10,10,ALEN(laClr,1))
  FOR lnClrs = 1 TO lnMaxInd
    SELECT (lcTempCur)
    SCATTER MEMVAR BLANK
    M.STYMAJOR = PADR(m.Style,lnMajorLen)
    M.COLOR = laClr[lnClrs]
    M.COLORDSC = PADR(gfCodDes(PADR(laClr[lnClrs],lnClrLen) , 'COLOR'),20)
    lnIncrmnt = 0
    *--Update Quantites from lcOrdLine if style is entred befor for the same store
    FOR lnCount = 1 TO ALEN(laExtSz,1)
      lcSeekSty = M.STYMAJOR+lcSepart+PADR(M.COLOR,lnClrLen)+laExtSz[lnCount,1]
      IF SEEK(lcOrdType+laData[1]+laData[3]+lcSeekSty,(lcOrdLine))
        FOR lnJ = 1 TO laExtSz[lnCount,2]
          lcZ = STR(lnJ,1)
          lcX = ALLT(STR(lnIncrmnt+lnJ))
          M.SZ&lcX = &lcOrdLine..Qty&lcZ
          m.nTotal = m.nTotal + &lcOrdLine..Qty&lcZ
        ENDFOR
        M.NOTE_MEM = ALLT(&lcOrdLine..Note_Mem)
        IF !EMPTY(M.NOTE_MEM)
          SELECT (lcTempNote)
          REPLACE NOTE_MEM WITH M.NOTE_MEM
        ENDIF        
        *C200358,4 TMI [Start] Save Style and totqty to compre with it in save process
        DIMENSION laStyClQty[ALEN(laStyClQty,1)+1,3]
        laStyClQty[ALEN(laStyClQty,1),1] = &lcOrdLine..Style
        laStyClQty[ALEN(laStyClQty,1),2] = &lcOrdLine..TotBook
        laStyClQty[ALEN(laStyClQty,1),3] = &lcOrdLine..TotQty
        *C200358,4 TMI [End  ] Save Style and totqty to compre with it in save process 
      ENDIF
      lnIncrmnt = lnIncrmnt + laExtSz[lnCount,2]
    ENDFOR     
    INSERT INTO (lcTempCur) FROM MEMVAR
  ENDFOR  
 
  =SEEK(PADR(m.Style,lnMajorLen),'STYLE')
  
  SELECT CHR(255),'','','Totals',;
         SUM(SZ1),SUM(SZ2),SUM(SZ3),SUM(SZ4),SUM(SZ5),SUM(SZ6),SUM(SZ7),SUM(SZ8),;
         SUM(SZ9),SUM(SZ10),SUM(SZ11),SUM(SZ12),SUM(SZ13),SUM(SZ14),SUM(SZ15),SUM(SZ16),SUM(NTOTAL) ;
         FROM (lcTempCur) ;
         INTO ARRAY laSum

  *--Add total line
  INSERT INTO (lcTempCur) FROM ARRAY laSum
  STORE laSum[21] TO laTot[1,2],m.TotQty
  
  llEdit = laSum[21]>0

  SHOW GET m.Style DISABLE
  SHOW GET m.TotQty ENABLE
  SHOW GET m.Comm1 ENABLE
  SHOW GET pbNote ENABLE
  SHOW GET m.Desc1 DISABLE
  
  IF llDifPrice  
    SHOW GET m.Gros_Price DISABLE
    SHOW GET m.Disc_Pcnt DISABLE
    SHOW GET m.Price DISABLE
  ELSE
    SHOW GET m.Gros_Price ENABLE
    SHOW GET m.Disc_Pcnt ENABLE
    SHOW GET m.Price ENABLE
  ENDIF  
  
  laSavStat = IIF(laSum[21]>0,'ENABLE','DISABLE')
  SHOW GET pbSav &laSavStat

  =lfBrowLine(.T.)
ENDIF

*-- end of lfvQStyle.

*:**************************************************************************
*:* Name        : lfvQkSav                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/18/2002
*:* Purpose     : Save valid fucntio for screen QkOrdEnt
*:***************************************************************************
*:* Called from : QkOrdEnt.scx
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvQkSav()
*:***************************************************************************
FUNCTION lfvQkSav
PRIVATE lcOrd,lnQkCnt,lnJ,lcJ,lcQ,lnIncrmnt,lnK,llDfChkQty


*- Compare check qty with total qty  
llDfChkQty = m.TotQty <> laTot[1,2]
IF llDfChkQty AND gfModalGen('QRM32031B32000','ALERT',ALLTRIM(STR(laTot[1,2],8)))=2  
  RETURN .F.
ENDIF

SELECT (lcTempNote)
SCATTER MEMVAR MEMO

*--Assign variables values
m.CORDTYPE  = lcOrdType
m.ORDER     = laData[1]
m.ACCOUNT   = laData[2]
m.STORE     = laData[3]
m.CustPo    = IIF(!laData[7],&lcOrdHdr..CustPo,'')   &&Save Cust PO # in OrdLine if not Multi Store
m.cWareCode = laData[31]
m.Start     = laData[9]
m.Complete  = laData[10]

SELECT (lcTempCur)
GO TOP
SCAN FOR EMPTY(LASTLINE)
  lnIncrmnt = 0
  FOR lnQkCnt = 1 TO ALEN(laExtSz,1)    
    SELECT (lcTempCur)
    m.Style = STYMAJOR+lcSepart+SUBSTR(COLOR,1,lnClrLen)+laExtSz[lnQkCnt,1]
    IF SEEK(m.Style,'STYLE')
      STORE 0 TO m.Qty1,m.Qty2,m.Qty3,m.Qty4,m.Qty5,m.Qty6,m.Qty7,m.Qty8,m.TotQty,;
                 m.Book1,m.Book2,m.Book3,m.Book4,m.Book5,m.Book6,m.Book7,m.Book8,m.TotBook
      FOR lnJ = lnIncrmnt + 1 TO lnIncrmnt + laExtSz[lnQkCnt,2]
        lcJ = ALLT(STR(lnJ))
        lcQ = STR(lnJ - lnIncrmnt,1)
        m.TotQty = m.TotQty +  SZ&lcJ
        m.Qty&lcQ = SZ&lcJ
        m.Book&lcQ = SZ&lcJ
      ENDFOR    
      m.TotBook  = m.TotQty
      m.Scale    = STYLE.SCALE     
      m.Desc1    = STYLE.Desc1 
      m.PrePak   = Style.PrePak
      m.Season   = Style.Season
      m.Gl_Sales = ALLTRIM(laData[53])+Style.cSlsGlLink
      m.Gl_Sales = IIF(laSetups[4,2]='Y' AND SEEK('02'+m.Gl_Sales,'Gl_Link'),m.Gl_Sales,'DEFDEF')
      m.Flag     = 'N'      
      lnLines    = lnLines + 1
      m.LineNo   = lnLines      

*-*      IF SEEK(lcOrdType+laData[1]+laData[3]+m.Style,(lcOrdLine)) .AND. m.TotQty>0
*-*        SELECT (lcOrdLine)
*-*        REPLACE DESC1      WITH m.Desc1,;
*-*                Price      WITH m.Price,;
*-*                Gros_Price WITH m.Gros_Price ,;
*-*                Disc_Pcnt  WITH m.Disc_Pcnt ,;
*-*                Price      WITH m.Price ,;
*-*                Comm1      WITH m.Comm1                 
*-*        REPLACE QTY1 WITH m.Qty1,;
*-*                QTY2 WITH m.Qty2,;
*-*                QTY3 WITH m.Qty3,;
*-*                QTY4 WITH m.Qty4,;
*-*                QTY5 WITH m.Qty5,;
*-*                QTY6 WITH m.Qty6,;
*-*                QTY7 WITH m.Qty7,;
*-*                QTY8 WITH m.Qty8,;
*-*                TOTQTY WITH m.TOTQty                
*-*        IF &lcOrdLine..FLAG = 'N'
*-*          REPLACE BOOK1 WITH m.BOOK1,;
*-*                  BOOK2 WITH m.BOOK2,;
*-*                  BOOK3 WITH m.BOOK3,;
*-*                  BOOK4 WITH m.BOOK4,;
*-*                  BOOK5 WITH m.BOOK5,;
*-*                  BOOK6 WITH m.BOOK6,;
*-*                  BOOK7 WITH m.BOOK7,;
*-*                  BOOK8 WITH m.BOOK8,;
*-*                  TOTBOOK WITH m.TOTBOOK
*-*        ENDIF
*-*      ELSE
*-*        IF m.TotQty>0
*-*          INSERT INTO (lcOrdLine) FROM MEMVAR
*-*        ELSE
*-*          SELECT (lcOrdLine)
*-*          DELETE
*-*        ENDIF
*-*      ENDIF

      IF !SEEK(lcOrdType+laData[1]+laData[3]+m.Style,(lcOrdLine))
        *-- Get price for each line of scales has different prices , 
        *-- or check qty differs from entred qty
        IF llDifPrice
          =lfQkPrice()
        ENDIF
        IF m.TotQty>0
          INSERT INTO (lcOrdLine) FROM MEMVAR
          *--Update laData array 
          laData[35] = laData[35] + m.TotBook
          laData[36] = laData[36] + m.TotBook*m.Price
          laData[41] = laData[41] + m.TotQty
          laData[42] = laData[42] + m.TotQty*m.Price          
        ENDIF        
      ELSE
        IF m.TotQty>0
          SELECT (lcOrdLine)
*          REPLACE DESC1      WITH m.Desc1
*                  Price      WITH m.Price,;
*                  Gros_Price WITH m.Gros_Price ,;
*                  Disc_Pcnt  WITH m.Disc_Pcnt ,;
*                  Price      WITH m.Price ,;
*                  Comm1      WITH m.Comm1                 
          REPLACE QTY1 WITH m.Qty1,;
                  QTY2 WITH m.Qty2,;
                  QTY3 WITH m.Qty3,;
                  QTY4 WITH m.Qty4,;
                  QTY5 WITH m.Qty5,;
                  QTY6 WITH m.Qty6,;
                  QTY7 WITH m.Qty7,;
                  QTY8 WITH m.Qty8,;
                  TOTQTY WITH m.TOTQty                
          IF &lcOrdLine..FLAG = 'N'
            REPLACE BOOK1 WITH m.BOOK1,;
                    BOOK2 WITH m.BOOK2,;
                    BOOK3 WITH m.BOOK3,;
                    BOOK4 WITH m.BOOK4,;
                    BOOK5 WITH m.BOOK5,;
                    BOOK6 WITH m.BOOK6,;
                    BOOK7 WITH m.BOOK7,;
                    BOOK8 WITH m.BOOK8,;
                    TOTBOOK WITH m.TOTBOOK
            *C200358,4 TMI [Start] Updates Booked qty
            IF ASCAN(laStyClQty,m.Style)>0
              lnK = ASUBSCRIPT(laStyClQty,ASCAN(laStyClQty,m.Style),1)
              laData[35] = laData[35] + (m.TotBook-laStyClQty[lnK,2])
              laData[36] = laData[36] + (m.TotBook-laStyClQty[lnK,2])*&lcOrdline..Price
            ENDIF
            *C200358,4 TMI [End  ] 
          ENDIF 
          *C200358,4 TMI [Start] Update qty
          IF ASCAN(laStyClQty,m.Style)>0
            lnK = ASUBSCRIPT(laStyClQty,ASCAN(laStyClQty,m.Style),1)
            laData[41] = laData[41] + (m.TotQty-laStyClQty[lnK,3])
            laData[42] = laData[42] + (m.TotQty-laStyClQty[lnK,3])*&lcOrdline..Price
          ENDIF
          *C200358,4 TMI [End  ] 
          
        ELSE
        
          SELECT (lcOrdLine)
          *C200358,4 TMI [Start] Update qty
          laData[35] = laData[35] - m.TotBook
          laData[36] = laData[36] - m.TotBook*&lcOrdline..Price
          laData[41] = laData[41] - m.TotQty
          laData[42] = laData[42] - m.TotQty*&lcOrdline..Price
          *C200358,4 TMI [End  ] 
          DELETE
        ENDIF
        
      ENDIF

      lnIncrmnt = lnIncrmnt + laExtSz[lnQkCnt,2]
    ENDIF
  ENDFOR
ENDSCAN

*--Save NOTE_MEM
SELECT (lcTempCur)
LOCATE
m.Style = STYMAJOR
SELECT (lcOrdLine)
IF SEEK(lcOrdType+laData[1]+laData[3]+m.Style,(lcOrdLine))
  M.NOTE_MEM = &lcTempNote..NOTE_MEM
  *--Clear field note_mem for colors other than the first color filled with qty>0
  SCAN REST WHILE CORDTYPE+ORDER+STORE+STYLE+STR(LINENO,6) = lcOrdType+laData[1]+laData[3]+m.Style
    REPLACE NOTE_MEM WITH m.Note_mem
    m.Note_mem = ''      
  ENDSCAN
ENDIF 
*-- Clear screen
=lfvClear()
*-- end of lfvQkSav.

*:**************************************************************************
*:* Name        : lfvqTotQty                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/19/2002
*:* Purpose     : Valid fn for total qty
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqTotQty()
*:***************************************************************************
FUNCTION lfvqTotQty
IF m.TotQty < 0 
  *B603449,1 Message : 42000
  *B603449,1 Negative values are not allowed.
  *B603449,1 Button  : 40011
  *B603449,1 Ok
  = gfModalGen('TRM42000B40011','DIALOG')
  m.TotQty = lcOldValue
  _CUROBJ = OBJNUM(m.TotQty)
  RETURN
ENDIF
IF LASTKEY()=15
  ACTIVATE WINDOW (lcQkWin3)
  _CUROBJ=OBJNUM(pbExit)  
ENDIF
=lfDoTab()

*-- end of lfvqTotQty.

*:**************************************************************************
*:* Name        : lfvqStyDesc                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/19/2002
*:* Purpose     : 
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqStyDesc()
*:***************************************************************************
FUNCTION lfvqStyDesc
  
*-- end of lfvqStyDesc.

*:**************************************************************************
*:* Name        : lfvNotes                                         *C200358,1
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : Entering Line notes , that will be saved againest the first 
*                 color that has quantity
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvNotes()
*:***************************************************************************
FUNCTION lfvNotes
PRIVATE lnRecno,lcAlias
SELECT (lcTempNote)
DO (gcScrDir+"ARLNOTES.SPX")
SELECT (lcTempCur)
*-- end of lfvNotes.

*:**************************************************************************
*:* Name        : lfvqPrcDisc                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/19/2002
*:* Purpose     : 
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqPrcDisc()
*:***************************************************************************
FUNCTION lfvqGPrice
IF m.Gros_Price < 0 
  *B603449,1 Message : 42000
  *B603449,1 Negative values are not allowed.
  *B603449,1 Button  : 40011
  *B603449,1 Ok
  = gfModalGen('TRM42000B40011','DIALOG')
  m.Gros_Price = lcOldValue
  _CUROBJ = OBJNUM(m.Gros_Price)
  RETURN
ENDIF
m.Price = ROUND(m.Gros_Price*(100-m.Disc_Pcnt)/100,2)
SHOW GET m.Price
=lfDoTab()

*-- end of lfvqGPrice.

*:**************************************************************************
*:* Name        : lfvqPrcDisc                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/19/2002
*:* Purpose     : 
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqPrcDisc()
*:***************************************************************************
FUNCTION lfvqPrcDisc
IF m.Disc_Pcnt < 0 
  *B603449,1 Message : 42000
  *B603449,1 Negative values are not allowed.
  *B603449,1 Button  : 40011
  *B603449,1 Ok
  = gfModalGen('TRM42000B40011','DIALOG')
  m.Disc_Pcnt = lcOldValue
  _CUROBJ = OBJNUM(m.Disc_Pcnt)
  RETURN
ENDIF
IF m.Disc_Pcnt > 99.99
  *--Can not exceed 999
  *-- 40171 :  cannot exceeds   
  =gfModalGen('TRM40171B00000','DIALOG','Percent Discount|99.99')
  m.Disc_Pcnt = lcOldValue
  _CUROBJ = OBJNUM(m.Disc_Pcnt)
  RETURN
ENDIF
m.Price = ROUND(m.Gros_Price*(100-m.Disc_Pcnt)/100,2)
SHOW GET m.Price
=lfDoTab()
*-- end of lfvqPrcDisc.

*:**************************************************************************
*:* Name        : lfvqNPrice                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/19/2002
*:* Purpose     : 
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqPrcDisc()
*:***************************************************************************
FUNCTION lfvqNPrice

IF m.Price < 0
  *B603449,1 Message : 42000
  *B603449,1 Negative values are not allowed.
  *B603449,1 Button  : 40011
  *B603449,1 Ok
  = gfModalGen('TRM42000B40011','DIALOG')
  m.Price = lcOldValue
  _CUROBJ = OBJNUM(m.Price)
  RETURN
ENDIF

m.Price = IIF(m.Price>m.Gros_Price,m.Gros_Price,m.Price)
m.Disc_Pcnt = IIF(m.Gros_Price=0,0,100-m.Price*100/m.Gros_Price)

SHOW GET m.Gros_Price
SHOW GET m.Disc_Pcnt
SHOW GET m.Price

=lfDoTab()
*-- end of lfvqNPrice.


*:**************************************************************************
*:* Name        : lfvqComm                                        *C200358,1
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/25/2002
*:* Purpose     : Valid fn for commesion 
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvqComm()
*:***************************************************************************
FUNCTION lfvqComm

*-- end of lfvqComm.

*:**************************************************************************
*:* Name        : lfGetClrD                                      *C200358,1 
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/20/2002
*:* Purpose     : Get Color Position and Color length
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfGetClrD()
*:***************************************************************************
FUNCTION lfGetClrD
DECLARE laItemSeg[1]
PRIVATE lnCount &&Tmi 07/15/2002
lcOldSelect=select()
=gfItemMask(@laItemSeg)
FOR lnCount = 1 TO ALEN(laItemSeg,1)
  IF laItemSeg[lnCount,1]='C'
    lnClrLen = LEN(laItemSeg[lnCount,3])
    lnClrPos = laItemSeg[lnCount,4]
    EXIT
  ENDIF
ENDFOR
SELECT(lcOldSelect)
*--end function lfGetClrD

*:**************************************************************************
*:* Name        : lfvQkClose                                     *C200358,1
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 06/24/2002
*:* Purpose     : Close fn. for QkOrdEnt screen
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfvQkClose()
*:***************************************************************************
FUNCTION lfvQkClose
PRIVATE llClose
llClose = .T.
IF (llEdit AND llChang) OR (!llEdit AND laTot[1,2]>0)
  *M38093   . Are you sure you want to proceed with closing ?  
  *B32005   \<Proceed;\?\<Cancel
  llClose = (gfModalGen('QRM38093B32005','ALERT','Quantities have been '+IIF(llEdit,'changed','entered');
                                                +'|The Quick Order Entry screen')=1)
ENDIF
IF llClose
  ERASE (gcWorkDir+lcTempCur+'.*')
  ERASE (gcWorkDir+lcTempNote+'.*')
  CLEAR READ
ELSE
  ACTIVATE WINDOW (lcDet_Ttl)  
ENDIF

*-- end of lfvQkClose.

*:**************************************************************************
*:* Name        : lfQkPrice                                       *C200358,4
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 07/15/2002
*:* Purpose     : Get Prices in save case
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfQkPrice()
*:***************************************************************************
FUNCTION lfQkPrice

  *--Get style price according to ordered quantity
  PUSH KEY
  ON KEY
  m.lContract = lcOrdType<>'C' .AND. lfvContPri(m.Style,'m.Gros_Price','m.Price','m.Disc_Pcnt')
  IF !m.lContract
    m.Gros_Price = MAX( lfGetprice(m.Style,lcPriceLvl,m.TotQty) , 0 )
  ENDIF
  POP KEY

  m.Price    = m.Gros_Price
  
  *-- Get Style discount percent and Calculate net price  
  IF !m.lContract
    *-- get the cDiscCode From stydye in every case
    lcDiscCode  = IIF(SEEK(m.Style+laData[31]+SPACE(10),'StyDye'),StyDye.cDiscCode,'')
    m.Disc_Pcnt = 0 
    IF !EMPTY(ALLTRIM(lcDiscCode))
      *-- Get the disecound related filed to now which 
      *-- type whole Sale Or Retail sale Or Both.
      DECLARE laDisType[1,2] , lastartDte[1,2] , laEndDate[1,2]
      STORE '' To lcDisType , ldstartDte ,ldEndDate
      *-- Array to get the Discount affect for DecCode.
      laDisType[1,1]  = 'CCOSTAFECT'
      laDisType[1,2]  = 'lcDisType'
      *-- Array to get the start date For DescCode.
      lastartDte[1,1] = 'START'
      lastartDte[1,2] = 'ldstartDte'
      *-- Array to get the end date For DescCode.
      laEndDate[1,1]  = 'DENDATE'
      laEndDate[1,2]  = 'ldEndDate'
      = gfRltFld(lcDiscCode , @laDisType, 'CDISCCODE')
      = gfRltFld(lcDiscCode, @lastartDte, 'CDISCCODE')
      = gfRltFld(lcDiscCode , @laEndDate, 'CDISCCODE')
      lnDisc_Pcnt = 0
      IF ALLTRIM(lcDisType) <> 'R' .AND. BETWEEN(laData[8],ldstartDte,ldEndDate)
        lnDisc_Pcnt = m.Disc_Pcnt
        =gfRltFld(lcDiscCode,@laDisRltFld,'CDISCCODE')
        m.Disc_Pcnt = lnDisc_Pcnt
      ENDIF
    ENDIF  
    m.Price     = m.Gros_Price*(100-m.Disc_Pcnt)/100  
  ENDIF 

*-- end of lfQkPrice.


*:**************************************************************************
*:* Name        : lfQkWhen
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 07/15/2002
*:* Purpose     : When Fn that disable tab
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfQkWhen()
*:***************************************************************************
FUNCTION lfQkWhen
*C200358,4 TMI 
lcOldValue = EVALUATE('m.' + SYS(18))
ON KEY LABEL TAB
ON KEY LABEL BACKTAB
*-- end of lfQkWhen.

*:**************************************************************************
*:* Name        : lfDoTab
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 07/15/2002
*:* Purpose     : ReDefine tab keys
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfDoTab()
*:***************************************************************************
FUNCTION lfDoTab
*C200358,4 TMI 
  *B606386,1 ABD - Close the local tab and let the standered tab work. [Begin]
  *ON KEY LABEL TAB   DO lptab 
  *B606386,1 ABD - [End]
  ON KEY LABEL BACKTAB DO lpBacktab 

*-- end of lfDoTab.

*:**************************************************************************
*:* Name        : lfwGPrice
*:* Developer   : TMI - TAREK MOHAMED IBRAHIM
*:* Date        : 07/18/2002
*! Purpose      : Disable When function for Style Gross price (Specialized for MBI)
*               : This is to use only price level A
*:***************************************************************************
*:* Called from : 
*:***************************************************************************
*:* Parameters : None
*:***************************************************************************
*:* Return      : None
*:***************************************************************************
*:* Example     :  = lfwGPrice()
*:***************************************************************************
FUNCTION lfwGPrice
RETURN .T.


*!**************************************************************************
*! Name      : lfGetORQty
*! Developer : Mohamed Shokry (MHM)
*! Date      : 04/15/2002
*! Purpose   : Get Ordered Qty
*!**************************************************************************
*! Example   : = lfALSAVORD()
*!**************************************************************************
*! Due to ,1
*!**************************************************************************
*C037816,1 MHM 04/06/2004 Save data to Bin Location files

FUNCTION lfGetORQty
PARAMETER lnQty,lnSize,lcPkTkt,lcOrder

lnAlias    = SELECT()
*-- lnQty -------> Qty per size
*-- lnSize -------> size
*-- lcPkTkt -------> PikTkt
*-- lcOrder -------> Order
lcSize = ALLT(STR(lnSize,2))

IF !USED('PKBINLOC')
  =gfOpenFile(gcDataDir+'PKBINLOC','PKBINPKT','SH') 
ENDIF

IF !USED('WHSLOC')
  =gfOpenFile(gcDataDir+'WHSLOC','WHSLOC','SH') 
ENDIF

IF !EMPTY(STYLE.cPrimClss&lcSize)
  lcClass =  STYLE.cPrimClss&lcSize
ELSE
  IF !EMPTY(STYLE.cSecClss&lcSize)
    lcClass =  STYLE.cSecClss&lcSize
  ELSE
    lcClass =  STYLE.cRemClss&lcSize
  ENDIF
ENDIF

  
IF !SEEK(lcPkTkt+WHBINLOC.cWareCode+WHBINLOC.cLocation+WHBINLOC.Style ,'PKBINLOC') 
  =SEEK(WHBINLOC.cWareCode+WHBINLOC.cLocation,'WHSLOC')
  SELECT PKBINLOC
  APPEND BLANK
  REPLACE STYLE      WITH WHBINLOC.Style,;
          CWARECODE  WITH WHBINLOC.cWareCode,;
          PIKTKT     WITH lcPkTkt ,;
          ORDER      WITH lcOrder,;
          cFlatHang  WITH WHSLOC.cFlatHang,;
          clocation  WITH WHBINLOC.cLocation ,;
          Qty&lcSize WITH lnQty,;
          TotQty     WITH lnQty
  REPLACE cBinClass&lcSize  WITH lcClass
  =gfAdd_Info('PKBINLOC')
  IF TotQty = 0
    DELETE
  ENDIF         

ELSE
  SELECT PKBINLOC
  REPLACE Qty&lcSize WITH Qty&lcSize+ lnQty,;
          TotQty     WITH TotQty+lnQty
  REPLACE cBinClass&lcSize  WITH lcClass
  IF TotQty = 0
    DELETE
  ENDIF         
ENDIF
SELECT (lnAlias)

*!**************************************************************************
*! Name      : lfALSAVAUT
*! Developer : Mohamed Shokry (MHM)
*! Date      : 04/15/2002
*! Purpose   : Save Data to Automatic alocation screen
*!**************************************************************************
*! Example   : = lfALSAVAUT()
*!**************************************************************************
*! Due to ,1
*!**************************************************************************
*C037816,1 MHM 04/06/2004 Save data to Bin Location files
FUNCTION lfALSAVAUT
DIMENSION laPikQty[9]
STORE 0 TO laPikQty
lnAlias    = SELECT()

IF !USED('PKBINLOC')
  =gfOpenFile(gcDataDir+'PKBINLOC','PKBINPKT','SH') 
ENDIF

IF !USED('WHBINLOC')
  =gfOpenFile(gcDataDir+'WHBINLOC','WHBINLST','SH')
ENDIF

IF SEEK(&lcOrdLine..Style+ &lcOrdLine..cWareCode ,'WHBINLOC') 
  IF SEEK(&lcOrdLine..PikTkt+&lcOrdLine..cWareCode+WHBINLOC.cLocation+WHBINLOC.Style ,'PKBINLOC') 
    FOR lnPkCount =1 To 8
      lcPkCount = ALLT(STR(lnPkCount,2))
      SELECT PKBINLOC
      =SEEK(&lcOrdLine..PikTkt+&lcOrdLine..cWareCode+WHBINLOC.cLocation+WHBINLOC.Style) 
      SCAN REST WHILE piktkt+cwarecode+clocation+style = &lcOrdLine..PikTkt+&lcOrdLine..cWareCode+WHBINLOC.cLocation+WHBINLOC.Style
        laPikQty[lnPkCount] =laPikQty[lnPkCount]+ PKBINLOC.QTY&lcPkCount
      ENDSCAN  
    ENDFOR
    laPikQty[9]= laPikQty[1]+laPikQty[2]+laPikQty[3]+laPikQty[4]+laPikQty[5]+laPikQty[6]+laPikQty[7]+laPikQty[8]
  ENDIF  

  lnNetQty = 0
  SELECT WHBINLOC
  FOR lnCnt = 1 TO 8
    lcCnt = ALLT(STR(lnCnt,2))
    lnNetQty = (WHBINLOC.QTY&lcCnt-WHBINLOC.Alo&lcCnt)
    IF lnNetQty >= (&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt])
      REPLACE WHBINLOC.Alo&lcCnt WITH WHBINLOC.Alo&lcCnt+ (&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt]) ,;
              WHBINLOC.TotAlo    WITH WHBINLOC.TotAlo + (&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt])
      IF (&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt]) <> 0
        =lfGetORQty((&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt]),lnCnt,m.PikTkt,&lcOrdLine..Order)
      ENDIF  
    ELSE
      REPLACE WHBINLOC.Alo&lcCnt WITH WHBINLOC.Alo&lcCnt+lnNetQty,;
              WHBINLOC.TotAlo    WITH WHBINLOC.TotAlo +lnNetQty
              
      lnRem = (&lcOrdLine..PIK&lcCnt-laPikQty[lnCnt]) - lnNetQty
      IF WHBINLOC.QTY&lcCnt <>0
        =lfGetORQty(lnNetQty,lnCnt,m.PikTkt,&lcOrdLine..Order)
      ENDIF  
      SKIP
      SCAN REST WHILE STYLE+CWARECODE = &lcOrdLine..Style+ &lcOrdLine..cWareCode
        lnNetQty = (WHBINLOC.QTY&lcCnt-WHBINLOC.Alo&lcCnt)
        IF  lnNetQty >= lnRem
          REPLACE WHBINLOC.Alo&lcCnt WITH WHBINLOC.Alo&lcCnt+lnRem,;
                  WHBINLOC.TotAlo    WITH WHBINLOC.TotAlo +lnRem
          IF lnRem <>0
            =lfGetORQty(lnRem,lnCnt,m.PikTkt,&lcOrdLine..Order)
          ENDIF  
          EXIT        
        ELSE
          REPLACE WHBINLOC.Alo&lcCnt WITH  WHBINLOC.Alo&lcCnt + lnNetQty,;
                  WHBINLOC.TotAlo    WITH WHBINLOC.TotAlo + lnNetQty
          lnRem = lnRem - lnNetQty
          IF lnRem <>0
            =lfGetORQty(lnNetQty,lnCnt,m.PikTkt,&lcOrdLine..Order)
          ENDIF  
        ENDIF          
      ENDSCAN 
      =SEEK(&lcOrdLine..Style+ &lcOrdLine..cWareCode ,'WHBINLOC')       
    ENDIF  
  ENDFOR
ENDIF

SELECT(lnAlias)

